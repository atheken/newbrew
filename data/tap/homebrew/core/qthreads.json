{
  "name": "qthreads",
  "full_name": "qthreads",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Lightweight locality-aware user-level threading runtime",
  "license": "BSD-3-Clause",
  "homepage": "https://github.com/Qthreads/qthreads",
  "versions": {
    "stable": "1.18",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/Qthreads/qthreads/archive/refs/tags/1.18.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "c2d1ba85533dc980ff61e422c9b7531417e8884c3a1a701d59229c0e6956594c"
    },
    "head": {
      "url": "https://github.com/Qthreads/qthreads.git",
      "branch": "main"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/qthreads/blobs/sha256:5d9d7bd839e5ea29c6e9907907d153388c37f6011242c241ca650f19a6b75e73",
          "sha256": "5d9d7bd839e5ea29c6e9907907d153388c37f6011242c241ca650f19a6b75e73"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/qthreads/blobs/sha256:20e1c3bfd839efc644db0d69c98d0d58a9fce71b4a2830d054d4792d5180fc92",
          "sha256": "20e1c3bfd839efc644db0d69c98d0d58a9fce71b4a2830d054d4792d5180fc92"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/qthreads/blobs/sha256:a584249b31c678d1a723e3c2dc78ce455a76275baef8e9d3c59e5d624f0f5369",
          "sha256": "a584249b31c678d1a723e3c2dc78ce455a76275baef8e9d3c59e5d624f0f5369"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/qthreads/blobs/sha256:847863371988e92cc7e6d1290db352f9dcdf7847c5baeca4fe18bf02d403be57",
          "sha256": "847863371988e92cc7e6d1290db352f9dcdf7847c5baeca4fe18bf02d403be57"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/qthreads/blobs/sha256:b60ec614ce7bd7cfc835a084e1aa371efa7bbf3790f84f8942e5933f4b77fd27",
          "sha256": "b60ec614ce7bd7cfc835a084e1aa371efa7bbf3790f84f8942e5933f4b77fd27"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/qthreads/blobs/sha256:0523493be01de6b4e4159ac430693ce59919d3970349643b8b9278bbe1fe6054",
          "sha256": "0523493be01de6b4e4159ac430693ce59919d3970349643b8b9278bbe1fe6054"
        },
        "catalina": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/qthreads/blobs/sha256:c4f9b57d8bd7fb1536aa668317d3fc5cff24ca3db5d78a8d52f26f80431277fd",
          "sha256": "c4f9b57d8bd7fb1536aa668317d3fc5cff24ca3db5d78a8d52f26f80431277fd"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/qthreads/blobs/sha256:083a3510caf257af5108d87e1d23cc036c5e65e3263487d68ee1afb41d6fa6bf",
          "sha256": "083a3510caf257af5108d87e1d23cc036c5e65e3263487d68ee1afb41d6fa6bf"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "autoconf",
    "automake",
    "libtool"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/qthreads.rb",
  "ruby_source_checksum": {
    "sha256": "f11e0436d3a6f9a7912d6e215c8648406481a6109cc3a3ba9dc1e64494b9a3c6"
  },
  "date_added": "2021-05-24T12:41:36+00:00",
  "readme": "[![Build Status](https://travis-ci.org/Qthreads/qthreads.svg?branch=master)](https://travis-ci.org/Qthreads/qthreads)\n\n# QTHREADS IS MOVING TO A NEW LOCATION ON GITHUB -- STAY TUNED FOR MORE INFO  \n\nQTHREADS!\n=========\n\nThe qthreads API is designed to make using large numbers of threads convenient\nand easy. The API maps well to both MTA-style threading and PIM-style\nthreading, and is still quite useful in a standard SMP context. The qthreads\nAPI also provides access to full/empty-bit (FEB) semantics, where every word of\nmemory can be marked either full or empty, and a thread can wait for any word\nto attain either state.\n\nThe qthreads library on an SMP is essentially a library for spawning and\ncontrolling coroutines: threads with small (4-8k) stacks. The threads are\nentirely in user-space and use their locked/unlocked status as part of their\nscheduling.\n\nThe library's metaphor is that there are many qthreads and several \"shepherds\".\nShepherds generally map to specific processors or memory regions, but this is\nnot an explicit part of the API. Qthreads are assigned to specific shepherds\nand do not generally migrate.\n\nThe API includes utility functions for making threaded loops, sorting, and\nsimilar operations convenient.\n\n## Collaboration\n\nNeed help or interested in finding out more? Join us on our Slack channel: https://join.slack.com/t/qthreads/signup\n\n## Performance\n\nOn a machine with approximately 2GB of RAM, this library was able to spawn and\nhandle 350,000 qthreads. With some modifications (mostly in stack-size), it was\nable to handle 1,000,000 qthreads. It may be able to do more, but swapping will\nbecome an issue, and you may start to run out of address space.\n\nThis library has been tested, and runs well, on a 64-bit machine. It is\noccasionally tested on 32-bit machines, and has even been tested under Cygwin.\n\nCurrently, the only real limiting factor on the number of threads is the amount\nof memory and address space you have available. For more than 2^32 threads, the\nthread_id value will need to be made larger (or eliminated, as it is not\n*required* for correct operation by the library itself).\n\nFor information on how to use qthread or qalloc, there is A LOT of information\nin the header files (qthread.h and qalloc.h), but the primary documentation is\nman pages.\n\n## FUTURELIB DOCUMENTATION (the 10-minute version)\n\nThe most important functions in futurelib that a person is going to use are\nmt_loop and mt_loop_returns. The mt_loop function is for parallel iterations\nthat do not return values, and the mt_loop_returns function is for parallel\niterations that DO return values. The distinction is not always so obvious.\n\n`mt_loop` is used in a format like so:\n```\n  mt_loop<...argtypelist..., looptype>\n         (function, ...arglist..., startval, stopval, stepval);\n```\nThe \"stepval\" is optional, and defaults to 1.\n\nEssentially what you're doing is in the template setup (in the <>) you're\nspecifying how to handle the arguments to the parallel functions and what kind\nof parallelism you want. Options for 'looptype' (i.e. the kind of parallelism)\nare:\n\n  `mt_loop_traits::Par` - fork all iterations, wait for them to finish\n  `mt_loop_traits::ParNoJoin` - same as Par, but without the waiting\n  `mt_loop_traits::Future` - a resource-constrained version of par, will limit\n    the number of threads running at a given time\n  `mt_loop_traits::FutureNoJoin` - same as Future, but without waiting for\n    threads to finish\n\nThe argtypelist is a list of conceptual types defining how the arguments to the\nparallel function will be handled. Use one conceptual type per argument, in the\norder the arguments will be passed. Valid conceptual types are:\n\n\tIterator - The parallel function will be called with the current loop\n\t\titeration number passed into this argument.\n\tArrayPtr - The corresponding argument is a pointer to an array, and each\n\t\titeration will be passed the value of array[iteration]\n\tRef - The corresponding argument will be passed as a reference.\n\tVal - The corresponding argument will be passed as a constant value\n\t\t(i.e. the same value will be passed to all iterations)\n\nFor example, doing this:\n```\n  for (int i = 0; i < 10; i++) {\n    array[i] = i;\n  }\n```\nWould be achieved like so:\n```\n  void assign(int &array_value, const int i) {\n    array_value = i;\n  }\n\n  mt_loop<ArrayPtr, Iterator, mt_loop_traits::Par>\n    (assign, array, 0, 0, 10);\n```\nThe `mt_loop_returns` variant adds the specification of what to do with the\nreturn values. The pattern is like this:\n```\n  mt_loop_returns<returnvaltype, ...argtypelist..., looptype>\n    (retval, function, ...args..., start, stop, step);\n```\nThe only difference is in the returnvaltype and the retval. The returnvaltype\ncan be either an ArrayPtr or a Collect. If it is an ArrayPtr, the loop will\nbehave similar to the following loop:\n```\n  for (int i = start; i < stop; i += step) {\n    retval[i] = function(args);\n  }\n```\nEach return value will be stored in a separate entry in the retval array. The\nCollect type is more interesting, and can be either:\n\n  `Collect<mt_loop_traits::Add>` - this sums all of the return values in\n    parallel\n  `Collect<mt_loop_traits::Sub>` - this subtracts all of the return values in\n    parallel. Note that the answer may be nondeterministic.\n  `Collect<mt_loop_traits::Mult>` - this multiplies all of the\n    return values in parallel\n  `Collect<mt_loop_traits::Div>` - this divides all of the\n    return values in parallel. Note that the answer is nondeterministic.\n\nFor example, `Collect<mt_loop_traits::Add>` is rougly equivalent to the following loop:\n```\n  for (int i = start; i < stop; i += step) {\n    retval += function(args);\n  }\n```\n******************************************************\n\n##NOTE FOR PGI USERS\npgcc needs the `-c9x` flag in order to correctly process variadic macros (which\nare used in qthread.c) and the PRIuMAX format definitions (used in `qalloc.c`).\nUse the CFLAGS variable to add this flag. Note that pgcc's support for the full\nC90/C99 standards is lousy, so most C90/C99 features that COULD be used are\navoided.\n\n******************************************************\n\n##NOTE FOR IBM XL USERS\nmake check will probably fail with the error:\n\n`xlc++: 1501-210 command option t contains an incorrect subargument`\n`.../.libs/libqthread.so: could not read symbols: Invalid operation`\n\nThis does not mean that the library did not compile correctly, but instead\nmeans that your libtool is probably broken (most are). The problem seems to be\nthat the wrapper script (testloop) is created with incorrect arguments to\nxlc++. The other wrapper scripts (e.g. test1/test2/test3/testq) all have the\ncorrect arguments, and if you modify testloop so that $relink_command uses the\n`-Wl,--rpath -Wl,directory` syntax rather than the `-rpath,directory` syntax,\nit would work just fine.\n\n*******************************************************\n\n## NOTE FOR IBM BLUEGENE/P GCC USERS\nOld versions of GCC do not handle builtin atomics correctly on this platform.\nThe non-existence of `__sync_fetch_and_add()` cannot be reliably detected, so to\nuse those compilers, you probably need to configure with\n`--disable-internal-spinlock`.\n\n*******************************************************\n\n## NOTE FOR TILERA USERS\nThe Tilera cache coherency protocols, as of the TileGX boards, appear to be\nsomewhat buggy for large multithreaded programs. And by buggy I mean they cause\nkernel panics (at least, I haven't been able to demonstrate data corruption\nyet). Thankfully, you can pick from several cache coherency protocols, and one\nof them is more stable than the default. What I have found that seems to be\n*more* stable, if not perfectly stable, is to force the cache coherency\nprotocol to hashed. The way you do this is with a boot argument to the Tilera\nkernel. The tile-monitor command I use is this:\n\n\t`tile-monitor --net <tilera> --hvx ucache_hash=all --`\n\nGood luck!"
}
