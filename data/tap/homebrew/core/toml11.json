{
  "name": "toml11",
  "full_name": "toml11",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "TOML for Modern C++",
  "license": "MIT",
  "homepage": "https://github.com/ToruNiina/toml11",
  "versions": {
    "stable": "3.7.1",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/ToruNiina/toml11/archive/refs/tags/v3.7.1.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "afeaa9aa0416d4b6b2cd3897ca55d9317084103077b32a852247d8efd4cf6068"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "all": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/toml11/blobs/sha256:81f63739751b2e5b61269547bd02ce49fa35bbf57cb85b5e9cf83833489a4098",
          "sha256": "81f63739751b2e5b61269547bd02ce49fa35bbf57cb85b5e9cf83833489a4098"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/toml11.rb",
  "ruby_source_checksum": {
    "sha256": "e73c1c172ba61df5d93373a56f4bed44255db8ced9689d3cbdd3b6a8430712e6"
  },
  "date_added": "2021-10-17T02:36:02+00:00",
  "readme": "toml11\n======\n\n[![Build Status on GitHub Actions](https://github.com/ToruNiina/toml11/workflows/build/badge.svg)](https://github.com/ToruNiina/toml11/actions)\n[![Build status on Appveyor](https://ci.appveyor.com/api/projects/status/m2n08a926asvg5mg/branch/master?svg=true)](https://ci.appveyor.com/project/ToruNiina/toml11/branch/master)\n[![Build status on CircleCI](https://circleci.com/gh/ToruNiina/toml11/tree/master.svg?style=svg)](https://circleci.com/gh/ToruNiina/toml11/tree/master)\n[![Version](https://img.shields.io/github/release/ToruNiina/toml11.svg?style=flat)](https://github.com/ToruNiina/toml11/releases)\n[![License](https://img.shields.io/github/license/ToruNiina/toml11.svg?style=flat)](LICENSE)\n[![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.1209136.svg)](https://doi.org/10.5281/zenodo.1209136)\n\ntoml11 is a C++11 (or later) header-only toml parser/encoder depending only on C++ standard library.\n\n- It is compatible to the latest version of [TOML v1.0.0](https://toml.io/en/v1.0.0).\n- It is one of the most TOML standard compliant libraries, tested with [the language agnostic test suite for TOML parsers by BurntSushi](https://github.com/BurntSushi/toml-test).\n- It shows highly informative error messages. You can see the error messages about invalid files at [CircleCI](https://circleci.com/gh/ToruNiina/toml11).\n- It has configurable container. You can use any random-access containers and key-value maps as backend containers.\n- It optionally preserves comments without any overhead.\n- It has configurable serializer that supports comments, inline tables, literal strings and multiline strings.\n- It supports user-defined type conversion from/into toml values.\n- It correctly handles UTF-8 sequences, with or without BOM, both on posix and Windows.\n\n## Example\n\n```cpp\n#include <toml.hpp>\n#include <iostream>\n\nint main()\n{\n    // ```toml\n    // title = \"an example toml file\"\n    // nums  = [3, 1, 4, 1, 5]\n    // ```\n    auto data = toml::parse(\"example.toml\");\n\n    // find a value with the specified type from a table\n    std::string title = toml::find<std::string>(data, \"title\");\n\n    // convert the whole array into any container automatically\n    std::vector<int> nums = toml::find<std::vector<int>>(data, \"nums\");\n\n    // access with STL-like manner\n    if(!data.contains(\"foo\"))\n    {\n        data[\"foo\"] = \"bar\";\n    }\n\n    // pass a fallback\n    std::string name = toml::find_or<std::string>(data, \"name\", \"not found\");\n\n    // width-dependent formatting\n    std::cout << std::setw(80) << data << std::endl;\n\n    return 0;\n}\n```\n\n## Table of Contents\n\n- [Integration](#integration)\n- [Decoding a toml file](#decoding-a-toml-file)\n  - [In the case of syntax error](#in-the-case-of-syntax-error)\n  - [Invalid UTF-8 Codepoints](#invalid-utf-8-codepoints)\n- [Finding a toml value](#finding-a-toml-value)\n  - [Finding a value in a table](#finding-a-value-in-a-table)\n  - [In case of error](#in-case-of-error)\n  - [Dotted keys](#dotted-keys)\n- [Casting a toml value](#casting-a-toml-value)\n- [Checking value type](#checking-value-type)\n- [More about conversion](#more-about-conversion)\n  - [Converting an array](#converting-an-array)\n  - [Converting a table](#converting-a-table)\n  - [Getting an array of tables](#getting-an-array-of-tables)\n  - [Cost of conversion](#cost-of-conversion)\n  - [Converting datetime and its variants](#converting-datetime-and-its-variants)\n- [Getting with a fallback](#getting-with-a-fallback)\n- [Expecting conversion](#expecting-conversion)\n- [Visiting a toml::value](#visiting-a-tomlvalue)\n- [Constructing a toml::value](#constructing-a-tomlvalue)\n- [Preserving Comments](#preserving-comments)\n- [Customizing containers](#customizing-containers)\n- [TOML literal](#toml-literal)\n- [Conversion between toml value and arbitrary types](#conversion-between-toml-value-and-arbitrary-types)\n- [Formatting user-defined error messages](#formatting-user-defined-error-messages)\n- [Obtaining location information](#obtaining-location-information)\n- [Exceptions](#exceptions)\n- [Colorize Error Messages](#colorize-error-messages)\n- [Serializing TOML data](#serializing-toml-data)\n- [Underlying types](#underlying-types)\n- [Unreleased TOML features](#unreleased-toml-features)\n- [Breaking Changes from v2](#breaking-changes-from-v2)\n- [Running Tests](#running-tests)\n- [Contributors](#contributors)\n- [Licensing Terms](#licensing-terms)\n\n## Integration\n\nJust include the file after adding it to the include path.\n\n```cpp\n#include <toml.hpp> // that's all! now you can use it.\n#include <iostream>\n\nint main()\n{\n    const auto data  = toml::parse(\"example.toml\");\n    const auto title = toml::find<std::string>(data, \"title\");\n    std::cout << \"the title is \" << title << std::endl;\n    return 0;\n}\n```\n\nThe convenient way is to add this repository as a git-submodule or to install\nit in your system by CMake.\n\nNote for MSVC: We recommend to set `/Zc:__cplusplus` to detect C++ version correctly.\n\n### Example installation\n\nFor local installation build & use the provided install target\n\n```bash\ngit clone https://github.com/ToruNiina/toml11.git\nmkdir -p toml11/build\ncd toml11/build\ncmake .. -DCMAKE_CXX_STANDARD=11\nsudo make install\n```\n\nIn case you want to create a `.deb` you can use `checkinstall`.\n```bash\nsudo checkinstall\n[[ .. skipping for clarity ]]\n**********************************************************************\n\n Done. The new package has been installed and saved to\n\n /home/user/toml11/build/build_20230728-1_amd64.deb\n\n You can remove it from your system anytime using:\n\n      dpkg -r build\n\n**********************************************************************\n```\n\nYou should get a package that you can install with `dpkg -i <myfile>.deb` and remove with `dpkg -r <myfile>.deb`\n\n## Decoding a toml file\n\nTo parse a toml file, the only thing you have to do is\nto pass a filename to the `toml::parse` function.\n\n```cpp\nconst std::string fname(\"sample.toml\");\nconst toml::value data = toml::parse(fname);\n```\n\nAs required by the TOML specification, the top-level value is always a table.\nYou can find a value inside it, cast it into a table explicitly, and insert it as a value into other `toml::value`.\n\nIf it encounters an error while opening a file, it will throw `std::runtime_error`.\n\nYou can also pass a `std::istream` to the  `toml::parse` function.\nTo show a filename in an error message, however, it is recommended to pass the\nfilename with the stream.\n\n```cpp\nstd::ifstream ifs(\"sample.toml\", std::ios_base::binary);\nassert(ifs.good());\nconst auto data = toml::parse(ifs, /*optional -> */ \"sample.toml\");\n```\n\n**Note**: When you are **on Windows, open a file in binary mode**.\nIf a file is opened in text-mode, CRLF (\"\\r\\n\") will automatically be\nconverted to LF (\"\\n\") and this causes inconsistency between file size\nand the contents that would be read. This causes weird error.\n\n### In the case of syntax error\n\nIf there is a syntax error in a toml file, `toml::parse` will throw\n`toml::syntax_error` that inherits `std::exception`.\n\ntoml11 has clean and informative error messages inspired by Rust and\nit looks like the following.\n\n```console\nterminate called after throwing an instance of 'toml::syntax_error'\n  what():  [error] toml::parse_table: invalid line format # error description\n --> example.toml                                         # file name\n 3 | a = 42 = true                                        # line num and content\n   |        ^------ expected newline, but got '='.        # error reason\n```\n\nIf you (mistakenly) duplicate tables and got an error, it is helpful to see\nwhere they are. toml11 shows both at the same time like the following.\n\n```console\nterminate called after throwing an instance of 'toml::syntax_error'\n  what():  [error] toml::insert_value: table (\"table\") already exists.\n --> duplicate-table.toml\n 1 | [table]\n   | ~~~~~~~ table already exists here\n ...\n 3 | [table]\n   | ~~~~~~~ table defined twice\n```\n\nWhen toml11 encounters a malformed value, it tries to detect what type it is.\nThen it shows hints to fix the format. An error message while reading one of\nthe malformed files in [the language agnostic test suite](https://github.com/BurntSushi/toml-test).\nis shown below.\n\n```console\nwhat(): [error] bad time: should be HH:MM:SS.subsec\n --> ./datetime-malformed-no-secs.toml\n 1 | no-secs = 1987-07-05T17:45Z\n   |                     ^------- HH:MM:SS.subsec\n   |\nHint: pass: 1979-05-27T07:32:00, 1979-05-27 07:32:00.999999\nHint: fail: 1979-05-27T7:32:00, 1979-05-27 17:32\n```\n\nYou can find other examples in a job named `output_result` on\n[CircleCI](https://circleci.com/gh/ToruNiina/toml11).\n\nSince the error message generation is generally a difficult task, the current\nstatus is not ideal. If you encounter a weird error message, please let us know\nand contribute to improve the quality!\n\n### Invalid UTF-8 codepoints\n\nIt throws `syntax_error` if a value of an escape sequence\nrepresenting unicode character is not a valid UTF-8 codepoint.\n\n```console\n  what():  [error] toml::read_utf8_codepoint: input codepoint is too large.\n --> utf8.toml\n 1 | exceeds_unicode = \"\\U0011FFFF example\"\n   |                              ^--------- should be in [0x00..0x10FFFF]\n```\n\n## Finding a toml value\n\nAfter parsing successfully, you can obtain the values from the result of\n`toml::parse` using `toml::find` function.\n\n```toml\n# sample.toml\nanswer  = 42\npi      = 3.14\nnumbers = [1,2,3]\ntime    = 1979-05-27T07:32:00Z\n```\n\n``` cpp\nconst auto data      = toml::parse(\"sample.toml\");\nconst auto answer    = toml::find<std::int64_t    >(data, \"answer\");\nconst auto pi        = toml::find<double          >(data, \"pi\");\nconst auto numbers   = toml::find<std::vector<int>>(data, \"numbers\");\nconst auto timepoint = toml::find<std::chrono::system_clock::time_point>(data, \"time\");\n```\n\nBy default, `toml::find` returns a `toml::value`.\n\n```cpp\nconst toml::value& answer = toml::find(data, \"answer\");\n```\n\nWhen you pass an exact TOML type that does not require type conversion,\n`toml::find` returns a reference without copying the value.\n\n```cpp\nconst auto  data   = toml::parse(\"sample.toml\");\nconst auto& answer = toml::find<toml::integer>(data, \"answer\");\n```\n\nIf the specified type requires conversion, you can't take a reference to the value.\nSee also [underlying types](#underlying-types).\n\n**NOTE**: For some technical reason, automatic conversion between `integer` and\n`floating` is not supported. If you want to get a floating value even if a value\nhas integer value, you need to convert it manually after obtaining a value,\nlike the following.\n\n```cpp\nconst auto vx = toml::find(data, \"x\");\ndouble x = vx.is_floating() ? vx.as_floating(std::nothrow) :\n           static_cast<double>(vx.as_integer()); // it throws if vx is neither\n                                                 // floating nor integer.\n```\n\n### Finding a value in a table\n\nThere are several way to get a value defined in a table.\nFirst, you can get a table as a normal value and find a value from the table.\n\n```toml\n[fruit]\nname = \"apple\"\n[fruit.physical]\ncolor = \"red\"\nshape = \"round\"\n```\n\n``` cpp\nconst auto  data  = toml::parse(\"fruit.toml\");\nconst auto& fruit = toml::find(data, \"fruit\");\nconst auto  name  = toml::find<std::string>(fruit, \"name\");\n\nconst auto& physical = toml::find(fruit, \"physical\");\nconst auto  color    = toml::find<std::string>(physical, \"color\");\nconst auto  shape    = toml::find<std::string>(physical, \"shape\");\n```\n\nHere, variable `fruit` is a `toml::value` and can be used as the first argument\nof `toml::find`.\n\nSecond, you can pass as many arguments as the number of subtables to `toml::find`.\n\n```cpp\nconst auto data  = toml::parse(\"fruit.toml\");\nconst auto color = toml::find<std::string>(data, \"fruit\", \"physical\", \"color\");\nconst auto shape = toml::find<std::string>(data, \"fruit\", \"physical\", \"shape\");\n```\n\n### Finding a value in an array\n\nYou can find n-th value in an array by `toml::find`.\n\n```toml\nvalues = [\"foo\", \"bar\", \"baz\"]\n```\n\n``` cpp\nconst auto data   = toml::parse(\"sample.toml\");\nconst auto values = toml::find(data, \"values\");\nconst auto bar    = toml::find<std::string>(values, 1);\n```\n\n`toml::find` can also search array recursively.\n\n```cpp\nconst auto data = toml::parse(\"fruit.toml\");\nconst auto bar  = toml::find<std::string>(data, \"values\", 1);\n```\n\nBefore calling `toml::find`, you can check if a value corresponding to a key\nexists. You can use both `bool toml::value::contains(const key&) const` and\n`std::size_t toml::value::count(const key&) const`. Those behaves like the\n`std::map::contains` and `std::map::count`.\n\n```cpp\nconst auto data = toml::parse(\"fruit.toml\");\nif(data.contains(\"fruit\") && data.at(\"fruit\").count(\"physical\") != 0)\n{\n    // ...\n}\n```\n\n### In case of error\n\nIf the value does not exist, `toml::find` throws `std::out_of_range` with the\nlocation of the table.\n\n```console\nterminate called after throwing an instance of 'std::out_of_range'\n  what():  [error] key \"answer\" not found\n --> example.toml\n 6 | [tab]\n   | ~~~~~ in this table\n```\n\n----\n\nIf the specified type differs from the actual value contained, it throws\n`toml::type_error` that inherits `std::exception`.\n\nSimilar to the case of syntax error, toml11 also displays clean error messages.\nThe error message when you choose `int` to get `string` value would be like this.\n\n```console\nterminate called after throwing an instance of 'toml::type_error'\n  what():  [error] toml::value bad_cast to integer\n --> example.toml\n 3 | title = \"TOML Example\"\n   |         ~~~~~~~~~~~~~~ the actual type is string\n```\n\n**NOTE**: In order to show this kind of error message, all the toml values have\na pointer to represent its range in a file. The entire contents of a file is\nshared by `toml::value`s and remains on the heap memory. It is recommended to\ndestruct all the `toml::value` classes after configuring your application\nif you have a large TOML file compared to the memory resource.\n\n### Dotted keys\n\nTOML v0.5.0 has a new feature named \"dotted keys\".\nYou can chain keys to represent the structure of the data.\n\n```toml\nphysical.color = \"orange\"\nphysical.shape = \"round\"\n```\n\nThis is equivalent to the following.\n\n```toml\n[physical]\ncolor = \"orange\"\nshape = \"round\"\n```\n\nYou can get both of the above tables with the same c++ code.\n\n```cpp\nconst auto physical = toml::find(data, \"physical\");\nconst auto color    = toml::find<std::string>(physical, \"color\");\n```\n\nThe following code does not work for the above toml file.\n\n```cpp\n// XXX this does not work!\nconst auto color = toml::find<std::string>(data, \"physical.color\");\n```\n\nThe above code works with the following toml file.\n\n```toml\n\"physical.color\" = \"orange\"\n# equivalent to {\"physical.color\": \"orange\"},\n# NOT {\"physical\": {\"color\": \"orange\"}}.\n```\n\n\n## Casting a toml value\n\n### `toml::get`\n\n`toml::parse` returns `toml::value`. `toml::value` is a union type that can\ncontain one of the following types.\n\n- `toml::boolean` (`bool`)\n- `toml::integer` (`std::int64_t`)\n- `toml::floating` (`double`)\n- `toml::string` (a type convertible to std::string)\n- `toml::local_date`\n- `toml::local_time`\n- `toml::local_datetime`\n- `toml::offset_datetime`\n- `toml::array` (by default, `std::vector<toml::value>`)\n  - It depends. See [customizing containers](#customizing-containers) for detail.\n- `toml::table` (by default, `std::unordered_map<toml::key, toml::value>`)\n  - It depends. See [customizing containers](#customizing-containers) for detail.\n\nTo get a value inside, you can use `toml::get<T>()`. The usage is the same as\n`toml::find<T>` (actually, `toml::find` internally uses `toml::get` after casting\na value to `toml::table`).\n\n``` cpp\nconst toml::value  data    = toml::parse(\"sample.toml\");\nconst toml::value  answer_ = toml::get<toml::table >(data).at(\"answer\");\nconst std::int64_t answer  = toml::get<std::int64_t>(answer_);\n```\n\nWhen you pass an exact TOML type that does not require type conversion,\n`toml::get` returns a reference through which you can modify the content\n(if the `toml::value` is `const`, it returns `const` reference).\n\n```cpp\ntoml::value   data    = toml::parse(\"sample.toml\");\ntoml::value   answer_ = toml::get<toml::table >(data).at(\"answer\");\ntoml::integer& answer = toml::get<toml::integer>(answer_);\nanswer = 6 * 9; // write to data.answer. now `answer_` contains 54.\n```\n\nIf the specified type requires conversion, you can't take a reference to the value.\nSee also [underlying types](#underlying-types).\n\nIt also throws a `toml::type_error` if the type differs.\n\n### `as_xxx`\n\nYou can also use a member function to cast a value.\n\n```cpp\nconst std::int64_t answer = data.as_table().at(\"answer\").as_integer();\n```\n\nIt also throws a `toml::type_error` if the type differs. If you are sure that\nthe value `v` contains a value of the specified type, you can suppress checking\nby passing `std::nothrow`.\n\n```cpp\nconst auto& answer = data.as_table().at(\"answer\");\nif(answer.is_integer() && answer.as_integer(std::nothrow) == 42)\n{\n    std::cout << \"value is 42\" << std::endl;\n}\n```\n\nIf `std::nothrow` is passed, the functions are marked as noexcept.\n\nBy casting a `toml::value` into an array or a table, you can iterate over the\nelements.\n\n```cpp\nconst auto data = toml::parse(\"example.toml\");\nstd::cout << \"keys in the top-level table are the following: \\n\";\nfor(const auto& kv : data.as_table())\n{\n    std::cout << kv.first << '\\n';\n}\nfor(const auto& [k, v] : data.as_table()) // or in C++17\n{\n    std::cout << k << '\\n';\n}\n\n\nconst auto& fruits = toml::find(data, \"fruits\");\nfor(const auto& v : fruits.as_array())\n{\n    std::cout << toml::find<std::string>(v, \"name\") << '\\n';\n}\n```\n\nThe full list of the functions is below.\n\n```cpp\nnamespace toml {\nclass value {\n    // ...\n    const boolean&         as_boolean()         const&;\n    const integer&         as_integer()         const&;\n    const floating&        as_floating()        const&;\n    const string&          as_string()          const&;\n    const offset_datetime& as_offset_datetime() const&;\n    const local_datetime&  as_local_datetime()  const&;\n    const local_date&      as_local_date()      const&;\n    const local_time&      as_local_time()      const&;\n    const array&           as_array()           const&;\n    const table&           as_table()           const&;\n    // --------------------------------------------------------\n    // non-const version\n    boolean&               as_boolean()         &;\n    // ditto...\n    // --------------------------------------------------------\n    // rvalue version\n    boolean&&              as_boolean()         &&;\n    // ditto...\n\n    // --------------------------------------------------------\n    // noexcept versions ...\n    const boolean&         as_boolean(const std::nothrow_t&) const& noexcept;\n    boolean&               as_boolean(const std::nothrow_t&) &      noexcept;\n    boolean&&              as_boolean(const std::nothrow_t&) &&     noexcept;\n    // ditto...\n};\n} // toml\n```\n\n### `at()`\n\nYou can access to the element of a table and an array by `toml::basic_value::at`.\n\n```cpp\nconst toml::value v{1,2,3,4,5};\nstd::cout << v.at(2).as_integer() << std::endl; // 3\n\nconst toml::value v{{\"foo\", 42}, {\"bar\", 3.14}};\nstd::cout << v.at(\"foo\").as_integer() << std::endl; // 42\n```\n\nIf an invalid key (integer for a table, string for an array), it throws\n`toml::type_error` for the conversion. If the provided key is out-of-range,\nit throws `std::out_of_range`.\n\nNote that, although `std::string` has `at()` member function, `toml::value::at`\nthrows if the contained type is a string. Because `std::string` does not\ncontain `toml::value`.\n\n### `operator[]`\n\nYou can also access to the element of a table and an array by\n`toml::basic_value::operator[]`.\n\n```cpp\nconst toml::value v{1,2,3,4,5};\nstd::cout << v[2].as_integer() << std::endl; // 3\n\nconst toml::value v{{\"foo\", 42}, {\"bar\", 3.14}};\nstd::cout << v[\"foo\"].as_integer() << std::endl; // 42\n```\n\nWhen you access to a `toml::value` that is not initialized yet via\n`operator[](const std::string&)`, the `toml::value` will be a table,\njust like the `std::map`.\n\n```cpp\ntoml::value v; // not initialized as a table.\nv[\"foo\"] = 42; // OK. `v` will be a table.\n```\n\nContrary, if you access to a `toml::value` that contains an array via `operator[]`,\nit does not check anything. It converts `toml::value` without type check and then\naccess to the n-th element without boundary check, just like the `std::vector::operator[]`.\n\n```cpp\ntoml::value v; // not initialized as an array\nv[2] = 42;     // error! UB\n```\n\nPlease make sure that the `toml::value` has an array inside when you access to\nits element via `operator[]`.\n\n## Checking value type\n\nYou can check the type of a value by `is_xxx` function.\n\n```cpp\nconst toml::value v = /* ... */;\nif(v.is_integer())\n{\n    std::cout << \"value is an integer\" << std::endl;\n}\n```\n\nThe complete list of the functions is below.\n\n```cpp\nnamespace toml {\nclass value {\n    // ...\n    bool is_boolean()         const noexcept;\n    bool is_integer()         const noexcept;\n    bool is_floating()        const noexcept;\n    bool is_string()          const noexcept;\n    bool is_offset_datetime() const noexcept;\n    bool is_local_datetime()  const noexcept;\n    bool is_local_date()      const noexcept;\n    bool is_local_time()      const noexcept;\n    bool is_array()           const noexcept;\n    bool is_table()           const noexcept;\n    bool is_uninitialized()   const noexcept;\n    // ...\n};\n} // toml\n```\n\nAlso, you can get `enum class value_t` from `toml::value::type()`.\n\n```cpp\nswitch(data.at(\"something\").type())\n{\n    case toml::value_t::integer:  /*do some stuff*/ ; break;\n    case toml::value_t::floating: /*do some stuff*/ ; break;\n    case toml::value_t::string :  /*do some stuff*/ ; break;\n    default : throw std::runtime_error(\n        \"unexpected type : \" + toml::stringize(data.at(\"something\").type()));\n}\n```\n\nThe complete list of the `enum`s can be found in the section\n[underlying types](#underlying-types).\n\nThe `enum`s can be used as a parameter of `toml::value::is` function like the following.\n\n```cpp\ntoml::value v = /* ... */;\nif(v.is(toml::value_t::boolean)) // ...\n```\n\n## More about conversion\n\nSince `toml::find` internally uses `toml::get`, all the following examples work\nwith both `toml::get` and `toml::find`.\n\n### Converting an array\n\nYou can get any kind of `container` class from a `toml::array`\nexcept for `map`-like classes.\n\n``` cpp\n// # sample.toml\n// numbers = [1,2,3]\n\nconst auto numbers = toml::find(data, \"numbers\");\n\nconst auto vc  = toml::get<std::vector<int>  >(numbers);\nconst auto ls  = toml::get<std::list<int>    >(numbers);\nconst auto dq  = toml::get<std::deque<int>   >(numbers);\nconst auto ar  = toml::get<std::array<int, 3>>(numbers);\n// if the size of data.at(\"numbers\") is larger than that of std::array,\n// it will throw toml::type_error because std::array is not resizable.\n```\n\nSurprisingly, you can convert `toml::array` into `std::pair` and `std::tuple`.\n\n```cpp\n// numbers = [1,2,3]\nconst auto tp = toml::get<std::tuple<short, int, unsigned int>>(numbers);\n```\n\nThis functionality is helpful when you have a toml file like the following.\n\n```toml\narray_of_arrays = [[1, 2, 3], [\"foo\", \"bar\", \"baz\"]] # toml allows this\n```\n\nWhat is the corresponding C++ type?\nObviously, it is a `std::pair` of `std::vector`s.\n\n```cpp\nconst auto array_of_arrays = toml::find(data, \"array_of_arrays\");\nconst auto aofa = toml::get<\n    std::pair<std::vector<int>, std::vector<std::string>>\n    >(array_of_arrays);\n```\n\nIf you don't know the type of the elements, you can use `toml::array`,\nwhich is a `std::vector` of `toml::value`, instead.\n\n```cpp\nconst auto a_of_a = toml::get<toml::array>(array_of_arrays);\nconst auto first  = toml::get<std::vector<int>>(a_of_a.at(0));\n```\n\nYou can change the implementation of `toml::array` with `std::deque` or some\nother array-like container. See [Customizing containers](#customizing-containers)\nfor detail.\n\n### Converting a table\n\nWhen all the values of the table have the same type, toml11 allows you to\nconvert a `toml::table` to a `map` that contains the convertible type.\n\n```toml\n[tab]\nkey1 = \"foo\" # all the values are\nkey2 = \"bar\" # toml String\n```\n\n```cpp\nconst auto data = toml::parse(\"sample.toml\");\nconst auto tab = toml::find<std::map<std::string, std::string>>(data, \"tab\");\nstd::cout << tab[\"key1\"] << std::endl; // foo\nstd::cout << tab[\"key2\"] << std::endl; // bar\n```\n\nBut since `toml::table` is just an alias of `std::unordered_map<toml::key, toml::value>`,\nnormally you don't need to convert it because it has all the functionalities that\n`std::unordered_map` has (e.g. `operator[]`, `count`, and `find`). In most cases\n`toml::table` is sufficient.\n\n```cpp\ntoml::table tab = toml::get<toml::table>(data);\nif(data.count(\"title\") != 0)\n{\n    data[\"title\"] = std::string(\"TOML example\");\n}\n```\n\nYou can change the implementation of `toml::table` with `std::map` or some\nother map-like container. See [Customizing containers](#customizing-containers)\nfor detail.\n\n### Getting an array of tables\n\nAn array of tables is just an array of tables.\nYou can get it in completely the same way as the other arrays and tables.\n\n```toml\n# sample.toml\narray_of_inline_tables = [{key = \"value1\"}, {key = \"value2\"}, {key = \"value3\"}]\n\n[[array_of_tables]]\nkey = \"value4\"\n[[array_of_tables]]\nkey = \"value5\"\n[[array_of_tables]]\nkey = \"value6\"\n```\n\n```cpp\nconst auto data = toml::parse(\"sample.toml\");\nconst auto aot1 = toml::find<std::vector<toml::table>>(data, \"array_of_inline_tables\");\nconst auto aot2 = toml::find<std::vector<toml::table>>(data, \"array_of_tables\");\n```\n\n### Cost of conversion\n\nAlthough conversion through `toml::(get|find)` is convenient, it has additional\ncopy-cost because it copies data contained in `toml::value` to the\nuser-specified type. Of course in some cases this overhead is not ignorable.\n\n```cpp\n// the following code constructs a std::vector.\n// it requires heap allocation for vector and element conversion.\nconst auto array = toml::find<std::vector<int>>(data, \"foo\");\n```\n\nBy passing the exact types, `toml::get` returns reference that has no overhead.\n\n``` cpp\nconst auto& tab     = toml::find<toml::table>(data, \"tab\");\nconst auto& numbers = toml::find<toml::array>(data, \"numbers\");\n```\n\nAlso, `as_xxx` are zero-overhead because they always return a reference.\n\n``` cpp\nconst auto& tab     = toml::find(data, \"tab\"    ).as_table();\nconst auto& numbers = toml::find(data, \"numbers\").as_array();\n```\n\nIn this case you need to call `toml::get` each time you access to\nthe element of `toml::array` because `toml::array` is an array of `toml::value`.\n\n```cpp\nconst auto& num0 = toml::get<toml::integer>(numbers.at(0));\nconst auto& num1 = toml::get<toml::integer>(numbers.at(1));\nconst auto& num2 = toml::get<toml::integer>(numbers.at(2));\n```\n\n### Converting datetime and its variants\n\nTOML v0.5.0 has 4 different datetime objects, `local_date`, `local_time`,\n`local_datetime`, and `offset_datetime`.\n\nSince `local_date`, `local_datetime`, and `offset_datetime` represent a time\npoint, you can convert them to `std::chrono::system_clock::time_point`.\n\nContrary, `local_time` does not represents a time point because they lack a\ndate information, but it can be converted to `std::chrono::duration` that\nrepresents a duration from the beginning of the day, `00:00:00.000`.\n\n```toml\n# sample.toml\ndate = 2018-12-23\ntime = 12:30:00\nl_dt = 2018-12-23T12:30:00\no_dt = 2018-12-23T12:30:00+09:30\n```\n\n```cpp\nconst auto data = toml::parse(\"sample.toml\");\n\nconst auto date = toml::get<std::chrono::system_clock::time_point>(data.at(\"date\"));\nconst auto l_dt = toml::get<std::chrono::system_clock::time_point>(data.at(\"l_dt\"));\nconst auto o_dt = toml::get<std::chrono::system_clock::time_point>(data.at(\"o_dt\"));\n\nconst auto time = toml::get<std::chrono::minutes>(data.at(\"time\")); // 12 * 60 + 30 min\n```\n\n`local_date` and `local_datetime` are assumed to be in the local timezone when\nthey are converted into `time_point`. On the other hand, `offset_datetime` only\nuses the offset part of the data and it does not take local timezone into account.\n\nTo contain datetime data, toml11 defines its own datetime types.\nFor more detail, you can see the definitions in [toml/datetime.hpp](toml/datetime.hpp).\n\n## Getting with a fallback\n\n`toml::find_or` returns a default value if the value is not found or has a\ndifferent type.\n\n```cpp\nconst auto data = toml::parse(\"example.toml\");\nconst auto num  = toml::find_or(data, \"num\", 42);\n```\n\nIt works recursively if you pass several keys for subtables.\nIn that case, the last argument is considered to be the optional value.\nAll other arguments between `toml::value` and the optional value are considered as keys.\n\n```cpp\n// [fruit.physical]\n// color = \"red\"\nauto data  = toml::parse(\"fruit.toml\");\nauto color = toml::find_or(data, \"fruit\", \"physical\", \"color\", \"red\");\n//                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^\n//                               arguments                     optional value\n```\n\nAlso, `toml::get_or` returns a default value if `toml::get<T>` failed.\n\n```cpp\ntoml::value v(\"foo\"); // v contains String\nconst int value = toml::get_or(v, 42); // conversion fails. it returns 42.\n```\n\nThese functions automatically deduce what type you want to get\nfrom the default value you passed.\n\nTo get a reference through this function, take care about the default value.\n\n```cpp\ntoml::value v(\"foo\"); // v contains String\ntoml::integer& i = toml::get_or(v, 42); // does not work because binding `42`\n                                        // to `integer&` is invalid\ntoml::integer opt = 42;\ntoml::integer& i = toml::get_or(v, opt); // this works.\n```\n\n## Expecting conversion\n\nBy using `toml::expect`, you will get your expected value or an error message\nwithout throwing `toml::type_error`.\n\n```cpp\nconst auto value = toml::expect<std::string>(data.at(\"title\"));\nif(value.is_ok()) {\n    std::cout << value.unwrap() << std::endl;\n} else {\n    std::cout << value.unwrap_err() << std::endl;\n}\n```\n\nAlso, you can pass a function object to modify the expected value.\n\n```cpp\nconst auto value = toml::expect<int>(data.at(\"number\"))\n    .map(// function that receives expected type (here, int)\n    [](const int number) -> double {\n        return number * 1.5 + 1.0;\n    }).unwrap_or(/*default value =*/ 3.14);\n```\n\n## Visiting a toml::value\n\ntoml11 provides `toml::visit` to apply a function to `toml::value` in the\nsame way as `std::variant`.\n\n```cpp\nconst toml::value v(3.14);\ntoml::visit([](const auto& val) -> void {\n        std::cout << val << std::endl;\n    }, v);\n```\n\nThe function object that would be passed to `toml::visit` must be able to\nreceive all the possible TOML types. Also, the result types should be the same\neach other.\n\n## Constructing a toml::value\n\n`toml::value` can be constructed in various ways.\n\n```cpp\ntoml::value v(true);     // boolean\ntoml::value v(42);       // integer\ntoml::value v(3.14);     // floating\ntoml::value v(\"foobar\"); // string\ntoml::value v(toml::local_date(2019, toml::month_t::Apr, 1)); // date\ntoml::value v{1, 2, 3, 4, 5};                                 // array\ntoml::value v{{\"foo\", 42}, {\"bar\", 3.14}, {\"baz\", \"qux\"}};    // table\n```\n\nWhen constructing a string, you can choose to use either literal or basic string.\nBy default, it will be a basic string.\n\n```cpp\ntoml::value v(\"foobar\", toml::string_t::basic  );\ntoml::value v(\"foobar\", toml::string_t::literal);\n```\n\nDatetime objects can be constructed from `std::tm` and\n`std::chrono::system_clock::time_point`. But you need to specify what type\nyou use to avoid ambiguity.\n\n```cpp\nconst auto now = std::chrono::system_clock::now();\ntoml::value v(toml::local_date(now));\ntoml::value v(toml::local_datetime(now));\ntoml::value v(toml::offset_datetime(now));\n```\n\nSince local time is not equivalent to a time point, because it lacks date\ninformation, it will be constructed from `std::chrono::duration`.\n\n```cpp\ntoml::value v(toml::local_time(std::chrono::hours(10)));\n```\n\nYou can construct an array object not only from `initializer_list`, but also\nfrom STL containers. In that case, the element type must be convertible to\n`toml::value`.\n\n```cpp\nstd::vector<int> vec{1,2,3,4,5};\ntoml::value v(vec);\n```\n\nWhen you construct an array value, all the elements of `initializer_list`\nmust be convertible into `toml::value`.\n\nIf a `toml::value` has an array, you can `push_back` an element in it.\n\n```cpp\ntoml::value v{1,2,3,4,5};\nv.push_back(6);\n```\n\n`emplace_back` also works.\n\n## Preserving comments\n\ntoml11 v3 or later allows you yo choose whether comments are preserved or not via template parameter\n\n```cpp\nconst auto data1 = toml::parse<toml::discard_comments >(\"example.toml\");\nconst auto data2 = toml::parse<toml::preserve_comments>(\"example.toml\");\n```\n\nor macro definition.\n\n```cpp\n#define TOML11_PRESERVE_COMMENTS_BY_DEFAULT\n#include <toml11/toml.hpp>\n```\n\nThis feature is controlled by template parameter in `toml::basic_value<...>`.\n`toml::value` is an alias of `toml::basic_value<...>`.\n\nIf template parameter is explicitly specified, the return value of `toml::parse`\nwill be `toml::basic_value<toml::preserve_comments>`.\nIf the macro is defined, the alias `toml::value` will be\n`toml::basic_value<toml::preserve_comments>`.\n\nComments related to a value can be obtained by `toml::value::comments()`.\nThe return value has the same interface as `std::vector<std::string>`.\n\n```cpp\nconst auto& com = v.comments();\nfor(const auto& c : com)\n{\n    std::cout << c << std::endl;\n}\n```\n\nComments just before and just after (within the same line) a value are kept in a value.\n\n```toml\n# this is a comment for v1.\nv1 = \"foo\"\n\nv2 = \"bar\" # this is a comment for v2.\n# Note that this comment is NOT a comment for v2.\n\n# this comment is not related to any value\n# because there are empty lines between v3.\n# this comment will be ignored even if you set `preserve_comments`.\n\n# this is a comment for v3\n# this is also a comment for v3.\nv3 = \"baz\" # ditto.\n```\n\nEach comment line becomes one element of a `std::vector`.\n\nHash signs will be removed, but spaces after hash sign will not be removed.\n\n```cpp\nv1.comments().at(0) == \" this is a comment for v1.\"s;\n\nv2.comments().at(1) == \" this is a comment for v1.\"s;\n\nv3.comments().at(0) == \" this is a comment for v3.\"s;\nv3.comments().at(1) == \" this is also a comment for v3.\"s;\nv3.comments().at(2) == \" ditto.\"s;\n```\n\nNote that a comment just after an opening brace of an array will not be a\ncomment for the array.\n\n```toml\n# this is a comment for a.\na = [ # this is not a comment for a. this will be ignored.\n  1, 2, 3,\n  # this is a comment for `42`.\n  42, # this is also a comment for `42`.\n  5\n] # this is a comment for a.\n```\n\nYou can also append and modify comments.\nThe interfaces are the same as `std::vector<std::string>`.\n\n```cpp\ntoml::basic_value<toml::preserve_comments> v(42);\nv.comments().push_back(\" add this comment.\");\n// # add this comment.\n// i = 42\n```\n\nAlso, you can pass a `std::vector<std::string>` when constructing a\n`toml::basic_value<toml::preserve_comments>`.\n\n```cpp\nstd::vector<std::string> comments{\"comment 1\", \"comment 2\"};\nconst toml::basic_value<toml::preserve_comments> v1(42, std::move(comments));\nconst toml::basic_value<toml::preserve_comments> v2(42, {\"comment 1\", \"comment 2\"});\n```\n\nWhen `toml::discard_comments` is chosen, comments will not be contained in a value.\n`value::comments()` will always be kept empty.\nAll the modification on comments would be ignored.\nAll the element access in a `discard_comments` causes the same error as accessing\nan element of an empty `std::vector`.\n\nThe comments will also be serialized. If comments exist, those comments will be\nadded just before the values.\n\n__NOTE__: Result types from `toml::parse(...)` and\n`toml::parse<toml::preserve_comments>(...)` are different.\n\n## Customizing containers\n\nActually, `toml::basic_value` has 3 template arguments.\n\n```cpp\ntemplate<typename Comment, // discard/preserve_comment\n         template<typename ...> class Table = std::unordered_map,\n         template<typename ...> class Array = std::vector>\nclass basic_value;\n```\n\nThis enables you to change the containers used inside. E.g. you can use\n`std::map` to contain a table object instead of `std::unordered_map`.\nAnd also can use `std::deque` as a array object instead of `std::vector`.\n\nYou can set these parameters while calling `toml::parse` function.\n\n```cpp\nconst auto data = toml::parse<\n    toml::preserve_comments, std::map, std::deque\n    >(\"example.toml\");\n```\n\nNeedless to say, the result types from `toml::parse(...)` and\n`toml::parse<Com, Map, Cont>(...)` are different (unless you specify the same\ntypes as default).\n\nNote that, since `toml::table` and `toml::array` is an alias for a table and an\narray of a default `toml::value`, so it is different from the types actually\ncontained in a `toml::basic_value` when you customize containers.\nTo get the actual type in a generic way, use\n`typename toml::basic_type<C, T, A>::table_type` and\n`typename toml::basic_type<C, T, A>::array_type`.\n\n## TOML literal\n\ntoml11 supports `\"...\"_toml` literal.\nIt accept both a bare value and a file content.\n\n```cpp\nusing namespace toml::literals::toml_literals;\n\n// `_toml` can convert a bare value without key\nconst toml::value v = u8\"0xDEADBEEF\"_toml;\n// v is an Integer value containing 0xDEADBEEF.\n\n// raw string literal (`R\"(...)\"` is useful for this purpose)\nconst toml::value t = u8R\"(\n    title = \"this is TOML literal\"\n    [table]\n    key = \"value\"\n)\"_toml;\n// the literal will be parsed and the result will be contained in t\n```\n\nThe literal function is defined in the same way as the standard library literals\nsuch as `std::literals::string_literals::operator\"\"s`.\n\n```cpp\nnamespace toml\n{\ninline namespace literals\n{\ninline namespace toml_literals\n{\ntoml::value operator\"\" _toml(const char* str, std::size_t len);\n} // toml_literals\n} // literals\n} // toml\n```\n\nAccess to the operator can be gained with `using namespace toml::literals;`,\n`using namespace toml::toml_literals`, and `using namespace toml::literals::toml_literals`.\n\nNote that a key that is composed only of digits is allowed in TOML.\nAnd, unlike the file parser, toml-literal allows a bare value without a key.\nThus it is difficult to distinguish arrays having integers and definitions of\ntables that are named as digits.\nCurrently, literal `[1]` becomes a table named \"1\".\nTo ensure a literal to be considered as an array with one element, you need to\nadd a comma after the first element (like `[1,]`).\n\n```cpp\n\"[1,2,3]\"_toml;   // This is an array\n\"[table]\"_toml;   // This is a table that has an empty table named \"table\" inside.\n\"[[1,2,3]]\"_toml; // This is an array of arrays\n\"[[table]]\"_toml; // This is a table that has an array of tables inside.\n\n\"[[1]]\"_toml;     // This literal is ambiguous.\n                  // Currently, it becomes an empty array of table named \"1\".\n\"1 = [{}]\"_toml;  // This is a table that has an array of table named 1.\n\"[[1,]]\"_toml;    // This is an array of arrays.\n\"[[1],]\"_toml;    // ditto.\n```\n\nNOTE: `_toml` literal returns a `toml::value`  that does not have comments.\n\n## Conversion between toml value and arbitrary types\n\nYou can also use `toml::get` and other related functions with the types\nyou defined after you implement a way to convert it.\n\n```cpp\nnamespace ext\n{\nstruct foo\n{\n    int         a;\n    double      b;\n    std::string c;\n};\n} // ext\n\nconst auto data = toml::parse(\"example.toml\");\n\n// to do this\nconst foo f = toml::find<ext::foo>(data, \"foo\");\n```\n\nThere are 3 ways to use `toml::get` with the types that you defined.\n\nThe first one is to implement `from_toml(const toml::value&)` member function.\n\n```cpp\nnamespace ext\n{\nstruct foo\n{\n    int         a;\n    double      b;\n    std::string c;\n\n    void from_toml(const toml::value& v)\n    {\n        this->a = toml::find<int        >(v, \"a\");\n        this->b = toml::find<double     >(v, \"b\");\n        this->c = toml::find<std::string>(v, \"c\");\n        return;\n    }\n};\n} // ext\n```\n\nIn this way, because `toml::get` first constructs `foo` without arguments,\nthe type should be default-constructible.\n\nThe second is to implement `constructor(const toml::value&)`.\n\n```cpp\nnamespace ext\n{\nstruct foo\n{\n    explicit foo(const toml::value& v)\n        : a(toml::find<int>(v, \"a\")), b(toml::find<double>(v, \"b\")),\n          c(toml::find<std::string>(v, \"c\"))\n    {}\n\n    int         a;\n    double      b;\n    std::string c;\n};\n} // ext\n```\n\nNote that implicit default constructor declaration will be suppressed\nwhen a constructor is defined. If you want to use the struct (here, `foo`)\nin a container (e.g. `std::vector<foo>`), you may need to define default\nconstructor explicitly.\n\nThe third is to implement specialization of `toml::from` for your type.\n\n```cpp\nnamespace ext\n{\nstruct foo\n{\n    int         a;\n    double      b;\n    std::string c;\n};\n} // ext\n\nnamespace toml\n{\ntemplate<>\nstruct from<ext::foo>\n{\n    static ext::foo from_toml(const value& v)\n    {\n        ext::foo f;\n        f.a = find<int        >(v, \"a\");\n        f.b = find<double     >(v, \"b\");\n        f.c = find<std::string>(v, \"c\");\n        return f;\n    }\n};\n} // toml\n```\n\nIn this way, since the conversion function is defined outside of the class,\nyou can add conversion between `toml::value` and classes defined in another library.\n\nIn some cases, a class has a templatized constructor that takes a template, `T`.\nIt confuses `toml::get/find<T>` because it makes the class \"constructible\" from\n`toml::value`. To avoid this problem, `toml::from` and `from_toml` always\nprecede constructor. It makes easier to implement conversion between\n`toml::value` and types defined in other libraries because it skips constructor.\n\nBut, importantly, you cannot define `toml::from<T>` and `T.from_toml` at the same\ntime because it causes ambiguity in the overload resolution of `toml::get<T>` and `toml::find<T>`.\n\nSo the precedence is `toml::from<T>` == `T.from_toml()` > `T(toml::value)`.\n\nIf you want to convert any versions of `toml::basic_value`,\nyou need to templatize the conversion function as follows.\n\n```cpp\nstruct foo\n{\n    template<typename C, template<typename ...> class M, template<typename ...> class A>\n    void from_toml(const toml::basic_value<C, M, A>& v)\n    {\n        this->a = toml::find<int        >(v, \"a\");\n        this->b = toml::find<double     >(v, \"b\");\n        this->c = toml::find<std::string>(v, \"c\");\n        return;\n    }\n};\n// or\nnamespace toml\n{\ntemplate<>\nstruct from<ext::foo>\n{\n    template<typename C, template<typename ...> class M, template<typename ...> class A>\n    static ext::foo from_toml(const basic_value<C, M, A>& v)\n    {\n        ext::foo f;\n        f.a = find<int        >(v, \"a\");\n        f.b = find<double     >(v, \"b\");\n        f.c = find<std::string>(v, \"c\");\n        return f;\n    }\n};\n} // toml\n```\n\n----\n\nThe opposite direction is also supported in a similar way. You can directly\npass your type to `toml::value`'s constructor by introducing `into_toml` or\n`toml::into<T>`.\n\n```cpp\nnamespace ext\n{\nstruct foo\n{\n    int         a;\n    double      b;\n    std::string c;\n\n    toml::value into_toml() const // you need to mark it const.\n    {\n        return toml::value{{\"a\", this->a}, {\"b\", this->b}, {\"c\", this->c}};\n    }\n};\n} // ext\n\next::foo    f{42, 3.14, \"foobar\"};\ntoml::value v(f);\n```\n\nThe definition of `toml::into<T>` is similar to `toml::from<T>`.\n\n```cpp\nnamespace ext\n{\nstruct foo\n{\n    int         a;\n    double      b;\n    std::string c;\n};\n} // ext\n\nnamespace toml\n{\ntemplate<>\nstruct into<ext::foo>\n{\n    static toml::value into_toml(const ext::foo& f)\n    {\n        return toml::value{{\"a\", f.a}, {\"b\", f.b}, {\"c\", f.c}};\n    }\n};\n} // toml\n\next::foo    f{42, 3.14, \"foobar\"};\ntoml::value v(f);\n```\n\nAny type that can be converted to `toml::value`, e.g. `int`, `toml::table` and\n`toml::array` are okay to return from `into_toml`.\n\nYou can also return a custom `toml::basic_value` from `toml::into`.\n\n```cpp\nnamespace toml\n{\ntemplate<>\nstruct into<ext::foo>\n{\n    static toml::basic_value<toml::preserve_comments> into_toml(const ext::foo& f)\n    {\n        toml::basic_value<toml::preserve_comments> v{{\"a\", f.a}, {\"b\", f.b}, {\"c\", f.c}};\n        v.comments().push_back(\" comment\");\n        return v;\n    }\n};\n} // toml\n```\n\nBut note that, if this `basic_value` would be assigned into other `toml::value`\nthat discards `comments`, the comments would be dropped.\n\n### Macro to automatically define conversion functions\n\nThere is a helper macro that automatically generates conversion functions `from` and `into` for a simple struct.\n\n```cpp\nnamespace foo\n{\nstruct Foo\n{\n    std::string s;\n    double      d;\n    int         i;\n};\n} // foo\n\nTOML11_DEFINE_CONVERSION_NON_INTRUSIVE(foo::Foo, s, d, i)\n\nint main()\n{\n    const auto file = toml::parse(\"example.toml\");\n    auto f = toml::find<foo::Foo>(file, \"foo\");\n}\n```\n\nAnd then you can use `toml::find<foo::Foo>(file, \"foo\");`\n\n**Note** that, because of a slight difference in implementation of preprocessor between gcc/clang and MSVC, [you need to define `/Zc:preprocessor`](https://github.com/ToruNiina/toml11/issues/139#issuecomment-803683682) to use it in MSVC (Thank you @glebm !).\n\n## Formatting user-defined error messages\n\nWhen you encounter an error after you read the toml value, you may want to\nshow the error with the value.\n\ntoml11 provides you a function that formats user-defined error message with\nrelated values. With a code like the following,\n\n```cpp\nconst auto value = toml::find<int>(data, \"num\");\nif(value < 0)\n{\n    std::cerr << toml::format_error(\"[error] value should be positive\",\n                                    data.at(\"num\"), \"positive number required\")\n              << std::endl;\n}\n```\n\nyou will get an error message like this.\n\n```console\n[error] value should be positive\n --> example.toml\n 3 | num = -42\n   |       ~~~ positive number required\n```\n\nWhen you pass two values to `toml::format_error`,\n\n```cpp\nconst auto min = toml::find<int>(range, \"min\");\nconst auto max = toml::find<int>(range, \"max\");\nif(max < min)\n{\n    std::cerr << toml::format_error(\"[error] max should be larger than min\",\n                                    data.at(\"min\"), \"minimum number here\",\n                                    data.at(\"max\"), \"maximum number here\");\n              << std::endl;\n}\n```\n\nyou will get an error message like this.\n\n```console\n[error] max should be larger than min\n --> example.toml\n 3 | min = 54\n   |       ~~ minimum number here\n ...\n 4 | max = 42\n   |       ~~ maximum number here\n```\n\nYou can print hints at the end of the message.\n\n```cpp\nstd::vector<std::string> hints;\nhints.push_back(\"positive number means n >= 0.\");\nhints.push_back(\"negative number is not positive.\");\nstd::cerr << toml::format_error(\"[error] value should be positive\",\n                                data.at(\"num\"), \"positive number required\", hints)\n          << std::endl;\n```\n\n```console\n[error] value should be positive\n --> example.toml\n 2 | num = 42\n   |       ~~ positive number required\n   |\nHint: positive number means n >= 0.\nHint: negative number is not positive.\n```\n\n## Obtaining location information\n\nYou can also format error messages in your own way by using `source_location`.\n\n```cpp\nstruct source_location\n{\n    std::uint_least32_t line()      const noexcept;\n    std::uint_least32_t column()    const noexcept;\n    std::uint_least32_t region()    const noexcept;\n    std::string const&  file_name() const noexcept;\n    std::string const&  line_str()  const noexcept;\n};\n// +-- line()       +--- length of the region (here, region() == 9)\n// v            .---+---.\n// 12 | value = \"foo bar\" <- line_str() returns the line itself.\n//              ^-------- column() points here\n```\n\nYou can get this by\n```cpp\nconst toml::value           v   = /*...*/;\nconst toml::source_location loc = v.location();\n```\n\n## Exceptions\n\nThe following `exception` classes inherits `toml::exception` that inherits\n`std::exception`.\n\n```cpp\nnamespace toml {\nstruct exception      : public std::exception  {/**/};\nstruct syntax_error   : public toml::exception {/**/};\nstruct type_error     : public toml::exception {/**/};\nstruct internal_error : public toml::exception {/**/};\n} // toml\n```\n\n`toml::exception` has `toml::exception::location()` member function that returns\n`toml::source_location`, in addition to `what()`.\n\n```cpp\nnamespace toml {\nstruct exception : public std::exception\n{\n    // ...\n    source_location const& location() const noexcept;\n};\n} // toml\n```\n\nIt represents where the error occurs.\n\n`syntax_error` will be thrown from `toml::parse` and `_toml` literal.\n`type_error` will be thrown from `toml::get/find`, `toml::value::as_xxx()`, and\nother functions that takes a content inside of `toml::value`.\n\nNote that, currently, from `toml::value::at()` and `toml::find(value, key)`\nmay throw an `std::out_of_range` that does not inherits `toml::exception`.\n\nAlso, in some cases, most likely in the file open error, it will throw an\n`std::runtime_error`.\n\n## Colorize Error Messages\n\nBy defining `TOML11_COLORIZE_ERROR_MESSAGE`, the error messages from\n`toml::parse` and `toml::find|get` will be colorized. By default, this feature\nis turned off.\n\nWith the following toml file taken from `toml-lang/toml/tests/hard_example.toml`,\n\n```toml\n[error]\narray = [\n         \"This might most likely happen in multiline arrays\",\n         Like here,\n         \"or here,\n         and here\"\n        ]     End of array comment, forgot the #\n```\n\nthe error message would be like this.\n\n![error-message-1](https://github.com/ToruNiina/toml11/blob/misc/misc/toml11-err-msg-1.png)\n\nWith the following,\n\n```toml\n[error]\n# array = [\n#          \"This might most likely happen in multiline arrays\",\n#          Like here,\n#          \"or here,\n#          and here\"\n#         ]     End of array comment, forgot the #\nnumber = 3.14  pi <--again forgot the #\n```\n\nthe error message would be like this.\n\n![error-message-2](https://github.com/ToruNiina/toml11/blob/misc/misc/toml11-err-msg-2.png)\n\nThe message would be messy when it is written to a file, not a terminal because\nit uses [ANSI escape code](https://en.wikipedia.org/wiki/ANSI_escape_code).\n\nWithout `TOML11_COLORIZE_ERROR_MESSAGE`, you can still colorize user-defined\nerror message by passing `true` to the `toml::format_error` function.\nIf you define `TOML11_COLORIZE_ERROR_MESSAGE`, the value is `true` by default.\nIf not, the default value would be `false`.\n\n```cpp\nstd::cerr << toml::format_error(\"[error] value should be positive\",\n                                data.at(\"num\"), \"positive number required\",\n                                hints, /*colorize = */ true) << std::endl;\n```\n\nNote: It colorizes `[error]` in red. That means that it detects `[error]` prefix\nat the front of the error message. If there is no `[error]` prefix,\n`format_error` adds it to the error message.\n\nCompared to the `TOML11_COLORIZE_ERROR_MESSAGE` macro that enables colorization\nstatically, toml11 provides `toml::color::enable` & `toml::color::disable`\nfunctions to dynamically change the color mode. This feature overwrites\n`TOML11_COLORIZE_ERROR_MESSAGE` and the `colorize` argument of\n`toml::format_error` when you call `enable`.\n\nNote: If either `TOML11_COLORIZE_ERROR_MESSAGE` is defined or the `colorize`\nargument is used, it takes precedence, meaning that `disable` won't work.\nAccordingly, we highly recommend using only one of them.\n\n```cpp\ntoml::color::enable();  // enable colorization\ntoml::color::disable(); // disable colorization\n```\n\nIf you use user-defined error message, you can manage the setting as follows:\n\n```cpp\ntoml::color::enable();\nstd::cerr << toml::format_error(\"[error] value should be positive\",\n                                data.at(\"num\"), \"positive number required\",\n                                hints) << std::endl; // colorized\n\ntoml::color::disable();\nstd::cerr << toml::format_error(\"[error] value should be positive\",\n                                data.at(\"num\"), \"positive number required\",\n                                hints) << std::endl; // NOT colorized\n```\n\nOr you may use toml11 in your application like:\n\n```cpp\nstd::vector<std::string> args(argv + 1, argv + argc);\nauto result = std::find(args.begin(), args.end(), \"--color\");\nif (result != args.end()) {\n    toml::color::enable();\n} else {\n    toml::color::disable();\n}\n\n// use toml11 ...\n```\n\n## Opting out of the default `[error]` prefix\n\ntoml11 prints error messages with the `[error]` prefix by default.\nDefining `TOML11_NO_ERROR_PREFIX` will let toml11 omit the prefix regardless of colorized or not in case you would use a custom prefix, such as `Error:`.\n\n```cpp\n#define TOML11_NO_ERROR_PREFIX\n```\n\n## Serializing TOML data\n\ntoml11 enables you to serialize data into toml format.\n\n```cpp\nconst toml::value data{{\"foo\", 42}, {\"bar\", \"baz\"}};\nstd::cout << data << std::endl;\n// bar = \"baz\"\n// foo = 42\n```\n\ntoml11 automatically makes a small table and small array inline.\nYou can specify the width to make them inline by `std::setw` for streams.\n\n```cpp\nconst toml::value data{\n    {\"qux\",    {{\"foo\", 42}, {\"bar\", \"baz\"}}},\n    {\"quux\",   {\"small\", \"array\", \"of\", \"strings\"}},\n    {\"foobar\", {\"this\", \"array\", \"of\", \"strings\", \"is\", \"too\", \"long\",\n                \"to\", \"print\", \"into\", \"single\", \"line\", \"isn't\", \"it?\"}},\n};\n\n// the threshold becomes 80.\nstd::cout << std::setw(80) << data << std::endl;\n// foobar = [\n// \"this\",\"array\",\"of\",\"strings\",\"is\",\"too\",\"long\",\"to\",\"print\",\"into\",\n// \"single\",\"line\",\"isn't\",\"it?\",\n// ]\n// quux = [\"small\",\"array\",\"of\",\"strings\"]\n// qux = {bar=\"baz\",foo=42}\n\n\n// the width is 0. nothing become inline.\nstd::cout << std::setw(0) << data << std::endl;\n// foobar = [\n// \"this\",\n// ... (snip)\n// \"it?\",\n// ]\n// quux = [\n// \"small\",\n// \"array\",\n// \"of\",\n// \"strings\",\n// ]\n// [qux]\n// bar = \"baz\"\n// foo = 42\n```\n\nIt is recommended to set width before printing data. Some I/O functions changes\nwidth to 0, and it makes all the stuff (including `toml::array`) multiline.\nThe resulting files becomes too long.\n\nTo control the precision of floating point numbers, you need to pass\n`std::setprecision` to stream.\n\n```cpp\nconst toml::value data{\n    {\"pi\", 3.141592653589793},\n    {\"e\",  2.718281828459045}\n};\nstd::cout << std::setprecision(17) << data << std::endl;\n// e = 2.7182818284590451\n// pi = 3.1415926535897931\nstd::cout << std::setprecision( 7) << data << std::endl;\n// e = 2.718282\n// pi = 3.141593\n```\n\nThere is another way to format toml values, `toml::format()`.\nIt returns `std::string` that represents a value.\n\n```cpp\nconst toml::value v{{\"a\", 42}};\nconst std::string fmt = toml::format(v);\n// a = 42\n```\n\nNote that since `toml::format` formats a value, the resulting string may lack\nthe key value.\n\n```cpp\nconst toml::value v{3.14};\nconst std::string fmt = toml::format(v);\n// 3.14\n```\n\nTo control the width and precision, `toml::format` receives optional second and\nthird arguments to set them. By default, the width is 80 and the precision is\n`std::numeric_limits<double>::max_digit10`.\n\n```cpp\nconst auto serial = toml::format(data, /*width = */ 0, /*prec = */ 17);\n```\n\nWhen you pass a comment-preserving-value, the comment will also be serialized.\nAn array or a table containing a value that has a comment would not be inlined.\n\n## Underlying types\n\nThe toml types (can be used as `toml::*` in this library) and corresponding `enum` names are listed in the table below.\n\n| TOML type      | underlying c++ type                | enum class                       |\n| -------------- | ---------------------------------- | -------------------------------- |\n| Boolean        | `bool`                             | `toml::value_t::boolean`         |\n| Integer        | `std::int64_t`                     | `toml::value_t::integer`         |\n| Float          | `double`                           | `toml::value_t::floating`        |\n| String         | `toml::string`                     | `toml::value_t::string`          |\n| LocalDate      | `toml::local_date`                 | `toml::value_t::local_date`      |\n| LocalTime      | `toml::local_time`                 | `toml::value_t::local_time`      |\n| LocalDatetime  | `toml::local_datetime`             | `toml::value_t::local_datetime`  |\n| OffsetDatetime | `toml::offset_datetime`            | `toml::value_t::offset_datetime` |\n| Array          | `array-like<toml::value>`          | `toml::value_t::array`           |\n| Table          | `map-like<toml::key, toml::value>` | `toml::value_t::table`           |\n\n`array-like` and `map-like` are the STL containers that works like a `std::vector` and\n`std::unordered_map`, respectively. By default, `std::vector` and `std::unordered_map`\nare used. See [Customizing containers](#customizing-containers) for detail.\n\n`toml::string` is effectively the same as `std::string` but has an additional\nflag that represents a kind of a string, `string_t::basic` and `string_t::literal`.\nAlthough `std::string` is not an exact toml type, still you can get a reference\nthat points to internal `std::string` by using `toml::get<std::string>()` for convenience.\nThe most important difference between `std::string` and `toml::string` is that\n`toml::string` will be formatted as a TOML string when outputted with `ostream`.\nThis feature is introduced to make it easy to write a custom serializer.\n\n`Datetime` variants are `struct` that are defined in this library.\nBecause `std::chrono::system_clock::time_point` is a __time point__,\nnot capable of representing a Local Time independent from a specific day.\n\n## Unreleased TOML features\n\nAfter TOML v1.0.0 has been released, some features are added to the main branch\nof the TOML spec repository. (see: [CHANGELOG.md in toml-lang/toml repository](https://github.com/toml-lang/toml/blob/main/CHANGELOG.md)).\n\nThe following list shows available \"unreleased\" features that can be activated\nby defining a macro named `TOML11_USE_UNRELEASED_FEATURES`.\n\n- Add new `\\e` shorthand for the escape character.\n\n## Note about heterogeneous arrays\n\nAlthough `toml::parse` allows heterogeneous arrays, constructor of `toml::value`\ndoes not. Here the reason is explained.\n\n```cpp\n// this won't be compiled\ntoml::value v{\n    \"foo\", 3.14, 42, {1,2,3,4,5}, {{\"key\", \"value\"}}\n}\n```\n\nThere is a workaround for this. By explicitly converting values into\n`toml::value`, you can initialize `toml::value` with a heterogeneous array.\nAlso, you can first initialize a `toml::value` with an array and then\n`push_back` into it.\n\n```cpp\n// OK!\ntoml::value v{\n    toml::value(\"foo\"), toml::value(3.14), toml::value(42),\n    toml::value{1,2,3,4,5}, toml::value{{\"key\", \"value\"}}\n}\n\n// OK!\ntoml::value v(toml::array{});\nv.push_back(\"foo\");\nv.push_back(3.14);\n\n// OK!\ntoml::array a;\na.push_back(\"foo\");\na.push_back(3.14);\ntoml::value v(std::move(a));\n```\n\nThe reason why the first example is not allowed is the following.\nLet's assume that you are initializing a `toml::value` with a table.\n\n```cpp\n                    // # expecting TOML table.\ntoml::value v{      // [v]\n    {\"answer\", 42}, // answer = 42\n    {\"pi\",   3.14}, // pi = 3.14\n    {\"foo\", \"bar\"}  // foo = \"bar\"\n};\n```\n\nThis is indistinguishable from a (heterogeneous) TOML array definition.\n\n```toml\nv = [\n    [\"answer\", 42],\n    [\"pi\",   3.14],\n    [\"foo\", \"bar\"],\n]\n```\n\nThis means that the above C++ code makes constructor's overload resolution\nambiguous. So a constructor that allows both \"table as an initializer-list\" and\n\"heterogeneous array as an initializer-list\" cannot be implemented.\n\nThus, although it is painful, we need to explicitly cast values into\n`toml::value` when you initialize heterogeneous array in a C++ code.\n\n```cpp\ntoml::value v{\n    toml::value(\"foo\"), toml::value(3.14), toml::value(42),\n    toml::value{1,2,3,4,5}, toml::value{{\"key\", \"value\"}}\n};\n```\n\n## Breaking Changes from v2\n\nAlthough toml11 is relatively new library (it's three years old now), it had\nsome confusing and inconvenient user-interfaces because of historical reasons.\n\nBetween v2 and v3, those interfaces are rearranged.\n\n- `toml::parse` now returns a `toml::value`, not `toml::table`.\n- `toml::value` is now an alias of `toml::basic_value<discard_comment, std::vector, std::unordered_map>`.\n  - See [Customizing containers](#customizing-containers) for detail.\n- The elements of `toml::value_t` are renamed as `snake_case`.\n  - See [Underlying types](#underlying-types) for detail.\n- Supports for the CamelCaseNames are dropped.\n  - See [Underlying types](#underlying-types) for detail.\n- `(is|as)_float` has been removed to make the function names consistent with others.\n  - Since `float` is a keyword, toml11 named a float type as `toml::floating`.\n  - Also a `value_t` corresponds to `toml::floating` is named `value_t::floating`.\n  - So `(is|as)_floating` is introduced and `is_float` has been removed.\n  - See [Casting a toml::value](#casting-a-tomlvalue) and [Checking value type](#checking-value-type) for detail.\n- An overload of `toml::find` for `toml::table` has been dropped. Use `toml::value` version instead.\n  - Because type conversion between a table and a value causes ambiguity while overload resolution\n  - Since `toml::parse` now returns a `toml::value`, this feature becomes less important.\n  - Also because `toml::table` is a normal STL container, implementing utility function is easy.\n  - See [Finding a toml::value](#finding-a-toml-value) for detail.\n- An overload of `operator<<` and `toml::format` for `toml::table`s are dropped.\n  - Use `toml::value` instead.\n  - See [Serializing TOML data](#serializing-toml-data) for detail.\n- Interface around comments.\n  - See [Preserving Comments](#preserving-comments) for detail.\n- An ancient `from_toml/into_toml` has been removed. Use arbitrary type conversion support.\n  - See [Conversion between toml value and arbitrary types](#conversion-between-toml-value-and-arbitrary-types) for detail.\n\nSuch a big change will not happen in the coming years.\n\n## Running Tests\n\nAfter cloning this repository, run the following command (thank you @jwillikers\nfor automating test set fetching!).\n\n```sh\n$ mkdir build\n$ cd build\n$ cmake .. -Dtoml11_BUILD_TEST=ON\n$ make\n$ make test\n```\n\nTo run the language agnostic test suite, you need to compile\n`tests/check_toml_test.cpp` and pass it to the tester.\n\n## Contributors\n\nI appreciate the help of the contributors who introduced the great feature to this library.\n\n- Guillaume Fraux (@Luthaf)\n  - Windows support and CI on Appvayor\n  - Intel Compiler support\n- Quentin Khan (@xaxousis)\n  - Found & Fixed a bug around ODR\n  - Improved error messages for invalid keys to show the location where the parser fails\n- Petr Beneš (@wbenny)\n  - Fixed warnings on MSVC\n- Ivan Shynkarenka (@chronoxor)\n  - Fixed Visual Studio 2019 warnings\n  - Fix compilation error in `<filesystem>` with MinGW\n- Khoi Dinh Trinh (@khoitd1997)\n  - Fixed warnings while type conversion\n- @KerstinKeller\n  - Added installation script to CMake\n- J.C. Moyer (@jcmoyer)\n  - Fixed an example code in the documentation\n- Jt Freeman (@blockparty-sh)\n  - Fixed feature test macro around `localtime_s`\n  - Suppress warnings in Debug mode\n- OGAWA Kenichi (@kenichiice)\n  - Suppress warnings on intel compiler\n  - Fix include path in README\n- Jordan Williams (@jwillikers)\n  - Fixed clang range-loop-analysis warnings\n  - Fixed feature test macro to suppress -Wundef\n  - Use cache variables in CMakeLists.txt\n  - Automate test set fetching, update and refactor CMakeLists.txt\n- Scott McCaskill\n  - Parse 9 digits (nanoseconds) of fractional seconds in a `local_time`\n- Shu Wang (@halfelf)\n  - fix \"Finding a value in an array\" example in README\n- @maass-tv and @SeverinLeonhardt\n  - Fix MSVC warning C4866\n- Mohammed Alyousef (@MoAlyousef)\n  - Made testing optional in CMake\n- Alex Merry (@amerry)\n  - Add missing include files\n- sneakypete81 (@sneakypete81)\n  - Fix typo in error message\n- Oliver Kahrmann (@founderio)\n  - Fix missing filename in error message if parsed file is empty\n- Karl Nilsson (@karl-nilsson)\n  - Fix many spelling errors\n- ohdarling88 (@ohdarling)\n  - Fix a bug in a constructor of serializer\n- estshorter (@estshorter)\n  - Fix MSVC warning C26478\n- Philip Top (@phlptp)\n  - Improve checking standard library feature availability check\n- Louis Marascio (@marascio)\n  - Fix free-nonheap-object warning\n- Axel Huebl (@ax3l)\n  - Make installation optional if the library is embedded\n- Ken Matsui (@ken-matsui)\n  - Support user-defined error message prefix\n  - Support dynamic color mode\n- Giel van Schijndel (@GielVanSchijndel-TomTom)\n  - Remove needless copy in `parse` function\n- Lukáš Hrázký (@lukash)\n  - Add a `parse(FILE *)` interface and improve file-related error messages\n- Moritz Klammler (@ctcmkl)\n  - Many patches in (#200) including:\n  - Improve CMake scripts, build process, and test file handling\n  - Detect error when `discard_comments` is accessed\n  - And more.\n- Chris White (@cxw42)\n  - Fix address-sanitizer error when parsing literal strings having invalid UTF-8 characters\n- offa (@offa)\n  - Update checkout action to v3\n- Sergey Vidyuk (@VestniK)\n  - Fix for case when vector iterator is raw pointer\n\n## Licensing terms\n\nThis product is licensed under the terms of the [MIT License](LICENSE).\n\n- Copyright (c) 2017-2022 Toru Niina\n\nAll rights reserved."
}
