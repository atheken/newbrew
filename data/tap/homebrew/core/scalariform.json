{
  "name": "scalariform",
  "full_name": "scalariform",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Scala source code formatter",
  "license": "MIT",
  "homepage": "https://github.com/scala-ide/scalariform",
  "versions": {
    "stable": "0.2.10",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/scala-ide/scalariform/releases/download/0.2.10/scalariform.jar",
      "tag": null,
      "revision": null,
      "checksum": "59d7c26f26c13bdbc27e3011da244f01001d55741058062f49e4626862b7991e"
    },
    "head": {
      "url": "https://github.com/scala-ide/scalariform.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 1,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "all": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/scalariform/blobs/sha256:0a155625340add1d947b67289ee0ebfad84655735801562fe67ed853840ec92a",
          "sha256": "0a155625340add1d947b67289ee0ebfad84655735801562fe67ed853840ec92a"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [
    "openjdk"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/scalariform.rb",
  "ruby_source_checksum": {
    "sha256": "6594db0efa42fc9747e6525f00e31680c39180af83b736afee6b2f0ce1fdd3d8"
  },
  "head_dependencies": {
    "build_dependencies": [
      "sbt"
    ],
    "dependencies": [
      "openjdk"
    ],
    "test_dependencies": [],
    "recommended_dependencies": [],
    "optional_dependencies": [],
    "uses_from_macos": [],
    "uses_from_macos_bounds": []
  },
  "date_added": "2015-04-20T12:57:08+01:00",
  "readme": "Scalariform\n===========\n\nScalariform is a code formatter for Scala. It's available as a\nlibrary, a stand-alone command line tool, or via integrations with\nvarious editors and build tools (listed below).\n\nThe plan is to add preferences and features as and when people ask for\nthem, so please do raise a Github issue if it doesn't format your code\nthe way you'd like it, and I'll see what I can do.\n\nScalariform is licenced under `The MIT Licence`_.\n\n.. _Scala Style Guide: http://docs.scala-lang.org/style/\n.. _The MIT Licence: http://opensource.org/licenses/mit-license.php\n\nInstalling with Homebrew (for OS X users)\n-----------------------------------------\n\nMac OS X users can install the scalariform CLI tool using the `Homebrew`_ package manager. ::\n\n    brew install scalariform\n\nOr, if you would like to install the latest development release: ::\n\n    brew install --HEAD scalariform\n\n.. _Homebrew: https://github.com/Homebrew/homebrew\n\nPackaging an executable JAR\n---------------------------\n\nIf you would like to package scalariform for use on the command line with java -jar, clone the repo and perform the following simple steps: ::\n\n    sbt \"project cli\" \"assembly\"\n\nsbt will build one jar with all the dependencies and put it in ::\n\n    cli/target/scala-$your_scala_version/cli-assembly-$scalariform_version.jar\n\nYou can copy this to a location in your path and execute it as follows: ::\n\n   java -jar /home/me/bin/cli-assembly-$scalariform_version.jar -f -q +compactControlReadability +alignParameters +alignSingleLineCaseStatements +doubleIndentConstructorArguments +rewriteArrowSymbols +preserveSpaceBeforeArguments --stdout ~/myproject/src/main/scala/Stuff.scala > Stuff.scala\n\nIntegration with sbt\n--------------------\n\nA plugin for SBT is available at https://github.com/sbt/sbt-scalariform.\n\nUsage within a project\n----------------------\n\nHave a use for the scalariform source code directly? You can use it as a build dependency: ::\n\n    \"org.scalariform\" %% \"scalariform\" % \"0.2.10\"\n\nIntegration with Eclipse\n------------------------\n\nScala IDE for Eclipse uses Scalariform for code formatting:\n\n- Right click in the editor -> Source -> Format\n- Press Ctrl-Shift-F\n\nIf you select some lines, only those will be formatted.\n\nYou can also configure formatting to be run as a save action (Window -> Preferences -> Java -> Editor -> Save Actions).\n\nTo set preferences, go to either\n\n- Window -> Preferences -> Scala -> Editor -> Formatter\n- Project -> Properties -> Scala Formatter\n\nFrom the formatter preference window you can import/export existing preferences.\nSee the `reference.conf`_ for a listing of all available preferences and their defaults.\n\n.. _reference.conf: https://github.com/scala-ide/scalariform/blob/master/formatterPreferences.properties\n\nIntegration with Emacs/ENSIME\n-----------------------------\n\n\"`ENSIME`_ uses the Scalariform library to format Scala sources. Type C-c C-v f to format the current buffer.\"\n\n.. _ENSIME: https://github.com/ensime/ensime-server\n\nIntegration with jEdit\n----------------------\n\nSee `ScalaSidekick`_ by Stefan Ettrup:\n\n.. _ScalaSidekick: https://github.com/StefanE/ScalaSidekick\n\nRun Plugins -> scalaSidekickPlugin -> Format Scala File\n\nIntegration with Maven\n----------------------\n\nThere is `scalariform-maven-plugin`_ compatible with Scalariform 0.2.x.\n\n.. _scalariform-maven-plugin: https://github.com/tashoyan/scalariform-maven-plugin\n\nIntegration with Gradle\n-----------------------\n\nThere is a `Gradle plugin`_ to run Scalariform contributed by Jeroen van Erp.\n\n.. _Gradle plugin: https://github.com/hierynomus/scalariform-gradle-plugin\n\nUsage (Gradle 2.1 and above)::\n\n  plugins {\n    id \"com.github.hierynomus.scalariform\" version \"0.1.0\"\n  }\n\n  // optionally, configure Scalariform settings\n  scalariform {\n    alignParameters = true\n    alignSingleLineCaseStatements = true\n  }\n\n  formatAllScala\n\nSee `the documentation`_ for further usage examples.\n\n.. _the documentation: https://github.com/hierynomus/scalariform-gradle-plugin/blob/master/README.adoc\n\nIntegration with TextMate\n-------------------------\n\nSee Mads Jensen's Scala TextMate bundle:\n\n  http://github.com/mads379/scala.tmbundle\n\nReformat using Ctrl-Shift-H.\n\nUse with Vim\n------------\n\nWhile there is no specific Vim integration at present, you can use\nScalariform as an external formatter for the ``gg=G`` command by adding\nthe following to ``.vimrc`` ::\n\n  au BufEnter *.scala setl formatprg=java\\ -jar\\ /home/me/bin/scalariform.jar\\ -f\\ -q\\ +compactControlReadability\\ +alignParameters\\ +alignSingleLineCaseStatements\\ +doubleIndentConstructorArguments\\ +rewriteArrowSymbols\\ +preserveSpaceBeforeArguments\\ --stdin\\ --stdout\n  au BufEnter *.scala setl equalprg=java\\ -jar\\ /home/me/bin/scalariform.jar\\ -f\\ -q\\ +compactControlReadability\\ +alignParameters\\ +alignSingleLineCaseStatements\\ +doubleIndentConstructorArguments\\ +rewriteArrowSymbols\\ +preserveSpaceBeforeArguments\\ --stdin\\ --stdout\n\n\nDownload scalariform.jar from the `latest release`_\n\n.. _latest release: https://github.com/scala-ide/scalariform/releases/latest\n\nCommand line tool\n-----------------\n\n  https://github.com/scala-ide/scalariform/wiki/Command-line-tool\n\nLibrary\n-------\n\n  https://github.com/scala-ide/scalariform/wiki/Library\n\nPreferences\n-----------\n\nalignArguments\n~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nAligns multi-line arguments\n\nFor example, if ``false``, then:\n\n.. code:: scala\n\n  Cake(candles = 10,\n    frostingFlavor = Vanilla,\n    layerFlavor = Chocolate,\n    iceCream = true\n  )\n\nIf ``true``, then:\n\n.. code:: scala\n\n  Cake(candles        = 10,\n       frostingFlavor = Vanilla,\n       layerFlavor    = Chocolate,\n       iceCream       = true\n  )\n\nThis option is disabled if ``indentWithTabs`` is ``true``.\n\nalignParameters\n~~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nAlign class/function parameters (modifiers and name, type, and defaults) in three columns.\n\nFor example, if ``false``, then:\n\n.. code:: scala\n\n  class Person(name: String,\n    age: Int = 24,\n    birthdate: Date,\n    astrologicalSign: String = \"libra\",\n    shoeSize: Int,\n    favoriteColor: java.awt.Color\n  )\n\nIf ``true``, then:\n\n.. code:: scala\n\n  class Person(name:             String,\n               age:              Int            = 24,\n               birthdate:        Date,\n               astrologicalSign: String         = \"libra\",\n               shoeSize:         Int,\n               favoriteColor:    java.awt.Color\n  )\n\nThis will also place the \"implicit\" keyword in parameters on its own line, whenever\nthe parameter being formatted contains a newline::\n\nFor example, if ``false``, then:\n\n.. code:: scala\n\n  def formatBirthDate(\n    implicit birthdate: Date = Date(\"11/11/11\"),\n    birthtime: Time\n  ): DateTime\n\nIf ``true``, then:\n\n.. code:: scala\n\n  def formatBirthDate(\n    implicit\n    birthdate: Date = Date(\"11/11/11\"),\n    birthtime: Time\n  ): DateTime\n\nThis option is disabled if ``indentWithTabs`` is ``true``.\n\nalignSingleLineCaseStatements\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nAlign the arrows of consecutive single-line case statements. For example, if ``true``, then:\n\n.. code:: scala\n\n  a match {\n    case b => 1\n    case ccc => 2\n    case dd => 3\n  }\n\nIs reformatted as:\n\n.. code:: scala\n\n  a match {\n    case b   => 1\n    case ccc => 2\n    case dd  => 3\n  }\n\nThis option is disabled if ``indentWithTabs`` is ``true``.\n\nalignSingleLineCaseStatements.maxArrowIndent\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``40``\n\nWhen ``alignSingleLineCaseStatements`` is ``true`` there is a limit on\nthe number of spaces that can be inserted before an arrow to align it\nwith other case statements. This can be used to avoid very large gaps,\ne.g.:\n\n.. code:: scala\n\n  a match {\n    case Some(wibble, wobble) if wibble + wibble > wobble * wibble => 1\n    case ccc                                                       => 2\n  }\n\nallowParamGroupsOnNewlines\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nWhen ``allowParamGroupsOnNewlines`` is ``true`` the default behavior of collapsing\nparam groups into a single line is disabled. This allows for the following formatting style:\n\n.. code:: scala\n\n  def foo[T]\n    (a: A)\n    (b: B)\n    (implicit t: T)\n\ncompactControlReadability\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nWhen ``compactControlReadability`` is ``true``, then ``if``/``else`` and\n``try``/``catch``/``finally`` control structures will be formatted\nusing `Compact Control Readability`_ style\n\n.. _Compact Control Readability: https://en.wikipedia.org/wiki/Indent_style#Variant:_Stroustrup\n\n.. code:: scala\n\n  if (x == y) {\n    foo()\n  }\n  else if (y == z) {\n    bar()\n  }\n  else {\n    baz()\n  }\n\n  try {\n    foo()\n  }\n  catch {\n    case _ => bar()\n  }\n  finally {\n    baz()\n  }\n\n\ncompactStringConcatenation\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nOmit spaces when formatting a '+' operator on String literals. For example, if ``false``, then:\n\n.. code:: scala\n\n  \"Hello \" + name + \"!\"\n\nIf ``true``, then:\n\n.. code:: scala\n\n  \"Hello \"+name+\"!\"\n\nThe Scala Style Guide recommends_ that operators, \"should `always` be\ninvoked using infix notation with spaces separated the target\".\n\n.. _recommends: http://docs.scala-lang.org/style/method-invocation.html#symbolic-methodsoperators\n\ndanglingCloseParenthesis\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``Prevent``\n\nIf ``Force``, any closing parentheses will be set to dangle. For example:\n\n.. code:: scala\n\n   Box(\n     contents: List[Thing])\n\nbecomes:\n\n.. code:: scala\n\n   Box(\n     contents: List[Thing]\n   )\n\nIf ``Prevent``, all dangling parenthesis are collapsed. For example:\n\n.. code:: scala\n\n   Box(\n     contents: List[Thing]\n   )\n\nbecomes:\n\n.. code:: scala\n\n   Box(\n     contents: List[Thing])\n\nIf ``Preserve``, scalariform will try to match what unformatted source code is already doing per parenthesis,\neither forcing or preventing.\n\n~~doubleIndentClassDeclaration~~ (Deprecated, use `doubleIndentConstructorArguments`)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nWith this set to ``true`` and ``doubleIndentConstructorArguments`` set to ``false``,\nclass (and trait / object) declarations that span multiple lines will be formatted so\nthat the inheritance section is doubly indented. This provides a visual distinction\nfrom the members of the class. For example:\n\n.. code:: scala\n\n  class Person(\n    name: String,\n    age: Int,\n    birthdate: Date,\n    astrologicalSign: String,\n    shoeSize: Int,\n    favoriteColor: java.awt.Color)\n      extends Entity\n      with Logging\n      with Identifiable\n      with Serializable {\n    def firstMethod = ...\n  }\n\nNote: ``doubleIndentConstructorArguments`` style formatting is recommended_ by the Scala Style Guide.\n\ndoubleIndentConstructorArguments\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nWith this set to ``true``, class (and trait / object) declarations\nwill be formatted as recommended_ by the Scala Style Guide. That is,\nif the declaration section spans multiple lines, it will be formatted\nso that the parameter section is doubly indented. This provides a visual\ndistinction between the constructor arguments & the extensions. For example:\n\n.. code:: scala\n\n  class Person(\n      name: String,\n      age: Int,\n      birthdate: Date,\n      astrologicalSign: String,\n      shoeSize: Int,\n      favoriteColor: java.awt.Color)\n    extends Entity\n    with Logging\n    with Identifiable\n    with Serializable {\n  }\n\nOr:\n\n.. code:: scala\n\n  class Person(\n      name: String,\n      age: Int,\n      birthdate: Date,\n      astrologicalSign: String,\n      shoeSize: Int,\n      favoriteColor: java.awt.Color) {\n    def firstMethod = ...\n  }\n\n.. _recommended: http://docs.scala-lang.org/style/declarations.html#classes\n\n.. _recommended: http://docs.scala-lang.org/style/declarations.html#classes\n\ndoubleIndentMethodDeclaration\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nWith this set to ``true``, method declarations will have an extra indentation\nadded to their parameter list, if it spans multiple lines.\nThis provides a visual distinction from the method body. For example::\n\n  def longMethodNameIsLong(paramOneNameIsLong: String, paramTwo: String,\n      paramThreeNameIsReallyLong): Unit = {\n    val startOfMethod = ...\n  }\n\nOr::\n\n  def longMethodNameIsLong(\n      paramOneNameIsLong: String,\n      paramTwoNameIsLong: String,\n      paramThreeNameIsLong): Unit = {\n    val startOfMethod = ...\n  }\n\nfirstArgumentOnNewline\n~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``Force``\n\nWhether or not to place the first argument of multi-line function calls on its own line.\n\nIf ``Force``, first arguments will be on a new line:\n\n.. code:: scala\n\n  foo(\n    1,\n    2\n  )\n\n  bar(\n    3,\n    4\n  )\n\nIf ``Prevent``, first arguments will be on function call line:\n\n.. code:: scala\n\n  foo(1,\n    2\n  )\n\n  bar(3,\n    4\n  )\n\nIf ``Preserve``, first arguments will stay where they are:\n\n.. code:: scala\n\n  foo(\n    1,\n    2\n  )\n\n  bar(3,\n    4\n  )\n\nfirstParameterOnNewline\n~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``Force``\n\nWhether or not to place the first parameter for multi-line method or constructor definition on its own line.\n\nIf ``Force``, first parameters will be on a new line:\n\n.. code:: scala\n\n  abstract class Person(\n    name: Int,\n    age: String\n  ) {\n    def livesIn(\n      city: String,\n      state: String\n    ): Boolean\n  }\n\nIf ``Prevent``, first parameters will be on the definition line:\n\n.. code:: scala\n\n  abstract class Person(name: Int,\n    age: String\n  ) {\n    def livesIn(city: String,\n      state: String\n    ): Boolean\n  }\n\nIf ``Preserve``, first parameters will stay where they are:\n\n.. code:: scala\n\n  abstract class Person(name: Int,\n    age: String\n  ) {\n    def livesIn(\n      city: String,\n      state: String\n    ): Boolean\n  }\n\nformatXml\n~~~~~~~~~\n\nDefault: ``true``\n\nFormat embedded XML literals; if ``false`` they will be left untouched.\n\nindentLocalDefs\n~~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nIf ``true``, indent local methods an extra level, with the intention of distinguishing them from other statements. For example,:\n\n.. code:: scala\n\n  class A {\n    def find(...) = {\n      val x = ...\n        def find0() = {\n          ...\n        }\n      find0(...)\n    }\n  }\n\n\nindentPackageBlocks\n~~~~~~~~~~~~~~~~~~~\n\nDefault: ``true``\n\nWhether to indent package blocks. For example, if ``true``:\n\n.. code:: scala\n\n  package foo {\n    package bar {\n      class Baz\n    }\n  }\n\nElse if ``false``:\n\n.. code:: scala\n\n  package foo {\n  package bar {\n  class Baz\n  }\n  }\n\nindentSpaces\n~~~~~~~~~~~~\n\nDefault: ``2``\n\nThe number of spaces to use for each level of indentation.\n\nThis option is ignored if ``indentWithTabs`` is ``true``.\n\nindentWithTabs\n~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nUse a tab for each level of indentation. When set to ``true``, this\nignores any setting given for ``indentSpaces``. In addition, for the\nmoment, ``alignSingleLineCaseStatements``, ``alignArguments``, and ``alignParameters``\noptions are not supported when indenting with tabs, and XML\nindentation is handled differently.\n\nmultilineScaladocCommentsStartOnFirstLine\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nIf ``true``, start a multi-line Scaladoc comment body on same line as the opening comment delimiter:\n\n.. code:: scala\n\n  /** This method applies f to each\n   *  element of the given list.\n   */\n\nIf ``false``, start the comment body on a separate line below the opening delimiter:\n\n.. code:: scala\n\n  /**\n   * This method applies f to each\n   * element of the given list.\n   */\n\nnewlineAtEndOfFile\n~~~~~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nIf ``true``, newlines will be added at the end of all formatted files.\n\nplaceScaladocAsterisksBeneathSecondAsterisk\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nIf ``true``, Scaladoc asterisks will be placed beneath the second asterisk:\n\n.. code:: scala\n\n  /** Wibble\n    * wobble\n    */\n  class A\n\nOtherwise, if ``false``, beneath the first asterisk:\n\n.. code:: scala\n\n  /** Wibble\n   *  wobble\n   */\n  class A\n\npreserveSpaceBeforeArguments\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nIf ``true``, the formatter will keep an existing space before a parenthesis argument. For example:\n\n.. code:: scala\n\n  stack.pop() should equal (2)\n\nOtherwise, if ``false``, spaces before arguments will always be removed.\n\nrewriteArrowSymbols\n~~~~~~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nReplace arrow tokens uniformly, either as Unicode symbols or as ASCII, depending on the setting of\n``useUnicodeArrows``. Starting from Scala 2.13, unicode arrows are deprecated.\n\nFor example, if ``useUnicodeArrows == true``:\n\n.. code:: scala\n\n  for (n <- 1 to 10) n % 2 match {\n    case 0 => println(\"even\")\n    case 1 => println(\"odd\")\n  }\n\nis formatted as:\n\n.. code:: scala\n\n  for (n ← 1 to 10) n % 2 match {\n    case 0 ⇒ println(\"even\")\n    case 1 ⇒ println(\"odd\")\n  }\n\nsingleCasePatternOnNewline\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``true``\n\nWhen ``singleCasePatternOnNewline`` is ``false`` the default behavior of forcing\na single case pattern onto a newline is disabled. This allows for the following formatting style:\n\n.. code:: scala\n\n  items.map { case (key, value) =>\n    (key, transform(value))\n  }\n\nspaceBeforeColon\n~~~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nWhether to ensure a space before all single colons. For example, if ``false``, then:\n\n.. code:: scala\n\n  def add[T: Numeric](a: T, b: T): Int = implictly[Numeric[T]].plus(a, b)\n\nIf ``true``, then:\n\n.. code:: scala\n\n  def add[T : Numeric](a : T, b : T): Int = implictly[Numeric[T]].plus(a, b)\n\nspaceBeforeContextColon\n~~~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nWhether to ensure a space before colons in context bounds (the typeclass pattern). For example, if ``false``, then:\n\n.. code:: scala\n\n  def newArray[T: ClassManifest](n: Int) = new Array[T](n)\n\nIf ``true``, then:\n\n.. code:: scala\n\n  def newArray[T : ClassManifest](n: Int) = new Array[T](n)\n\nspaceInsideBrackets\n~~~~~~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nWhether to use a space inside type brackets. For example, if ``true``, then:\n\n.. code:: scala\n\n  Array[ String ]\n\nIf ``false``, then:\n\n.. code:: scala\n\n  Array[String]\n\nspaceInsideParentheses\n~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``false``\n\nWhether to use a space inside non-empty parentheses. For example, if ``true``, then:\n\n.. code:: scala\n\n  def main( args : Array[String] )\n\nIf ``false``, then:\n\n.. code:: scala\n\n  def main(args : Array[String])\n\nspacesAroundMultiImports\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``true``\n\nWhether or not to add spaces around multi-imports.\nFor example, if ``false``, then:\n\n.. code:: scala\n\n  import a.{b,c,d}\n  import foo.{bar => baz}\n\nIf ``true``, then:\n\n.. code:: scala\n\n  import a.{ b, c, d }\n  import foo.{ bar => baz }\n\nCompatibility note: Versions 0.1.6 & 0.1.7 of `Scalariform` used ``false``.\n\nspacesWithinPatternBinders\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nDefault: ``true``\n\nWhether to add a space around the @ token in pattern binders. For example, if ``true``,:\n\n.. code:: scala\n\n  case elem @ Multi(values @ _*) =>\n\nIf ``false``,:\n\n.. code:: scala\n\n  case elem@Multi(values@_*) =>\n\nuseUnicodeArrows\n~~~~~~~~~~~~~~~~\n\nDefault: ``true``\n\nControls the replacement of arrows if ``rewriteArrowSymbols == true``. To use unicode arrows in your codebase\nset to `true`, otherwise, set to false. For example, if ``useUnicodeArrows == false`` (and ``rewriteArrowSymbols == true``):\n\n.. code:: scala\n\n  for (n ← 1 to 10) n % 2 match {\n    case 0 ⇒ println(\"even\")\n    case 1 ⇒ println(\"odd\")\n  }\n\nis formatted as:\n\n.. code:: scala\n\n  for (n <- 1 to 10) n % 2 match {\n    case 0 => println(\"even\")\n    case 1 => println(\"odd\")\n  }\n\nScala Style Guide\n~~~~~~~~~~~~~~~~~\n\nScalariform is compatible with the `Scala Style Guide`_ in the sense\nthat, given the right preference settings, source code that is\ninitially compliant with the Style Guide will not become uncompliant\nafter formatting. In a number of cases, running the formatter will\nmake uncompliant source more compliant.\n\n=========================================== ========= =========\nPreference                                  Value     Default?\n=========================================== ========= =========\nalignParameters                             ``false``\ncompactStringConcatenation                  ``false``\ndoubleIndentConstructorArguments            ``true``    No\nindentSpaces                                ``2``\nplaceScaladocAsterisksBeneathSecondAsterisk ``true``    No\npreserveSpaceBeforeArguments                ``false``\nrewriteArrowSymbols                         ``false``\nspaceBeforeColon                            ``false``\nspaceInsideBrackets                         ``false``\nspaceInsideParentheses                      ``false``\nspacesAroundMultiImports                    ``false``\nuseUnicodeArrows                            ``true``\n=========================================== ========= =========\n\nSource Directives\n-----------------\n\nAs well as global preferences, formatting can be tweaked at the source level through comments.\n\nformat: [ON|OFF]\n~~~~~~~~~~~~~~~~\n\nDisables the formatter for selective portions of a source file:\n\n.. code:: scala\n\n  // format: OFF    <-- this directive disables formatting from this point\n  class AsciiDSL {\n    n ¦- \"1\" -+ { n: Node =>\n            n ¦- \"i\"\n            n ¦- \"ii\"\n            n ¦- \"iii\"\n            n ¦- \"iv\"\n            n ¦- \"v\"\n    }\n    n ¦- \"2\"\n    n ¦- \"3\" -+ { n: Node =>\n            n ¦- \"i\"\n            n ¦- \"ii\" -+ { n: Node =>\n                     n ¦- \"a\"\n                     n ¦- \"b\"\n                     n ¦- \"c\"\n            }\n            n ¦- \"iii\"\n            n ¦- \"iv\"\n            n ¦- \"v\"\n    }\n    // format: ON   <-- formatter resumes from this point\n    ...\n  }\n  // (see: http://dev.day.com/microsling/content/blogs/main/scalajcr2.html)\n\nformat: [+|-]<preferenceName>\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSets a preference for the entirety of the source file, overriding the global formatting settings:\n\n.. code:: scala\n\n  // format: +preserveSpaceBeforeArguments\n  class StackSpec extends FlatSpec with ShouldMatchers {\n    // ...\n    stack.pop() should equal (2)\n  }"
}
