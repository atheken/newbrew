{
  "name": "tere",
  "full_name": "tere",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Terminal file explorer",
  "license": "EUPL-1.2",
  "homepage": "https://github.com/mgunyho/tere",
  "versions": {
    "stable": "1.5.0",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/mgunyho/tere/archive/refs/tags/v1.5.0.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "84195f45b738fb7c805d7b348185658d0dc58aa26e7f92fcad9578bc7bd694bf"
    },
    "head": {
      "url": "https://github.com/mgunyho/tere.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/tere/blobs/sha256:3127d3aad6b0d14f520883ffbbd76094f12379a3eb90a3014cfb5df3dadc0b14",
          "sha256": "3127d3aad6b0d14f520883ffbbd76094f12379a3eb90a3014cfb5df3dadc0b14"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/tere/blobs/sha256:bb69192a655ecdc6584b90910eba6508dc14ee6a5910b0fda2868810dc27b7c8",
          "sha256": "bb69192a655ecdc6584b90910eba6508dc14ee6a5910b0fda2868810dc27b7c8"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/tere/blobs/sha256:7a1c85a9135fc5f1a2d9287390eeb6b47ef9657b99020387c03d7586f3408c8f",
          "sha256": "7a1c85a9135fc5f1a2d9287390eeb6b47ef9657b99020387c03d7586f3408c8f"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/tere/blobs/sha256:c61a055f643e9b45a3ea810a75d950baa0e9b7cf3f3770dff9190864420e90be",
          "sha256": "c61a055f643e9b45a3ea810a75d950baa0e9b7cf3f3770dff9190864420e90be"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/tere/blobs/sha256:35241180534467310032cd931e4ab56080e551b8fe3a8cac105e0dec0af08222",
          "sha256": "35241180534467310032cd931e4ab56080e551b8fe3a8cac105e0dec0af08222"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/tere/blobs/sha256:26c58eac7b1b9e1ea976dfd7fdd33a1afe94aacc82586e65c8e3f103a8595b73",
          "sha256": "26c58eac7b1b9e1ea976dfd7fdd33a1afe94aacc82586e65c8e3f103a8595b73"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/tere/blobs/sha256:fa494fe8026952a11252edf6191b3e4a1bf6ed19b43a50b64e25a119f85713c6",
          "sha256": "fa494fe8026952a11252edf6191b3e4a1bf6ed19b43a50b64e25a119f85713c6"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "rust"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/tere.rb",
  "ruby_source_checksum": {
    "sha256": "8b8a5521f8350448aa356686a0ddccee7fb84148932a285ea009f349ddccc495"
  },
  "date_added": "2022-07-25T11:04:06+00:00",
  "readme": "# tere - a faster alternative to cd + ls\n\n\n`tere` is a terminal file explorer. It is a faster alternative to using `cd`\nand `ls` to browse folders in your terminal. `tere` only really does one thing: it\nprovides a TUI for efficiently navigating to a folder, and then prints the path\nto that folder when you exit. By configuring your shell to `cd` to the printed\nfolder, you can move around in your filesystem very quickly.\n\n![A gif showing what using tere looks like](./demo/tere-demo-2022-07-10-2027-e2-O3.gif)\n\nNote that `tere` is not a file _manager_, it\ncan only be used to browse folders, not to create, rename or delete them.\n\n`tere` aims to be minimal and simple. It should be obvious how to use it.\nNavigating the file system should be efficient and require as few keystrokes as\npossible. A great source of inspiration for `tere` is the \"type-ahead search\"\nfunctionality found in many GUI file managers.\n\n\"Tere\" means \"hello\" in Estonian. It also feels nice to type.\n\n## Setup\n\nTo use `tere` for changing directories, you need to install it, and then\nconfigure your shell to `cd` to the folder `tere` prints when it exits. Here's\nhow to do it:\n\n### Step 1: Obtain a copy of `tere`\n\nThis can be done in various ways:\n\n- Download the [latest release](https://github.com/mgunyho/tere-rs/releases).\n- Install `tere` with [Homebrew](https://brew.sh) by running `brew install tere`.\n- Install `tere` with [Nix](https://nixos.org/) by running `nix-env -i tere`.\n- Install `tere` with [Cargo](https://www.rust-lang.org/tools/install) by running `cargo install tere`.\n- Install `tere` with [Pacman](https://wiki.archlinux.org/title/pacman) by running `pacman -S tere`.\n- Install `tere` with [Scoop](https://scoop.sh) by running `scoop install tere`.\n- Build from source, see [below](#hacking).\n\n### Step 2: Configure your shell to `cd` using `tere`\n\n`tere` only prints a folder when it exits. To make your shell actually `cd` to this folder, you have to define a function or alias, since the working directory cannot be changed by a subprocess. See instructions for your shell below.\n\n<details>\n<summary>Bash/Zsh</summary>\n\nPut this in your `.bashrc` or `.zshrc`:\n\n```sh\ntere() {\n    local result=$(command tere \"$@\")\n    [ -n \"$result\" ] && cd -- \"$result\"\n}\n```\n</details>\n\n<details>\n<summary>fish</summary>\n\nPut this in your `config.fish`:\n\n```sh\nfunction tere\n    set --local result (command tere $argv)\n    [ -n \"$result\" ] && cd -- \"$result\"\nend\n```\n</details>\n\n<details>\n<summary>Xonsh</summary>\n\nPut this in your `.xonshrc` (Xonsh v0.10. or newer is required):\n\n```py\ndef _tere(args):\n    result = $(tere @(args)).strip()\n    if result:\n        cd @(result)\n\naliases[\"tere\"] = _tere\n```\n</details>\n\n<details>\n<summary>PowerShell</summary>\n\nPut this in your `$PROFILE`:\n\n```powershell\nfunction Invoke-Tere() {\n    $result = . (Get-Command -CommandType Application tere) $args\n    if ($result) {\n        Set-Location $result\n    }\n}\nSet-Alias tere Invoke-Tere\n```\n</details>\n\n<details>\n<summary>Windows Command Prompt (CMD)</summary>\n\nPut this in a batch script file called `tere.bat` in a folder included in your `PATH` environment variable such as `C:\\Windows`:\n\n```batch\n@echo off\n\nrem set the location/path of the tere executable here...\nSET TereEXE=C:\\path\\to\\tere.exe\n\nFOR /F \"tokens=*\" %%a in ('%TereEXE% %*') do SET OUTPUT=%%a\nIF [\"%OUTPUT%\"] == [\"\"] goto :EOF\ncd %OUTPUT%\n```\nNote that if you want to make `tere` work with *both* PowerShell and CMD, you should *not* put `tere.exe` to a location that is in your `PATH`, because then the `.exe` will be run instead of the `.bat`. Place `tere.exe` somewhere that is not in your `PATH`, and use the full path to the exe in both the `.bat` file and in the PowerShell `$PROFILE`.\n</details>\n\nIf `tere` is not in your `PATH`, use an absolute path to the tere binary in your shell config file. For example, for Bash/Zsh, you would need to replace `local result=$(command tere \"$@\")` with `local result=$(/path/to/tere \"$@\")`, or for PowerShell, replace `(Get-Command -CommandType Application tere)` with `C:\\path\\to\\tere.exe`.\n\nIf instructions for your shell are missing, feel free to send a pull request that includes them!\n\n### Step 3: That's it\n\nThe next time you open a new shell, the command `tere` should work. You can of course rename the shell function/alias to whatever you like. The shell configuration also acts as a config file for `tere`, just add the options you want (see `tere --help`).\n\n### Supported platforms\n\n`tere` works on Linux, Windows and macOS. For Linux and Windows, binaries are provided in the [releases](https://github.com/mgunyho/tere-rs/releases). For Mac, you can install using Homebrew or Cargo, or build from source.\n\nIf you get libc errors on Linux, try the `musl` version.\n\n## User guide\n\n### Basic navigation\n\nYou can navigate folders in `tere` by moving the cursor around and by typing to search. By default, the cursor can be moved up or down using the arrow keys, and pressing <kbd>Enter</kbd> or the right arrow <kbd>→</kbd> to enter the highlighted folder. You can move to the parent folder by pressing <kbd>Enter</kbd> on the parent folder item `..`, or with the left arrow <kbd>←</kbd>. Once you have navigated to the folder you want, exit `tere` by perssing <kbd>Esc</kbd>. If you have configured your shell correctly, your shell's current working directory should now be set to that folder.\n\n### Keyboard shortcuts\n\n`tere` has the following keyboard shortcuts by default:\n\n| Description | Default shortcut(s) | Action name |\n|:---:|:---:|:--:|\n|Enter directory under cursor | <kbd>Enter</kbd> or <kbd>→</kbd> or <kbd>Alt</kbd>-<kbd>↓</kbd> or <kbd>Alt</kbd>-<kbd>l</kbd> or if not searching, <kbd>Space</kbd> | `ChangeDir` |\n|Go to parent directory| <kbd>←</kbd> or <kbd>Alt</kbd>-<kbd>↑</kbd> or <kbd>Alt</kbd>-<kbd>h</kbd> or if not searching, <kbd>Backspace</kbd> or <kbd>-</kbd> | `ChangeDirParent` |\n|Go to home directory| <kbd>~</kbd> or <kbd>Ctrl</kbd>-<kbd>Home</kbd> or <kbd>Ctrl</kbd>-<kbd>Alt</kbd>-<kbd>h</kbd>| `ChangeDirHome` |\n|Go to root directory| <kbd>/</kbd> or <kbd>Alt</kbd>-<kbd>r</kbd>| `ChangeDirRoot` |\n|Move cursor up  | <kbd>↑</kbd> or <kbd>Alt</kbd>-<kbd>k</kbd> | `CursorUp` |\n|Move cursor down| <kbd>↓</kbd> or <kbd>Alt</kbd>-<kbd>j</kbd> | `CursorDown` |\n|Move cursor up   by one screen| <kbd>Page Up</kbd>   or <kbd>Ctrl</kbd>-<kbd>u</kbd> or <kbd>Alt</kbd>-<kbd>u</kbd> | `CursorUpScreen` |\n|Move cursor down by one screen| <kbd>Page Down</kbd> or <kbd>Ctrl</kbd>-<kbd>d</kbd> or <kbd>Alt</kbd>-<kbd>d</kbd> | `CursorDownScreen` |\n|Move cursor to the top   | <kbd>Home</kbd> or <kbd>Alt</kbd>-<kbd>g</kbd> | `CursorTop` |\n|Move cursor to the bottom| <kbd>End</kbd>  or <kbd>Alt</kbd>-<kbd>Shift</kbd>-<kbd>g</kbd> | `CursorBottom` |\n|Erase a character from the search | <kbd>Backspace</kbd> if searching | `EraseSearchChar` |\n|Clear the search | <kbd>Esc</kbd> if searching | `ClearSearch` |\n|Toggle filter search| <kbd>Alt</kbd>-<kbd>f</kbd> | `ChangeFilterSearchMode` |\n|Change case sensitivity mode| <kbd>Alt</kbd>-<kbd>c</kbd> | `ChangeCaseSensitiveMode` |\n|Change gap search mode| <kbd>Ctrl</kbd>-<kbd>f</kbd> | `ChangeGapSearchMode` |\n|Change sorting mode| <kbd>Alt</kbd>-<kbd>s</kbd> | `ChangeSortMode` |\n|Refresh current directory| <kbd>Ctrl</kbd>-<kbd>r</kbd>| `RefreshListing` |\n|Show help screen| <kbd>?</kbd> | `Help` |\n|Exit `tere`| <kbd>Esc</kbd> or <kbd>Alt</kbd>-<kbd>q</kbd> | `Exit` |\n|Enter directory and exit `tere`| <kbd>Alt</kbd>-<kbd>Enter</kbd> or <kbd>Ctrl</kbd>-<kbd>Space</kbd> | `ChangeDirAndExit` |\n|Exit `tere` without changing directory| <kbd>Ctrl</kbd>-<kbd>c</kbd> | `ExitWithoutCd` |\n\nSome of the shortcuts starting with <kbd>Alt</kbd> should be familiar to Vim users.\n\n#### Customizing keyboard shortcuts\n\nAll of the keyboard shortcuts listed above can be customized using the `--map` (or `-m`) CLI option. Keyboard mappings can be either of the form `--map key-combination:action` or `--map key-combination:context:action`, where `key-combination` is a key combination, such as `ctrl-x`, `action` is a valid action name (for example `Exit` or `ChangeDir`, see the table above or `--help` for a full list of actions), and the optional `context` specifies the context in which the mappling applies (for example `Searching` and `NotSearching`, see `--help`). To remove a mapping, use `--map key-combination:None`. Multiple mappings can be made by providing `--map` multiple times, or by using a comma-separated list of mappings: `--map combination1:action1,combination2:action2`.\n\nFor further details and examples, see the output of `--help`.\n\n### Searching\n\nTo search for an item in the current folder, just type some letters. `tere` will incrementally highlight all folders that match the search query.\n\nWhile searching, moving the cursor up or down jumps between only the items that match the search. The search query, as well as the number of matching items is shown at the bottom of the screen.\n\nIf only one folder matches your current search, `tere` will highlight it, and change the working directory to that folder. This way you can navigate folders very quickly.\n\nTo stop searching, press <kbd>Esc</kbd> or erase all search characters by pressing <kbd>Backspace</kbd>.\n\nNote that by default, `tere` searches only folders and not files, since `tere` cannot do anything with files. This can be changed with the `--files` option. For further details, see below, or check the output of `--help`.\n\nBy default, the searching uses \"smart case\", meaning that if the query contains only lowercase letters, case is ignored, but if there are uppercase letters, the search is case sensitive. This can be changed with the `--ignore-case` and `--case-sensitive` options, or with the keyboard shortcut <kbd>Alt</kbd>-<kbd>c</kbd> by default.\n\nAdditionally, in the default search mode, \"gap search\" (sometimes also known as fuzzy search) is enabled. This means that the search matches any folder name as long as it starts with the same character as the search query, and contains the rest of the query characters, even if there are other characters between them. For example, searching for `dt` would match both `DeskTop` and `DocumenTs`. With the `--gap-search-anywhere` option, the first character of the query doesn't have to match the first character of a folder/file name. The gap search can be disabled with the `--normal-search` and `--normal-search-anywhere` options, which only allow matching consecutive characters, either from the start or anywhere within the folder/file name, respsectively. The gap search behavior can also be changed with the keyboard shortcut <kbd>Ctrl</kbd>-<kbd>f</kbd> by default. See `--help` for details.\n\n### Mouse navigation\n\nAlthough `tere` is mainly keyboard-focused, it is also possible to navigate using the mouse. To maximize compatibility, mouse support is off by default, and has to be enabled with the option `--mouse=on`. With the mouse enabled, you can change to a folder by clicking on it, and move to the parent folder by right-clicking.\n\n### CLI options\n\nYou can adjust the behavior of `tere` by passing the following CLI options to it:\n\n- `--help` or `-h`: Print a short help and all CLI options. Note that the output goes to stderr, to not interfere with `cd` ing in the shell functions defined during the setup.\n- `--version` or `-V`: Print the version of `tere`. This also goes to stderr.\n- `--filter-search` or `-f` / `--no-filter-search` or `-F`: If `--filter-search` is set, show only items that match the current search query in the listing. Otherwise all items are shown in the listing while searching (this is the default behavior).\n- `--files` or `-l ignore` / `hide` / `match` (or `i` / `h` / `m`): How to handle files while searching. If `ignore` (the default), only folders are searched / matched. If `hide`, files are hidden and only folders shown and matched, and if `match`, both files and folders are matched. Note that currently `tere` cannot do anything with files, so searching for a file name with `--files=match` is mostly only useful for checking whether a file can be found in the current folder.\n- `--smart-case` or `-S` / `--ignore-case` or `-i` / `--case-sensitive` or `-s`: Set the case sensitivity mode. The default mode is smart case, which is case insensitive if the query contains only lowercase letters and case sensitive otherwise.\n- `--gap-search` or `-g` / `--gap-search-anywhere` or `-G` / `--normal-search` or `-n` / `--normal-search-anywhere` or `-N`: Configure whether to allow matches with gaps in them (see above).\n- `--sort name` / `created` / `modified`: Change the sorting order of the listing.\n- `--autocd-timeout` - If the current search matches only one folder, automatically change to that folder after this many milliseconds. Can also be set to `off`, which disables this behaviour.\n- `--history-file`: To make browsing more convenient, `tere` saves a history of folders you have visited to this file in JSON format. It should be an absolute path. Defaults to `$CACHE_DIR/tere/history.json`, where `$CACHE_DIR` is `$XDG_CACHE_HOME` or `~/.cache`. Set to the empty string `''` to disable saving the history. Note that the history reveals parts of your folder structure if it can be read by someone else.\n- `--mouse=on` or `--mouse=off`: Enable or disable navigating with the mouse. If enabled, you can left-click to enter folders and right-click to go to the parent folder. Off by default.\n\nSome options have two or more versions that override each other (for example `--filter-search` and `--no-filter-search`). For such options, whichever is passed last wins. This way, you can have one option as the default in your shell's `rc` file, but you can sometimes manually override that option when running `tere`.\n\n## Similar projects\n\nThe idea of `tere` is by no means unique. There are actually quite a few CLI\napplications that attempt to make folder navigation faster. Below is a\nnon-exhaustive list of such programs. The purpose of this section is to justify\nthe existence of `tere` by showing how it is different from all these\napplications in subtle but important ways.\n\nIf there is a program that should be mentioned here, feel free to open an issue\nor pull request about it!\n\n### Terminal file browsers\n\nThese programs are designed for basically the same task as `tere`: navigate to a\nfolder in the terminal and then `cd` to it.\n\n- [Broot](https://dystroy.org/broot/) - Broot is more focused on browsing large directories, and has a more complex UI than `tere`.\n- [xplr](https://github.com/sayanarijit/xplr) - Lots of features, fully customizable. Not entirely focused on navigation, has file management features. Navigation by searching requires jumping between typing and pressing arrow keys.\n- [deer](https://github.com/Vifon/deer) - zsh only, searching requires extra keystrokes.\n- [cdir](https://github.com/EskelinenAntti/cdir) - Basically exactly the same idea as `tere`, but in written in Python. Doesn't have Vim-like keyboard navigation, and it's not a standalone binary.\n- [llama](https://github.com/antonmedv/llama) - Very similar to `tere`, written in Go.\n- [sdn](https://git.janouch.name/p/sdn) - Also very similar to `tere`, even in terms of the UI as well. Type-ahead search mode is not the default, searching requires a couple of extra keystrokes.\n\n### Fuzzy matching and history-based navigation\n\nThese programs have a very similar goal as `tere`, to speed up filesystem\nnavigation. However, these kinds of programs are not well suited for\nexploration, as they require that you visit a folder before you can jump to it.\nThey also differ from `tere` in philosophy; `tere` aims to be deterministic,\nwhile the results of a fuzzy match or \"frecency\"-based query vary depending on\nyour previous queries.\n\n- [z](https://github.com/rupa/z)\n- [autojump](https://github.com/wting/autojump)\n- [zoxide](https://github.com/ajeetdsouza/zoxide)\n- [fasd](https://github.com/clvv/fasd)\n- [jump](https://github.com/gsamokovarov/jump)\n- [bashmarks](https://github.com/huyng/bashmarks)\n- [goto](https://github.com/ankitvad/goto)\n- [fzf](https://github.com/junegunn/fzf)\n- [skim](https://github.com/lotabout/skim)\n\n### Terminal file managers\n\nThere are quite a few terminal file managers, and they can often be used in the\nsame way as `tere`, for example using the `--choosedir` option of ranger.\nHowever, they have a huge number of other features compared to `tere`, which\nusually leads to a more complex UI and a higher learning curve. File managers are\nalso not entirely focused on navigation, and therefore often require extra\nkeystrokes to search and navigate folders. File management is not in the scope of\n`tere`, so these programs are not directly comparable to it.\n\n- [ranger](https://ranger.github.io/)\n- [nnn](https://github.com/jarun/nnn)\n- [Midnight Commander](https://midnight-commander.org/)\n- [vifm](https://vifm.info/)\n- [clifm](https://github.com/leo-arch/clifm) (C)\n- [clifm](https://github.com/pasqu4le/clifm) (Haskell)\n- [lf](https://github.com/gokcehan/lf)\n- [fff](https://github.com/dylanaraps/fff)\n- [joshuto](https://github.com/kamiyaa/joshuto)\n- [hunter](https://github.com/rabite0/hunter)\n\n### Other similar programs\n\n- [noice](https://git.2f30.org/noice/file/README.html) - Very similar to `tere`, but there is no option to print the current directory on exit. Filtering/searching directory contents requires two extra keystrokes.\n- [twilight commander](https://github.com/golmman/twilight-commander) - Main goal seems to be a folder tree browser embedded in other apps. No search. No option to go above the initial working directory.\n\n## Hacking\n\nTo compile `tere` from source, follow the standard procedure:\n\n1. [Install the Rust toolchain](https://www.rust-lang.org/tools/install)\n1. `git clone git@github.com:mgunyho/tere.git`\n1. `cd tere`\n1. Run `cargo build` (`--release` for the release version)\n\nThis will place the `tere` binary in the folder `target/debug`, or `target/release` if you used `--release`.\n\nNew features should go on the `develop` branch before they are released, and they should be mentioned in `CHANGELOG.md`.\n\nTo set up cross-compilation for other platforms (e.g. when making a release), run (on Ubuntu):\n```shell\n# Support for linux without dependence on glibc\nrustup target add x86_64-unknown-linux-musl\n\n# Windows support\nsudo apt install gcc-mingw-w64\nrustup target add x86_64-pc-windows-gnu\n\n# ARM (raspberry pi) support\nsudo apt install gcc-aarch64-linux-gnu\nrustup target add aarch64-unknown-linux-gnu\n\n# NOTE: macOS is not available\n```\nThen, the `build-release.sh` script should work.\n\nFor further details, see the [`rustup` guide](https://rust-lang.github.io/rustup/cross-compilation.html), and the [`rustc` platform support page](https://doc.rust-lang.org/nightly/rustc/platform-support.html), and consult your favourite search engine for help on cross-compilation.\n\n### Making a new release\n\nHere's a checklist of things to do for a new release. The release binaries should be compiled on Linux with a suitably old version of glibc for compatibility (Ubuntu 20.04 LTS as of 2023 July).\n\n- Change to the `develop` branch (all changes should be merged to it)\n- Run `cargo test` and verify that all tests pass\n- Update version in `Cargo.toml`\n- Run `cargo build` so that `Cargo.lock` is also updated, and make a commit with the updated versions.\n- Update the release date in `CHANGELOG.md` and commit it\n- `git checkout master && git merge --no-ff develop`. The commit title should be \"Version X.Y.Z\" and the commit message should contain the changelog.\n- `git tag vX.Y.Z`\n- `git push && git push --tags`. Also make sure that the latest version of `develop` is pushed.\n- `sh ./build-release.sh` to build the binaries. They are zipped and placed in the folder `release/`.\n- Upload binaries to github and copy-paste the changelog from the commit message\n- `cargo publish` to upload to crates.io\n\n\n## License\n\nCopyright 2023 András Márton Gunyhó. Licensed under the EUPL, see the `LICENSE` file."
}
