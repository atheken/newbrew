{
  "name": "gradle-profiler",
  "full_name": "gradle-profiler",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Profiling and benchmarking tool for Gradle builds",
  "license": "Apache-2.0",
  "homepage": "https://github.com/gradle/gradle-profiler/",
  "versions": {
    "stable": "0.20.0",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://search.maven.org/remotecontent?filepath=org/gradle/profiler/gradle-profiler/0.20.0/gradle-profiler-0.20.0.zip",
      "tag": null,
      "revision": null,
      "checksum": "5eb01652a348dd929f8ca03231bd7906521b75463003e085dcb49a59612bbaa2"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "all": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gradle-profiler/blobs/sha256:a995687e972bf699a77deffa4bed8fde8e1bdfcafdae76abcf10a734d12a9d78",
          "sha256": "a995687e972bf699a77deffa4bed8fde8e1bdfcafdae76abcf10a734d12a9d78"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [
    "openjdk@11"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/gradle-profiler.rb",
  "ruby_source_checksum": {
    "sha256": "ad3763296b5cfeb9da98743827fef4acc6c17c025635cf9688bf04056807450b"
  },
  "date_added": "2020-07-24T20:49:23+00:00",
  "readme": "# Gradle Profiler\n\nA tool to automate the gathering of profiling and benchmarking information for Gradle builds.\n\nProfiling information can be captured using several different tools:\n\n- Using [Gradle build scans](https://gradle.com)\n- Using [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler)\n- Using [JProfiler](https://www.ej-technologies.com/products/jprofiler/overview.html)\n- Using [YourKit](https://www.yourkit.com) profiler\n- Using [Java flight recorder](https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH170)\n- Producing a heap dump in HPROF format\n- Producing [Chrome Trace](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool) output\n\n## Installing\n\n### SDKMAN!\n\n[SDKMAN!](http://sdkman.io/) is a tool for managing parallel versions of multiple Software Development Kits on most Unix-based systems.\n\n    > sdk install gradleprofiler\n    > gradle-profiler --benchmark help\n\n### Homebrew\n\n[Homebrew](https://brew.sh/) is the easiest and most flexible way to install the UNIX tools Apple didnâ€™t include with macOS.\n\n    > brew install gradle-profiler\n    > gradle-profiler --benchmark help\n\n\n### Download binaries\n\nBinaries are available and linked from the [releases](https://github.com/gradle/gradle-profiler/releases) page.\n\n### Build from source\n\nFirst, build and install the `gradle-profiler` app using:\n\n    > ./gradlew installDist\n\nThis will install the executable into `./build/install/gradle-profiler/bin`. The examples below assume that you add this location to your PATH or create a `gradle-profiler` alias for it.\n\nNOTE: You have to use Java 11 or later to build this project.\n\n## Benchmarking a build\n\nBenchmarking simply records the time it takes to execute your build several times and calculates a mean and standard error for it.\nIt has zero impact on the execution time, so it is ideal for making before/after comparisons for new Gradle versions or changes to your build.\n\nRun the `gradle-profiler` app using:\n\n    > gradle-profiler --benchmark --project-dir <root-dir-of-build> <task>...\n\nWhere `<root-dir-of-build>` is the directory containing the build to be benchmarked, and `<task>` is the name of the task to run,\nexactly as you would use for the `gradle` command.\n\nResults will be written to a file called `profile-out/benchmark.html` and `profile-out/benchmark.csv`.\n\nWhen the profiler runs the build, it will use the tasks you specified. The profiler will use the default\nGradle version, Java installation and JVM args that have been specified for your build, if any.\nThis generally works the same way as if you were using the Gradle wrapper. For example, the profiler will use the values\nfrom your Gradle wrapper properties file, if present, to determine which Gradle version to run.\n\nYou can use the `--gradle-version` option to specify a Gradle version or installation to use to benchmark the build.\nYou can specify multiple versions and each of these is used to benchmark the build, allowing you to compare the behaviour of several different Gradle versions.\n\nYou can also use the `--measure-config-time` option to measure some additional details about configuration time.\n\nYou can use `--measure-build-op` together with the fully qualified class name of the enveloping type of the `Details` interface to benchmark cumulative build operation time.\nFor example, for Gradle 5.x there is a [`org.gradle.api.internal.tasks.SnapshotTaskInputsBuildOperationType`](https://github.com/gradle/gradle/blob/c671360a3f1729b406c5b8b5b0d22c7b81296993/subprojects/core/src/main/java/org/gradle/api/internal/tasks/SnapshotTaskInputsBuildOperationType.java) which can be used to capture snapshotting time.\nThe time recorded is cumulative time, so the wall clock time spent on executing the measured build operations is probably smaller.\nIf the build operation does not exists in a benchmarked version of Gradle, it is gracefully ignored.\nIn the resulting reports it will show up with 0 time.\n\n### Regression detection\n\nIf multiple versions are tested, then Gradle profiler determines whether there is an statistically significant difference in the run times by using a [Mann-Whitney U-Test](https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test).\nThe result files contain the confidence if a sample has a different performance behavior - i.e. it is faster or slower - than the baseline.\n\n## Profiling a build\n\nProfiling allows you to get deeper insight into the performance of your build.\n\nTo run the `gradle-profiler` app to profile a build use:\n\n    > gradle-profiler --profile <name-of-profiler> --project-dir <root-dir-of-build> <task>...\n\nThe app will run the build several times to warm up a daemon, then enable the profiler and run the build.\nOnce complete, the results are available under `profile-out/`.\n\nIf you use Async profiler or JFR for profiling, Gradle profiler will also create flame graphs for each scenario.\nIf you profile multiple scenarios or multiple versions, then Gradle profiler will create differential flame graphs as well.\n\n### Gradle build scans\n\n[Gradle build scans](https://gradle.com) are a powerful tool to investigate the structure of your build and quickly find bottlenecks. \nYou can use the timeline view to see which tasks ran, how long they took, whether they were cached, how well your build parallelized etc. \nThe performance tab will show you details about configuration time and other hints on how to make your build faster.\n\nIn order to create a build scan of your build, use `--profile buildscan`. The build scan URL is reported on the console and is also available in `profile-out/profile.log`. \n\n### Async Profiler\n\nAsync profiler provides low-overhead CPU, allocation and perf event sampling on Linux and MacOS. \nIt also correctly handles native method calls, making it preferable to JFR on these operating systems. \n\nYou can use async profiler to profile a Gradle build using `--profile async-profiler`. By default, this will profile CPU usage, with some reasonable default settings. These settings can be configured using various command-line options, listed below.\n\nAlternatively, you can also use `--profile async-profiler-heap` to profile heap allocations, with some reasonable default settings.\n\nFinally, you can also use `--profile async-profiler-all` to profile cpu, heap allocations, and locks with some reasonable default settings.\n\nBy default, an Async profiler release will be downloaded from [Github](https://github.com/jvm-profiling-tools/async-profiler/releases) and installed, if not already available.\n\nThe output are flame and icicle graphs which show you the call tree and hotspots of your code.\n\nThe following options are supported and closely mimic the options of Async profiler. Have a look at its readme to find out more about each option:\n\n- `--async-profiler-event`: The event to sample, e.g. `cpu`, `wall`, `lock` or `alloc`. Defaults to `cpu`. Multiple events can be profiled by using this parameter multiple times.\n- `--async-profiler-count`: The count to use when aggregating event data. Either `samples` or `total`. `total` is especially useful for allocation profiling. Defaults to `samples`. Corresponds to the `--samples` and `--total` command line options for Async profiler.\n- `--async-profiler-interval`: The sampling interval in ns, defaults to 10_000_000 (10 ms).\n- `--async-profiler-alloc-interval`: The sampling interval in bytes for allocation profiling, defaults to 10 bytes. Corresponds to the `--alloc` command line option for Async profiler.\n- `--async-profiler-lock-threshold`: lock profiling threshold in nanoseconds, defaults to 250 microseconds. Corresponds to the `--lock` command line option for Async profiler.\n- `--async-profiler-stackdepth`: The maximum stack depth. Lower this if profiles with deep recursion get too large. Defaults to 2048.\n- `--async-profiler-system-threads`: Whether to show system threads like GC and JIT compilation in the profile. Usually makes them harder to read, but can be useful if you suspect problems in that area. Defaults to `false`. \n\nYou can also use either the `ASYNC_PROFILER_HOME` environment variable or the `--async-profiler-home` command line option to point to the Async profiler install directory.\n\n### JProfiler\n\nJProfiler is a powerful commercial profiler, which provides both sampling and instrumentation capabilities.\nYou can tailor its settings in the JProfiler UI and then instruct the Gradle profiler to use these settings for full control\nover what you want to investigate. For instance, you could split calls to a dependency resolution rule by argument to\nfind out if the rule is slow for a specific dependency.\n\nIn order to work with JProfiler, use the `--profile jprofiler` option.\n\nThis will use JProfiler's CPU sampling by default. JProfiler supports several other options:\n\n- Enable CPU sampling of all methods by adding `--jprofiler-config sampling-all` (by default only packages containing the word `gradle` are sampled)\n- Switch to CPU instrumentation by adding `--jprofiler-config instrumentation`\n- Enable memory allocation recording by adding `--jprofiler-alloc`\n- Enable monitor usage recording by adding `--jprofiler-monitors`\n- Enable probes with `--jprofiler-probes:<probe ids, separated by comma>` (e.g. `--jprofiler-probes builtin.FileProbe`)\n- Enable heapdump after build with `--jprofiler-heapdump`\n- Use a specific profiler session (for full control over filters, sampling intervals etc.) by adding `--jprofiler-session <sessionId>`\n- use a different JProfiler installation with `--jprofiler-home /path/to/jprofiler`\n\n### YourKit\n\nYourKit is a powerful commercial profiler, which provides both sampling and instrumentation capabilities.\nIts integration in the Gradle profiler is currently limited, e.g. support for probes and other custom settings\nis missing. If you are using YourKit and would like to see better support, pull requests are welcome.\n\nIn order to work with YourKit, make sure the `YOURKIT_HOME` environment variable is set and then use the `--profile yourkit` option. This will use YourKit's CPU sampling instrumentation by default. \n\nYou can switch to CPU tracing using the `--profile yourkit-tracing` option. \nYou can switch to memory allocation profiling by using the `--profile yourkit-heap` option. \nAll probes are disabled when using sampling or memory allocation profiling.\n\n### Java Flight Recorder\n\nJFR provides low overhead CPU, allocation, IO wait and lock profiling and runs on all major operating systems.\nIt is available on Oracle JDK since Java 7 and on OpenJDK since Java 11 (make sure you have at least [11.0.3](https://bugs.openjdk.java.net/browse/JDK-8219347)).\n\nTo our knowledge, it is the only low-overhead allocation profiler for Windows.\nHowever, be aware of its shortcomings, e.g. it will not sample native method calls, so you will get misleading CPU results if your code does a lot of system calls (like reading files). \n\nYou will get both the JFR file and flame graph visualizations of the data, which are much easier to understand than the Java Mission Control UI. \n\nIn order to profile with JFR, add the `--profile jfr` option. \nYou can change the profiler settings using `--jfr-settings`, specifying either the path to a `.jfc` file or the name of a built-in template like `profile`.\n\n### Heap dump\n\nTo capture a heap dump at the end of each measured build, add the `--profile heap-dump` option. You can use this with other `--profile` options.\n\n### Chrome Trace\n\nChrome traces are a low-level event dump (e.g. projects being evaluated, tasks being run etc.).\nThey are useful when you can't create a build scan, but need to look at the overall structure of a build.\nIt also displays CPU load, memory usage and GC activity. Using chrome-trace requires Gradle 3.3+.\n\nAdd the `--profile chrome-trace` option and open the result in Google Chrome in chrome://tracing. \n\n## Command line options\n\n- `--project-dir`: Directory containing the build to run (required).\n- `--benchmark`: Benchmark the build. Runs the builds more times and writes the results to a CSV file.\n- `--profile <profiler>`: Profile the build using the specified profiler. See above for details on each profiler.\n- `--output-dir <dir>`: Directory to write results to. Default value is `profile-out`. If profile-out directory already exists, it tries to find a `profile-out-<index>` directory, that does not exist.\n- `--warmups`: Specifies the number of warm-up builds to run for each scenario. Defaults to 2 for profiling, 6 for benchmarking, and 1 when not using a warm daemon.\n- `--iterations`: Specifies the number of builds to run for each scenario. Defaults to 1 for profiling, 10 for benchmarking.\n- `--bazel`: Benchmark scenarios using Bazel instead of Gradle. By default, only Gradle scenarios are run. You cannot profile a Bazel build using this tool.\n- `--buck`: Benchmark scenarios using Buck instead of Gradle. By default, only Gradle scenarios are run. You cannot profile a Buck build using this tool.\n- `--maven`: Benchmark scenarios using Maven instead of Gradle. By default, only Gradle scenarios are run. You cannot profile a Maven build using this tool.\n\nThe following command line options only apply when measuring Gradle builds:\n\n- `--gradle-user-home`: The Gradle user home. Defaults to `<project-dir>/gradle-user-home` to isolate performance tests from your other builds.\n- `--gradle-version <version>`: Specifies a Gradle version or installation to use to run the builds, overriding the default for the build. You can specify multiple versions by using this option once for each version.\n- `--no-daemon`: Uses the `gradle` command-line client with the `--no-daemon` option to run the builds. The default is to use the Gradle tooling API and Gradle daemon.\n- `--cold-daemon`: Use a cold daemon (one that has just started) rather than a warm daemon (one that has already run some builds). The default is to use a warm daemon.\n- `--cli`: Uses the `gradle` command-line client to run the builds. The default is to use the Gradle tooling API and Gradle daemon.\n- `--measure-build-op`: Additionally measure the cumulative time spent in the given build operation. Only supported for Gradle 6.1 and later.\n- `--measure-config-time`: Measure some additional details about configuration time. Only supported for Gradle 6.1 and later.\n- `--measure-gc`: Measure the garbage collection time. Only supported for Gradle 6.1 and later.\n- `--measure-local-build-cache`: Measure the size of the local build cache.\n- `-D<key>=<value>`: Defines a system property when running the build, overriding the default for the build.\n- `--studio-install-dir`: The Android Studio installation directory. Required when measuring Android Studio sync.\n- `--studio-sandbox-dir`: The Android Studio sandbox directory. It's recommended to use it since it isolates the Android Studio process from your other Android Studio processes. By default, this will be set to `<output-dir>/studio-sandbox`. If you want Android Studio to keep old data (e.g. indexes) you should set and reuse your own folder. \n- `--no-studio-sandbox`: Do not use the Android Studio sandbox but use the default Android Studio folders for the Android Studio data.\n- `--no-diffs`: Do not generate differential flame graphs.\n\n## Advanced profiling scenarios\n\nA scenario file can be provided to define more complex scenarios to benchmark or profile. Use the `--scenario-file` option to provide this. The scenario file is defined in [Typesafe config](https://github.com/typesafehub/config) format.\n\nThe scenario file defines one or more scenarios. You can select which scenarios to run by specifying its name on the command-line when running `gradle-profiler`, e.g.\n\n    > gradle-profiler --benchmark --scenario-file performance.scenarios clean_build\n\nHere is an example:\n\n    # Can specify scenarios to use when none are specified on the command line\n    default-scenarios = [\"assemble\"]\n    \n    # Scenarios are run in alphabetical order\n    assemble {\n        # Show a slightly more human-readable title in reports\n        title = \"Assemble\"\n        # Run the 'assemble' task\n        tasks = [\"assemble\"]\n    }\n    clean_build {\n        title = \"Clean Build\"\n        versions = [\"3.1\", \"/Users/me/gradle\"]\n        tasks = [\"build\"]\n        gradle-args = [\"--parallel\"]\n        system-properties {\n            \"key\" = \"value\"\n        }\n        cleanup-tasks = [\"clean\"]\n        run-using = tooling-api // value can be \"cli\" or \"tooling-api\"\n        daemon = warm // value can be \"warm\", \"cold\", or \"none\"\n        measured-build-ops = [\"org.gradle.api.internal.tasks.SnapshotTaskInputsBuildOperationType\"] // see --measure-build-op\n\n        buck {\n            targets = [\"//thing/res_debug\"]\n            type = \"android_binary\" // can be a Buck build rule type or \"all\"\n        }\n\n        warm-ups = 10\n    }\n    ideaModel {\n        title = \"IDEA model\"\n        # Fetch the IDEA tooling model\n        tooling-api {\n            model = \"org.gradle.tooling.model.idea.IdeaProject\"\n        }\n        # Can also run tasks\n        # tasks = [\"assemble\"]\n    }\n    toolingAction {\n        title = \"IDEA model\"\n        # Fetch the IDEA tooling model\n        tooling-api {\n            action = \"org.gradle.profiler.toolingapi.FetchProjectPublications\"\n        }\n        # Can also run tasks\n        # tasks = [\"assemble\"]\n    }\n    androidStudioSync {\n        title = \"Android Studio Sync\"\n        # Measure an Android studio sync\n        # Note: Android Studio Bumblebee (2021.1.1) or newer is required\n        # Note2: If you are testing with Android Studio Giraffe (2022.3) or later\n        # you need to have local.properties file in your project with sdk.dir set\n        android-studio-sync {\n            # Override default Android Studio jvm args\n            # studio-jvm-args = [\"-Xms256m\", \"-Xmx4096m\"]\n            # Pass an IDEA properties to Android Studio. This can be used to set a registry values as well\n            # idea-properties = [\"gradle.tooling.models.parallel.fetch=true\"]\n        }\n    }\n\nValues are optional and default to the values provided on the command-line or defined in the build.\n\n### Profiling incremental builds\n\nA scenario can define changes that should be applied to the source before each build. You can use this to benchmark or profile an incremental build. The following mutations are available:\n\n- `apply-build-script-change-to`: Add a statement to a Groovy or Kotlin DSL build script, init script or settings script. Each iteration adds a new statement and removes the statement added by the previous iteration.\n- `apply-project-dependency-change-to`: Add project dependencies to a Groovy or a Kotlin DSL build script. Each iteration adds a new combination of projects as dependencies and removes the projects added by the previous iteration.\n- `apply-abi-change-to`: Add a public method to a Java or Kotlin source class. Each iteration adds a new method and removes the method added by the previous iteration.\n- `apply-non-abi-change-to`: Change the body of a public method in a Java or Kotlin source class.\n- `apply-h-change-to`: Add a function to a C/C++ header file. Each iteration adds a new function declaration and removes the function added by the previous iteration. \n- `apply-cpp-change-to`: Add a function to a C/C++ source file. Each iteration adds a new function and removes the function added by the previous iteration. \n- `apply-property-resource-change-to`: Add an entry to a properties file. Each iteration adds a new entry and removes the entry added by the previous iteration.\n- `apply-android-resource-change-to`: Add a string resource to an Android resource file. Each iteration adds a new resource and removes the resource added by the previous iteration.\n- `apply-android-resource-value-change-to`: Change a string resource in an Android resource file.\n- `apply-android-manifest-change-to`: Add a permission to an Android manifest file.\n- `apply-android-layout-change-to`: Add a hidden view with id to an Android layout file. Supports traditional layouts as well as Databinding layouts with a ViewGroup as the root element.\n- `apply-kotlin-composable-change-to`: Add a `@Composable` function to a Kotlin source file.\n- `clear-build-cache-before`: Deletes the contents of the build cache before the scenario is executed (`SCENARIO`), before cleanup (`CLEANUP`) or before the build is executed (`BUILD`).\n- `clear-gradle-user-home-before`: Deletes the contents of the Gradle user home directory before the scenario is executed (`SCENARIO`), before cleanup (`CLEANUP`) or before the build is executed (`BUILD`).\n   The mutator retains the `wrapper` cache in the Gradle user home, since the downloaded wrapper in that location is used to run Gradle.\n   Requires to use the `none` daemon option to use with `CLEANUP` or `BUILD`.\n- `clear-configuration-cache-state-before`: Deletes the contents of the `.gradle/configuration-cache-state` directory before the scenario is executed (`SCENARIO`), before cleanup (`CLEANUP`) or before the build is executed (`BUILD`).\n- `clear-project-cache-before`: Deletes the contents of the `.gradle` and `buildSrc/.gradle` project cache directories before the scenario is executed (`SCENARIO`), before cleanup (`CLEANUP`) or before the build is executed (`BUILD`).\n- `clear-transform-cache-before`: Deletes the contents of the transform cache before the scenario is executed (`SCENARIO`), before cleanup (`CLEANUP`) or before the build is executed (`BUILD`).\n- `clear-jars-cache-before`: Deletes the contents of the instrumented jars cache before the scenario is executed (`SCENARIO`), before cleanup (`CLEANUP`) or before the build is executed (`BUILD`).\n- `clear-android-studio-cache-before`: Invalidates the Android Studio caches before the scenario is executed (`SCENARIO`) or before the build is executed (`BUILD`). Due to Android Studio client specifics before cleanup (`CLEANUP`) is not supported. Note: cleaning the Android Studio caches is run only when Android Studio sync (`android-studio-sync`) is used.\n- `git-checkout`: Checks out a specific commit for the build step, and a different one for the cleanup step.\n- `git-revert`: Reverts a given set of commits before the build and resets it afterward.\n- `iterations`: Number of builds to actually measure\n- `jvm-args`: Sets or overrides the jvm arguments set by `org.gradle.jvmargs` in gradle.properties.\n- `show-build-cache-size`: Shows the number of files and their size in the build cache before scenario execution, and after each cleanup and build round..\n- `warm-ups`: Number of warmups to perform before measurement\n\nThey can be added to a scenario file like this:\n\n    incremental_build {\n        tasks = [\"assemble\"]\n\n        apply-build-script-change-to = \"build.gradle.kts\"\n        apply-project-dependency-change-to {\n            files = [\"build.gradle\"]\n            # Default number of dependency-count is 3.\n            # Gradle Profiler will simulate changes to project dependencies by generate some additional projects and then add a combination of project dependencies to every non-generated subprojects before each iteration.\n            # The profiler will generate the minimal number of subprojects to allow for a unique combination of dependencies to be used for each iteration.\n            # Note: Number of generated projects is calculated as binomial coffiecient: \"from `x` choose `dependency-count` = `iterations * files`\", where number of generated projects is `x`.\n            dependency-count = 3\n        }\n        apply-abi-change-to = \"src/main/java/MyThing.java\"\n        apply-non-abi-change-to = [\"src/main/java/MyThing.java\", \"src/main/java/MyOtherThing.java\"]\n        apply-h-change-to = \"src/main/headers/app.h\"\n        apply-cpp-change-to = \"src/main/cpp/app.cpp\"\n        apply-property-resource-change-to = \"src/main/resources/thing.properties\"\n        apply-android-resource-change-to = \"src/main/res/values/strings.xml\"\n        apply-android-resource-value-change-to = \"src/main/res/values/strings.xml\"\n        apply-android-manifest-change-to = \"src/main/AndroidManifest.xml\"\n        clear-build-cache-before = SCENARIO\n        clear-transform-cache-before = BUILD\n        show-build-cache-size = true\n        git-checkout = {\n            cleanup = \"efb43a1\"\n            build = \"master\"\n        }\n        git-revert = [\"efb43a1\"]\n        jvm-args = [\"-Xmx2500m\", \"-XX:MaxMetaspaceSize=512m\"]\n    }\n\n### Comparing against other build tools\n\nYou can compare Gradle against Bazel, Buck, and Maven by specifying their equivalent invocations in the scenario file. Only benchmarking mode is supported.\n\n#### Maven\n\n    > gradle-profiler --benchmark --maven clean_build\n\n    clean_build {\n        tasks = [\"build\"]\n        cleanup-tasks = [\"clean\"]\n        maven {\n            # If empty, it will be infered from MAVEN_HOME environment variable\n            home = \"/path/to/maven/home\"\n            targets = [\"clean\", \"build\"]\n        }\n    }\n\n#### Bazel\n\n    > gradle-profiler --benchmark --bazel build_some_target\n\n    build_some_target {\n        tasks = [\"assemble\"]\n\n        bazel {\n            # If empty, it will be infered from BAZEL_HOME environment variable\n            home = \"/path/to/bazel/home\"\n            targets = [\"build\" \"//some/target\"]\n        }\n    }\n    \n#### Buck\n\n    > gradle-profiler --benchmark --buck build_binaries\n\n    build_binaries {\n        tasks = [\"assemble\"]\n\n        buck {\n            # If empty, it will be infered from BUCK_HOME environment variable\n            home = \"/path/to/buck/home\"\n            type = \"android_binary\" // can be a Buck build rule type or \"all\"\n        }\n    }\n    build_resources {\n        tasks = [\"thing:processDebugResources\"]\n\n        buck {\n            targets = [\"//thing/res_debug\"]\n        }\n    }"
}
