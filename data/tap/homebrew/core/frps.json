{
  "name": "frps",
  "full_name": "frps",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Server app of fast reverse proxy to expose a local server to the internet",
  "license": "Apache-2.0",
  "homepage": "https://github.com/fatedier/frp",
  "versions": {
    "stable": "0.51.2",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/fatedier/frp.git",
      "tag": "v0.51.2",
      "revision": "7c8cbeb250e03b806759b66ca94fd1bf280d3d7c",
      "checksum": null
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/frps/blobs/sha256:f7f848d33b00c7596f06a88aac80a448f816fdafd09bf745ade530ef99b14abb",
          "sha256": "f7f848d33b00c7596f06a88aac80a448f816fdafd09bf745ade530ef99b14abb"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/frps/blobs/sha256:f7f848d33b00c7596f06a88aac80a448f816fdafd09bf745ade530ef99b14abb",
          "sha256": "f7f848d33b00c7596f06a88aac80a448f816fdafd09bf745ade530ef99b14abb"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/frps/blobs/sha256:f7f848d33b00c7596f06a88aac80a448f816fdafd09bf745ade530ef99b14abb",
          "sha256": "f7f848d33b00c7596f06a88aac80a448f816fdafd09bf745ade530ef99b14abb"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/frps/blobs/sha256:01e6f6e285dbe3c7aa0a24fdc3715aa42ce0d5170c056abcfad8adaa750fe6c2",
          "sha256": "01e6f6e285dbe3c7aa0a24fdc3715aa42ce0d5170c056abcfad8adaa750fe6c2"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/frps/blobs/sha256:01e6f6e285dbe3c7aa0a24fdc3715aa42ce0d5170c056abcfad8adaa750fe6c2",
          "sha256": "01e6f6e285dbe3c7aa0a24fdc3715aa42ce0d5170c056abcfad8adaa750fe6c2"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/frps/blobs/sha256:01e6f6e285dbe3c7aa0a24fdc3715aa42ce0d5170c056abcfad8adaa750fe6c2",
          "sha256": "01e6f6e285dbe3c7aa0a24fdc3715aa42ce0d5170c056abcfad8adaa750fe6c2"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/frps/blobs/sha256:2805003ff9809147c2dddd604ed6afad698b6800015015a78ada172f16862d11",
          "sha256": "2805003ff9809147c2dddd604ed6afad698b6800015015a78ada172f16862d11"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "go"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": {
    "run": [
      "/home/linuxbrew/.linuxbrew/opt/frps/bin/frps",
      "-c",
      "/home/linuxbrew/.linuxbrew/etc/frp/frps.ini"
    ],
    "run_type": "immediate",
    "keep_alive": {
      "always": true
    },
    "log_path": "/home/linuxbrew/.linuxbrew/var/log/frps.log",
    "error_log_path": "/home/linuxbrew/.linuxbrew/var/log/frps.log"
  },
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/frps.rb",
  "ruby_source_checksum": {
    "sha256": "a2912ae0e91fef0300a8e5bbe088036cb109bed66e385a98f80a25b25b6f3f15"
  },
  "date_added": "2019-04-11T14:09:24-04:00",
  "readme": "# frp\n\n[![Build Status](https://circleci.com/gh/fatedier/frp.svg?style=shield)](https://circleci.com/gh/fatedier/frp)\n[![GitHub release](https://img.shields.io/github/tag/fatedier/frp.svg?label=release)](https://github.com/fatedier/frp/releases)\n\n[README](README.md) | [中文文档](README_zh.md)\n\n<h3 align=\"center\">Gold Sponsors</h3>\n<!--gold sponsors start-->\n<p align=\"center\">\n  <a href=\"https://workos.com/?utm_campaign=github_repo&utm_medium=referral&utm_content=frp&utm_source=github\" target=\"_blank\">\n    <img width=\"350px\" src=\"https://raw.githubusercontent.com/fatedier/frp/dev/doc/pic/sponsor_workos.png\">\n  </a>\n</p>\n<!--gold sponsors end-->\n\n## What is frp?\n\nfrp is a fast reverse proxy that allows you to expose a local server located behind a NAT or firewall to the Internet. It currently supports **TCP** and **UDP**, as well as **HTTP** and **HTTPS** protocols, enabling requests to be forwarded to internal services via domain name.\n\nfrp also offers a P2P connect mode.\n\n## Table of Contents\n\n<!-- vim-markdown-toc GFM -->\n\n* [Development Status](#development-status)\n    * [About V2](#about-v2)\n* [Architecture](#architecture)\n* [Example Usage](#example-usage)\n    * [Access your computer in a LAN network via SSH](#access-your-computer-in-a-lan-network-via-ssh)\n    * [Multiple SSH services sharing the same port](#multiple-ssh-services-sharing-the-same-port)\n    * [Accessing Internal Web Services with Custom Domains in LAN](#accessing-internal-web-services-with-custom-domains-in-lan)\n    * [Forward DNS query requests](#forward-dns-query-requests)\n    * [Forward Unix Domain Socket](#forward-unix-domain-socket)\n    * [Expose a simple HTTP file server](#expose-a-simple-http-file-server)\n    * [Enable HTTPS for a local HTTP(S) service](#enable-https-for-a-local-https-service)\n    * [Expose your service privately](#expose-your-service-privately)\n    * [P2P Mode](#p2p-mode)\n* [Features](#features)\n    * [Configuration Files](#configuration-files)\n    * [Using Environment Variables](#using-environment-variables)\n    * [Split Configures Into Different Files](#split-configures-into-different-files)\n    * [Dashboard](#dashboard)\n    * [Admin UI](#admin-ui)\n    * [Monitor](#monitor)\n        * [Prometheus](#prometheus)\n    * [Authenticating the Client](#authenticating-the-client)\n        * [Token Authentication](#token-authentication)\n        * [OIDC Authentication](#oidc-authentication)\n    * [Encryption and Compression](#encryption-and-compression)\n        * [TLS](#tls)\n    * [Hot-Reloading frpc configuration](#hot-reloading-frpc-configuration)\n    * [Get proxy status from client](#get-proxy-status-from-client)\n    * [Only allowing certain ports on the server](#only-allowing-certain-ports-on-the-server)\n    * [Port Reuse](#port-reuse)\n    * [Bandwidth Limit](#bandwidth-limit)\n        * [For Each Proxy](#for-each-proxy)\n    * [TCP Stream Multiplexing](#tcp-stream-multiplexing)\n    * [Support KCP Protocol](#support-kcp-protocol)\n    * [Support QUIC Protocol](#support-quic-protocol)\n    * [Connection Pooling](#connection-pooling)\n    * [Load balancing](#load-balancing)\n    * [Service Health Check](#service-health-check)\n    * [Rewriting the HTTP Host Header](#rewriting-the-http-host-header)\n    * [Setting other HTTP Headers](#setting-other-http-headers)\n    * [Get Real IP](#get-real-ip)\n        * [HTTP X-Forwarded-For](#http-x-forwarded-for)\n        * [Proxy Protocol](#proxy-protocol)\n    * [Require HTTP Basic Auth (Password) for Web Services](#require-http-basic-auth-password-for-web-services)\n    * [Custom Subdomain Names](#custom-subdomain-names)\n    * [URL Routing](#url-routing)\n    * [TCP Port Multiplexing](#tcp-port-multiplexing)\n    * [Connecting to frps via HTTP PROXY](#connecting-to-frps-via-http-proxy)\n    * [Range ports mapping](#range-ports-mapping)\n    * [Client Plugins](#client-plugins)\n    * [Server Manage Plugins](#server-manage-plugins)\n* [Development Plan](#development-plan)\n* [Contributing](#contributing)\n* [Donation](#donation)\n    * [GitHub Sponsors](#github-sponsors)\n    * [PayPal](#paypal)\n\n<!-- vim-markdown-toc -->\n\n## Development Status\n\nfrp is currently under development. You can try the latest release version in the `master` branch, or use the `dev` branch to access the version currently in development.\n\nWe are currently working on version 2 and attempting to perform some code refactoring and improvements. However, please note that it will not be compatible with version 1.\n\nWe will transition from version 0 to version 1 at the appropriate time and will only accept bug fixes and improvements, rather than big feature requests.\n\n### About V2\n\nThe overall situation is currently unfavorable, and there is significant pressure in both personal and professional aspects.\n\nThe complexity and difficulty of the v2 version are much higher than anticipated. I can only work on its development during fragmented time periods, and the constant interruptions disrupt productivity significantly. Given this situation, we will continue to optimize and iterate on the current version until we have more free time to proceed with the major version overhaul.\n\nThe concept behind v2 is based on my years of experience and reflection in the cloud-native domain, particularly in K8s and ServiceMesh. Its core is a modernized four-layer and seven-layer proxy, similar to envoy. This proxy itself is highly scalable, not only capable of implementing the functionality of intranet penetration but also applicable to various other domains. Building upon this highly scalable core, we aim to implement all the capabilities of frp v1 while also addressing the functionalities that were previously unachievable or difficult to implement in an elegant manner. Furthermore, we will maintain efficient development and iteration capabilities.\n\nIn addition, I envision frp itself becoming a highly extensible system and platform, similar to how we can provide a range of extension capabilities based on K8s. In K8s, we can customize development according to enterprise needs, utilizing features such as CRD, controller mode, webhook, CSI, and CNI. In frp v1, we introduced the concept of server plugins, which implemented some basic extensibility. However, it relies on a simple HTTP protocol and requires users to start independent processes and manage them on their own. This approach is far from flexible and convenient, and real-world demands vary greatly. It is unrealistic to expect a non-profit open-source project maintained by a few individuals to meet everyone's needs.\n\nFinally, we acknowledge that the current design of modules such as configuration management, permission verification, certificate management, and API management is not modern enough. While we may carry out some optimizations in the v1 version, ensuring compatibility remains a challenging issue that requires a considerable amount of effort to address.\n\nWe sincerely appreciate your support for frp.\n\n## Architecture\n\n![architecture](/doc/pic/architecture.png)\n\n## Example Usage\n\nTo begin, download the latest program for your operating system and architecture from the [Release](https://github.com/fatedier/frp/releases) page.\n\nNext, place the `frps` binary and `frps.ini` configuration file on Server A, which has a public IP address.\n\nFinally, place the `frpc` binary and `frpc.ini` configuration file on Server B, which is located on a LAN that cannot be directly accessed from the public internet.\n\n### Access your computer in a LAN network via SSH\n\n1. Modify `frps.ini` on server A by setting the `bind_port` for frp clients to connect to:\n\n  ```ini\n  # frps.ini\n  [common]\n  bind_port = 7000\n  ```\n\n2. Start `frps` on server A:\n\n  `./frps -c ./frps.ini`\n\n3. Modify `frpc.ini` on server B and set the `server_addr` field to the public IP address of your frps server:\n\n  ```ini\n  # frpc.ini\n  [common]\n  server_addr = x.x.x.x\n  server_port = 7000\n\n  [ssh]\n  type = tcp\n  local_ip = 127.0.0.1\n  local_port = 22\n  remote_port = 6000\n  ```\n\nNote that the `local_port` (listened on the client) and `remote_port` (exposed on the server) are used for traffic going in and out of the frp system, while the `server_port` is used for communication between frps and frpc.\n\n4. Start `frpc` on server B:\n\n  `./frpc -c ./frpc.ini`\n\n5. To access server B from another machine through server A via SSH (assuming the username is `test`), use the following command:\n\n  `ssh -oPort=6000 test@x.x.x.x`\n\n### Multiple SSH services sharing the same port\n\nThis example implements multiple SSH services exposed through the same port using a proxy of type tcpmux. Similarly, as long as the client supports the HTTP Connect proxy connection method, port reuse can be achieved in this way.\n\n1. Deploy frps on a machine with a public IP and modify the frps.ini file. Here is a simplified configuration:\n\n  ```ini\n  [common]\n  bind_port = 7000\n  tcpmux_httpconnect_port = 5002\n  ```\n\n2. Deploy frpc on the internal machine A with the following configuration:\n\n  ```ini\n  [common]\n  server_addr = x.x.x.x\n  server_port = 7000\n\n  [ssh1]\n  type = tcpmux\n  multiplexer = httpconnect\n  custom_domains = machine-a.example.com\n  local_ip = 127.0.0.1\n  local_port = 22\n  ```\n\n3. Deploy another frpc on the internal machine B with the following configuration:\n\n  ```ini\n  [common]\n  server_addr = x.x.x.x\n  server_port = 7000\n\n  [ssh2]\n  type = tcpmux\n  multiplexer = httpconnect\n  custom_domains = machine-b.example.com\n  local_ip = 127.0.0.1\n  local_port = 22\n  ```\n\n4. To access internal machine A using SSH ProxyCommand, assuming the username is \"test\":\n\n  `ssh -o 'proxycommand socat - PROXY:x.x.x.x:machine-a.example.com:22,proxyport=5002' test@machine-a`\n\n5. To access internal machine B, the only difference is the domain name, assuming the username is \"test\":\n\n  `ssh -o 'proxycommand socat - PROXY:x.x.x.x:machine-b.example.com:22,proxyport=5002' test@machine-b`\n\n### Accessing Internal Web Services with Custom Domains in LAN\n\nSometimes we need to expose a local web service behind a NAT network to others for testing purposes with our own domain name.\n\nUnfortunately, we cannot resolve a domain name to a local IP. However, we can use frp to expose an HTTP(S) service.\n\n1. Modify `frps.ini` and set the HTTP port for vhost to 8080:\n\n  ```ini\n  # frps.ini\n  [common]\n  bind_port = 7000\n  vhost_http_port = 8080\n  ```\n\n  If you want to configure an https proxy, you need to set up the `vhost_https_port`.\n\n2. Start `frps`:\n\n  `./frps -c ./frps.ini`\n\n3. Modify `frpc.ini` and set `server_addr` to the IP address of the remote frps server. Specify the `local_port` of your web service:\n\n  ```ini\n  # frpc.ini\n  [common]\n  server_addr = x.x.x.x\n  server_port = 7000\n\n  [web]\n  type = http\n  local_port = 80\n  custom_domains = www.example.com\n  ```\n\n4. Start `frpc`:\n\n  `./frpc -c ./frpc.ini`\n\n5. Map the A record of `www.example.com` to either the public IP of the remote frps server or a CNAME record pointing to your original domain.\n\n6. Visit your local web service using url `http://www.example.com:8080`.\n\n### Forward DNS query requests\n\n1. Modify `frps.ini`:\n\n  ```ini\n  # frps.ini\n  [common]\n  bind_port = 7000\n  ```\n\n2. Start `frps`:\n\n  `./frps -c ./frps.ini`\n\n3. Modify `frpc.ini` and set `server_addr` to the IP address of the remote frps server. Forward DNS query requests to the Google Public DNS server `8.8.8.8:53`:\n\n  ```ini\n  # frpc.ini\n  [common]\n  server_addr = x.x.x.x\n  server_port = 7000\n\n  [dns]\n  type = udp\n  local_ip = 8.8.8.8\n  local_port = 53\n  remote_port = 6000\n  ```\n\n4. Start frpc:\n\n  `./frpc -c ./frpc.ini`\n\n5. Test DNS resolution using the `dig` command:\n\n  `dig @x.x.x.x -p 6000 www.google.com`\n\n### Forward Unix Domain Socket\n\nExpose a Unix domain socket (e.g. the Docker daemon socket) as TCP.\n\nConfigure `frps` as above.\n\n1. Start `frpc` with the following configuration:\n\n  ```ini\n  # frpc.ini\n  [common]\n  server_addr = x.x.x.x\n  server_port = 7000\n\n  [unix_domain_socket]\n  type = tcp\n  remote_port = 6000\n  plugin = unix_domain_socket\n  plugin_unix_path = /var/run/docker.sock\n  ```\n\n2. Test the configuration by getting the docker version using `curl`:\n\n  `curl http://x.x.x.x:6000/version`\n\n### Expose a simple HTTP file server\n\nExpose a simple HTTP file server to access files stored in the LAN from the public Internet.\n\nConfigure `frps` as described above, then:\n\n1. Start `frpc` with the following configuration:\n\n  ```ini\n  # frpc.ini\n  [common]\n  server_addr = x.x.x.x\n  server_port = 7000\n\n  [test_static_file]\n  type = tcp\n  remote_port = 6000\n  plugin = static_file\n  plugin_local_path = /tmp/files\n  plugin_strip_prefix = static\n  plugin_http_user = abc\n  plugin_http_passwd = abc\n  ```\n\n2. Visit `http://x.x.x.x:6000/static/` from your browser and specify correct username and password to view files in `/tmp/files` on the `frpc` machine.\n\n### Enable HTTPS for a local HTTP(S) service\n\nYou may substitute `https2https` for the plugin, and point the `plugin_local_addr` to a HTTPS endpoint.\n\n1. Start `frpc` with the following configuration:\n\n  ```ini\n  # frpc.ini\n  [common]\n  server_addr = x.x.x.x\n  server_port = 7000\n  vhost_https_port = 443\n\n  [test_https2http]\n  type = https\n  custom_domains = test.example.com\n\n  plugin = https2http\n  plugin_local_addr = 127.0.0.1:80\n  plugin_crt_path = ./server.crt\n  plugin_key_path = ./server.key\n  plugin_host_header_rewrite = 127.0.0.1\n  plugin_header_X-From-Where = frp\n  ```\n\n2. Visit `https://test.example.com`.\n\n### Expose your service privately\n\nTo mitigate risks associated with exposing certain services directly to the public network, STCP (Secret TCP) mode requires a preshared key to be used for access to the service from other clients.\n\nConfigure `frps` same as above.\n\n1. Start `frpc` on machine B with the following config. This example is for exposing the SSH service (port 22), and note the `sk` field for the preshared key, and that the `remote_port` field is removed here:\n\n  ```ini\n  # frpc.ini\n  [common]\n  server_addr = x.x.x.x\n  server_port = 7000\n\n  [secret_ssh]\n  type = stcp\n  sk = abcdefg\n  local_ip = 127.0.0.1\n  local_port = 22\n  ```\n\n2. Start another `frpc` (typically on another machine C) with the following config to access the SSH service with a security key (`sk` field):\n\n  ```ini\n  # frpc.ini\n  [common]\n  server_addr = x.x.x.x\n  server_port = 7000\n\n  [secret_ssh_visitor]\n  type = stcp\n  role = visitor\n  server_name = secret_ssh\n  sk = abcdefg\n  bind_addr = 127.0.0.1\n  bind_port = 6000\n  ```\n\n3. On machine C, connect to SSH on machine B, using this command:\n\n  `ssh -oPort=6000 127.0.0.1`\n\n### P2P Mode\n\n**xtcp** is designed to transmit large amounts of data directly between clients. A frps server is still needed, as P2P here only refers to the actual data transmission.\n\nNote that it may not work with all types of NAT devices. You might want to fallback to stcp if xtcp doesn't work.\n\n1. Start `frpc` on machine B, and expose the SSH port. Note that the `remote_port` field is removed:\n\n  ```ini\n  # frpc.ini\n  [common]\n  server_addr = x.x.x.x\n  server_port = 7000\n  # set up a new stun server if the default one is not available.\n  # nat_hole_stun_server = xxx\n\n  [p2p_ssh]\n  type = xtcp\n  sk = abcdefg\n  local_ip = 127.0.0.1\n  local_port = 22\n  ```\n\n2. Start another `frpc` (typically on another machine C) with the configuration to connect to SSH using P2P mode:\n\n  ```ini\n  # frpc.ini\n  [common]\n  server_addr = x.x.x.x\n  server_port = 7000\n  # set up a new stun server if the default one is not available.\n  # nat_hole_stun_server = xxx\n\n  [p2p_ssh_visitor]\n  type = xtcp\n  role = visitor\n  server_name = p2p_ssh\n  sk = abcdefg\n  bind_addr = 127.0.0.1\n  bind_port = 6000\n  # when automatic tunnel persistence is required, set it to true\n  keep_tunnel_open = false\n  ```\n\n3. On machine C, connect to SSH on machine B, using this command:\n\n  `ssh -oPort=6000 127.0.0.1`\n\n## Features\n\n### Configuration Files\n\nRead the full example configuration files to find out even more features not described here.\n\n[Full configuration file for frps (Server)](./conf/frps_full.ini)\n\n[Full configuration file for frpc (Client)](./conf/frpc_full.ini)\n\n### Using Environment Variables\n\nEnvironment variables can be referenced in the configuration file, using Go's standard format:\n\n```ini\n# frpc.ini\n[common]\nserver_addr = {{ .Envs.FRP_SERVER_ADDR }}\nserver_port = 7000\n\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\nremote_port = {{ .Envs.FRP_SSH_REMOTE_PORT }}\n```\n\nWith the config above, variables can be passed into `frpc` program like this:\n\n```\nexport FRP_SERVER_ADDR=\"x.x.x.x\"\nexport FRP_SSH_REMOTE_PORT=\"6000\"\n./frpc -c ./frpc.ini\n```\n\n`frpc` will render configuration file template using OS environment variables. Remember to prefix your reference with `.Envs`.\n\n### Split Configures Into Different Files\n\nYou can split multiple proxy configs into different files and include them in the main file.\n\n```ini\n# frpc.ini\n[common]\nserver_addr = x.x.x.x\nserver_port = 7000\nincludes=./confd/*.ini\n```\n\n```ini\n# ./confd/test.ini\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\nremote_port = 6000\n```\n\n### Dashboard\n\nCheck frp's status and proxies' statistics information by Dashboard.\n\nConfigure a port for dashboard to enable this feature:\n\n```ini\n[common]\ndashboard_port = 7500\n# dashboard's username and password are both optional\ndashboard_user = admin\ndashboard_pwd = admin\n```\n\nThen visit `http://[server_addr]:7500` to see the dashboard, with username and password both being `admin`.\n\nAdditionally, you can use HTTPS port by using your domains wildcard or normal SSL certificate:\n\n```ini\n[common]\ndashboard_port = 7500\n# dashboard's username and password are both optional\ndashboard_user = admin\ndashboard_pwd = admin\ndashboard_tls_mode = true\ndashboard_tls_cert_file = server.crt\ndashboard_tls_key_file = server.key\n```\n\nThen visit `https://[server_addr]:7500` to see the dashboard in secure HTTPS connection, with username and password both being `admin`.\n\n![dashboard](/doc/pic/dashboard.png)\n\n### Admin UI\n\nThe Admin UI helps you check and manage frpc's configuration.\n\nConfigure an address for admin UI to enable this feature:\n\n```ini\n[common]\nadmin_addr = 127.0.0.1\nadmin_port = 7400\nadmin_user = admin\nadmin_pwd = admin\n```\n\nThen visit `http://127.0.0.1:7400` to see admin UI, with username and password both being `admin`.\n\n### Monitor\n\nWhen dashboard is enabled, frps will save monitor data in cache. It will be cleared after process restart.\n\nPrometheus is also supported.\n\n#### Prometheus\n\nEnable dashboard first, then configure `enable_prometheus = true` in `frps.ini`.\n\n`http://{dashboard_addr}/metrics` will provide prometheus monitor data.\n\n### Authenticating the Client\n\nThere are 2 authentication methods to authenticate frpc with frps. \n\nYou can decide which one to use by configuring `authentication_method` under `[common]` in `frpc.ini` and `frps.ini`.\n\nConfiguring `authenticate_heartbeats = true` under `[common]` will use the configured authentication method to add and validate authentication on every heartbeat between frpc and frps.\n\nConfiguring `authenticate_new_work_conns = true` under `[common]` will do the same for every new work connection between frpc and frps.\n\n#### Token Authentication\n\nWhen specifying `authentication_method = token` under `[common]` in `frpc.ini` and `frps.ini` - token based authentication will be used.\n\nMake sure to specify the same `token` in the `[common]` section in `frps.ini` and `frpc.ini` for frpc to pass frps validation\n\n#### OIDC Authentication\n\nWhen specifying `authentication_method = oidc` under `[common]` in `frpc.ini` and `frps.ini` - OIDC based authentication will be used.\n\nOIDC stands for OpenID Connect, and the flow used is called [Client Credentials Grant](https://tools.ietf.org/html/rfc6749#section-4.4).\n\nTo use this authentication type - configure `frpc.ini` and `frps.ini` as follows:\n\n```ini\n# frps.ini\n[common]\nauthentication_method = oidc\noidc_issuer = https://example-oidc-issuer.com/\noidc_audience = https://oidc-audience.com/.default\n```\n\n```ini\n# frpc.ini\n[common]\nauthentication_method = oidc\noidc_client_id = 98692467-37de-409a-9fac-bb2585826f18 # Replace with OIDC client ID\noidc_client_secret = oidc_secret\noidc_audience = https://oidc-audience.com/.default\noidc_token_endpoint_url = https://example-oidc-endpoint.com/oauth2/v2.0/token\n```\n\n### Encryption and Compression\n\nThe features are off by default. You can turn on encryption and/or compression:\n\n```ini\n# frpc.ini\n[ssh]\ntype = tcp\nlocal_port = 22\nremote_port = 6000\nuse_encryption = true\nuse_compression = true\n```\n\n#### TLS\n\nSince v0.50.0, the default value of `tls_enable` and `disable_custom_tls_first_byte` has been changed to true, and tls is enabled by default.\n\nFor port multiplexing, frp sends a first byte `0x17` to dial a TLS connection. This only takes effect when you set `disable_custom_tls_first_byte` to false.\n\nTo **enforce** `frps` to only accept TLS connections - configure `tls_only = true` in the `[common]` section in `frps.ini`. **This is optional.**\n\n**`frpc` TLS settings (under the `[common]` section):**\n```ini\ntls_enable = true\ntls_cert_file = certificate.crt\ntls_key_file = certificate.key\ntls_trusted_ca_file = ca.crt\n```\n\n**`frps` TLS settings (under the `[common]` section):**\n```ini\ntls_only = true\ntls_cert_file = certificate.crt\ntls_key_file = certificate.key\ntls_trusted_ca_file = ca.crt\n```\n\nYou will need **a root CA cert** and **at least one SSL/TLS certificate**. It **can** be self-signed or regular (such as Let's Encrypt or another SSL/TLS certificate provider).\n\nIf you using `frp` via IP address and not hostname, make sure to set the appropriate IP address in the Subject Alternative Name (SAN) area when generating SSL/TLS Certificates.\n\nGiven an example:\n\n* Prepare openssl config file. It exists at `/etc/pki/tls/openssl.cnf` in Linux System and `/System/Library/OpenSSL/openssl.cnf` in MacOS, and you can copy it to current path, like `cp /etc/pki/tls/openssl.cnf ./my-openssl.cnf`. If not, you can build it by yourself, like:\n```\ncat > my-openssl.cnf << EOF\n[ ca ]\ndefault_ca = CA_default\n[ CA_default ]\nx509_extensions = usr_cert\n[ req ]\ndefault_bits        = 2048\ndefault_md          = sha256\ndefault_keyfile     = privkey.pem\ndistinguished_name  = req_distinguished_name\nattributes          = req_attributes\nx509_extensions     = v3_ca\nstring_mask         = utf8only\n[ req_distinguished_name ]\n[ req_attributes ]\n[ usr_cert ]\nbasicConstraints       = CA:FALSE\nnsComment              = \"OpenSSL Generated Certificate\"\nsubjectKeyIdentifier   = hash\nauthorityKeyIdentifier = keyid,issuer\n[ v3_ca ]\nsubjectKeyIdentifier   = hash\nauthorityKeyIdentifier = keyid:always,issuer\nbasicConstraints       = CA:true\nEOF\n```\n\n* build ca certificates:\n```\nopenssl genrsa -out ca.key 2048\nopenssl req -x509 -new -nodes -key ca.key -subj \"/CN=example.ca.com\" -days 5000 -out ca.crt\n```\n\n* build frps certificates:\n```\nopenssl genrsa -out server.key 2048\n\nopenssl req -new -sha256 -key server.key \\\n    -subj \"/C=XX/ST=DEFAULT/L=DEFAULT/O=DEFAULT/CN=server.com\" \\\n    -reqexts SAN \\\n    -config <(cat my-openssl.cnf <(printf \"\\n[SAN]\\nsubjectAltName=DNS:localhost,IP:127.0.0.1,DNS:example.server.com\")) \\\n    -out server.csr\n\nopenssl x509 -req -days 365 -sha256 \\\n\t-in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial \\\n\t-extfile <(printf \"subjectAltName=DNS:localhost,IP:127.0.0.1,DNS:example.server.com\") \\\n\t-out server.crt\n```\n\n* build frpc certificates：\n```\nopenssl genrsa -out client.key 2048\nopenssl req -new -sha256 -key client.key \\\n    -subj \"/C=XX/ST=DEFAULT/L=DEFAULT/O=DEFAULT/CN=client.com\" \\\n    -reqexts SAN \\\n    -config <(cat my-openssl.cnf <(printf \"\\n[SAN]\\nsubjectAltName=DNS:client.com,DNS:example.client.com\")) \\\n    -out client.csr\n\nopenssl x509 -req -days 365 -sha256 \\\n    -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial \\\n\t-extfile <(printf \"subjectAltName=DNS:client.com,DNS:example.client.com\") \\\n\t-out client.crt\n```\n\n### Hot-Reloading frpc configuration\n\nThe `admin_addr` and `admin_port` fields are required for enabling HTTP API:\n\n```ini\n# frpc.ini\n[common]\nadmin_addr = 127.0.0.1\nadmin_port = 7400\n```\n\nThen run command `frpc reload -c ./frpc.ini` and wait for about 10 seconds to let `frpc` create or update or remove proxies.\n\n**Note that parameters in [common] section won't be modified except 'start'.**\n\nYou can run command `frpc verify -c ./frpc.ini` before reloading to check if there are config errors.\n\n### Get proxy status from client\n\nUse `frpc status -c ./frpc.ini` to get status of all proxies. The `admin_addr` and `admin_port` fields are required for enabling HTTP API.\n\n### Only allowing certain ports on the server\n\n`allow_ports` in `frps.ini` is used to avoid abuse of ports:\n\n```ini\n# frps.ini\n[common]\nallow_ports = 2000-3000,3001,3003,4000-50000\n```\n\n`allow_ports` consists of specific ports or port ranges (lowest port number, dash `-`, highest port number), separated by comma `,`.\n\n### Port Reuse\n\n`vhost_http_port` and `vhost_https_port` in frps can use same port with `bind_port`. frps will detect the connection's protocol and handle it correspondingly.\n\nWe would like to try to allow multiple proxies bind a same remote port with different protocols in the future.\n\n### Bandwidth Limit\n\n#### For Each Proxy\n\n```ini\n# frpc.ini\n[ssh]\ntype = tcp\nlocal_port = 22\nremote_port = 6000\nbandwidth_limit = 1MB\n```\n\nSet `bandwidth_limit` in each proxy's configure to enable this feature. Supported units are `MB` and `KB`.\n\nSet `bandwidth_limit_mode` to `client` or `server` to limit bandwidth on the client or server side. Default is `client`.\n\n### TCP Stream Multiplexing\n\nfrp supports tcp stream multiplexing since v0.10.0 like HTTP2 Multiplexing, in which case all logic connections to the same frpc are multiplexed into the same TCP connection.\n\nYou can disable this feature by modify `frps.ini` and `frpc.ini`:\n\n```ini\n# frps.ini and frpc.ini, must be same\n[common]\ntcp_mux = false\n```\n\n### Support KCP Protocol\n\nKCP is a fast and reliable protocol that can achieve the transmission effect of a reduction of the average latency by 30% to 40% and reduction of the maximum delay by a factor of three, at the cost of 10% to 20% more bandwidth wasted than TCP.\n\nKCP mode uses UDP as the underlying transport. Using KCP in frp:\n\n1. Enable KCP in frps:\n\n  ```ini\n  # frps.ini\n  [common]\n  bind_port = 7000\n  # Specify a UDP port for KCP.\n  kcp_bind_port = 7000\n  ```\n\n  The `kcp_bind_port` number can be the same number as `bind_port`, since `bind_port` field specifies a TCP port.\n\n2. Configure `frpc.ini` to use KCP to connect to frps:\n\n  ```ini\n  # frpc.ini\n  [common]\n  server_addr = x.x.x.x\n  # Same as the 'kcp_bind_port' in frps.ini\n  server_port = 7000\n  protocol = kcp\n  ```\n\n### Support QUIC Protocol\n\nQUIC is a new multiplexed transport built on top of UDP.\n\nUsing QUIC in frp:\n\n1. Enable QUIC in frps:\n\n  ```ini\n  # frps.ini\n  [common]\n  bind_port = 7000\n  # Specify a UDP port for QUIC.\n  quic_bind_port = 7000\n  ```\n\n  The `quic_bind_port` number can be the same number as `bind_port`, since `bind_port` field specifies a TCP port.\n\n2. Configure `frpc.ini` to use QUIC to connect to frps:\n\n  ```ini\n  # frpc.ini\n  [common]\n  server_addr = x.x.x.x\n  # Same as the 'quic_bind_port' in frps.ini\n  server_port = 7000\n  protocol = quic\n  ```\n\n### Connection Pooling\n\nBy default, frps creates a new frpc connection to the backend service upon a user request. With connection pooling, frps keeps a certain number of pre-established connections, reducing the time needed to establish a connection.\n\nThis feature is suitable for a large number of short connections.\n\n1. Configure the limit of pool count each proxy can use in `frps.ini`:\n\n  ```ini\n  # frps.ini\n  [common]\n  max_pool_count = 5\n  ```\n\n2. Enable and specify the number of connection pool:\n\n  ```ini\n  # frpc.ini\n  [common]\n  pool_count = 1\n  ```\n\n### Load balancing\n\nLoad balancing is supported by `group`.\n\nThis feature is only available for types `tcp`, `http`, `tcpmux` now.\n\n```ini\n# frpc.ini\n[test1]\ntype = tcp\nlocal_port = 8080\nremote_port = 80\ngroup = web\ngroup_key = 123\n\n[test2]\ntype = tcp\nlocal_port = 8081\nremote_port = 80\ngroup = web\ngroup_key = 123\n```\n\n`group_key` is used for authentication.\n\nConnections to port 80 will be dispatched to proxies in the same group randomly.\n\nFor type `tcp`, `remote_port` in the same group should be the same.\n\nFor type `http`, `custom_domains`, `subdomain`, `locations` should be the same.\n\n### Service Health Check\n\nHealth check feature can help you achieve high availability with load balancing.\n\nAdd `health_check_type = tcp` or `health_check_type = http` to enable health check.\n\nWith health check type **tcp**, the service port will be pinged (TCPing):\n\n```ini\n# frpc.ini\n[test1]\ntype = tcp\nlocal_port = 22\nremote_port = 6000\n# Enable TCP health check\nhealth_check_type = tcp\n# TCPing timeout seconds\nhealth_check_timeout_s = 3\n# If health check failed 3 times in a row, the proxy will be removed from frps\nhealth_check_max_failed = 3\n# A health check every 10 seconds\nhealth_check_interval_s = 10\n```\n\nWith health check type **http**, an HTTP request will be sent to the service and an HTTP 2xx OK response is expected:\n\n```ini\n# frpc.ini\n[web]\ntype = http\nlocal_ip = 127.0.0.1\nlocal_port = 80\ncustom_domains = test.example.com\n# Enable HTTP health check\nhealth_check_type = http\n# frpc will send a GET request to '/status'\n# and expect an HTTP 2xx OK response\nhealth_check_url = /status\nhealth_check_timeout_s = 3\nhealth_check_max_failed = 3\nhealth_check_interval_s = 10\n```\n\n### Rewriting the HTTP Host Header\n\nBy default frp does not modify the tunneled HTTP requests at all as it's a byte-for-byte copy.\n\nHowever, speaking of web servers and HTTP requests, your web server might rely on the `Host` HTTP header to determine the website to be accessed. frp can rewrite the `Host` header when forwarding the HTTP requests, with the `host_header_rewrite` field:\n\n```ini\n# frpc.ini\n[web]\ntype = http\nlocal_port = 80\ncustom_domains = test.example.com\nhost_header_rewrite = dev.example.com\n```\n\nThe HTTP request will have the `Host` header rewritten to `Host: dev.example.com` when it reaches the actual web server, although the request from the browser probably has `Host: test.example.com`.\n\n### Setting other HTTP Headers\n\nSimilar to `Host`, You can override other HTTP request headers with proxy type `http`.\n\n```ini\n# frpc.ini\n[web]\ntype = http\nlocal_port = 80\ncustom_domains = test.example.com\nhost_header_rewrite = dev.example.com\nheader_X-From-Where = frp\n```\n\nNote that parameter(s) prefixed with `header_` will be added to HTTP request headers.\n\nIn this example, it will set header `X-From-Where: frp` in the HTTP request.\n\n### Get Real IP\n\n#### HTTP X-Forwarded-For\n\nThis feature is for http proxy only.\n\nYou can get user's real IP from HTTP request headers `X-Forwarded-For`.\n\n#### Proxy Protocol\n\nfrp supports Proxy Protocol to send user's real IP to local services. It support all types except UDP.\n\nHere is an example for https service:\n\n```ini\n# frpc.ini\n[web]\ntype = https\nlocal_port = 443\ncustom_domains = test.example.com\n\n# now v1 and v2 are supported\nproxy_protocol_version = v2\n```\n\nYou can enable Proxy Protocol support in nginx to expose user's real IP in HTTP header `X-Real-IP`, and then read `X-Real-IP` header in your web service for the real IP.\n\n### Require HTTP Basic Auth (Password) for Web Services\n\nAnyone who can guess your tunnel URL can access your local web server unless you protect it with a password.\n\nThis enforces HTTP Basic Auth on all requests with the username and password specified in frpc's configure file.\n\nIt can only be enabled when proxy type is http.\n\n```ini\n# frpc.ini\n[web]\ntype = http\nlocal_port = 80\ncustom_domains = test.example.com\nhttp_user = abc\nhttp_pwd = abc\n```\n\nVisit `http://test.example.com` in the browser and now you are prompted to enter the username and password.\n\n### Custom Subdomain Names\n\nIt is convenient to use `subdomain` configure for http and https types when many people share one frps server.\n\n```ini\n# frps.ini\nsubdomain_host = frps.com\n```\n\nResolve `*.frps.com` to the frps server's IP. This is usually called a Wildcard DNS record.\n\n```ini\n# frpc.ini\n[web]\ntype = http\nlocal_port = 80\nsubdomain = test\n```\n\nNow you can visit your web service on `test.frps.com`.\n\nNote that if `subdomain_host` is not empty, `custom_domains` should not be the subdomain of `subdomain_host`.\n\n### URL Routing\n\nfrp supports forwarding HTTP requests to different backend web services by url routing.\n\n`locations` specifies the prefix of URL used for routing. frps first searches for the most specific prefix location given by literal strings regardless of the listed order.\n\n```ini\n# frpc.ini\n[web01]\ntype = http\nlocal_port = 80\ncustom_domains = web.example.com\nlocations = /\n\n[web02]\ntype = http\nlocal_port = 81\ncustom_domains = web.example.com\nlocations = /news,/about\n```\n\nHTTP requests with URL prefix `/news` or `/about` will be forwarded to **web02** and other requests to **web01**.\n\n### TCP Port Multiplexing\n\nfrp supports receiving TCP sockets directed to different proxies on a single port on frps, similar to `vhost_http_port` and `vhost_https_port`.\n\nThe only supported TCP port multiplexing method available at the moment is `httpconnect` - HTTP CONNECT tunnel.\n\nWhen setting `tcpmux_httpconnect_port` to anything other than 0 in frps under `[common]`, frps will listen on this port for HTTP CONNECT requests.\n\nThe host of the HTTP CONNECT request will be used to match the proxy in frps. Proxy hosts can be configured in frpc by configuring `custom_domain` and / or `subdomain` under `type = tcpmux` proxies, when `multiplexer = httpconnect`.\n\nFor example:\n\n```ini\n# frps.ini\n[common]\nbind_port = 7000\ntcpmux_httpconnect_port = 1337\n```\n\n```ini\n# frpc.ini\n[common]\nserver_addr = x.x.x.x\nserver_port = 7000\n\n[proxy1]\ntype = tcpmux\nmultiplexer = httpconnect\ncustom_domains = test1\nlocal_port = 80\n\n[proxy2]\ntype = tcpmux\nmultiplexer = httpconnect\ncustom_domains = test2\nlocal_port = 8080\n```\n\nIn the above configuration - frps can be contacted on port 1337 with a HTTP CONNECT header such as:\n\n```\nCONNECT test1 HTTP/1.1\\r\\n\\r\\n\n```\nand the connection will be routed to `proxy1`.\n\n### Connecting to frps via HTTP PROXY\n\nfrpc can connect to frps using HTTP proxy if you set OS environment variable `HTTP_PROXY`, or if `http_proxy` is set in frpc.ini file.\n\nIt only works when protocol is tcp.\n\n```ini\n# frpc.ini\n[common]\nserver_addr = x.x.x.x\nserver_port = 7000\nhttp_proxy = http://user:pwd@192.168.1.128:8080\n```\n\n### Range ports mapping\n\nProxy with names that start with `range:` will support mapping range ports.\n\n```ini\n# frpc.ini\n[range:test_tcp]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 6000-6006,6007\nremote_port = 6000-6006,6007\n```\n\nfrpc will generate 8 proxies like `test_tcp_0`, `test_tcp_1`, ..., `test_tcp_7`.\n\n### Client Plugins\n\nfrpc only forwards requests to local TCP or UDP ports by default.\n\nPlugins are used for providing rich features. There are built-in plugins such as `unix_domain_socket`, `http_proxy`, `socks5`, `static_file`, `http2https`, `https2http`, `https2https` and you can see [example usage](#example-usage).\n\nSpecify which plugin to use with the `plugin` parameter. Configuration parameters of plugin should be started with `plugin_`. `local_ip` and `local_port` are not used for plugin.\n\nUsing plugin **http_proxy**:\n\n```ini\n# frpc.ini\n[http_proxy]\ntype = tcp\nremote_port = 6000\nplugin = http_proxy\nplugin_http_user = abc\nplugin_http_passwd = abc\n```\n\n`plugin_http_user` and `plugin_http_passwd` are configuration parameters used in `http_proxy` plugin.\n\n### Server Manage Plugins\n\nRead the [document](/doc/server_plugin.md).\n\nFind more plugins in [gofrp/plugin](https://github.com/gofrp/plugin).\n\n## Development Plan\n\n* Log HTTP request information in frps.\n\n## Contributing\n\nInterested in getting involved? We would like to help you!\n\n* Take a look at our [issues list](https://github.com/fatedier/frp/issues) and consider sending a Pull Request to **dev branch**.\n* If you want to add a new feature, please create an issue first to describe the new feature, as well as the implementation approach. Once a proposal is accepted, create an implementation of the new features and submit it as a pull request.\n* Sorry for my poor English. Improvements for this document are welcome, even some typo fixes.\n* If you have great ideas, send an email to fatedier@gmail.com.\n\n**Note: We prefer you to give your advise in [issues](https://github.com/fatedier/frp/issues), so others with a same question can search it quickly and we don't need to answer them repeatedly.**\n\n## Donation\n\nIf frp helps you a lot, you can support us by:\n\n### GitHub Sponsors\n\nSupport us by [Github Sponsors](https://github.com/sponsors/fatedier).\n\nYou can have your company's logo placed on README file of this project.\n\n### PayPal\n\nDonate money by [PayPal](https://www.paypal.me/fatedier) to my account **fatedier@gmail.com**."
}
