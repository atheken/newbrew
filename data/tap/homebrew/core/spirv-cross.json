{
  "name": "spirv-cross",
  "full_name": "spirv-cross",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Performing reflection and disassembling SPIR-V",
  "license": "Apache-2.0 and MIT and CC-BY-4.0 and Cannot Represent",
  "homepage": "https://github.com/KhronosGroup/SPIRV-Cross",
  "versions": {
    "stable": "1.3.250.1",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/KhronosGroup/SPIRV-Cross/archive/refs/tags/sdk-1.3.250.1.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "5b7402d7078eeffca0926875b1dcd0f5dd78791a30529de7c8456686f6fc52ce"
    }
  },
  "revision": 0,
  "version_scheme": 1,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/spirv-cross/blobs/sha256:4a0d0374846b8bbf1b8ea99f30861225c1d73345c00556173bf748bed7d8cde5",
          "sha256": "4a0d0374846b8bbf1b8ea99f30861225c1d73345c00556173bf748bed7d8cde5"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/spirv-cross/blobs/sha256:999c8759b10c132d12208bac28f6cdc9cb69aa35a05d61eab220388044287626",
          "sha256": "999c8759b10c132d12208bac28f6cdc9cb69aa35a05d61eab220388044287626"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/spirv-cross/blobs/sha256:489f5ab1d672983cdc6ee5518ba3a22d6ddfe1e9ab1c7f7e70719676c63e5e5f",
          "sha256": "489f5ab1d672983cdc6ee5518ba3a22d6ddfe1e9ab1c7f7e70719676c63e5e5f"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/spirv-cross/blobs/sha256:f7b0421aeca71d23b3d48db19e920d998cd8bd0ac311c02df1ea30025a2b63c8",
          "sha256": "f7b0421aeca71d23b3d48db19e920d998cd8bd0ac311c02df1ea30025a2b63c8"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/spirv-cross/blobs/sha256:94080e31d9cf6fccdadeb9e0f472b68d3feaf7b6eb2f46a96f56073c86156c20",
          "sha256": "94080e31d9cf6fccdadeb9e0f472b68d3feaf7b6eb2f46a96f56073c86156c20"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/spirv-cross/blobs/sha256:b0bf60714c9a937de136ae7257b04d8a80428c221eb21484a7566e9574b7c69f",
          "sha256": "b0bf60714c9a937de136ae7257b04d8a80428c221eb21484a7566e9574b7c69f"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/spirv-cross/blobs/sha256:c816877297d71fda95b12497cea592cd9874c848a6cfc5b8c97c0b8079abbda9",
          "sha256": "c816877297d71fda95b12497cea592cd9874c848a6cfc5b8c97c0b8079abbda9"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake"
  ],
  "dependencies": [],
  "test_dependencies": [
    "glm",
    "glslang"
  ],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/spirv-cross.rb",
  "ruby_source_checksum": {
    "sha256": "cae0e00433b640d8f85487a29904a49a31f2b74b25ad95bbed8fedb80dee6ee7"
  },
  "date_added": "2019-02-16T14:46:52+01:00",
  "readme": "<!--\n    Copyright 2020-2021 The Khronos Group, Inc.\n    SPDX-License-Identifier: CC-BY-4.0\n-->\n\n# SPIRV-Cross\n\nSPIRV-Cross is a tool designed for parsing and converting SPIR-V to other shader languages.\n\n[![CI](https://github.com/KhronosGroup/SPIRV-Cross/actions/workflows/main.yml/badge.svg)](https://github.com/KhronosGroup/SPIRV-Cross/actions/workflows/main.yml)\n[![Build Status](https://ci.appveyor.com/api/projects/status/github/KhronosGroup/SPIRV-Cross?svg=true&branch=main)](https://ci.appveyor.com/project/HansKristian-Work/SPIRV-Cross)\n\n## Features\n\n  - Convert SPIR-V to readable, usable and efficient GLSL\n  - Convert SPIR-V to readable, usable and efficient Metal Shading Language (MSL)\n  - Convert SPIR-V to readable, usable and efficient HLSL\n  - Convert SPIR-V to a JSON reflection format\n  - Convert SPIR-V to debuggable C++ [DEPRECATED]\n  - Reflection API to simplify the creation of Vulkan pipeline layouts\n  - Reflection API to modify and tweak OpDecorations\n  - Supports \"all\" of vertex, fragment, tessellation, geometry and compute shaders.\n\nSPIRV-Cross tries hard to emit readable and clean output from the SPIR-V.\nThe goal is to emit GLSL or MSL that looks like it was written by a human and not awkward IR/assembly-like code.\n\nNOTE: Individual features are expected to be mostly complete, but it is possible that certain obscure GLSL features are not yet supported.\nHowever, most missing features are expected to be \"trivial\" improvements at this stage.\n\n## Building\n\nSPIRV-Cross has been tested on Linux, iOS/OSX, Windows and Android. CMake is the main build system.\n\n### NOTE: main branch rename\n\nOn 2023-01-12, `master` was renamed to `main` as per Khronos policy.\n\n### Linux and macOS\n\nBuilding with CMake is recommended, as it is the only build system which is tested in continuous integration.\nIt is also the only build system which has install commands and other useful build system features.\n\nHowever, you can just run `make` on the command line as a fallback if you only care about the CLI tool.\n\nA non-ancient GCC (4.8+) or Clang (3.x+) compiler is required as SPIRV-Cross uses C++11 extensively.\n\n### Windows\n\nBuilding with CMake is recommended, which is the only way to target MSVC.\nMinGW-w64 based compilation works with `make` as a fallback.\n\n### Android\n\nSPIRV-Cross is only useful as a library here. Use the CMake build to link SPIRV-Cross to your project.\n\n### C++ exceptions\n\nThe make and CMake build flavors offer the option to treat exceptions as assertions. To disable exceptions for make just append `SPIRV_CROSS_EXCEPTIONS_TO_ASSERTIONS=1` to the command line. For CMake append `-DSPIRV_CROSS_EXCEPTIONS_TO_ASSERTIONS=ON`. By default exceptions are enabled.\n\n### Static, shared and CLI\n\nYou can use `-DSPIRV_CROSS_STATIC=ON/OFF` `-DSPIRV_CROSS_SHARED=ON/OFF` `-DSPIRV_CROSS_CLI=ON/OFF` to control which modules are built (and installed).\n\n### Installing SPIRV-Cross (vcpkg)\n\nAlternatively, you can build and install SPIRV-Cross using [vcpkg](https://github.com/Microsoft/vcpkg/) dependency manager:\n\n```\ngit clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.sh\n./vcpkg integrate install\n./vcpkg install spirv-cross\n```\n\nThe SPIRV-Cross port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository.\n\n## Usage\n\n### Using the C++ API\n\nThe C++ API is the main API for SPIRV-Cross. For more in-depth documentation than what's provided in this README,\nplease have a look at the [Wiki](https://github.com/KhronosGroup/SPIRV-Cross/wiki).\n**NOTE**: This API is not guaranteed to be ABI-stable, and it is highly recommended to link against this API statically.\nThe API is generally quite stable, but it can change over time, see the C API for more stability.\n\nTo perform reflection and convert to other shader languages you can use the SPIRV-Cross API.\nFor example:\n\n```c++\n#include \"spirv_glsl.hpp\"\n#include <vector>\n#include <utility>\n\nextern std::vector<uint32_t> load_spirv_file();\n\nint main()\n{\n\t// Read SPIR-V from disk or similar.\n\tstd::vector<uint32_t> spirv_binary = load_spirv_file();\n\n\tspirv_cross::CompilerGLSL glsl(std::move(spirv_binary));\n\n\t// The SPIR-V is now parsed, and we can perform reflection on it.\n\tspirv_cross::ShaderResources resources = glsl.get_shader_resources();\n\n\t// Get all sampled images in the shader.\n\tfor (auto &resource : resources.sampled_images)\n\t{\n\t\tunsigned set = glsl.get_decoration(resource.id, spv::DecorationDescriptorSet);\n\t\tunsigned binding = glsl.get_decoration(resource.id, spv::DecorationBinding);\n\t\tprintf(\"Image %s at set = %u, binding = %u\\n\", resource.name.c_str(), set, binding);\n\n\t\t// Modify the decoration to prepare it for GLSL.\n\t\tglsl.unset_decoration(resource.id, spv::DecorationDescriptorSet);\n\n\t\t// Some arbitrary remapping if we want.\n\t\tglsl.set_decoration(resource.id, spv::DecorationBinding, set * 16 + binding);\n\t}\n\n\t// Set some options.\n\tspirv_cross::CompilerGLSL::Options options;\n\toptions.version = 310;\n\toptions.es = true;\n\tglsl.set_common_options(options);\n\n\t// Compile to GLSL, ready to give to GL driver.\n\tstd::string source = glsl.compile();\n}\n```\n\n### Using the C API wrapper\n\nTo facilitate C compatibility and compatibility with foreign programming languages, a C89-compatible API wrapper is provided. Unlike the C++ API,\nthe goal of this wrapper is to be fully stable, both API and ABI-wise.\nThis is the only interface which is supported when building SPIRV-Cross as a shared library.\n\nAn important point of the wrapper is that all memory allocations are contained in the `spvc_context`.\nThis simplifies the use of the API greatly. However, you should destroy the context as soon as reasonable,\nor use `spvc_context_release_allocations()` if you intend to reuse the `spvc_context` object again soon.\n\nMost functions return a `spvc_result`, where `SPVC_SUCCESS` is the only success code.\nFor brevity, the code below does not do any error checking.\n\n```c\n#include <spirv_cross_c.h>\n\nconst SpvId *spirv = get_spirv_data();\nsize_t word_count = get_spirv_word_count();\n\nspvc_context context = NULL;\nspvc_parsed_ir ir = NULL;\nspvc_compiler compiler_glsl = NULL;\nspvc_compiler_options options = NULL;\nspvc_resources resources = NULL;\nconst spvc_reflected_resource *list = NULL;\nconst char *result = NULL;\nsize_t count;\nsize_t i;\n\n// Create context.\nspvc_context_create(&context);\n\n// Set debug callback.\nspvc_context_set_error_callback(context, error_callback, userdata);\n\n// Parse the SPIR-V.\nspvc_context_parse_spirv(context, spirv, word_count, &ir);\n\n// Hand it off to a compiler instance and give it ownership of the IR.\nspvc_context_create_compiler(context, SPVC_BACKEND_GLSL, ir, SPVC_CAPTURE_MODE_TAKE_OWNERSHIP, &compiler_glsl);\n\n// Do some basic reflection.\nspvc_compiler_create_shader_resources(compiler_glsl, &resources);\nspvc_resources_get_resource_list_for_type(resources, SPVC_RESOURCE_TYPE_UNIFORM_BUFFER, &list, &count);\n\nfor (i = 0; i < count; i++)\n{\n    printf(\"ID: %u, BaseTypeID: %u, TypeID: %u, Name: %s\\n\", list[i].id, list[i].base_type_id, list[i].type_id,\n           list[i].name);\n    printf(\"  Set: %u, Binding: %u\\n\",\n           spvc_compiler_get_decoration(compiler_glsl, list[i].id, SpvDecorationDescriptorSet),\n           spvc_compiler_get_decoration(compiler_glsl, list[i].id, SpvDecorationBinding));\n}\n\n// Modify options.\nspvc_compiler_create_compiler_options(compiler_glsl, &options);\nspvc_compiler_options_set_uint(options, SPVC_COMPILER_OPTION_GLSL_VERSION, 330);\nspvc_compiler_options_set_bool(options, SPVC_COMPILER_OPTION_GLSL_ES, SPVC_FALSE);\nspvc_compiler_install_compiler_options(compiler_glsl, options);\n\nspvc_compiler_compile(compiler_glsl, &result);\nprintf(\"Cross-compiled source: %s\\n\", result);\n\n// Frees all memory we allocated so far.\nspvc_context_destroy(context);\n```\n\n### Linking\n\n#### CMake add_subdirectory()\n\nThis is the recommended way if you are using CMake and want to link against SPIRV-Cross statically.\n\n#### Integrating SPIRV-Cross in a custom build system\n\nTo add SPIRV-Cross to your own codebase, just copy the source and header files from root directory\nand build the relevant .cpp files you need. Make sure to build with C++11 support, e.g. `-std=c++11` in GCC and Clang.\nAlternatively, the Makefile generates a libspirv-cross.a static library during build that can be linked in.\n\n#### Linking against SPIRV-Cross as a system library\n\nIt is possible to link against SPIRV-Cross when it is installed as a system library,\nwhich would be mostly relevant for Unix-like platforms.\n\n##### pkg-config\n\nFor Unix-based systems, a pkg-config is installed for the C API, e.g.:\n\n```\n$ pkg-config spirv-cross-c-shared --libs --cflags\n-I/usr/local/include/spirv_cross -L/usr/local/lib -lspirv-cross-c-shared\n```\n\n##### CMake\n\nIf the project is installed, it can be found with `find_package()`, e.g.:\n\n```\ncmake_minimum_required(VERSION 3.5)\nset(CMAKE_C_STANDARD 99)\nproject(Test LANGUAGES C)\n\nfind_package(spirv_cross_c_shared)\nif (spirv_cross_c_shared_FOUND)\n        message(STATUS \"Found SPIRV-Cross C API! :)\")\nelse()\n        message(STATUS \"Could not find SPIRV-Cross C API! :(\")\nendif()\n\nadd_executable(test test.c)\ntarget_link_libraries(test spirv-cross-c-shared)\n```\n\ntest.c:\n```c\n#include <spirv_cross_c.h>\n\nint main(void)\n{\n        spvc_context context;\n        spvc_context_create(&context);\n        spvc_context_destroy(context);\n}\n```\n\n### CLI\n\nThe CLI is suitable for basic cross-compilation tasks, but it cannot support the full flexibility that the API can.\nSome examples below.\n\n#### Creating a SPIR-V file from GLSL with glslang\n\n```\nglslangValidator -H -V -o test.spv test.frag\n```\n\n#### Converting a SPIR-V file to GLSL ES\n\n```\nglslangValidator -H -V -o test.spv shaders/comp/basic.comp\n./spirv-cross --version 310 --es test.spv\n```\n\n#### Converting to desktop GLSL\n\n```\nglslangValidator -H -V -o test.spv shaders/comp/basic.comp\n./spirv-cross --version 330 --no-es test.spv --output test.comp\n```\n\n#### Disable prettifying optimizations\n\n```\nglslangValidator -H -V -o test.spv shaders/comp/basic.comp\n./spirv-cross --version 310 --es test.spv --output test.comp --force-temporary\n```\n\n### Using shaders generated from C++ backend\n\nPlease see `samples/cpp` where some GLSL shaders are compiled to SPIR-V, decompiled to C++ and run with test data.\nReading through the samples should explain how to use the C++ interface.\nA simple Makefile is included to build all shaders in the directory.\n\n### Implementation notes\n\nWhen using SPIR-V and SPIRV-Cross as an intermediate step for cross-compiling between high level languages there are some considerations to take into account,\nas not all features used by one high-level language are necessarily supported natively by the target shader language.\nSPIRV-Cross aims to provide the tools needed to handle these scenarios in a clean and robust way, but some manual action is required to maintain compatibility.\n\n#### HLSL source to GLSL\n\n##### HLSL entry points\n\nWhen using SPIR-V shaders compiled from HLSL, there are some extra things you need to take care of.\nFirst make sure that the entry point is used correctly.\nIf you forget to set the entry point correctly in glslangValidator (-e MyFancyEntryPoint),\nyou will likely encounter this error message:\n\n```\nCannot end a function before ending the current block.\nLikely cause: If this SPIR-V was created from glslang HLSL, make sure the entry point is valid.\n```\n\n##### Vertex/Fragment interface linking\n\nHLSL relies on semantics in order to effectively link together shader stages. In the SPIR-V generated by glslang, the transformation from HLSL to GLSL ends up looking like\n\n```c++\nstruct VSOutput {\n   // SV_Position is rerouted to gl_Position\n   float4 position : SV_Position;\n   float4 coord : TEXCOORD0;\n};\n\nVSOutput main(...) {}\n```\n\n```c++\nstruct VSOutput {\n   float4 coord;\n}\nlayout(location = 0) out VSOutput _magicNameGeneratedByGlslang;\n```\n\nWhile this works, be aware of the type of the struct which is used in the vertex stage and the fragment stage.\nThere may be issues if the structure type name differs in vertex stage and fragment stage.\n\nYou can make use of the reflection interface to force the name of the struct type.\n\n```\n// Something like this for both vertex outputs and fragment inputs.\ncompiler.set_name(varying_resource.base_type_id, \"VertexFragmentLinkage\");\n```\n\nSome platform may require identical variable name for both vertex outputs and fragment inputs. (for example MacOSX)\nto rename variable base on location, please add\n```\n--rename-interface-variable <in|out> <location> <new_variable_name>\n```\n\n#### HLSL source to legacy GLSL/ESSL\n\nHLSL tends to emit varying struct types to pass data between vertex and fragment.\nThis is not supported in legacy GL/GLES targets, so to support this, varying structs are flattened.\nThis is done automatically, but the API user might need to be aware that this is happening in order to support all cases.\n\nModern GLES code like this:\n```c++\nstruct Output {\n   vec4 a;\n   vec2 b;\n};\nout Output vout;\n```\n\nIs transformed into:\n```c++\nstruct Output {\n   vec4 a;\n   vec2 b;\n};\nvarying vec4 Output_a;\nvarying vec2 Output_b;\n```\n\nNote that now, both the struct name and the member names will participate in the linking interface between vertex and fragment, so\nAPI users might want to ensure that both the struct names and member names match so that vertex outputs and fragment inputs can link properly.\n\n\n#### Separate image samplers (HLSL/Vulkan) for backends which do not support it (GLSL)\n\nAnother thing you need to remember is when using samplers and textures in HLSL these are separable, and not directly compatible with GLSL. If you need to use this with desktop GL/GLES, you need to call `Compiler::build_combined_image_samplers` first before calling `Compiler::compile`, or you will get an exception.\n\n```c++\n// From main.cpp\n// Builds a mapping for all combinations of images and samplers.\ncompiler->build_combined_image_samplers();\n\n// Give the remapped combined samplers new names.\n// Here you can also set up decorations if you want (binding = #N).\nfor (auto &remap : compiler->get_combined_image_samplers())\n{\n   compiler->set_name(remap.combined_id, join(\"SPIRV_Cross_Combined\", compiler->get_name(remap.image_id),\n            compiler->get_name(remap.sampler_id)));\n}\n```\n\nIf your target is Vulkan GLSL, `--vulkan-semantics` will emit separate image samplers as you'd expect.\nThe command line client calls `Compiler::build_combined_image_samplers` automatically, but if you're calling the library, you'll need to do this yourself.\n\n#### Descriptor sets (Vulkan GLSL) for backends which do not support them (pre HLSL 5.1 / GLSL)\n\nDescriptor sets are unique to Vulkan, so make sure that descriptor set + binding is remapped to a flat binding scheme (set always 0), so that other APIs can make sense of the bindings.\nThis can be done with `Compiler::set_decoration(id, spv::DecorationDescriptorSet)`. For other backends like MSL and HLSL, descriptor sets\ncan be used, with some minor caveats, see below.\n\n##### MSL 2.0+\n\nMetal supports indirect argument buffers (--msl-argument-buffers). In this case, descriptor sets become argument buffers,\nand bindings are mapped to [[id(N)]] within the argument buffer. One quirk is that arrays of resources consume multiple ids,\nwhere Vulkan does not. This can be worked around either from shader authoring stage\nor remapping bindings as needed to avoid the overlap.\nThere is also a rich API to declare remapping schemes which is intended to work like\nthe pipeline layout in Vulkan. See `CompilerMSL::add_msl_resource_binding`. Remapping combined image samplers for example\nmust be split into two bindings in MSL, so it's possible to declare an id for the texture and sampler binding separately.\n\n##### HLSL - SM 5.1+\n\nIn SM 5.1+, descriptor set bindings are interpreted as register spaces directly. In HLSL however, arrays of resources consume\nmultiple binding slots where Vulkan does not, so there might be overlap if the SPIR-V was not authored with this in mind.\nThis can be worked around either from shader authoring stage (don't assign overlapping bindings)\nor remap bindings in SPIRV-Cross as needed to avoid the overlap.\n\n#### Linking by name for targets which do not support explicit locations (legacy GLSL/ESSL)\n\nModern GLSL and HLSL sources (and SPIR-V) relies on explicit layout(location) qualifiers to guide the linking process between shader stages,\nbut older GLSL relies on symbol names to perform the linking. When emitting shaders with older versions, these layout statements will be removed,\nso it is important that the API user ensures that the names of I/O variables are sanitized so that linking will work properly.\nThe reflection API can rename variables, struct types and struct members to deal with these scenarios using `Compiler::set_name` and friends.\n\n#### Clip-space conventions\n\nSPIRV-Cross can perform some common clip space conversions on gl_Position/SV_Position by enabling `CompilerGLSL::Options.vertex.fixup_clipspace`.\nWhile this can be convenient, it is recommended to modify the projection matrices instead as that can achieve the same result.\n\nFor GLSL targets, enabling this will convert a shader which assumes `[0, w]` depth range (Vulkan / D3D / Metal) into `[-w, w]` range.\nFor MSL and HLSL targets, enabling this will convert a shader in `[-w, w]` depth range (OpenGL) to `[0, w]` depth range.\n\nBy default, the CLI will not enable `fixup_clipspace`, but in the API you might want to set an explicit value using `CompilerGLSL::set_options()`.\n\nY-flipping of gl_Position and similar is also supported.\nThe use of this is discouraged, because relying on vertex shader Y-flipping tends to get quite messy.\nTo enable this, set `CompilerGLSL::Options.vertex.flip_vert_y` or `--flip-vert-y` in CLI.\n\n#### Reserved identifiers\n\nWhen cross-compiling, certain identifiers are considered to be reserved by the implementation.\nCode generated by SPIRV-Cross cannot emit these identifiers as they are reserved and used for various internal purposes,\nand such variables will typically show up as `_RESERVED_IDENTIFIER_FIXUP_`\nor some similar name to make it more obvious that an identifier has been renamed.\n\nReflection output will follow the exact name specified in the SPIR-V module. It might not be a valid identifier in the C sense,\nas it may contain non-alphanumeric/non-underscore characters.\n\nReserved identifiers currently assumed by the implementation are (in pseudo-regex):\n\n- _$digit+, e.g. `_100`, `_2`\n- _$digit+_.+, e.g. `_100_tmp`, `_2_foobar`. `_2Bar` is **not** reserved.\n- gl_- prefix\n- spv- prefix\n- SPIRV_Cross prefix. This prefix is generally used for interface variables where app needs to provide data for workaround purposes.\n  This identifier will not be rewritten, but be aware of potential collisions.\n- Double underscores (reserved by all target languages).\n\nMembers of structs also have a reserved identifier:\n- _m$digit+$END, e.g. `_m20` and `_m40` are reserved, but not `_m40Foobar`.\n\n## Contributing\n\nContributions to SPIRV-Cross are welcome. See Testing and Licensing sections for details.\n\n### Testing\n\nSPIRV-Cross maintains a test suite of shaders with reference output of how the output looks after going through a roundtrip through\nglslangValidator/spirv-as then back through SPIRV-Cross again.\nThe reference files are stored inside the repository in order to be able to track regressions.\n\nAll pull requests should ensure that test output does not change unexpectedly. This can be tested with:\n\n```\n./checkout_glslang_spirv_tools.sh # Checks out glslang and SPIRV-Tools at a fixed revision which matches the reference output.\n./build_glslang_spirv_tools.sh    # Builds glslang and SPIRV-Tools.\n./test_shaders.sh                 # Runs over all changes and makes sure that there are no deltas compared to reference files.\n```\n\n`./test_shaders.sh` currently requires a Makefile setup with GCC/Clang to be set up.\nHowever, on Windows, this can be rather inconvenient if a MinGW environment is not set up.\nTo use a spirv-cross binary you built with CMake (or otherwise), you can pass in an environment variable as such:\n\n```\nSPIRV_CROSS_PATH=path/to/custom/spirv-cross ./test_shaders.sh\n```\n\nHowever, when improving SPIRV-Cross there are of course legitimate cases where reference output should change.\nIn these cases, run:\n\n```\n./update_test_shaders.sh          # SPIRV_CROSS_PATH also works here.\n```\n\nto update the reference files and include these changes as part of the pull request.\nAlways make sure you are running the correct version of glslangValidator as well as SPIRV-Tools when updating reference files.\nSee `checkout_glslang_spirv_tools.sh` which revisions are currently expected. The revisions change regularly.\n\nIn short, the main branch should always be able to run `./test_shaders.py shaders` and friends without failure.\nSPIRV-Cross uses Travis CI to test all pull requests, so it is not strictly needed to perform testing yourself if you have problems running it locally.\nA pull request which does not pass testing on Travis will not be accepted however.\n\nWhen adding support for new features to SPIRV-Cross, a new shader and reference file should be added which covers usage of the new shader features in question.\nTravis CI runs the test suite with the CMake, by running `ctest`. This is a more straight-forward alternative to `./test_shaders.sh`.\n\n### Licensing\n\nContributors of new files should add a copyright header at the top of every new source code file with their copyright\nalong with the Apache 2.0 licensing stub.\n\n### Formatting\n\nSPIRV-Cross uses `clang-format` to automatically format code.\nPlease use `clang-format` with the style sheet found in `.clang-format` to automatically format code before submitting a pull request.\n\nTo make things easy, the `format_all.sh` script can be used to format all\nsource files in the library. In this directory, run the following from the\ncommand line:\n\n\t./format_all.sh\n\n## Regression testing\n\nIn shaders/ a collection of shaders are maintained for purposes of regression testing.\nThe current reference output is contained in reference/.\n`./test_shaders.py shaders` can be run to perform regression testing.\n\nSee `./test_shaders.py --help` for more.\n\n### Metal backend\n\nTo test the roundtrip path GLSL -> SPIR-V -> MSL, `--msl` can be added, e.g. `./test_shaders.py --msl shaders-msl`.\n\n### HLSL backend\n\nTo test the roundtrip path GLSL -> SPIR-V -> HLSL, `--hlsl` can be added, e.g. `./test_shaders.py --hlsl shaders-hlsl`.\n\n### Updating regression tests\n\nWhen legitimate changes are found, use `--update` flag to update regression files.\nOtherwise, `./test_shaders.py` will fail with error code.\n\n### Mali Offline Compiler cycle counts\n\nTo obtain a CSV of static shader cycle counts before and after going through spirv-cross, add\n`--malisc` flag to `./test_shaders`. This requires the Mali Offline Compiler to be installed in PATH."
}
