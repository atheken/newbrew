{
  "name": "page",
  "full_name": "page",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Use Neovim as pager",
  "license": "MIT",
  "homepage": "https://github.com/I60R/page",
  "versions": {
    "stable": "4.6.3",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/I60R/page/archive/v4.6.3.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "51cf01933180499b27027fcdbda067f0cf80cebaa06d62400b655419f1806d46"
    },
    "head": {
      "url": "https://github.com/I60R/page.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/page/blobs/sha256:115a1bee4a08a2e829bd9474e5896cc5f9ac415a509b29b26675bb14206465dc",
          "sha256": "115a1bee4a08a2e829bd9474e5896cc5f9ac415a509b29b26675bb14206465dc"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/page/blobs/sha256:7dff421473d67b5b753c57deb9221fbdc863ba341e72b41b1a90ce71286ced4c",
          "sha256": "7dff421473d67b5b753c57deb9221fbdc863ba341e72b41b1a90ce71286ced4c"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/page/blobs/sha256:8e41089194d5a0afbe9b9e7f0876ff9a30261ddcc983c2b8cc708e917cd5a0f3",
          "sha256": "8e41089194d5a0afbe9b9e7f0876ff9a30261ddcc983c2b8cc708e917cd5a0f3"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/page/blobs/sha256:9711f49884c59be816fa97363993b08b6f1655b1a4ec8de8a89c6e95355976b9",
          "sha256": "9711f49884c59be816fa97363993b08b6f1655b1a4ec8de8a89c6e95355976b9"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/page/blobs/sha256:ad312adf9e277f5dede93292f1cfb5001c4ad3a26ac55f877e25690d3c386f15",
          "sha256": "ad312adf9e277f5dede93292f1cfb5001c4ad3a26ac55f877e25690d3c386f15"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/page/blobs/sha256:d9598c8b80efa0b238478f877b19be504a1b07d3b41c8932e227a6ea4505cda8",
          "sha256": "d9598c8b80efa0b238478f877b19be504a1b07d3b41c8932e227a6ea4505cda8"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/page/blobs/sha256:e9cac68f8653a7f517a1cbe7429e98743e94379bf96564c11e6b81c964cb279d",
          "sha256": "e9cac68f8653a7f517a1cbe7429e98743e94379bf96564c11e6b81c964cb279d"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "rust"
  ],
  "dependencies": [
    "neovim"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [
    "tcl-tk"
  ],
  "conflicts_with_reasons": [
    "both install `page` binaries"
  ],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/page.rb",
  "ruby_source_checksum": {
    "sha256": "89437b9e0b0c98eb6ae008f22430f8f6b9d0e9f0facd8d413cc131481e38de1e"
  },
  "date_added": "2022-07-28T08:27:01+00:00",
  "readme": "# Page\n\n[![Rust Build](https://github.com/I60R/page/actions/workflows/rust_build.yml/badge.svg)](https://github.com/I60R/page/actions/workflows/rust_build.yml)\n[![Lines Of Code](https://tokei.rs/b1/github/I60R/page)](https://github.com/I60R/page)\n\nAllows you to redirect text into [neovim](https://github.com/neovim/neovim).\nYou can set it as `$PAGER` to view logs, diffs, various command outputs.\n\nANSI escape sequences will be interpreted by :term buffer, which makes `page` noticeably faster than [vimpager](https://github.com/rkitover/vimpager) and [nvimpager](https://github.com/lucc/nvimpager).\nAnd text will be displayed instantly as it arrives - no need to wait until EOF.\n\nAlso, text from neovim :term buffer will be redirected directly into a new buffer in the same neovim instance - no nested neovim will be spawned.\nThat's by utilizing `$NVIM` variable like [neovim-remote](https://github.com/mhinz/neovim-remote) does.\n\n**Bonus**: another binary named `nv` is included, which reimplements `neovim-remote` but with interface similar to `page`. There's no intention to have all `nvim --remote` features â€” it should be only a simple file picker that prevents spawning nested neovim instance. Also, in contrast with `neovim-remote` there are some safeguards e.g. it won't open non-text files unless explicit flag is provided for that so `nv *` opens only text files in current directory. I recommend to read `--help` output and experiment with options a bit.\n\nUltimately, `page` and `nv` reuses all of neovim's text editing+navigating+searching facilities and will either facilitate all of plugins+mappings+options set in your neovim config.\n\n## Usage\n\n* *under regular terminal*\n\n![usage under regular terminal](https://imgur.com/lxDCPpn.gif)\n\n* *under neovim's terminal*\n\n![usage under neovim's terminal](https://i.imgur.com/rcLEM6X.gif)\n\n---\n\n## CLI\n\n<details><summary> expand <code>page --help</code></summary>\n\n```xml\nUsage: page [OPTIONS] [FILE]...\n\nArguments:\n  [FILE]...  Open provided file in separate buffer [without other flags revokes implied by default -o or -p\n             option]\n\nOptions:\n  -o                         Create and use output buffer (to redirect text from page's stdin) [implied by\n                             default unless -x and/or <FILE> provided without other flags]\n  -O [<NOOPEN_LINES>]        Prefetch <NOOPEN_LINES> from page's stdin: if all input fits then print it to\n                             stdout and exit without neovim usage (to emulate `less --quit-if-one-screen`)\n                             [empty: term height - 3 (space for prompt); negative: term height -\n                             <NOOPEN_LINES>; 0: disabled and default; ignored with -o, -p, -x and when page\n                             isn't piped]\n  -p                         Print path of pty device associated with output buffer (to redirect text from\n                             commands respecting output buffer size and preserving colors) [implied if page\n                             isn't piped unless -x and/or <FILE> provided without other flags]\n  -P                         Set $PWD as working directory at output buffer (to navigate paths with `gf`)\n  -q [<QUERY_LINES>]         Read no more than <QUERY_LINES> from page's stdin: next lines should be\n                             fetched by invoking :Page <QUERY> command or 'r'/'R' keypress on neovim side\n                             [empty: term height - 2 (space for tab and buffer lines); negative: term\n                             height - <QUERY_LINES>; 0: disabled and default; <QUERY> is optional and\n                             defaults to <QUERY_LINES>; doesn't take effect on <FILE> buffers]\n  -f                         Cursor follows content of output buffer as it appears instead of keeping top\n                             position (like `tail -f`)\n  -F                         Cursor follows content of output and <FILE> buffers as it appears instead of\n                             keeping top position\n  -t <FILETYPE>              Set filetype on output buffer (to enable syntax highlighting) [pager: default;\n                             not works with text echoed by -O]\n  -b                         Return back to current buffer\n  -B                         Return back to current buffer and enter into INSERT/TERMINAL mode\n  -n <NAME>                  Set title for output buffer (to display it in statusline) [env:\n                             PAGE_BUFFER_NAME=]\n  -w                         Do not remap i, I, a, A, u, d, x, q (and r, R with -q) keys [wouldn't unmap on\n                             connected instance output buffer]\n  -z [<PAGERIZE>]            Pagerize output when it exceeds <PAGERIZE> lines (to view `journalctl`)\n                             [default: disabled; empty: 100_000]\n                              ~ ~ ~\n\n                              ~ ~ ~\n  -a <ADDRESS>               TCP/IP socked address or path to named pipe listened by running host neovim\n                             process [env: NVIM=/run/user/1000/nvim.9389.0]\n  -A <ARGUMENTS>             Arguments that will be passed to child neovim process spawned when <ADDRESS>\n                             is missing [env: NVIM_PAGE_ARGS=]\n  -c <CONFIG>                Config that will be used by child neovim process spawned when <ADDRESS> is\n                             missing [file:$XDG_CONFIG_HOME/page/init.vim]\n  -C                         Enable PageConnect PageDisconnect autocommands\n  -e <COMMAND>               Run command  on output buffer after it was created\n      --e <LUA>              Run lua expr on output buffer after it was created\n  -E <COMMAND_POST>          Run command  on output buffer after it was created or connected as instance\n      --E <LUA_POST>         Run lua expr on output buffer after it was created or connected as instance\n                              ~ ~ ~\n  -i <INSTANCE>              Create output buffer with <INSTANCE> tag or use existed with replacing its\n                             content by text from page's stdin\n  -I <INSTANCE_APPEND>       Create output buffer with <INSTANCE_APPEND> tag or use existed with appending\n                             to its content text from page's stdin\n  -x <INSTANCE_CLOSE>        Close  output buffer with <INSTANCE_CLOSE> tag if it exists [without other\n                             flags revokes implied by defalt -o or -p option]\n                              ~ ~ ~\n  -W                         Flush redirection protection that prevents from producing junk and possible\n                             overwriting of existed files by invoking commands like `ls > $(NVIM= page -E\n                             q)` where the RHS of > operator evaluates not into /path/to/pty as expected\n                             but into a bunch of whitespace-separated strings/escape sequences from neovim\n                             UI; bad things happens when some shells interpret this as many valid targets\n                             for text redirection. The protection is only printing of a path to the existed\n                             dummy directory always first before printing of a neovim UI might occur; this\n                             makes the first target for text redirection from page's output invalid and\n                             disrupts the whole redirection early before other harmful writes might occur.\n                             [env:PAGE_REDIRECTION_PROTECT; (0 to disable)]\n                              ~ ~ ~\n  -l...                      Split left  with ratio: window_width  * 3 / (<l-PROVIDED> + 1)\n  -r...                      Split right with ratio: window_width  * 3 / (<r-PROVIDED> + 1)\n  -u...                      Split above with ratio: window_height * 3 / (<u-PROVIDED> + 1)\n  -d...                      Split below with ratio: window_height * 3 / (<d-PROVIDED> + 1)\n  -L <SPLIT_LEFT_COLS>       Split left  and resize to <SPLIT_LEFT_COLS>  columns\n  -R <SPLIT_RIGHT_COLS>      Split right and resize to <SPLIT_RIGHT_COLS> columns\n  -U <SPLIT_ABOVE_ROWS>      Split above and resize to <SPLIT_ABOVE_ROWS> rows\n  -D <SPLIT_BELOW_ROWS>      Split below and resize to <SPLIT_BELOW_ROWS> rows\n                              ^\n  -+                         With any of -r -l -u -d -R -L -U -D open floating window instead of split [to\n                             not overwrite data in the current terminal]\n                              ~ ~ ~\n  -h, --help                 Print help information\n```\n\n</details>\n\n<details><summary> expand <code>nv --help</code></summary>\n\n```xml\nUsage: nv [OPTIONS] [FILE]...\n\nArguments:\n  [FILE]...  Open provided files as editable [if none provided nv opens last modified file in currend\n             directory]\n\nOptions:\n  -o                          Open non-text files including directories, binaries, images etc\n  -O [<RECURSE_DEPTH>]        Ignoring [FILE] open all text files in the current directory and recursively\n                              open all text files in its subdirectories [0: disabled and default; empty:\n                              defaults to 1 and implied if no <RECURSE_DEPTH> provided; <RECURSE_DEPTH>:\n                              also opens in subdirectories at this level of depth]\n  -v                          Open in `page` instead (just postfix shortcut)\n                               ~ ~ ~\n  -f                          Open each [FILE] at last line\n  -p <PATTERN>                Open and search for a specified <PATTERN>\n  -P <PATTERN_BACKWARDS>      Open and search backwars for a specified <PATTERN_BACKWARDS>\n  -b                          Return back to current buffer\n  -B                          Return back to current buffer and enter into INSERT/TERMINAL mode\n  -k                          Keep `nv` process until buffer is closed (for editing git commit message)\n  -K                          Keep `nv` process until first write occur, then close buffer and neovim if\n                              it was spawned by `nv`\n                               ~ ~ ~\n  -a <ADDRESS>                TCP/IP socket address or path to named pipe listened by running host neovim\n                              process [env: NVIM=/run/user/1000/nvim.604327.0]\n  -A <ARGUMENTS>              Arguments that will be passed to child neovim process spawned when <ADDRESS>\n                              is missing [env: NVIM_PAGE_PICKER_ARGS=]\n  -c <CONFIG>                 Config that will be used by child neovim process spawned when <ADDRESS> is\n                              missing [file: $XDG_CONFIG_HOME/page/init.vim]\n  -t <FILETYPE>               Override filetype on each [FILE] buffer (to enable custom syntax highlighting\n                              [text: default]\n                               ~ ~ ~\n  -e <COMMAND>                Run command  on each [FILE] buffer after it was created\n      --e <LUA>               Run lua expr on each [FILE] buffer after it was created\n  -x <COMMAND_ONLY>           Just run command  with ignoring all other options\n      --x <LUA_ONLY>          Just run lua expr with ignoring all other options\n                               ~ ~ ~\n  -l...                       Split left  with ratio: window_width  * 3 / (<l-PROVIDED> + 1)\n  -r...                       Split right with ratio: window_width  * 3 / (<r-PROVIDED> + 1)\n  -u...                       Split above with ratio: window_height * 3 / (<u-PROVIDED> + 1)\n  -d...                       Split below with ratio: window_height * 3 / (<d-PROVIDED> + 1)\n  -L <SPLIT_LEFT_COLS>        Split left  and resize to <SPLIT_LEFT_COLS>  columns\n  -R <SPLIT_RIGHT_COLS>       Split right and resize to <SPLIT_RIGHT_COLS> columns\n  -U <SPLIT_ABOVE_ROWS>       Split above and resize to <SPLIT_ABOVE_ROWS> rows\n  -D <SPLIT_BELOW_ROWS>       Split below and resize to <SPLIT_BELOW_ROWS> rows\n                               ^\n  -+                          With any of -r -l -u -d -R -L -U -D open floating window instead of split\n                              [to not overwrite data in the current terminal]\n                               ~ ~ ~\n  -h, --help                  Print help information\n```\n\n</details>\n\n**Note**: `page` and `nv` may be unergonomic to type so I suggest users to create alias like `p` and `v`\n\n## `nvim/init.lua` customizations\n\n```lua\n-- Opacity of popup window spawned with -+ option\nvim.g.page_popup_winblend = 25\n```\n\n## `nvim/init.lua` customizations (pager only)\n\nStatusline appearance:\n\n```lua\n-- String that will append to buffer name\nvim.g.page_icon_pipe = '|' -- When piped\nvim.g.page_icon_redirect = '>' -- When exposes pty device\nvim.g.page_icon_instance = '$' -- When `-i, -I` flags provided\n```\n\nAutocommand hooks:\n\n```lua\n-- Will run once when output buffer is created\nvim.api.create_autocmd('User', {\n    pattern = 'PageOpen',\n    callback = lua_function,\n})\n\n-- Will run once when file buffer is created\nvim.api.create_autocmd('User', {\n    pattern = 'PageOpenFile',\n    callback = lua_function,\n})\n```\n\nOnly with `-C` option provided:\n\n```lua\n-- will run always when output buffer is created\n-- and also when `page` connects to instance `-i, -I` buffers:\nvim.api.create_autocmd('User', {\n    pattern = 'PageConnect',\n    callback = lua_function,\n})\n\n-- Will run when page process exits\nvim.api.create_autocmd('User', {\n    pattern = 'PageDisconnect',\n    callback = lua_function,\n})\n```\n\n## Shell hacks\n\nTo use as `$PAGER` without [scrollback overflow](https://github.com/I60R/page/issues/7):\n\n```zsh\nexport PAGER=\"page -q 90000\"\n\n# Alternatively\n\nexport PAGER=\"page -z 90000\" # will pagerize output\n\n# And you can combine both\n\nexport PAGER=\"page -q 90000 -z 90000\"\n```\n\nTo configure:\n\n```zsh\nexport PAGER=\"page -WfC -q 90000 -z 90000\" # some sensible flags\nalias page=\"$PAGER\"\n\n# Usage\nls | page -q 100 # you can specify the same flag multiple times:\n                 # last provided will override previous\n```\n\nTo use as `$MANPAGER`:\n\n```zsh\nexport MANPAGER=\"page -t man\"\n\n# Alternatively, to pick a bit better `man` highlighting:\n\nman () {\n    PROGRAM=\"${@[-1]}\"\n    SECTION=\"${@[-2]}\"\n    page -W \"man://$PROGRAM${SECTION:+($SECTION)}\"\n}\n```\n\nTo set `nv` as popup `git` commit message editor:\n\n```zsh\n# Will spawn popup editor and exit on first write\ngit config --global core.editor \"nv -K -+-R 80 -B\"\n```\n\nTo cd into directory passed to `nv`\n\n```zsh\nnv() {\n    #stdin_is_term #one_argument   #it's_dir\n    if [ -t 1 ] && [ 1 -eq $# ] && [ -d $1 ]; then\n        cd $1\n    else\n        nv $*\n    fi\n}\n\ncompdef _nv nv # if you have completions installed\n```\n\nTo automatically `lcd` into terminal's directory:\n\n```zsh\nchpwd () {\n    [ ! -z \"$NVIM\" ] && nv -x \"lcd $PWD\"\n}\n```\n\nTo circumvent neovim config picking:\n\n```zsh\npage -c NONE\n\n# Alternatively, to override neovim config create this file:\n\ntouch $XDG_CONFIG_HOME/page/init.lua # init.vim is also supported\n```\n\nTo set output buffer name as first two words from invoked command (zsh only):\n\n```zsh\npreexec () {\n    if [ -z \"$NVIM\" ]; then\n        export PAGE_BUFFER_NAME=\"page\"\n    else\n        WORDS=(${1// *|*})\n        export PAGE_BUFFER_NAME=\"${WORDS[@]:0:2}\"\n    fi\n}\n```\n\n## Buffer defaults (pager)\n\n\n<details><summary> expand </summary>\n\nThese commands are run on each `page` buffer creation:\n\n```lua\nvim.b.page_alternate_bufnr = {$initial_buf_nr}\nif vim.wo.scrolloff > 999 or vim.wo.scrolloff < 0 then\n    vim.g.page_scrolloff_backup = 0\nelse\n    vim.g.page_scrolloff_backup = vim.wo.scrolloff\nend\nvim.bo.scrollback, vim.wo.scrolloff, vim.wo.signcolumn, vim.wo.number =\n    100000, 999, 'no', false\n{$filetype}\n{$edit}\nvim.api.nvim_create_autocmd('BufEnter', {\n    buffer = 0,\n    callback = function() vim.wo.scrolloff = 999 end\n})\nvim.api.nvim_create_autocmd('BufLeave', {\n    buffer = 0,\n    callback = function() vim.wo.scrolloff = vim.g.page_scrolloff_backup end\n})\n{$notify_closed}\n{$pre}\nvim.cmd 'silent doautocmd User PageOpen | redraw'\n{$lua_provided_by_user}\n{$cmd_provided_by_user}\n{$after}\n```\n\nWhere:\n\n```lua\n--{$initial_buf_nr}\n-- Is always set on all buffers created by page\n\n'number of parent :term buffer or -1 when page isn't spawned from :term'\n```\n\n```lua\n--{$filetype}\n-- Is set only on output buffers.\n-- On files buffers filetypes are detected automatically.\n\nvim.bo.filetype='value of -t argument or \"pager\"'\n```\n\n```lua\n--{$edit}\n-- Is appended when no -w option provided\n\nvim.bo.modifiable = false\n_G.page_echo_notification = function(message)\n    vim.defer_fn(function()\n        local msg = \"-- [PAGE] \" .. message .. \" --\"\n        vim.api.nvim_echo({{ msg, 'Comment' }, }, false, {})\n        vim.cmd 'au CursorMoved <buffer> ++once echo'\n    end, 64)\nend\n_G.page_bound = function(top, message, move)\n    local row, col, search\n    if top then\n        row, col, search = 1, 1, { '\\\\S', 'c' }\n    else\n        row, col, search = 9999999999, 9999999999, { '\\\\S', 'bc' }\n    end\n    vim.api.nvim_call_function('cursor', { row, col })\n    vim.api.nvim_call_function('search', search)\n    if move ~= nil then move() end\n    _G.page_echo_notification(message)\nend\n_G.page_scroll = function(top, message)\n    vim.wo.scrolloff = 0\n    local move\n    if top then\n        local key = vim.api.nvim_replace_termcodes('z<CR>M', true, false, true)\n        move = function() vim.api.nvim_feedkeys(key, 'nx', true) end\n    else\n        move = function() vim.api.nvim_feedkeys('z-M', 'nx', false) end\n    end\n    _G.page_bound(top, message, move)\n    vim.wo.scrolloff = 999\nend\n_G.page_close = function()\n    local buf = vim.api.nvim_get_current_buf()\n    if buf ~= vim.b.page_alternate_bufnr and\n        vim.api.nvim_buf_is_loaded(vim.b.page_alternate_bufnr)\n    then\n        vim.api.nvim_set_current_buf(vim.b.page_alternate_bufnr)\n    end\n    vim.api.nvim_buf_delete(buf, { force = true })\n    local exit = true\n    for _, b in ipairs(vim.api.nvim_list_bufs()) do\n        local bt = vim.api.nvim_buf_get_option(b, 'buftype')\n        if bt == \"\" or bt == \"acwrite\" or bt == \"terminal\" or bt == \"prompt\" then\n            local bm = vim.api.nvim_buf_get_option(b, 'modified')\n            if bm then\n                exit = false\n                break\n            end\n            local bl = vim.api.nvim_buf_get_lines(b, 0, -1, false)\n            if #bl ~= 0 and bl[1] ~= \"\" and #bl > 1 then\n                exit = false\n                break\n            end\n        end\n    end\n    if exit then\n        vim.cmd \"qa!\"\n    end\nend\nlocal function page_map(key, expr)\n    vim.api.nvim_buf_set_keymap(0, '', key, expr, { nowait = true })\nend\npage_map('I', '<CMD>lua _G.page_scroll(true, \"in the beginning of scroll\")<CR>')\npage_map('A', '<CMD>lua _G.page_scroll(false, \"at the end of scroll\")<CR>')\npage_map('i', '<CMD>lua _G.page_bound(true, \"in the beginning\")<CR>')\npage_map('a', '<CMD>lua _G.page_bound(false, \"at the end\")<CR>')\npage_map('q', '<CMD>lua _G.page_close()<CR>')\npage_map('u', '<C-u>')\npage_map('d', '<C-d>')\npage_map('x', 'G')\n```\n\n```lua\n--{$notify_closed}\n-- Is set only on output buffers\n\nlocal closed = 'rpcnotify({channel}, \"page_buffer_closed\", \"{page_id}\")'\nvim.api.nvim_create_autocmd('BufDelete', {\n    buffer = 0,\n    command = 'silent! call ' .. closed\n})\n```\n\n```lua\n--{$pre}\n-- Is appended when -q provided\n\nvim.b.page_query_size = {$query_lines_count}\nlocal def_args = '{channel}, \"page_fetch_lines\", \"{page_id}\", '\nlocal def = 'command! -nargs=? Page call rpcnotify(' .. def_args .. '<args>)'\nvim.cmd(def)\nvim.api.create_autocmd('BufEnter', {\n    buffer = 0,\n    command = def,\n})\n\n-- Also if -q provided and no -w provided\n\npage_map('r', '<CMD>call rpcnotify(' .. def_args .. 'b:page_query_size * v:count1)<CR>')\npage_map('R', '<CMD>call rpcnotify(' .. def_args .. '99999)<CR>')\n\n-- If -P provided ({pwd} is $PWD value)\n\nvim.b.page_lcd_backup = getcwd()\nvim.cmd 'lcd {pwd}'\nvim.api.nvim_create_autocmd('BufEnter', {\n    buffer = 0,\n    command = 'lcd {pwd}'\n})\nvim.api.nvim_create_autocmd('BufLeave', {\n    buffer = 0,\n    command = 'exe \"lcd\" . b:page_lcd_backup'\n})\n```\n\n```lua\n--{$lua_provided_by_user}\n-- Is appended when --e provided\n\n'value of --e flag'\n```\n\n```lua\n--{$cmd_provided_by_user}\n-- Is appended when -e provided\n\nvim.cmd [====[{$command}]====]\n```\n\n```lua\n--{$after}\n-- Is appended only on file buffers\n\nvim.api.nvim_exec_autocmds('User', {\n    pattern = 'PageOpenFile',\n})\n```\n\n</details>\n\n## Limitations (pager)\n\n* Only ~100000 lines can be displayed (that's neovim terminal limit)\n* No reflow: text that doesnt't fit into window will be lost on resize  ([due to data structures inherited from vim](https://github.com/neovim/neovim/issues/2514#issuecomment-580035346))\n\n## Installation\n\n* From binaries\n  * Grab binary for your platform from [releases](https://github.com/I60R/page/releases) (currently Linux and OSX are supported)\n\n* Arch Linux:\n  * Package [page-git](https://aur.archlinux.org/packages/page-git/) is available on AUR\n  * Or: `git clone git@github.com:I60R/page.git && cd page && makepkg -ef && sudo pacman -U page-git*.pkg.tar.xz`\n\n* Homebrew:\n  * Package [page](https://formulae.brew.sh/formula/page) is available on [Homebrew](https://brew.sh/)\n\n* Manually:\n  * Install `rustup` from your distribution package manager\n  * Configure toolchain: `rustup install stable && rustup default stable`\n  * `git clone git@github.com:I60R/page.git && cd page && cargo install --path .`"
}
