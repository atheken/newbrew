{
  "name": "landscaper",
  "full_name": "landscaper",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Manage the application landscape in a Kubernetes cluster",
  "license": "Apache-2.0",
  "homepage": "https://github.com/Eneco/landscaper",
  "versions": {
    "stable": "1.0.24",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/Eneco/landscaper.git",
      "tag": "v1.0.24",
      "revision": "1199b098bcabc729c885007d868f38b2cf8d2370",
      "checksum": null
    },
    "head": {
      "url": "https://github.com/Eneco/landscaper.git",
      "branch": "master"
    }
  },
  "revision": 1,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/landscaper/blobs/sha256:835b3c32293b1725d2065652ecd2a0017ba2387351f586936230ff96030f79cb",
          "sha256": "835b3c32293b1725d2065652ecd2a0017ba2387351f586936230ff96030f79cb"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/landscaper/blobs/sha256:d6d705dc7d36d5fd8f0f6abd093bd86398c799929069fa47f117deb25f5bbe0f",
          "sha256": "d6d705dc7d36d5fd8f0f6abd093bd86398c799929069fa47f117deb25f5bbe0f"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/landscaper/blobs/sha256:13cf71ffacb84e95c4346beec92e389893755f998f6f421b930b9adb5ccfdc5d",
          "sha256": "13cf71ffacb84e95c4346beec92e389893755f998f6f421b930b9adb5ccfdc5d"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/landscaper/blobs/sha256:bad7cf082826c5d92dd8c09a79b682e1582fcfc3f4e471dde4112393ec7095ce",
          "sha256": "bad7cf082826c5d92dd8c09a79b682e1582fcfc3f4e471dde4112393ec7095ce"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/landscaper/blobs/sha256:74decffaf180e0e0dd9bfa2312877da01443a3418afe0f485c1b655c4af1da41",
          "sha256": "74decffaf180e0e0dd9bfa2312877da01443a3418afe0f485c1b655c4af1da41"
        },
        "mojave": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/landscaper/blobs/sha256:ff82cdb7be6329f9a4a5ce34bcbb04bc9356ab46fa3ecd30b830cf35df268529",
          "sha256": "ff82cdb7be6329f9a4a5ce34bcbb04bc9356ab46fa3ecd30b830cf35df268529"
        },
        "high_sierra": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/landscaper/blobs/sha256:68302c1748fe4eb063855df24420a8681a54b8ce484f2e030616bd4c4a812d52",
          "sha256": "68302c1748fe4eb063855df24420a8681a54b8ce484f2e030616bd4c4a812d52"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/landscaper/blobs/sha256:a51ba397aeab58e4b2c68b916dcb3612aca5d7d383b6e4715db785e098270f4e",
          "sha256": "a51ba397aeab58e4b2c68b916dcb3612aca5d7d383b6e4715db785e098270f4e"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "dep",
    "go"
  ],
  "dependencies": [
    "helm@2",
    "kubernetes-cli"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": true,
  "disable_date": "2022-07-31",
  "disable_reason": "repo_archived",
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/landscaper.rb",
  "ruby_source_checksum": {
    "sha256": "537dd701a18e3dc8576d2974050a99164491b71d3ef2404a04f4cd5bc7547921"
  },
  "date_added": "2017-09-26T07:52:55-04:00",
  "readme": "# Landscaper is no more\n\nThanks for your interest in Landscaper. It was conceived in a turbulent time where k8s was relatively new, and Helm was brand new. Multiple people had the same ideas and vision as we (our team at Eneco Energy Trade) had, which now even has a name: GitOps. This project was cool as long as it lasted, but it never gained much traction. Other projects similar to Landscaper emerged, and have become more popular. Better go there, since there is no active community supporting this project. The most popular alternative to Landscaper seems to be https://github.com/roboll/helmfile. \n\n# Landscaper\n\n[![Build Status](https://travis-ci.org/Eneco/landscaper.svg?branch=master)](https://travis-ci.org/Eneco/landscaper)\n[![Go Report Card](https://goreportcard.com/badge/github.com/eneco/landscaper)](https://goreportcard.com/report/github.com/eneco/landscaper)\n[![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg?style=flat-square)](https://godoc.org/github.com/Eneco/landscaper/pkg/landscaper)\n[![Say Thanks!](https://img.shields.io/badge/Say%20Thanks-!-1EAEDB.svg)](https://saythanks.io/to/eneco)\n\nLandscaper takes a set of Helm Chart references with values (a desired state), and realizes this in a Kubernetes cluster. The intended use case is to have this desired state under version control, and let Landscaper first test and then apply the state as part of the CI/CD stages.\n\nThe Landscaper project is an ongoing project in an early stage, opened due to demand in the community. Contributions and feedback are more than welcome!\n\n - [Introduction](#introduction)\n - [Usage](#usage)\n - [Example](#example)\n - [Example Use Case](#example-use-case)\n - [Contributing](#contributing)\n\n## Introduction\n\n### Why\n\n - The set of applications in the Kubernetes cluster is potentially large and complex;\n - Manually inspecting and administering them, and keeping different environments (e.g. production, acceptance) in sync is laborious and difficult;\n - Cooperating with multiple tenants in this shared cluster increases the complexity.\n\n### How\n\n - Have a blue print of what the landscape (apps in the cluster) looks like;\n - Keep track of changes: when, what, why and by who;\n - Allow others to review changes before applying them;\n - Let the changes be promoted to specific environments.\n\n### What\n\n - A Git repository contains a desired state description of the landscape, with CI/CD and a review before merge regime;\n - Landscaper, an app that eliminates difference between desired and actual state of Helm releases in a Kubernetes cluster.\n\n## Installation\n\nBinaries are available [here](https://github.com/Eneco/landscaper/releases/); Docker images [here](https://hub.docker.com/r/eneco/landscaper/).\nOn macOS using Homebrew, a `brew install landscaper` should do.\n\n### From source\n\nYou must have a working Go environment with [`dep`](https://github.com/golang/dep) and `GNU Make` installed.\n\nFrom a terminal:\n```shell\n  cd $GOPATH\n  mkdir -p src/github.com/eneco/\n  cd !$\n  git clone https://github.com/Eneco/landscaper.git\n  cd landscaper\n  make bootstrap build\n```\n\nOutputs the landscaper binary in `./build/landscaper`.\n\n## Usage\n\nLandscaper consists of a core API and a command line interface (CLI) that consumes this API. It takes as input a set of files that constitute the desired state. The CLI assumes that `kubectl` and `helm` have been setup!\n\nThese files contain (a) reference(s) to a Helm Chart and its configuration (Values).\nAdditionally, Landscaper receives settings (tokens, credentials) needed to query and modify a Kubernetes cluster via Helm/Tiller. Typically these settings are provided by the CI/CD system.\n\nThe CLI uses a command structure in the spirit of `git` et al. The main command is `landscaper apply` to apply a desired state.\nThe `apply` command accepts the following arguments:\n\n    Usage:\n      landscaper apply [files]... [flags]\n    \n    Flags:\n          --azure-keyvault string         azure keyvault for fetching secrets. Azure credentials must be provided in the environment.\n          --chart-dir string              (deprecated; use --helm-home) Helm home directory (default \"$HOME/.helm\")\n          --config-override-file string   global configuration overrides. component specific environment overrides take precedence over this.\n          --context string                the kube context to use. defaults to the current context\n          --dir string                    (deprecated) path to a folder that contains all the landscape desired state files; overrides LANDSCAPE_DIR\n          --disable stringSlice           Stages to be disabled. Available stages are create/update/delete.\n          --dry-run                       simulate the applying of the landscape. useful in merge requests\n          --helm-home string              Helm home directory (default \"$HOME/.helm\")\n          --env string                    environment specifier. selects value overrides by environment.\n          --loop                          keep landscape in sync forever\n          --loop-interval duration        when running in a loop the interval between invocations (default 5m0s)\n          --namespace string              namespace to apply the landscape to; overrides LANDSCAPE_NAMESPACE (default \"default\")\n          --no-prefix                     disable prefixing release names\n          --prefix string                 prefix release names with this string instead of <namespace>; overrides LANDSCAPE_PREFIX\n          --tiller-namespace string       Tiller namespace for Helm (default \"kube-system\")\n      -v, --verbose                       be verbose\n          --wait                          wait for all resources to be ready\n          --wait-timeout duration         interval to wait for all resources to be ready (default 5m0s)\n\nInstead of using arguments, environment variables can be used. When arguments are present, they override environment variables.\n`--namespace` is used to isolate landscapes through Kubernetes namespaces.\nUnless otherwise specified, Helm releases are prefixed with the same namespace string to avoid collisions, since Helm release names aren't namespaced.\nAs of version 1.0.3, components can specify their namespace. This will override any provided global namespace.\n\n\n\nLandscaper can also be run as a control loop that constantly watches the desired landscape and applies it to the cluster. With this you can deploy landscaper once in your cluster, pass it a reference to a landscape description and have Landscaper apply it whenever the landscape changes.\n\nConnection to Tiller is made by setting up a port-forward to it's pod. However, when `$HELM_HOST` is defined with a \"host:port\" in it, a direct connection is made to that host and port instead.\n\n### Azure Credentials\nWhen using the `--azure-keyvault` argument, Azure Service Principal credentials must be available in the environment:\n\n  - `AZURE_CLIENT_ID`\n  - `AZURE_CLIENT_SECRET`\n  - `AZURE_TENANT_ID`\n\nThe key vault DNS suffix defaults to the public cloud, `vault.azure.net`, but can be overridden with `AZURE_KEYVAULT_DNS_SUFFIX`.\n\n### Desired State Files\nInput desired state files are in YAML and contain the name that identifies the \"component\", a reference to a chart, configuration and optionally secrets.\n\n    name: my-component\n    release:\n    \tchart: \"example/chart:0.1.0\"\n    \tversion: 0.1.0\n    \n    # This will become the .Values override for the chart deployment.\n    configuration: \n      hostname: \"example\"\n      url: \"http://default.example.com\"\n      \n    # These configurations can be selected with the '--env' flag \n    # and will override the above values. \n    environments: \n      dev:\n        url: \"http://dev.example.com\"\n      prod:\n        url: \"http://prod.example.com\"\n    \n    # These secrets will be fetched, and instantiated as a Kubernetes \n    # secret whose name will be written to .Values.secretsRef\n    secrets:     \n    - my-secret\n    - my-other-secret\n\nInstalling the above component with `default` prefix and `--env dev` will result in chart value overrides\n  \n    hostname: \"example\"\n    url: \"http://dev.example.com\"\n    secretsRef: 'default-my-component'\n    \nand a Kubernetes secret named `default-my-component` with the contents:\n\n    \n#### Secrets\n\nSecrets can be provided as a list or as a map. If a list is provided then the same string is used for the key in the Kubernetes secret and to find the secret value.\n\n```\n...\nsecrets:\n\t- my-secret\n\t- my-other-secret\n```\n\nis realised as:\n\n```\n    my-secret: <value of MY_SECRET environment variable>\n    my-other-secret: <value MY_OTHER_SECRET environment variable>\n```\n\nIf a map is provided the key is the used as the Kubernetes secret key, and the value is used to fetch the secret value.\n\n```\n...\nsecrets:\n\tsecret1: my-secret\n\tsecret2: my-other-secret\n```\n\nis realised as:\n\n```\n    secret1: <value of MY_SECRET environment variable>\n    secret2: <value MY_OTHER_SECRET environment variable>\n```\n    \nBy default the secrets are read from the environment with the string converted to `UPPER_SNAKE_CASE` e.g. `export MY_SECRET=Rumpelstiltskin`\n    \n### Global configuration override file\n\nYou can specify a global configuration override file with the `--config-override-file` argument. This will override chart and component defaults, but not environment specific configuration.\n\n    # my-component.yaml\n    name: my-component\n    release:\n      chart: \"example/chart:0.1.0\"\n      version: 0.1.0\n    \n    # This will become the .Values override for the chart deployment.\n    configuration:\n      hostname: \"example\"\n      url: \"http://default.example.com\"\n    environments:\n      env1:\n        hostname: \"env1\"\n    \n \n    \n    # global.yaml\n    hostname: \"global\"\n    url: \"http://global.example.com\"\n\nInstalling the above component with `--config-override-file global.yaml` and `--env env1` will result in chart value overrides\n    \n    hostname: \"env1\"\n    url: \"http://global.example.com\"\n    \n### Secret Usage in Helm Charts\nSecrets are made available as Kubernetes Secrets (as shown above). The helm chart needs to be setup to [use the secret in a pod](https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets), where the secret name is made available by the landscaper as `.Values.secretsRef`. For example, as an environment variable:\n\n    env:\n    - name: MY_SECRET\n      valueFrom:\n        secretKeyRef:\n          name: {{ .Values.secretsRef }}\n          key: my-secret\n          \n Or mounted volume:\n \n    volumes:\n    - name: my-secret\n      secret:\n        secretName: {{ .Values.secretsRef }}\n        items:\n        - key: my-secret\n          path: secrets/my-secret\n          mode: 511\n          \n## Example\n\nAn example is provided [here](./example).\n\n## Example Use Case\n\nWe, at Eneco, have setup a git repository with the inputs to the landscaper. During CI, non-master branches are Landscaped `--dry-run` to validate the inputs. After a pull request is reviewed, the changes are merged into `master` after which the Landscaper applies the new desired state.\n\n### Example disable a stage\n\nLandscaper is build on philosphy of applying charts in three stages delete, update and create and in that order.\n\nHowever it allows to disable stages during apply. So users can cover their corner cases.\n\ne.g to disable delete stage\n\n```\nlandscaper apply [files] --disable delete\n```\n\nand to disable delete and update\n\n```\nlandscaper apply [files] --disable delete --disable update\n```\n\n## Compatibility\n\nLandscaper uses both Helm and Kubernetes. The following Landscaper releases are built against the following versions:\n\n| Landscaper | Helm  | Kubernetes |\n|------------|-------|------------|\n| 1.0.24     | 2.13.1| 1.12.5     |\n| 1.0.23     | 2.13.1| 1.12.5     |\n| 1.0.21     | 2.11.0| 1.11.1     |\n| 1.0.20     | 2.11.0| 1.11.1     |\n| 1.0.19     | 2.10.0| 1.10.3     |\n| 1.0.17     | 2.8.2 | 1.9        |\n| 1.0.16     | 2.7.2 | 1.8        |\n| 1.0.15     | 2.7.2 | 1.8        |\n| 1.0.14     | 2.7.2 | 1.8        |\n| 1.0.13     | 2.7.2 | 1.8        |\n| 1.0.12     | 2.7.2 | 1.8        |\n| 1.0.11     | 2.6.1 | 1.7        |\n| 1.0.10     | 2.5.1 | 1.6        |\n| 1.0.9      | 2.5.1 | 1.6        |\n| 1.0.8      | 2.4.2 | 1.6        |\n| 1.0.7      | 2.4.2 | 1.6        |\n| 1.0.6      | 2.4.2 | 1.6        |\n| 1.0.5      | 2.4.2 | 1.6        |\n| 1.0.4      | 2.3.1 | 1.5        |\n| 1.0.3      | 2.1.3 | 1.5        |\n| 1.0.2      | 2.1.3 | 1.5        |\n| 1.0.1      | 2.1.3 | 1.5        |\n| 1.0.0      | 2.1.3 | 1.5        |\n\n## Contributing\n\nWe'd love to accept your contributions! Please use GitHub pull requests: fork the repo, develop and test your code, [semantically commit](http://karma-runner.github.io/1.0/dev/git-commit-msg.html) (as of April 2017) and submit a pull request. Thanks!"
}
