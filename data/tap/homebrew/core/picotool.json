{
  "name": "picotool",
  "full_name": "picotool",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Tool for interacting with RP2040 devices in BOOTSEL mode or RP2040 binaries",
  "license": "BSD-3-Clause",
  "homepage": "https://github.com/raspberrypi/picotool",
  "versions": {
    "stable": "1.1.2",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/raspberrypi/picotool/archive/refs/tags/1.1.2.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "f1746ead7815c13be1152f0645db8ea3b277628eb0110d42a0a186db37d40a91"
    },
    "head": {
      "url": "https://github.com/raspberrypi/picotool.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/picotool/blobs/sha256:ade5c431f3d8bc38a8344f568560e66ed9db419456135562911a2fa4857a6a91",
          "sha256": "ade5c431f3d8bc38a8344f568560e66ed9db419456135562911a2fa4857a6a91"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/picotool/blobs/sha256:f5215b286c3c79327faa53ae0cbea79a0127417eca52c9ff7888293932ffc5c2",
          "sha256": "f5215b286c3c79327faa53ae0cbea79a0127417eca52c9ff7888293932ffc5c2"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/picotool/blobs/sha256:a58c6248be802d53a62ed94e174895d96e8d785c06eaee7c8d868cb323f6367c",
          "sha256": "a58c6248be802d53a62ed94e174895d96e8d785c06eaee7c8d868cb323f6367c"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/picotool/blobs/sha256:7c0768d43b4ada8fd89e1749bab90b19e94a1ca5e1ceca09059323fbbb2d64cf",
          "sha256": "7c0768d43b4ada8fd89e1749bab90b19e94a1ca5e1ceca09059323fbbb2d64cf"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/picotool/blobs/sha256:94434284d05dd6e0a5ac3b484274805a7f848740ebec0e292b6a9f8b02c98f08",
          "sha256": "94434284d05dd6e0a5ac3b484274805a7f848740ebec0e292b6a9f8b02c98f08"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/picotool/blobs/sha256:ea42adeb280960f973b906bacfdd065d70ff08611a0c9f6e08cd350105c8a8e6",
          "sha256": "ea42adeb280960f973b906bacfdd065d70ff08611a0c9f6e08cd350105c8a8e6"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/picotool/blobs/sha256:26eb789f62304297bfbc00afe1eb8616c0e04dd381a2b95ae7d72869e81108e4",
          "sha256": "26eb789f62304297bfbc00afe1eb8616c0e04dd381a2b95ae7d72869e81108e4"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake",
    "pkg-config"
  ],
  "dependencies": [
    "libusb"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/picotool.rb",
  "ruby_source_checksum": {
    "sha256": "a04b5b927ab32bb6b355f89355fab2f054eedd8350871663ad3c6db218172bb6"
  },
  "date_added": "2023-03-12T06:20:57+00:00",
  "readme": "## Building\n\nYou need to set PICO_SDK_PATH in the environment, or pass it to cmake.\n\nYou also need to install `libusb-1.0`.\n\n### Linux / macOS\n\nUse your favorite package tool to install dependencies. For example, on Ubuntu:\n\n```console\nsudo apt install build-essential pkg-config libusb-1.0-0-dev cmake\n```\n\nOn Linux you can add udev rules in order to run picotool without sudo:\n\n```console\nsudo cp udev/99-picotool.rules /etc/udev/rules.d/\n```\n\n### Windows\n\n##### For Windows without MinGW\n\nDownload libUSB from here https://libusb.info/\n\nset LIBUSB_ROOT environment variable to the install directory.\n```console\nmkdir build\ncd build\ncmake -G \"NMake Makefiles\" ..\nnmake\n```\n\n##### For Windows with MinGW in WSL\n\nDownload libUSB from here https://libusb.info/\n\nset LIBUSB_ROOT environment variable to the install directory.\n\n```console\nmkdir build\ncd build\ncmake ..\nmake\n```\n\n##### For Windows with MinGW in MSYS2:\n\nNo need to download libusb separately or set `LIBUSB_ROOT`.\n\n```console\npacman -S $MINGW_PACKAGE_PREFIX-{toolchain,cmake,libusb}\nmkdir build\ncd build\nMSYS2_ARG_CONV_EXCL=- cmake .. -G\"MSYS Makefiles\" -DCMAKE_INSTALL_PREFIX=$MINGW_PREFIX\nmake\nmake install DESTDIR=/  # optional\n```\n\n## Overview\n\n`picotool` is a tool for inspecting RP2040 binaries, and interacting with RP2040 devices when they are in BOOTSEL mode. (As of version 1.1 of `picotool` it is also possible to interact with RP2040 devices that are not in BOOTSEL mode, but are using USB stdio support from the Raspberry Pi Pico SDK by using the `-f` argument of `picotool`).\n\nNote for additional documentation see https://rptl.io/pico-get-started\n\n```text\n$ picotool help\nPICOTOOL:\n    Tool for interacting with a RP2040 device in BOOTSEL mode, or with a RP2040 binary\n\nSYNOPSIS:\n    picotool info [-b] [-p] [-d] [-l] [-a] [--bus <bus>] [--address <addr>] [-f] [-F]\n    picotool info [-b] [-p] [-d] [-l] [-a] <filename> [-t <type>]\n    picotool load [-n] [-N] [-u] [-v] [-x] <filename> [-t <type>] [-o <offset>] [--bus <bus>] [--address <addr>] [-f] [-F]\n    picotool save [-p] [--bus <bus>] [--address <addr>] [-f] [-F] <filename> [-t <type>]\n    picotool save -a [--bus <bus>] [--address <addr>] [-f] [-F] <filename> [-t <type>]\n    picotool save -r <from> <to> [--bus <bus>] [--address <addr>] [-f] [-F] <filename> [-t <type>]\n    picotool verify [--bus <bus>] [--address <addr>] [-f] [-F] <filename> [-t <type>] [-r <from> <to>] [-o <offset>]\n    picotool reboot [-a] [-u] [--bus <bus>] [--address <addr>] [-f] [-F]\n    picotool version [-s]\n    picotool help [<cmd>]\n\nCOMMANDS:\n    info      Display information from the target device(s) or file.\n              Without any arguments, this will display basic information for all connected RP2040 devices in BOOTSEL mode\n    load      Load the program / memory range stored in a file onto the device.\n    save      Save the program / memory stored in flash on the device to a file.\n    verify    Check that the device contents match those in the file.\n    reboot    Reboot the device\n    version   Display picotool version\n    help      Show general help or help for a specific command\n\nUse \"picotool help <cmd>\" for more info\n```\n\nNote commands that aren't acting on files require an RP2040 device in BOOTSEL mode to be connected.\n\n## info\n\nSo there is now _Binary Information_ support in the SDK which allows for easily storing compact information that `picotool`\ncan find (See Binary Info section below). The info command is for reading this information.\n\nThe information can be either read from one or more connected RP2040 devices in BOOTSEL mode, or from \na file. This file can be an ELF, a UF2 or a BIN file.\n\n```text\n$ picotool help info\nINFO:\n    Display information from the target device(s) or file.\n    Without any arguments, this will display basic information for all connected RP2040 devices in BOOTSEL mode\n\nSYNOPSIS:\n    picotool info [-b] [-p] [-d] [-l] [-a] [--bus <bus>] [--address <addr>] [-f] [-F]\n    picotool info [-b] [-p] [-d] [-l] [-a] <filename> [-t <type>]\n\nOPTIONS:\n    Information to display\n        -b, --basic\n            Include basic information. This is the default\n        -p, --pins\n            Include pin information\n        -d, --device\n            Include device information\n        -l, --build\n            Include build attributes\n        -a, --all\n            Include all information\n\nTARGET SELECTION:\n    To target one or more connected RP2040 device(s) in BOOTSEL mode (the default)\n        --bus <bus>\n            Filter devices by USB bus number\n        --address <addr>\n            Filter devices by USB device address\n        -f, --force\n            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing\n            the command (unless the command itself is a 'reboot') the device will be rebooted back to application mode\n        -F, --force-no-reboot\n            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing\n            the command (unless the command itself is a 'reboot') the device will be left connected and accessible to picotool, but\n            without the RPI-RP2 drive mounted\n    To target a file\n        <filename>\n            The file name\n        -t <type>\n            Specify file type (uf2 | elf | bin) explicitly, ignoring file extension\n```\n\nNote the -f arguments vary slightly for Windows vs macOS / Unix platforms.\n\ne.g.\n\n```text\n$ picotool info\nProgram Information\n name:      hello_world\n features:  stdout to UART\n```\n\n```text\n$ picotool info -a\nProgram Information\n name:          hello_world\n features:      stdout to UART\n binary start:  0x10000000\n binary end:    0x1000606c\n\nFixed Pin Information\n 20:  UART1 TX\n 21:  UART1 RX\n\nBuild Information\n build date:        Dec 31 2020\n build attributes:  Debug build\n\nDevice Information\n flash size:   2048K\n ROM version:  2\n```\n\n```text\n$ picotool info -bp\nProgram Information\n name:      hello_world\n features:  stdout to UART\n\nFixed Pin Information\n 20:  UART1 TX\n 21:  UART1 RX\n```\n\n```text\n$ picotool info -a lcd_1602_i2c.uf2\nFile lcd_1602_i2c.uf2:\n\nProgram Information\n name:          lcd_1602_i2c\n web site:      https://github.com/raspberrypi/pico-examples/tree/HEAD/i2c/lcd_1602_i2c\n binary start:  0x10000000\n binary end:    0x10003c1c\n\nFixed Pin Information\n 4:  I2C0 SDA\n 5:  I2C0 SCL\n\nBuild Information\n build date:  Dec 31 2020\n```\n\n## load\n\nLoad allows you to write data from a file into flash\n\n```text\n$ picotool help load\nLOAD:\n    Load the program / memory range stored in a file onto the device.\n\nSYNOPSIS:\n    picotool load [-n] [-N] [-u] [-v] [-x] <filename> [-t <type>] [-o <offset>] [--bus <bus>] [--address <addr>] [-f] [-F]\n\nOPTIONS:\n    Post load actions\n        -n, --no-overwrite\n            When writing flash data, do not overwrite an existing program in flash. If picotool cannot determine the size/presence\n            of the program in flash, the command fails\n        -N, --no-overwrite-unsafe\n            When writing flash data, do not overwrite an existing program in flash. If picotool cannot determine the size/presence\n            of the program in flash, the load continues anyway\n        -u, --update\n            Skip writing flash sectors that already contain identical data\n        -v, --verify\n            Verify the data was written correctly\n        -x, --execute\n            Attempt to execute the downloaded file as a program after the load\n    File to load from\n        <filename>\n            The file name\n        -t <type>\n            Specify file type (uf2 | elf | bin) explicitly, ignoring file extension\n    BIN file options\n        -o, --offset\n            Specify the load address for a BIN file\n        <offset>\n            Load offset (memory address; default 0x10000000)\n    Target device selection\n        --bus <bus>\n            Filter devices by USB bus number\n        --address <addr>\n            Filter devices by USB device address\n        -f, --force\n            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing\n            the command (unless the command itself is a 'reboot') the device will be rebooted back to application mode\n        -F, --force-no-reboot\n            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing\n            the command (unless the command itself is a 'reboot') the device will be left connected and accessible to picotool, but\n            without the RPI-RP2 drive mounted\n```\n\ne.g.\n\n```text\n$ picotool load blink.uf2\nLoading into Flash: [==============================]  100%\n```\n\n## save\n\nSave allows you to save a range of memory or a program or the whole of flash from the device to a BIN file or a UF2 file\n\n```text\n$ picotool help save\nSAVE:\n    Save the program / memory stored in flash on the device to a file.\n\nSYNOPSIS:\n    picotool save [-p] [--bus <bus>] [--address <addr>] [-f] [-F] <filename> [-t <type>]\n    picotool save -a [--bus <bus>] [--address <addr>] [-f] [-F] <filename> [-t <type>]\n    picotool save -r <from> <to> [--bus <bus>] [--address <addr>] [-f] [-F] <filename> [-t <type>]\n\nOPTIONS:\n    Selection of data to save\n        -p, --program\n            Save the installed program only. This is the default\n        -a, --all\n            Save all of flash memory\n        -r, --range\n            Save a range of memory. Note that UF2s always store complete 256 byte-aligned blocks of 256 bytes, and the range is\n            expanded accordingly\n        <from>\n            The lower address bound in hex\n        <to>\n            The upper address bound in hex\n    Source device selection\n        --bus <bus>\n            Filter devices by USB bus number\n        --address <addr>\n            Filter devices by USB device address\n        -f, --force\n            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing\n            the command (unless the command itself is a 'reboot') the device will be rebooted back to application mode\n        -F, --force-no-reboot\n            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing\n            the command (unless the command itself is a 'reboot') the device will be left connected and accessible to picotool, but\n            without the RPI-RP2 drive mounted\n    File to save to\n        <filename>\n            The file name\n        -t <type>\n            Specify file type (uf2 | elf | bin) explicitly, ignoring file extension\n```\n\ne.g.\n\n```text\n$ picotool info\nProgram Information\nname:      lcd_1602_i2c\nweb site:  https://github.com/raspberrypi/pico-examples/tree/HEAD/i2c/lcd_1602_i2c\n```\n```text\n$ picotool save spoon.uf2\nSaving file: [==============================]  100%\nWrote 51200 bytes to spoon.uf2\n```\n```text\n$ picotool info spoon.uf2\nFile spoon.uf2:\nProgram Information\nname:      lcd_1602_i2c\nweb site:  https://github.com/raspberrypi/pico-examples/tree/HEAD/i2c/lcd_1602_i2c\n```\n\n## Binary Information\n\nBinary information is machine locatable and generally machine consumable. I say generally because anyone can\ninclude any information, and we can tell it from ours, but it is up to them whether they make their data self describing.\n\nNote that we will certainly add more binary info over time, but I'd like to get a minimum core set included\nin most binaries from launch!!\n\n### Basic Information\n\nThis information is really handy when you pick up a Pico and don't know what is on it!\n\nBasic information includes\n\n- program name\n- program description\n- program version string\n- program build date\n- program url\n- program end address\n- program features - this is a list built from individual strings in the binary, that can be displayed (e.g. we will have one for UART stdio and one for USB stdio) in the SDK\n- build attributes - this is a similar list of strings, for things pertaining to the binary itself (e.g. Debug Build)\n\nThe binary information is self-describing/extensible, so programs can include information picotool is not aware of (e.g. MicroPython includes a list of in-built libraries)\n\n### Pins\n\nThis is certainly handy when you have an executable called 'hello_world.elf' but you forgot what board it is built for...\n\nStatic (fixed) pin assignments can be recorded in the binary in very compact form:\n\n```text\n$ picotool info --pins sprite_demo.elf\nFile sprite_demo.elf:\n\nFixed Pin Information\n0-4:    Red 0-4\n6-10:   Green 0-4\n11-15:  Blue 0-4\n16:     HSync\n17:     VSync\n18:     Display Enable\n19:     Pixel Clock\n20:     UART1 TX\n21:     UART1 RX\n```\n\n### Including Binary information\n\nBinary information is declared in the program by macros (vile warped macros); for the previous example:\n\n```text\n$ picotool info --pins sprite_demo.elf\nFile sprite_demo.elf:\n\nFixed Pin Information\n0-4:    Red 0-4\n6-10:   Green 0-4\n11-15:  Blue 0-4\n16:     HSync\n17:     VSync\n18:     Display Enable\n19:     Pixel Clock\n20:     UART1 TX\n21:     UART1 RX\n```\n\n... there is one line in the `setup_default_uart` function:\n\n```c\nbi_decl_if_func_used(bi_2pins_with_func(PICO_DEFAULT_UART_RX_PIN, PICO_DEFAULT_UART_TX_PIN, GPIO_FUNC_UART));\n```\n\n\nThe two pin numbers, and the function UART are stored, then decoded to their actual function names (UART1 TX etc) by picotool.\nThe `bi_decl_if_func_used` makes sure the binary information is only included if the containing function is called.\n\nEqually, the video code contains a few lines like this:\n\n```c\nbi_decl_if_func_used(bi_pin_mask_with_name(0x1f << (PICO_SCANVIDEO_COLOR_PIN_BASE + PICO_SCANVIDEO_DPI_PIXEL_RSHIFT), \"Red 0-4\"));\n```\n\n### Details\n\nThings are designed to waste as little space as possible, but you can turn everything off with preprocessor var `PICO_NO_BINARY_INFO=1`. Additionally\nany SDK code that inserts binary info can be separately excluded by its own preprocesor var.\n\nYou need\n```c\n#include \"pico/binary_info.h\"\n```\n\nBasically you either use `bi_decl(bi_blah(...))` for unconditional inclusion of the binary info blah, or\n`bi_decl_if_func_used(bi_blah(...))` for binary information that may be stripped if the enclosing function\nis not included in the binary by the linker (think `--gc-sections`)\n\nThere are a bunch of bi_ macros in the headers\n\n```c\n#define bi_binary_end(end) ...\n#define bi_program_name(name) ...\n#define bi_program_description(description) ...\n#define bi_program_version_string(version_string) ...\n#define bi_program_build_date_string(date_string) ...\n#define bi_program_url(url) ...\n#define bi_program_feature(feature) ...\n#define bi_program_build_attribute(attr) ...\n#define bi_1pin_with_func(p0, func) ...\n#define bi_2pins_with_func(p0, p1, func) ...\n#define bi_3pins_with_func(p0, p1, p2, func) ...\n#define bi_4pins_with_func(p0, p1, p2, p3, func) ...\n#define bi_5pins_with_func(p0, p1, p2, p3, p4, func) ...\n#define bi_pin_range_with_func(plo, phi, func) ...\n#define bi_pin_mask_with_name(pmask, label) ...\n#define bi_pin_mask_with_names(pmask, label) ...\n#define bi_1pin_with_name(p0, name) ...\n#define bi_2pins_with_names(p0, name0, p1, name1) ...\n#define bi_3pins_with_names(p0, name0, p1, name1, p2, name2) ...\n#define bi_4pins_with_names(p0, name0, p1, name1, p2, name2, p3, name3) ... \n```\n\nwhich make use of underlying macros, e.g.\n```c\n#define bi_program_url(url) bi_string(BINARY_INFO_TAG_RASPBERRY_PI, BINARY_INFO_ID_RP_PROGRAM_URL, url)\n```\n\nNOTE: It is easy to forget to enclose these in `bi_decl` etc., so an effort has been made (at the expense of a lot of kittens)\nto make the build fail with a _somewhat_ helpful error message if you do so.\n\nFor example, trying to compile\n\n```c\nbi_1pin_with_name(0, \"Toaster activator\");\n```\n\ngives\n\n```\n/home/graham/dev/mu/pico_sdk/src/common/pico_binary_info/include/pico/binary_info/code.h:17:55: error: '_error_bi_is_missing_enclosing_decl_261' undeclared here (not in a function)\n17 | #define __bi_enclosure_check_lineno_var_name __CONCAT(_error_bi_is_missing_enclosing_decl_,__LINE__)\n|                                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n... more macro call stack of doom\n```\n\n## Setting common fields from CMake\n\nYou can use \n\n```cmake\npico_set_program_name(foo \"not foo\") # as \"foo\" would be the default\npico_set_program_description(foo \"this is a foo\")\npico_set_program_version(foo \"0.00001a\")\npico_set_program_url(foo \"www.plinth.com/foo\")\n```\n\nNote all of these are passed as command line arguments to the compilation, so if you plan to use\nquotes, newlines etc you may have better luck defining via bi_decl in the code.\n\n## Additional binary information/picotool features\n\n### Block devices\n\nMicroPython and CircuitPython, eventually the SDK and others may support one or more storage devices in flash. We already\nhave macros to define these although picotool doesn't do anything with them yet... but backup/restore/file copy and even fuse mount\nin the future might be interesting.\n\nI suggest we tag these now... \n\nThis is what I have right now off the top of my head (at the time)\n```c\n#define bi_block_device(_tag, _name, _offset, _size, _extra, _flags)\n```\nwith the data going into\n```c\ntypedef struct __packed _binary_info_block_device {\n        struct _binary_info_core core;\n        bi_ptr_of(const char) name; // optional static name (independent of what is formatted)\n        uint32_t offset;\n        uint32_t size;\n        bi_ptr_of(binary_info_t) extra; // additional info\n        uint16_t flags;\n} binary_info_block_device_t;\n```\nand\n```c\nenum {\n    BINARY_INFO_BLOCK_DEV_FLAG_READ = 1 << 0, // if not readable, then it is basically hidden, but tools may choose to avoid overwriting it\n    BINARY_INFO_BLOCK_DEV_FLAG_WRITE = 1 << 1,\n    BINARY_INFO_BLOCK_DEV_FLAG_REFORMAT = 1 << 2, // may be reformatted..\n\n    BINARY_INFO_BLOCK_DEV_FLAG_PT_UNKNOWN = 0 << 4, // unknown free to look\n    BINARY_INFO_BLOCK_DEV_FLAG_PT_MBR = 1 << 4, // expect MBR\n    BINARY_INFO_BLOCK_DEV_FLAG_PT_GPT = 2 << 4, // expect GPT\n    BINARY_INFO_BLOCK_DEV_FLAG_PT_NONE = 3 << 4, // no partition table\n};\n```\n### USB device descriptors\n\nSeems like tagging these might be nice (we just need to store the pointer to it assuming - as is often the case -\nthe descriptor is just a linear chunk of memory) ... I assume there is a tool out there to prettify such a thing if picotool dumps the descriptor\nin binary.\n\n### Issues\n\nIf you ctrl+c out of the middle of a long operation, then libusb seems to get a bit confused, which means we aren't able\nto unlock our lockout of USB MSD writes (we have turned them off so the user doesn't step on their own toes). Simply running\n`picotool info` again will unlock it properly the next time (or you can reboot the device)."
}
