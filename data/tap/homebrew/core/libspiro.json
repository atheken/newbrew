{
  "name": "libspiro",
  "full_name": "libspiro",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Library to simplify the drawing of curves",
  "license": "GPL-3.0-or-later",
  "homepage": "https://github.com/fontforge/libspiro",
  "versions": {
    "stable": "20221101",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/fontforge/libspiro/releases/download/20221101/libspiro-dist-20221101.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "5984fb5af3e4e1f927f3a74850b705a711fb86284802a5e6170b09786440e8be"
    },
    "head": {
      "url": "https://github.com/fontforge/libspiro.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 1,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libspiro/blobs/sha256:51c8921af221ce78f184e95a55a79e81d38fc1fa84abe2dc46625a57788e6b0e",
          "sha256": "51c8921af221ce78f184e95a55a79e81d38fc1fa84abe2dc46625a57788e6b0e"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libspiro/blobs/sha256:1e90fd585fcaa84a166d7a77c2ae5aeb97fd8692c98dc5b2f6952d9d9033bf9a",
          "sha256": "1e90fd585fcaa84a166d7a77c2ae5aeb97fd8692c98dc5b2f6952d9d9033bf9a"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libspiro/blobs/sha256:d2d54755d2a1a15ab93350e6a74697357a7e7478f9a53e78d7c40b2c47fd9651",
          "sha256": "d2d54755d2a1a15ab93350e6a74697357a7e7478f9a53e78d7c40b2c47fd9651"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libspiro/blobs/sha256:5721b7e65026b5a86e387c4f648925b6e9166825b158226fbfb6a4ce2387c2f4",
          "sha256": "5721b7e65026b5a86e387c4f648925b6e9166825b158226fbfb6a4ce2387c2f4"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libspiro/blobs/sha256:946ef3d6e92c177e4456421353ed3090128d8eebca4630bcd8f1ee1cd4bb9b49",
          "sha256": "946ef3d6e92c177e4456421353ed3090128d8eebca4630bcd8f1ee1cd4bb9b49"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libspiro/blobs/sha256:f95068a1f9cb22591a2e37cb2b061199f8f624cbab15d743b1176438020fb119",
          "sha256": "f95068a1f9cb22591a2e37cb2b061199f8f624cbab15d743b1176438020fb119"
        },
        "catalina": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libspiro/blobs/sha256:a4487593a91bce4bdd4456bee4f3a31219d03ed1c6960e6d998d551e50e186df",
          "sha256": "a4487593a91bce4bdd4456bee4f3a31219d03ed1c6960e6d998d551e50e186df"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/libspiro/blobs/sha256:b4dfa30c267a3b79aa235c9569a0289ebce4cd3d8f0a570c4fc48fea840d9ff3",
          "sha256": "b4dfa30c267a3b79aa235c9569a0289ebce4cd3d8f0a570c4fc48fea840d9ff3"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/libspiro.rb",
  "ruby_source_checksum": {
    "sha256": "855c938974fb5175ac32f3a9e43cdeb9777408312fedc624715e8bc5b5900d4a"
  },
  "head_dependencies": {
    "build_dependencies": [
      "autoconf",
      "automake",
      "libtool"
    ],
    "dependencies": [],
    "test_dependencies": [],
    "recommended_dependencies": [],
    "optional_dependencies": [],
    "uses_from_macos": [],
    "uses_from_macos_bounds": []
  },
  "date_added": "2012-07-27T11:15:23-07:00",
  "readme": "# Spiro ![](spiral32.png) [![Coverity Scan Build Status](https://scan.coverity.com/projects/794/badge.svg?flat=1)](https://scan.coverity.com/projects/794)\n\n## Introduction\n\n![](spiro-a.png)\n\nSpiro is the creation of [Raph Levien (ppedit 20070504, GPL2+)](http://www.levien.com/). It simplifies the drawing of beautiful curves.\n\nLibSpiro is an adaptation of Spiro formula and functions into a sharable library [George Williams (libspiro 20071029, GPL2+)](http://libspiro.sourceforge.net/).\n\nUsing Bézier splines an artist can easily draw curves with the same slope on either side of an on-curve point. Spiros, on the other hand, are based on clothoid splines which make it easy to maintain constant curvature as well as constant slope. Such curves will simply look nicer.\n\nRaph Levien's spiro splines only use on-curve points and so are easier to use and more intuitive to the artist.\n\nThis library will take an array of spiro control points and convert them into a series of Bézier splines which can then be used in the myriad of ways the world has come to use Béziers.\n\n## Installation\n\nInstalling from Git master requires 2 preparatory steps:\n\nFirst, you need to create the ./configure script if you do not have it yet\n```sh\nautoreconf -i  (or use 'autoreconf --install --force' for more modern setups)\nautomake --foreign -Wall\n```\n\nSecond, you then use the usual steps to compile the library.\nVarious operating systems and setups will need ./configure options set.\nThe INSTALLATION file has detailed info for `configure' options.\nExample install steps for Linux, FreeBSD, Win32/64 are shown below:\n\nInstalling on Linux\n```sh\n./configure\nmake\nmake check\nsudo make install\n```\n\nInstalling on FreeBSD\n```sh\n./configure --prefix=$(pwd)/BUILD\nmake clean\nmake\nmake install\n```\n\nInstalling on Windows 32-bit\n```sh\n./configure --host=i686-w64-mingw32 --prefix=$(pwd)/build-w32\nmake clean\nmake\nmake install\n```\n\nInstalling on Windows 64-bit\n```sh\n./configure --host=x86_64-w64-mingw32 --prefix=$(pwd)/build-w64\nmake clean\nmake\nmake install\n```\n\nNOTE: Some Distros and Operating Systems may require you to run 'ldconfig'\nto recognize libspiro if you are not rebooting your computer first before\ninstalling another program that depends on libspiro. To do this, you may\nneed to run 'ldconfig' in 'su -' mode after you have done 'make install':\n```sh\n\t$ su -\n\t# ldconfig\n\t# exit\n\t$\n```\n\n## Usage\n\n### In FontForge\n\nFontForge will autodetect libspiro when it is installed in the usual way.\n\nAn exception to this is with the Mac bundled version (where `FontForge.app` is copied to `/Applications`). To install your compiled version into the bundle, run ```sh ./configure --prefix=/Applications/FontForge.app/Contents/Resources/opt/local/ ```\n\n#### Crash Reporting\n\nMac OS X: A helping script, `./fontforge.sh` is provided to run FontForge inside a debugger to get useful information on solving crashes. An example issue is at https://github.com/fontforge/libspiro/issues/4\n\n# Developing\n\n### Two methods of using libspiro in your programs\n\n- [C](#programming-with-libspiro-in-c)\n- [Java](#programming-with-libspiro-in-java)\n\n### Programming with libspiro in C\n\n- Basic Types\n  - [spiro control point](#the-spiro-control-point)\n  - [ncq control value](#the-ncq-control-value)\n  - [Bézier context](#the-bezier-context)\n- [Header file](#calling-into-libspiro)\n- Entry points\n  - int [SpiroCPsToBezier2](#spirocpstobezier2)(spiro_cp *,int n,int ncq,int is_closed,bezctx *)\n  - int [TaggedSpiroCPsToBezier2](#taggedspirocpstobezier2)(spiro_cp *,int ncq,bezctx *)\n\n#### Basic Types\n\n#### The spiro control point\n\n```c\ntypedef struct {\n    double x;\n    double y;\n    char ty;\n} spiro_cp;\n\n    /* Possible values of the \"ty\" field. */\n#define SPIRO_CORNER\t'v'\n#define SPIRO_G4\t'o'\n#define SPIRO_G2\t'c'\n#define SPIRO_LEFT\t'['\n#define SPIRO_RIGHT\t']'\n#define SPIRO_ANCHOR\t'a'\n#define SPIRO_HANDLE\t'h'\n\n    /* For a closed contour add an extra cp with a ty set to */\n#define SPIRO_END\t\t'z'\n    /* For an open contour the first cp must have a ty set to*/\n#define SPIRO_OPEN_CONTOUR\t'{'\n    /* For an open contour the last cp must have a ty set to */\n#define SPIRO_END_OPEN_CONTOUR\t'}'\n```\n\nA spiro control point contains a location and a point type. There are six basic types of spiro control points:\n\n- A corner point – where the slopes and curvatures of the incoming and outgoing splines are unconstrained\n- A G4 curve point – Continuous up to the fourth derivative\n- A G2 curve point – Continuous up to the second derivative.\n- A left constraint point – Used to connect a curve to a straight line\n- A right constraint point – Used to connect a straight line to a curve.\n  If you have a contour which is drawn clockwise, and you have a straight segment at the top, then the left point of that straight segment should be a left constraint, and the right point should be a right constraint.\n- An anchor - Is a knot point with a fixed angle (followed by the handle cp which creates the angle).\n  The anchor behaves as both left and right constraint points at one single point.\n\nThe left constraint, right constraint, anchor and handle points are easiest explained using\nexamples from path5 and path6 which are tested in tests/call-test5.c and tests/call-test6.c\n\n![](path5.png) ![](path6.png)\n```c\npath5[]\t\tpath6[]\n{  0,   0,'{'},\t{  0,   0,'{'},\n{100, 100,'c'},\t{100, 100,'c'},\n{200, 200,'['},\t{200, 200,'a'},\n{300, 200,']'},\t{300, 200,'h'},\n{400, 150,'c'},\t{300, 150,'c'},\n{300, 100,'['},\t{200, 100,'a'},\n{200, 100,']'},\t{150, 100,'h'},\n{150,  50,'c'},\t{150,  50,'c'},\n{100,   0,'['},\t{100,   0,'a'},\n{  0,-100,']'},\t{  0,-100,'h'},\n{-50,-200,'c'},\t{ 50,-100,'c'},\n{-80,-250,'}'},\t{ 20,-150,'}'},\n```\n\n\n## The ncq control value\n\nThere is a need to pass additional information to libspiro, and therefore the 'ncq' value was added.\n'ncq' can be thought of as toggle switches telling libspiro how to work with the source spiro control points.\nBelow is the current toggle switch definitions, and default 'ncq' value is zero.\n\n```c\n/* int ncq flags and values */\n#define SPIRO_INCLUDE_LAST_KNOT\t0x0100\n#define SPIRO_INTERNAL_BEZCTX\t0x0200\n#define SPIRO_RETRO_VER1\t0x0400\n#define SPIRO_REVERSE_SRC\t0x0800\n#define SPIRO_ARC_CUB_QUAD_CLR\t0x7FFF\n#define SPIRO_ARC_CUB_QUAD_MASK\t0x7000\n#define SPIRO_CUBIC_TO_BEZIER\t0x0000\n#define SPIRO_CUBIC_MIN_MAYBE\t0x1000\n#define SPIRO_ARC_MAYBE\t\t0x2000\n#define SPIRO_ARC_MIN_MAYBE\t0x3000\n#define SPIRO_QUAD0_TO_BEZIER\t0x4000\n```\n\nThe definitions for ncq (above) are:\n\nSPIRO_INCLUDE_LAST_KNOT:\nExisting libspiro behaviour is to add a knot point to match each spiro point, but does not include the last knot.\nThis option includes the last knot with the existing output results while the spiro is still open. Closed spiros should refer to the first knot point since the last and first knot are the same.\n\nSPIRO_INTERNAL_BEZCTX:\nThis provides a simpler interface for developers having trouble with the main libspiro interface.\nWith this method, two new functions are also provided and needed here.\n\n- 1st, the calling program creates an oversized array for the results using function \"new_ls_bezctx()\",\n- 2nd, the calling program calls libspiro to create a curve result using \"TaggedSpiroCPsToBezier2()\" or \"SpiroCPsToBezier2()\",\n- 3rd, the calling program can resize the array to use less memory, or release the array using if it is not needed any more using \"free_ls_bezctx()\".\n\nFile \"tests/call-test21.c\" has sample code showing how this can be done.\n\nSPIRO_RETRO_VER1:\nThis newer version of libspiro (2019 and later) has modified the way path calculations are made.\nThe reason for this was seen as an advantage, because it allows a user to scale and move spiro paths, which is a common expectation in graphics, and there are other added advantages, such as making the path as part of templates, and more.\nAn effort was made to keep results as close to original as possible, but this was not possible due to scaling factors in the calculations.\nAs the main user for libspiro is FontForge, users such as font designers may see the least change since scaling targets x={0..1000}, y={0..1000}, while other users in graphics may see changes since they can be using scales much larger than 1000.\nThe good news here is 'SPIRO_RETRO_VER1' allows the user to toggle libspiro to use the older calculation method if the user needs backwards compatibility, otherwise, leaving this off allows spiros to use the new calculation method which allows scaling and moving spiro paths.\nOlder programs that use the older libspiro interfaces will see no-change since they use the older calculation method to maintain backwards compatibility.\n\nSPIRO_REVERSE_SRC:\nThere may be a need to reverse the spiro path direction.\nThis option edits the source spiro path, and reverses the information, then proceeds to continue doing libspiro calculations with the reversed path.\nWhen libspiro is done calculating bézier output, you will also have a reversed (input) spiro path, therefore save the new spiro path if you need it.\nThis simplifies this process for the calling program to a simple option 'SPIRO_REVERSE_SRC', and the results are up to date as per this version of libspiro.\nNOTE - libspiro calculations are a one-way calculation, so you are not likely to see the same results in the reverse spiro path direction, but if you need this option, it is available here.\n\nSPIRO_CUBIC_TO_BEZIER:\nLibSpiro default action is to create cubic bézier curves.\n\nSPIRO_CUBIC_MIN_MAYBE:\nCubic arcs can potentially be made with greater bends and less points.\n\nSPIRO_ARC_MAYBE and SPIRO_ARC_MIN_MAYBE:\nInstead of the default cubic output, this exposes the midpoint, which might be useful to someone.\n\nSPIRO_QUAD0_TO_BEZIER:\nRough approximation of quadratic to bézier curves. Knot points will have smooth connection but midpoints may be visually okay or not.\n\n\n#### The bezier context\n\n```c\nstruct _bezctx {\n    /* Called by spiro to start a contour */\n    void (*moveto)(bezctx *bc, double x, double y, int is_open);\n\n    /* Called by spiro to move from the last point to the next one on a straight line */\n    void (*lineto)(bezctx *bc, double x, double y);\n\n    /* Called by spiro to move from the last point to the next along a quadratic bézier spline */\n    /* (x1,y1) is the quadratic bézier control point and (x2,y2) will be the new end point */\n    void (*quadto)(bezctx *bc, double x1, double y1, double x2, double y2);\n\n    /* Called by spiro to move from the last point to the next along a cubic bézier spline */\n    /* (x1,y1) and (x2,y2) are the two off-curve control point and (x3,y3) will be the new end point */\n    void (*curveto)(bezctx *bc, double x1, double y1, double x2, double y2,\n            double x3, double y3);\n\n    /* Called by spiro to notify calling function this is a knot point */\n    void (*mark_knot)(bezctx *bc, int knot_idx);\n};\n```\n\nYou must create a super-class of this abstract type that handles the creation of your particular representation of bézier splines. As an [example I provide the one used by Raph to generate PostScript output](bezctx.md) (cubic béziers). Spiro will convert a set of spiro_cps into a set of bézier curves. As it does so it will call the appropriate routine in your bézier context with this information – this should allow you to create your own internal representation of those curves.\n\n#### Calling into libspiro\n\nYour program needs this Libspiro header file:\n\n```c\n#include <spiroentrypoints.h>\n```\n\nYou must define a bézier context that is appropriate for your internal splines (See [Raph's PostScript example](bezctx.md)).\n\n#### SpiroCPsToBezier2\n\nYou must create an array of spiro control points:\n\n```c\n   spiro_cp points[4];\n\n     /* This defines something very like a circle, centered at the origin with radius 100 */\n\n   points[0].x = -100; points[0].y =    0; points[0].ty = SPIRO_G4;\n   points[1].x =    0; points[1].y =  100; points[1].ty = SPIRO_G4;\n   points[2].x =  100; points[2].y =    0; points[2].ty = SPIRO_G4;\n   points[3].x =    0; points[3].y = -100; points[3].ty = SPIRO_G4;\n```\n\n![](closedspiro.png)\n\nThen call `SpiroCPsToBezier2`, a routine which takes 5 arguments and returns bc and an integer pass/fail flag.\n\n1. An array of input spiros\n2. The number of elements in the spiros array (this example has 4)\n3. Additional ncq control variable (default==0)\n4. Whether this describes a closed (True=1) or open (False=0) contour\n5. A bézier results output context\n6. An integer success flag. 1 = completed task and have valid bézier results, or  0 = unable to complete task, bézier results are invalid.\n\n  ```c\n    bc = new_bezctx_ps();\n    success = SpiroCPsToBezier2(points,4,ncq,True,bc)\n    bezctx_ps_close(bc);\n  ```\n\n#### TaggedSpiroCPsToBezier2\n\nOr call `TaggedSpiroCPsToBezier2`. This routine requires that the array of spiro control points be tagged according to Raph's internal conventions. A closed curve will have an extra control point attached to the end of it with a type of `SPIRO_END`;\n\n```c\n   spiro_cp points[5];\n\n   points[0].x = -100; points[0].y =    0; points[0].ty = SPIRO_G4;\n   points[1].x =    0; points[1].y =  100; points[1].ty = SPIRO_G4;\n   points[2].x =  100; points[2].y =    0; points[2].ty = SPIRO_G4;\n   points[3].x =    0; points[3].y = -100; points[3].ty = SPIRO_G4;\n   points[4].x =    0; points[4].y =    0; points[4].ty = SPIRO_END;\n```\n\n(The x,y location of this last SPIRO_END point is irrelevant).\n\nAn open curve will have the type of the first control point set to `SPIRO_OPEN_CONTOUR` and the last to `SPIRO_END_OPEN_CONTOUR`.\n\n```c\n   spiro_cp points[4];\n\n   points[0].x = -100; points[0].y =    0; points[0].ty = SPIRO_OPEN_CONTOUR;\n   points[1].x =    0; points[1].y =  100; points[1].ty = SPIRO_G4;\n   points[2].x =  100; points[2].y =    0; points[2].ty = SPIRO_G4;\n   points[3].x =    0; points[3].y = -100; points[3].ty = SPIRO_END_OPEN_CONTOUR;\n```\n\n![](openspiro.png)\n\n(In an open contour the point types of the first and last control points are going to be ignored).\n\nIn this case there is no need to provide a point count nor an open/closed contour flag. That information can be obtained from the control points themselves. So `TaggedSpiroCPsToBezier2` only takes 3 arguments and returns bc and an integer pass/fail flag.\n\n1. An array of input spiros\n2. A bézier results output context\n3. Additional ncq control variable (default==0)\n4. An integer success flag. 1 = completed task and have valid bézier results, or  0 = unable to complete task, bézier results are invalid.\n\n   ```c\n    bc = new_bezctx_ps();\n    success = TaggedSpiroCPsToBezier2(points,ncq,bc)\n    bezctx_ps_close(bc);\n   ```\n\n### Programming with libspiro in Java\n\n**CAVEAT:** I'm not proficient in Java.\n\n### Classes\n\n- `SpiroPointType` – this is an enumerated type which defines the same pointtypes used by the C interface: `CORNER`, `G4`, `G2`, `LEFT`, `RIGHT`, `END`, `OPEN`, `OPEN_END`\n\n- `SpiroCP`\n  ```java\n  public class SpiroCP {\n    public double x,y;\n    SpiroPointType type;\n    public SpiroCP(double xx, double yy, SpiroPointType ty);\n    public String toString();\n  }\n  ```\n\n- `SpiroBezierContext` – a Java interface used in conversion of an array of SpiroCPs to a Bézier contour.\n\n  ```java\n  public interface SpiroBezierContext {\n    void MoveTo(double x, double y, boolean isOpen);\n    void LineTo(double x, double y);\n    void QuadTo(double x1, double y1, double x2, double y2);\n    void CubicTo(double x1, double y1, double x2, double y2, double x3, double y3);\n    void MarkKnot(int knotIdx);\n  }\n  ```\n\n- `Spiro` – a class with only static members:\n\n  ```java\n  public class Spiro {\n    // takes an array of SpiroCPs and converts to a Bézier\n    static public void\n      SpiroCPsToBezier(SpiroCP [] spiros,int n,boolean isclosed,\n          SpiroBezierContext bc);\n    // takes an array of SpiroCPs (the array contains its own terminator and indication of whether the contour is open or closed)\n    static public void\n      TaggedSpiroCPsToBezier(SpiroCP [] spiros,SpiroBezierContext bc);\n\n    // Two routines for reading and writing one of Raph's plate files\n    static public void\n      SavePlateFile(Writer output,SpiroCP [][] spirocontours)\n      throws IOException;\n    static public SpiroCP [][]\n      ReadPlateFile(BufferedReader input) throws IOException;\n  }\n  ```"
}
