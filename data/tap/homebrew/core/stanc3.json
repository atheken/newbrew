{
  "name": "stanc3",
  "full_name": "stanc3",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Stan transpiler",
  "license": "BSD-3-Clause",
  "homepage": "https://github.com/stan-dev/stanc3",
  "versions": {
    "stable": "2.32.2",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/stan-dev/stanc3.git",
      "tag": "v2.32.2",
      "revision": "bcbf83c52c76018ce4a6cd86233de1601ddf9422",
      "checksum": null
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/stanc3/blobs/sha256:8b40bb946526bd9fca5832f864526e76de1445cac36e20b5a9855a256b43c7d1",
          "sha256": "8b40bb946526bd9fca5832f864526e76de1445cac36e20b5a9855a256b43c7d1"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/stanc3/blobs/sha256:d873cf39e57996a690c5a9b98a553c9c43c1b8b756a00067019626c6d77af7fa",
          "sha256": "d873cf39e57996a690c5a9b98a553c9c43c1b8b756a00067019626c6d77af7fa"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/stanc3/blobs/sha256:46609f4cff24ecd2d3b49ff95c7f748179d4c809bdce8e62f5d2bf77335dbffd",
          "sha256": "46609f4cff24ecd2d3b49ff95c7f748179d4c809bdce8e62f5d2bf77335dbffd"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/stanc3/blobs/sha256:5e9f7124184ec9afe926f667d742838150befbfa803aba62918d02673e81d6b0",
          "sha256": "5e9f7124184ec9afe926f667d742838150befbfa803aba62918d02673e81d6b0"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/stanc3/blobs/sha256:2052622b2ab8035d8fa5f9ee2004dabf1e450a3193857f4cbba35b679aa7f0ad",
          "sha256": "2052622b2ab8035d8fa5f9ee2004dabf1e450a3193857f4cbba35b679aa7f0ad"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/stanc3/blobs/sha256:2499e463f55f18225b4d79c942d1ccc0e747f42003176e58688a6e6c80dea998",
          "sha256": "2499e463f55f18225b4d79c942d1ccc0e747f42003176e58688a6e6c80dea998"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/stanc3/blobs/sha256:5e684d8fd2b13d3d1f02fc304e8b6bf205288a8806fbdbbbfffc9ca10480465f",
          "sha256": "5e684d8fd2b13d3d1f02fc304e8b6bf205288a8806fbdbbbfffc9ca10480465f"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "ocaml",
    "opam"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [
    {
      "unzip": "build"
    }
  ],
  "uses_from_macos_bounds": [
    {}
  ],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/stanc3.rb",
  "ruby_source_checksum": {
    "sha256": "9b007024b24190c346317bbe76eba2fcee784e8dab9641b3eb4f425ccbf903c9"
  },
  "date_added": "2022-05-05T08:38:55+00:00",
  "readme": "# A New Stan-to-C++ Compiler, stanc3\nThis repo contains a new compiler for Stan, stanc3, written in OCaml.\nSince version 2.26, this has been the default compiler for Stan. See [this wiki](https://github.com/stan-dev/stanc3/wiki/changes-from-stanc2) for a list of minor differences between this compiler and the previous Stan compiler.\n\nTo read more about why we built this, see this [introductory blog post](https://statmodeling.stat.columbia.edu/2019/03/13/stanc3-rewriting-the-stan-compiler/). For some discussion as to how we chose OCaml, see [this accidental flamewar](https://discourse.mc-stan.org/t/choosing-the-new-stan-compilers-implementation-language/6203).\nWe're testing [these models](https://jenkins.flatironinstitute.org/job/Stan/job/Stanc3/job/master/) (listed under Test Results) on every pull request.\n\n[![Build Status](https://jenkins.flatironinstitute.org/job/Stan/job/Stanc3/job/master/badge/icon?style=flat-square)](https://jenkins.flatironinstitute.org/job/Stan/job/Stanc3/job/master/) [![codecov](https://codecov.io/gh/stan-dev/stanc3/branch/master/graph/badge.svg?token=tt76nVXoht)](https://codecov.io/gh/stan-dev/stanc3)\n\n## Documentation\n\nDocumentation for users of stanc3 is in the Stan Users' Guide [here](https://mc-stan.org/docs/stan-users-guide/using-the-stan-compiler.html)\n\nThe Stanc3 Developer documentation is available here: https://mc-stan.org/stanc3/stanc\n\nWant to contribute? See [Getting Started](https://mc-stan.org/stanc3/stanc/getting_started.html)\nfor setup instructions and some useful commands.\n\n## High-level concepts, invariants, and 30,000-ft view\nStanc3 has 4 main src packages: `frontend`, `middle`, `analysis_and_optimization` and `stan_math_backend`.\n\n```mermaid\nflowchart\n    Stanc --> Frontend & Analysis & Backend <-.-> Middle\n```\n\nThe goal is to keep as many details about the way Stan is implemented by the core C++ implementation in the Stan Math backend library as possible.\nThe Middle library contains the MIR and currently any types or functions used by the two ends.\nThe entrypoint for the compiler is in `src/stanc/stanc.ml` which sequences the various components together.\n\n### Distinct stanc Phases\n\nThe phases of stanc are summarized in the following information flowchart and list.\n```mermaid\nflowchart TB\n\n    subgraph frontend[Frontend]\n        direction TB\n        infile>Source file]\n        lexer(frontend/lexer.mll)\n        parser(frontend/parser.mly)\n        typecheck(frontend/Typechecker.ml)\n        lower(frontend/Ast_to_Mir.ml)\n\n        infile --> lexer -->|Tokens| parser\n        parser -->|Untyped AST| typecheck -->|Typed AST| lower\n    end\n\n\n    subgraph middle[Middle Representation]\n        data{{MIR Data Structures}}\n    end\n\n    subgraph analysis[Static Analysis and Optimization]\n        optimize(analysis_and_optimization/Optimize.ml)\n    end\n\n    subgraph backend[Backend]\n        codegen(*_backend/*_code_gen.ml)\n        transform(*_backend/Transform_Mir.ml)\n\n        transform -.->|MIR with backend specific code| optimize\n        transform --> codegen\n        optimize -->|Optimized MIR| codegen\n    end\n\n    outfile>Output File, e.g. a .hpp]\n\n    middle --- analysis\n    frontend ==> middle =====> backend ==> outfile\n\n\n    click lexer \"https://github.com/stan-dev/stanc3/blob/master/src/frontend/lexer.mll\"\n    click parser \"https://github.com/stan-dev/stanc3/blob/master/src/frontend/parser.mly\"\n    click typecheck \"https://github.com/stan-dev/stanc3/blob/master/src/frontend/Typechecker.ml\"\n    click lower \"https://github.com/stan-dev/stanc3/blob/master/src/frontend/Ast_to_Mir.ml\"\n    click optimize \"https://github.com/stan-dev/stanc3/blob/master/src/analysis_and_optimization/Optimize.ml\"\n    click data \"https://github.com/stan-dev/stanc3/tree/master/src/middle\"\n    click codegen \"https://github.com/stan-dev/stanc3/blob/master/src/stan_math_backend/Stan_math_code_gen.ml\"\n    click transform \"https://github.com/stan-dev/stanc3/blob/master/src/stan_math_backend/Transform_Mir.ml\"\n```\n\n1. [Lex](src/frontend/lexer.mll) the Stan language into tokens.\n1. [Parse](src/frontend/parser.mly) Stan language into AST that represents the syntax quite closely and aides in development of pretty-printers and linters. `stanc --debug-ast` to print this out.\n1. Typecheck & add type information [Typechecker.ml](src/frontend/Typechecker.ml).  `stanc --debug-decorated-ast`\n1. [Lower](src/frontend/Ast_to_Mir.ml) into [Middle Intermediate Representation](src/middle/Program.ml) (AST -> MIR) `stanc --debug-mir` (or `--debug-mir-pretty`)\n1. Backend-specific MIR transform  (MIR -> MIR) [Transform_Mir.ml](src/stan_math_backend/Transform_Mir.ml)  `stanc --debug-transformed-mir`\n1. Analyze & optimize (MIR -> MIR)\n1. Code generation  (MIR -> [C++](src/stan_math_backend/Stan_math_code_gen.ml)) (or other outputs, like [Tensorflow](https://github.com/stan-dev/stan2tfp/)).\n\n### The central data structures\n\n1. `src/frontend/Ast.ml` defines the AST. The AST is intended to have a direct 1-1 mapping with the syntax, so there are things like parentheses being kept around.\nThe pretty-printer in the frontend uses the AST and attempts to keep user syntax the same while just adjusting whitespace.\n\n    The AST uses a particular functional programming trick to add metadata to the AST (and its other tree types), sometimes called [the \"two-level types\" pattern](http://lambda-the-ultimate.org/node/4170#comment-63836). Essentially, many of the tree variant types are parameterized by something that ends up being a placeholder not for just metadata but for the recursive type including metadata, sometimes called the fixed point. So instead of recursively referencing `expression` you would instead reference type parameter `'e`, which will later be filled in with something like `type expr_with_meta = metadata expression`.\n\n    The AST intends to keep very close to Stan-level semantics and syntax in every way.\n\n2. `src/middle/Program.ml` contains the MIR (Middle Intermediate Language). `src/frontend/Ast_to_Mir.ml` performs the lowering and attempts to strip out as much Stan-specific semantics and syntax as possible, though this is still something of a work-in-progress.\n\n    The MIR uses the same two-level types idea to add metadata, notably expression types and autodiff levels as well as locations on many things. The MIR is used as the output data type from the frontend and the input for dataflow analysis, optimization (which also outputs MIR), and code generation.\n\n\n3. `src/stan_math_backend/Cpp.ml` defines a minimal representation of C++ used in code generation.\n\n    This is intentionally simpler than both the above structures and than a true C++ AST and is tailored pretty specifically\n    to the C++ generated in our model class.\n\n## Design goals\n* **Multiple phases** - each with human-readable intermediate representations for easy debugging and optimization design.\n* **Optimizing** - takes advantage of info known at the Stan language level. Minimize information we must teach users for them to write performant code.\n* **Holistic** - bring as much of the code as possible into the MIR for whole-program optimization.\n* **Research platform** - enable a new class of optimizations based on probability theory.\n* **Modular** - architect & build in a way that makes it easy to outsource things like symbolic differentiation to external libraries and to use parts of the compiler as the basis for other tools built around the Stan language.\n* **Simplicity first** - When making a choice between correct simplicity and a perceived performance benefit, we want to make the choice for simplicity unless we can show significant (> 5%) benchmark improvements to compile times or run times. Premature optimization is the root of all evil."
}
