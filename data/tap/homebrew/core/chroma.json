{
  "name": "chroma",
  "full_name": "chroma",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "General purpose syntax highlighter in pure Go",
  "license": "MIT",
  "homepage": "https://github.com/alecthomas/chroma",
  "versions": {
    "stable": "2.8.0",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/alecthomas/chroma/archive/refs/tags/v2.8.0.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "d6ddb56fd3cf0d7ae2c592f834aced1be4494f21338a79636743c25305a65a00"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/chroma/blobs/sha256:3e6fa480ad6a4930f4acf5d443a7fee16ef72ff4d412e5449dc90ef6082b4e70",
          "sha256": "3e6fa480ad6a4930f4acf5d443a7fee16ef72ff4d412e5449dc90ef6082b4e70"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/chroma/blobs/sha256:3e6fa480ad6a4930f4acf5d443a7fee16ef72ff4d412e5449dc90ef6082b4e70",
          "sha256": "3e6fa480ad6a4930f4acf5d443a7fee16ef72ff4d412e5449dc90ef6082b4e70"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/chroma/blobs/sha256:3e6fa480ad6a4930f4acf5d443a7fee16ef72ff4d412e5449dc90ef6082b4e70",
          "sha256": "3e6fa480ad6a4930f4acf5d443a7fee16ef72ff4d412e5449dc90ef6082b4e70"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/chroma/blobs/sha256:bd928d2aa4240cc90c3b433fc5eafe192fd7bad97a97d44e7ca3cfb629aefc89",
          "sha256": "bd928d2aa4240cc90c3b433fc5eafe192fd7bad97a97d44e7ca3cfb629aefc89"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/chroma/blobs/sha256:bd928d2aa4240cc90c3b433fc5eafe192fd7bad97a97d44e7ca3cfb629aefc89",
          "sha256": "bd928d2aa4240cc90c3b433fc5eafe192fd7bad97a97d44e7ca3cfb629aefc89"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/chroma/blobs/sha256:bd928d2aa4240cc90c3b433fc5eafe192fd7bad97a97d44e7ca3cfb629aefc89",
          "sha256": "bd928d2aa4240cc90c3b433fc5eafe192fd7bad97a97d44e7ca3cfb629aefc89"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/chroma/blobs/sha256:eaf1571e561296e570c853c2fcdba368b57160eb20b3cdace5bd51a3ae653dd5",
          "sha256": "eaf1571e561296e570c853c2fcdba368b57160eb20b3cdace5bd51a3ae653dd5"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "go"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/chroma.rb",
  "ruby_source_checksum": {
    "sha256": "91b41deec51c28801c8296de359706203d5960c9c339868f6f82d6575ca45802"
  },
  "date_added": "2021-12-18T03:47:19+00:00",
  "readme": "# Chroma â€” A general purpose syntax highlighter in pure Go\n[![Golang Documentation](https://godoc.org/github.com/alecthomas/chroma?status.svg)](https://godoc.org/github.com/alecthomas/chroma) [![CI](https://github.com/alecthomas/chroma/actions/workflows/ci.yml/badge.svg)](https://github.com/alecthomas/chroma/actions/workflows/ci.yml) [![Slack chat](https://img.shields.io/static/v1?logo=slack&style=flat&label=slack&color=green&message=gophers)](https://invite.slack.golangbridge.org/)\n\n> **NOTE:** As Chroma has just been released, its API is still in flux. That said, the high-level interface should not change significantly.\n\nChroma takes source code and other structured text and converts it into syntax\nhighlighted HTML, ANSI-coloured text, etc.\n\nChroma is based heavily on [Pygments](http://pygments.org/), and includes\ntranslators for Pygments lexers and styles.\n\n<a id=\"markdown-table-of-contents\" name=\"table-of-contents\"></a>\n## Table of Contents\n\n<!-- TOC -->\n\n1. [Table of Contents](#table-of-contents)\n2. [Supported languages](#supported-languages)\n3. [Try it](#try-it)\n4. [Using the library](#using-the-library)\n    1. [Quick start](#quick-start)\n    2. [Identifying the language](#identifying-the-language)\n    3. [Formatting the output](#formatting-the-output)\n    4. [The HTML formatter](#the-html-formatter)\n5. [More detail](#more-detail)\n    1. [Lexers](#lexers)\n    2. [Formatters](#formatters)\n    3. [Styles](#styles)\n6. [Command-line interface](#command-line-interface)\n7. [Testing lexers](#testing-lexers)\n8. [What's missing compared to Pygments?](#whats-missing-compared-to-pygments)\n\n<!-- /TOC -->\n\n<a id=\"markdown-supported-languages\" name=\"supported-languages\"></a>\n## Supported languages\n\nPrefix | Language\n:----: | --------\nA | ABAP, ABNF, ActionScript, ActionScript 3, Ada, Angular2, ANTLR, ApacheConf, APL, AppleScript, ArangoDB AQL, Arduino, Awk\nB | Ballerina, Bash, Batchfile, BibTeX, Bicep, BlitzBasic, BNF, Brainfuck, BQN\nC | C, C#, C++, Caddyfile, Caddyfile Directives, Cap'n Proto, Cassandra CQL, Ceylon, CFEngine3, cfstatement, ChaiScript, Chapel, Cheetah, Clojure, CMake, COBOL, CoffeeScript, Common Lisp, Coq, Crystal, CSS, Cython\nD | D, Dart, Diff, Django/Jinja, Docker, DTD, Dylan\nE | EBNF, Elixir, Elm, EmacsLisp, Erlang\nF | Factor, Fish, Forth, Fortran, FSharp\nG | GAS, GDScript, Genshi, Genshi HTML, Genshi Text, Gherkin, GLSL, Gnuplot, Go, Go HTML Template, Go Text Template, GraphQL, Groff, Groovy\nH | Handlebars, Haskell, Haxe, HCL, Hexdump, HLB, HLSL, HTML, HTTP, Hy\nI | Idris, Igor, INI, Io\nJ | J, Java, JavaScript, JSON, Julia, Jungle\nK | Kotlin\nL | Lighttpd configuration file, LLVM, Lua\nM | Makefile, Mako, markdown, Mason, Mathematica, Matlab, MiniZinc, MLIR, Modula-2, MonkeyC, MorrowindScript, Myghty, MySQL\nN | NASM, Newspeak, Nginx configuration file, Nim, Nix\nO | Objective-C, OCaml, Octave, OnesEnterprise, OpenEdge ABL, OpenSCAD, Org Mode\nP | PacmanConf, Perl, PHP, PHTML, Pig, PkgConfig, PL/pgSQL, plaintext, Pony, PostgreSQL SQL dialect, PostScript, POVRay, PowerShell, Prolog, PromQL, Properties, Protocol Buffer, PSL, Puppet, Python 2, Python\nQ | QBasic\nR | R, Racket, Ragel, Raku, react, ReasonML, reg, reStructuredText, Rexx, Ruby, Rust\nS | SAS, Sass, Scala, Scheme, Scilab, SCSS, Sed, Smali, Smalltalk, Smarty, Snobol, Solidity, SPARQL, SQL, SquidConf, Standard ML, stas, Stylus, Svelte, Swift, SYSTEMD, systemverilog\nT | TableGen, TASM, Tcl, Tcsh, Termcap, Terminfo, Terraform, TeX, Thrift, TOML, TradingView, Transact-SQL, Turing, Turtle, Twig, TypeScript, TypoScript, TypoScriptCssData, TypoScriptHtmlData\nV | VB.net, verilog, VHDL, VHS, VimL, vue\nW | WDTE\nX | XML, Xorg\nY | YAML, YANG\nZ | Zig\n\n\n_I will attempt to keep this section up to date, but an authoritative list can be\ndisplayed with `chroma --list`._\n\n<a id=\"markdown-try-it\" name=\"try-it\"></a>\n## Try it\n\nTry out various languages and styles on the [Chroma Playground](https://swapoff.org/chroma/playground/).\n\n<a id=\"markdown-using-the-library\" name=\"using-the-library\"></a>\n## Using the library\n\nChroma, like Pygments, has the concepts of\n[lexers](https://github.com/alecthomas/chroma/tree/master/lexers),\n[formatters](https://github.com/alecthomas/chroma/tree/master/formatters) and\n[styles](https://github.com/alecthomas/chroma/tree/master/styles).\n\nLexers convert source text into a stream of tokens, styles specify how token\ntypes are mapped to colours, and formatters convert tokens and styles into\nformatted output.\n\nA package exists for each of these, containing a global `Registry` variable\nwith all of the registered implementations. There are also helper functions\nfor using the registry in each package, such as looking up lexers by name or\nmatching filenames, etc.\n\nIn all cases, if a lexer, formatter or style can not be determined, `nil` will\nbe returned. In this situation you may want to default to the `Fallback`\nvalue in each respective package, which provides sane defaults.\n\n<a id=\"markdown-quick-start\" name=\"quick-start\"></a>\n### Quick start\n\nA convenience function exists that can be used to simply format some source\ntext, without any effort:\n\n```go\nerr := quick.Highlight(os.Stdout, someSourceCode, \"go\", \"html\", \"monokai\")\n```\n\n<a id=\"markdown-identifying-the-language\" name=\"identifying-the-language\"></a>\n### Identifying the language\n\nTo highlight code, you'll first have to identify what language the code is\nwritten in. There are three primary ways to do that:\n\n1. Detect the language from its filename.\n\n    ```go\n    lexer := lexers.Match(\"foo.go\")\n    ```\n\n3. Explicitly specify the language by its Chroma syntax ID (a full list is available from `lexers.Names()`).\n\n    ```go\n    lexer := lexers.Get(\"go\")\n    ```\n\n3. Detect the language from its content.\n\n    ```go\n    lexer := lexers.Analyse(\"package main\\n\\nfunc main()\\n{\\n}\\n\")\n    ```\n\nIn all cases, `nil` will be returned if the language can not be identified.\n\n```go\nif lexer == nil {\n  lexer = lexers.Fallback\n}\n```\n\nAt this point, it should be noted that some lexers can be extremely chatty. To\nmitigate this, you can use the coalescing lexer to coalesce runs of identical\ntoken types into a single token:\n\n```go\nlexer = chroma.Coalesce(lexer)\n```\n\n<a id=\"markdown-formatting-the-output\" name=\"formatting-the-output\"></a>\n### Formatting the output\n\nOnce a language is identified you will need to pick a formatter and a style (theme).\n\n```go\nstyle := styles.Get(\"swapoff\")\nif style == nil {\n  style = styles.Fallback\n}\nformatter := formatters.Get(\"html\")\nif formatter == nil {\n  formatter = formatters.Fallback\n}\n```\n\nThen obtain an iterator over the tokens:\n\n```go\ncontents, err := ioutil.ReadAll(r)\niterator, err := lexer.Tokenise(nil, string(contents))\n```\n\nAnd finally, format the tokens from the iterator:\n\n```go\nerr := formatter.Format(w, style, iterator)\n```\n\n<a id=\"markdown-the-html-formatter\" name=\"the-html-formatter\"></a>\n### The HTML formatter\n\nBy default the `html` registered formatter generates standalone HTML with\nembedded CSS. More flexibility is available through the `formatters/html` package.\n\nFirstly, the output generated by the formatter can be customised with the\nfollowing constructor options:\n\n- `Standalone()` - generate standalone HTML with embedded CSS.\n- `WithClasses()` - use classes rather than inlined style attributes.\n- `ClassPrefix(prefix)` - prefix each generated CSS class.\n- `TabWidth(width)` - Set the rendered tab width, in characters.\n- `WithLineNumbers()` - Render line numbers (style with `LineNumbers`).\n- `WithLinkableLineNumbers()` - Make the line numbers linkable and be a link to themselves.\n- `HighlightLines(ranges)` - Highlight lines in these ranges (style with `LineHighlight`).\n- `LineNumbersInTable()` - Use a table for formatting line numbers and code, rather than spans.\n\nIf `WithClasses()` is used, the corresponding CSS can be obtained from the formatter with:\n\n```go\nformatter := html.New(html.WithClasses(true))\nerr := formatter.WriteCSS(w, style)\n```\n\n<a id=\"markdown-more-detail\" name=\"more-detail\"></a>\n## More detail\n\n<a id=\"markdown-lexers\" name=\"lexers\"></a>\n### Lexers\n\nSee the [Pygments documentation](http://pygments.org/docs/lexerdevelopment/)\nfor details on implementing lexers. Most concepts apply directly to Chroma,\nbut see existing lexer implementations for real examples.\n\nIn many cases lexers can be automatically converted directly from Pygments by\nusing the included Python 3 script `pygments2chroma_xml.py`. I use something like\nthe following:\n\n```sh\npython3 _tools/pygments2chroma_xml.py \\\n  pygments.lexers.jvm.KotlinLexer \\\n  > lexers/embedded/kotlin.xml\n```\n\nSee notes in [pygments-lexers.txt](https://github.com/alecthomas/chroma/blob/master/pygments-lexers.txt)\nfor a list of lexers, and notes on some of the issues importing them.\n\n<a id=\"markdown-formatters\" name=\"formatters\"></a>\n### Formatters\n\nChroma supports HTML output, as well as terminal output in 8 colour, 256 colour, and true-colour.\n\nA `noop` formatter is included that outputs the token text only, and a `tokens`\nformatter outputs raw tokens. The latter is useful for debugging lexers.\n\n<a id=\"markdown-styles\" name=\"styles\"></a>\n### Styles\n\nChroma styles are defined in XML. The style entries use the\n[same syntax](http://pygments.org/docs/styles/) as Pygments.\n\nAll Pygments styles have been converted to Chroma using the `_tools/style.py`\nscript.\n\nWhen you work with one of [Chroma's styles](https://github.com/alecthomas/chroma/tree/master/styles), \nknow that the `Background` token type provides the default style for tokens. It does so\nby defining a foreground color and background color.\n\nFor example, this gives each token name not defined in the style a default color\nof `#f8f8f8` and uses `#000000` for the highlighted code block's background:\n\n```xml\n<entry type=\"Background\" style=\"#f8f8f2 bg:#000000\"/>\n```\n\nAlso, token types in a style file are hierarchical. For instance, when `CommentSpecial` is not defined, Chroma uses the token style from `Comment`. So when several comment tokens use the same color, you'll only need to define `Comment` and override the one that has a different color.\n\nFor a quick overview of the available styles and how they look, check out the [Chroma Style Gallery](https://xyproto.github.io/splash/docs/).\n\n<a id=\"markdown-command-line-interface\" name=\"command-line-interface\"></a>\n## Command-line interface\n\nA command-line interface to Chroma is included.\n\nBinaries are available to install from [the releases page](https://github.com/alecthomas/chroma/releases).\n\nThe CLI can be used as a preprocessor to colorise output of `less(1)`,\nsee documentation for the `LESSOPEN` environment variable.\n\nThe `--fail` flag can be used to suppress output and return with exit status\n1 to facilitate falling back to some other preprocessor in case chroma\ndoes not resolve a specific lexer to use for the given file. For example:\n\n```shell\nexport LESSOPEN='| p() { chroma --fail \"$1\" || cat \"$1\"; }; p \"%s\"'\n```\n\nReplace `cat` with your favourite fallback preprocessor.\n\nWhen invoked as `.lessfilter`, the `--fail` flag is automatically turned\non under the hood for easy integration with [lesspipe shipping with\nDebian and derivatives](https://manpages.debian.org/lesspipe#USER_DEFINED_FILTERS);\nfor that setup the `chroma` executable can be just symlinked to `~/.lessfilter`.\n\n<a id=\"markdown-whats-missing-compared-to-pygments\" name=\"whats-missing-compared-to-pygments\"></a>\n\n<a id=\"markdown-testing-lexers\" name=\"testing-lexers\"></a>\n## Testing lexers\nIf you edit some lexers and want to try it, open a shell in `cmd/chromad` and run:\n```shell\ngo run .\n```\nA Link will be printed. Open it in your Browser. Now you can test on the Playground with your local changes.\n\nIf you want to run the tests and the lexers, open a shell in the root directory and run:\n```shell\ngo test ./lexers\n```\nWhen updating or adding a lexer, please add tests. See [lexers/README.md](lexers/README.md) for more.\n\n## What's missing compared to Pygments?\n\n- Quite a few lexers, for various reasons (pull-requests welcome):\n    - Pygments lexers for complex languages often include custom code to\n      handle certain aspects, such as Raku's ability to nest code inside\n      regular expressions. These require time and effort to convert.\n    - I mostly only converted languages I had heard of, to reduce the porting cost.\n- Some more esoteric features of Pygments are omitted for simplicity.\n- Though the Chroma API supports content detection, very few languages support them.\n  I have plans to implement a statistical analyser at some point, but not enough time."
}
