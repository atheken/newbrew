{
  "name": "portablegl",
  "full_name": "portablegl",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Implementation of OpenGL 3.x-ish in clean C",
  "license": "MIT",
  "homepage": "https://github.com/rswinkle/PortableGL",
  "versions": {
    "stable": "0.97.1",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/rswinkle/PortableGL.git",
      "tag": "0.97.1",
      "revision": "24f8840b800f247c328860c578c19b0535be6d58",
      "checksum": null
    },
    "head": {
      "url": "https://github.com/rswinkle/PortableGL.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/portablegl/blobs/sha256:abb0c595bf1ede018e8e0644d3aa263c9cd65af2572c16590b6214f23aa7f402",
          "sha256": "abb0c595bf1ede018e8e0644d3aa263c9cd65af2572c16590b6214f23aa7f402"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/portablegl/blobs/sha256:abb0c595bf1ede018e8e0644d3aa263c9cd65af2572c16590b6214f23aa7f402",
          "sha256": "abb0c595bf1ede018e8e0644d3aa263c9cd65af2572c16590b6214f23aa7f402"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/portablegl/blobs/sha256:abb0c595bf1ede018e8e0644d3aa263c9cd65af2572c16590b6214f23aa7f402",
          "sha256": "abb0c595bf1ede018e8e0644d3aa263c9cd65af2572c16590b6214f23aa7f402"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/portablegl/blobs/sha256:abb0c595bf1ede018e8e0644d3aa263c9cd65af2572c16590b6214f23aa7f402",
          "sha256": "abb0c595bf1ede018e8e0644d3aa263c9cd65af2572c16590b6214f23aa7f402"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/portablegl/blobs/sha256:abb0c595bf1ede018e8e0644d3aa263c9cd65af2572c16590b6214f23aa7f402",
          "sha256": "abb0c595bf1ede018e8e0644d3aa263c9cd65af2572c16590b6214f23aa7f402"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/portablegl/blobs/sha256:abb0c595bf1ede018e8e0644d3aa263c9cd65af2572c16590b6214f23aa7f402",
          "sha256": "abb0c595bf1ede018e8e0644d3aa263c9cd65af2572c16590b6214f23aa7f402"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/portablegl/blobs/sha256:acdd41c99fd456db8443da0d8b1bd7a85da618b6f7c885749527a125729bb25d",
          "sha256": "acdd41c99fd456db8443da0d8b1bd7a85da618b6f7c885749527a125729bb25d"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [],
  "test_dependencies": [
    "sdl2"
  ],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/portablegl.rb",
  "ruby_source_checksum": {
    "sha256": "0fdc325d829b5d79fec9e656d3f9c147aa7d6ad28eafa9c389503ba27aaeb53e"
  },
  "date_added": "2022-12-13T03:05:25+00:00",
  "readme": "PortableGL\n==========\n\n\"Because of the nature of Moore's law, anything that an extremely clever graphics programmer can do at one point can be replicated by a merely competent programmer some number of years later.\" - John Carmack\n\n\nIn a nutshell, PortableGL is an implementation of OpenGL 3.x core in clean C99 as a single header library (in the style of the\n[stb libraries](https://github.com/nothings/stb)).\n\nIt can theoretically be used with anything that takes a framebuffer/texture as input (including just writing images to disk manually or using something like stb_image_write) but all the demos use SDL2 and it currently only supports 8-bits per channel RGBA as a target (and also for textures).\n\nIts goals are,\n\n1. Portability\n2. Matching the API within reason, at the least matching features/abilities\n3. Ease of Use\n4. Straightforward code\n5. Speed\n\nObviously there are trade-offs between several of those.  An example where 4 trumps 2 (and arguably 3) is with shaders.  Rather than\nwrite or include a GLSL parser and have a built in compiler or interpreter, shaders are special C functions that match a specific prototype.\nUniforms are another example where 3 and 4 beat 2 because it made no sense to match the API because we can do things so much simpler by\npassing a pointer to a user defined struct (see the examples).\n\nDownload\n========\nGet the source from [Github](https://github.com/rswinkle/PortableGL).\n\nYou can also install it via [Homebrew](https://formulae.brew.sh/formula/portablegl).\n\nGallery\n=======\n![gears](https://raw.githubusercontent.com/rswinkle/PortableGL/master/media/screenshots/gears.png)\n![sphereworld](https://raw.githubusercontent.com/rswinkle/PortableGL/master/media/screenshots/sphereworld.png)\n[![backpack](https://raw.githubusercontent.com/rswinkle/PortableGL/master/media/screenshots/backpack_model.png)](https://github.com/rswinkle/LearnPortableGL/blob/main/src/3.model_loading/model_loading.cpp)\n![craft](https://raw.githubusercontent.com/rswinkle/PortableGL/master/media/screenshots/craft.png)\n\nThe last is a [PortableGL port](https://github.com/rswinkle/Craft/tree/portablegl) of Michael Fogleman's [Craft](https://www.michaelfogleman.com/projects/craft/).\n\nSee the [demos README.md](https://github.com/rswinkle/PortableGL/tree/master/demos)\nfor more screenshots, or look in the\n[screenshots directory](https://github.com/rswinkle/PortableGL/tree/master/media/screenshots).\n\nHistory\n=======\nPortableGL started as a very simple wireframe software renderer based on a tutorial in summer 2011.  I kept playing with it, adding minor features\nover the next year, until in early 2013 I decided I should turn it into a software implementation of OpenGL.  This would save me a huge amount of time\nand energy on API design since I'd just be implementing an existing good API (though some disagree) and also make the project more useful both to me\nand potentially others.  Also, at the time Mesa3D was still years away from full 3.x support, not that I'm really competing, and the fact that there\nwas no finished implementation was a little motivating.  I made a lot of progress that year and had a few bursts here and there since, but once I got it\nmostly working, I was less motivated and when I did work on it I spent my time on creating new demos/examples and tweaking or fixing minor things.  I\ncould have released an MVP back in 2014 at the earliest but late 2016 would have been the best compromise.  Anyway, after somewhere over 2000\nhours spread out over 10 years, it is as you see it today. Software is never finished, and I'll be the first to admit PortableGL could use more polish.\n\nWhy\n===\nAside from the fact that I just wrote it for fun and because I thought it was cool (maybe others will too), I can think of a few semi-practical purposes.\n\n### Educational\nI took a 400 level 3D Graphics course in college in fall 2010 months after OpenGL 3.3/4.0 was released.  It was taught based on the original\nRed Book using OpenGL 1.1.  Fortunately, the professor let me use OpenGL 3.3 as long as I met the assignment requirements.  Sadly, college graphics\nprofessors still teach 1.x and 2.x OpenGL today in 2022 more commonly than 3.x/4.x (or Vulkan).  A few are using WebGL 2.0 which I kind of\nconsider 1 step forward, 2 steps back.\n\nWhile Vulkan is the newest thing (already 5 years old time flies), it really is overkill for learning 3D graphics.  There is rarely anything that students\nmake in your standard intro to 3D graphics that remotely stresses the performance of any laptop built in the last decade plus.  Using modern OpenGL (ie 3.3+ core profile)\nto introduce all the standard concepts, vertices, triangles, textures, shaders, fragments/pixels, the transformation pipeline etc. first is much better\nthan trying to teach them Vulkan and graphics at the same time, and obviously better than teaching OpenGL API's that are decades old.\n\nPortableGL could be a very convenient base for such a class.  It's easy to walk through the code and see the pipeline and how all the steps flow together.\nFor more advanced classes or graduate students in a shared class, modifying PortableGL in some way would be a good project.  It could be some\noptimization or algorithm, maybe a new feature.  Theoretically it could be used as starter code for actual research into new graphics algorithms or techniques because it's such a convenient small foundation to change and share, vs trying to modify a project the size and complexity of Mesa3D or create a software\nrenderer from scratch.\n\n### Special Cases\nIt's hard to imagine any hardware today that has a CPU capable of running software rendered 3D graphics at any respectable speed (especially with full\nIEEE floating point) that doesn't *also* have some kind of dedicated GPU.  The GPU might only support OpenGL 2.0 give or take but for performance it'd\nbe better to stick to whatever the hardware supported than use PortableGL.  However, theoretically, there could be some platform somewhere where the CPU\nis relatively powerful that doesn't have a GPU.  Maybe some of the current and future RISC SoC's for example?  In such a case PortableGL might be a\nuseful alternative to Mesa3D or similar.\n\nAnother special case is hobby OS's.  The hardware they run on might have a GPU but it might be impossible or more trouble than it's worth to get Mesa3D\nto run on some systems.  If they have a C99 compliant compiler and standard library, they could use PortableGL to get at least some OpenGL-ish 3D support.\n\n### Why C\nI recently came across a comment regarding PortableGL that essentially asked, \"why implement a dead technology\nin a dying language?\"\n\nWhile I would argue that OpenGL is far from dead and C [isn't even close to dying](https://www.tiobe.com/tiobe-index/),\nthere are many [good reasons](https://chipmunk-physics.net/release/ChipmunkLatest-Docs/#Intro-WhyC) to write a library\nin C.  Beyond those, OpenGL is a C API so it would be weird if you couldn't use it from C.  Writing it in clean C means it\ncompiles as C++ too.  Lastly, I just like C.  It was my first language and is still my favorite for a host of reasons.\nHey, if it's good enough for Bellard, it's certainly good enough for me.\n\n\nDocumentation\n=============\n\nThere is the documentation in the comments at the top of the\n[file](https://raw.githubusercontent.com/rswinkle/PortableGL/master/src/header_docs.txt) but there\nis currently no formal documentation.  Looking at the examples and demos (and comparing them to\n[opengl_reference](https://github.com/rswinkle/opengl_reference)) should be helpful.\n\nI've also started porting the [learnopengl](https://learnopengl.com/) tutorial code [here](https://github.com/rswinkle/LearnPortableGL)\nwhich is or will be the best resource, combining his tutorials explaining the OpenGL aspects and my comments in the ported code\nexplaining PortableGL's differences and limitations (at least in the first time they appear).\n\nHonestly, the official OpenGL docs\nand [reference pages](https://www.khronos.org/registry/OpenGL-Refpages/gl4/) are good for 90-95% of it as far as basic usage:\n\n[4.6 Core reference](https://www.khronos.org/opengl/wiki/Category:Core_API_Reference)\n[4.5 comprehensive reference](https://www.khronos.org/registry/OpenGL-Refpages/gl4/)\n[tutorials and guides](https://www.khronos.org/opengl/wiki/Getting_Started#Tutorials_and_How_To_Guides)\n\nBuilding\n========\n\nThere are no dependencies for PortableGL itself, other than a compliant C99/C++ compiler.  The examples, demos,\nand the performance test use SDL2 for the window/input/getting a framebuffer to the screen.\nIf you just want to do a quick test that it compiles and runs:\n\n\tcd testing\n\tmake run_tests\n\t...\n\t./run_tests\n\t...\n\tAll tests passed\n\nYou can look in testing/test_output to see the png's generated by `run_tests` which are compared with those in testing/expected_output.\n\n\nFor the rest, on Debian/Ubuntu based distributions you can install SDL2 using the following command:\n\n`sudo apt install libsdl2-dev`\n\nOn Mac you can download the DMG file from their [releases page](https://github.com/libsdl-org/SDL/releases/tag/release-2.24.1) or install it through\na package manager like [Homebrew](https://brew.sh/), [MacPorts](https://ports.macports.org/), or [Fink](https://www.finkproject.org/).  Note, I do\nnot own a mac and have never tested PortableGL on one.  Worst case, you can always just compile SDL2 from source but one of the above options should work.\n\nOnce you have SDL2 installed you should be able to cd into examples, demos, or testing, and just run `make` or `make config=release` for optimized builds.\n\nOn Windows you can grab the zip you want from the same releases page linked above.\n\nI use premake generated makefiles that I include in the repo which I use on Linux.  I have used these same Makefiles\nto build under [MSYS2](https://www.msys2.org/) on Windows.  However, at least for now, even though PortableGL and all the\nexamples and demos are cross platform, I don't officially support building them on other platforms.  I've thought about\nremoving the premake scripts from the repo entirely and just leaving the Makefiles to make that clearer but decided not to\nfor the benefit of those who want to modify it for themselves to handle different platforms and build systems.\n\nTo sum up, the only thing that should be guaranteed to build and run anywhere out of the box with no extra effort on your part\nare the regression tests since they don't depend on anything.\n\nModifying\n=========\nportablegl.h (and portablegl_unsafe.h) is generated in the src subdirectory with the python script generate_gl_h.py.\nYou can see how it's put together and either modify the script to leave out or add files, or actually edit any of the code.\nMake sure if you edit gl_impl.c that you also edit gl_impl_unsafe.c.\n\nAdditionally, there is a growing set of more formal tests in /testing, one set of regression/feature tests, and one for\nperformance.  If you make any changes to core algorithms or data structures, you should definitely run those and make\nsure nothing broke or got drastically slower.  The demos can also function as performance tests, so if one of those\nwould be especially affected by a change, it might be worth comparing its before/after performance too.\n\nOn the other hand, if you're adding a function or feature that doesn't really affect anything else, it might be worth\nadding your own test if applicable.  You can see how they work from looking at the code, but I'll add more details and\ndocumentation about the testing system later when it's more mature.\n\n\nReferences\n==========\n\nWhile I often used the official OpenGL documentation to make sure I was matching the spec as closely as realistically\npossible, what I used most, especially early on were a few textbooks.\n\nThe first was [Fundamentals of Computer Graphics 3rd Edition](https://amzn.to/2UIyAor) which I used\nextensively early on to understand all the math involved, including the matrix transformation pipeline, barycentric coordinates\nand interpolation, texture mapping and more.  There is now a [4th Edition](https://amzn.to/3quOj69) and a soon to be released\n[5th Edition](https://amzn.to/2U6nEkh).\n\nThe second was the 5th edition of the [OpenGL Superbible](https://amzn.to/3hcbLAS).  I got this in 2010, right\nafter OpenGL 3.3/4.0 was released, and used it for my college graphics course mentioned above.  A lot of people didn't like\nthis book because they thought it relied too much on the author`s helper libraries but I had no problems.  It was my first\nexposure to any kind of OpenGL so I didn't have to unlearn the old stuff and all his code was free and available online so\nit was easy to look inside and not only see what actual OpenGL calls are used, but to then develop\nyour own classes to your own preferences.  I still use a\n[class](https://raw.githubusercontent.com/rswinkle/PortableGL/master/glcommon/rsw_glframe.h)\nbased on his [GLFrame](https://raw.githubusercontent.com/rswinkle/oglsuperbible5/master/Src/GLTools/include/GLFrame.h)\nclass for example.\n\nIn any case, that's the book I actually learned OpenGL from, and still use as a reference sometimes.  I have a fork of\nthe [book repo](https://github.com/rswinkle/oglsuperbible5) too that I occasionally look at/update.  Of course they've come\nout with a [6th](https://amzn.to/3qF0iOZ) and a [7th edition](https://amzn.to/2UBRbCt) in the last decade.\n\nLastly, while I haven't used it as much since I got it years later, the\n[OpenGL 4.0 Shading Language Cookbook](https://amzn.to/3h7P0hI) has been useful in specific OpenGL topics occasionally.\nOnce again, you can now get the expanded [3rd edition](https://amzn.to/3qtatWr).\n\nBindings/Ports\n==============\n\n[pgl](https://github.com/TotallyGamerJet/pgl) is a Go port using [CXGO](https://github.com/gotranspile/cxgo), and hand\ntranslating the individual examples/demos.\n\n\nSimilar/Related Projects\n========================\nI'll probably add others to this list as I find them.\n\n[TinyGL](https://bellard.org/TinyGL/) is Fabrice Bellard's implementation of a subset of OpenGL 1.x.  If you want something like PortableGL\nbut don't want to write shaders, just want old style glBegin/glEnd/glVertex etc. this is the closest I know of.  Also I shamelessly copied his\nclipping code because I'm not 1/10th the programmer Bellard was even as an undergrad and I knew it would \"just work\".\n\n[TinyGL Updated](https://github.com/C-Chads/tinygl): An updated and cleaned up version of TinyGL that adds several fixes and features, including performance\ntuning and limited multithreading.\n\n[Pixomatic](http://www.radgametools.com/cn/pixofeat.htm) is/was a software implementation of D3D 7 and 9 written in C and assembly by Michael Abrash\nand Mike Sartain.  You can read a [series](https://www.drdobbs.com/architecture-and-design/optimizing-pixomatic-for-x86-processors/184405765)\n[of](https://www.drdobbs.com/optimizing-pixomatic-for-modern-x86-proc/184405807)\n[articles](https://www.drdobbs.com/optimizing-pixomatic-for-modern-x86-proc/184405848) about it written by Abrash for Dr. Dobbs.\n\n[TTSIOD](https://www.thanassis.space/renderer.html) is an advanced software renderer written in C++.\n\nAs an aside, the way I handle interpolation in PortableGL works as a semi-rebuttal of [this article](https://www.thanassis.space/cpp.html).\nThe answer is not the terrible strawman C approach he comes up with just to easily say \"look how bad that is\".  The answer is that interpolation is\nan algorithm, a simple function, and it doesn't care what the data means or how many elements there are.  Pass it data and let the\nalgorithm do its job, same as graphics hardware does.  While the inheritance + template functions method works ok if you only have a few \"types\" of data,\nevery time you think of some new feature you want to interpolate, you need to define a new struct and a new template function specialization.\nHaving a function/pipeline that just takes an arbitrary amount of float data to operate on takes less code *and* even has less runtime overhead\nsince it's a single function that interpolates all the features at once rather than having to call a function for each feature.  See lines ~1200-1250\nof gl_internals.c.  Obviously it looks more complicated with all the other openGL stuff going on but you can see a simpler version on line 308 that's\nused for interpolating between line endpoints instead of over a triangle.  This is closer to his example but still longer because it has to support\nSMOOTH, PERSPECTIVE and FLAT.  You can see the shape of a straightforward implementation even there though, and the benefits of decoupling the\nalgorithm from the data it operates on.\n\n[Mesa3D](https://mesa3d.org/) is an open source implementation of OpenGL, Vulkan and other graphics APIs.  It includes several different software renderers including the Gallium rasterizer (softpipe or llvmpipe depending on whether llvm is used) and Intel's OpenSWR.\n\n[libosmesa](https://github.com/starseeker/osmesa) is an extraction and clean-up of the subset of Mesa3D 7.0.4 needed to support the old \"swrast\"\nsoftware rasterizer and OSMesa offscreen renderer (both of which were removed from upstream Mesa3D in 2020.)  libosmesa's intended purpose is to\nallow programs to offer a last-resort fallback renderer when system OpenGL capabilities are unavailable (or inadequate), while being fully self\ncontained and buildable as simple C with no external dependencies (which is why the 7.0.4 version was chosen for ths purpose.)  As that version\nof Mesa targets OpenGL v2.1, libosmesa may be a useful middle ground between PortableGL's OpenGL 3.x target and TinyGL's minimalist subset.\n\n[bbgl](https://github.com/graphitemaster/bbgl) is just a very interesting concept.  When I first saw it soon after it was published I was very frightened that it was exactly what PortableGL is but far more polished and from a better programmer.  Fortunately, it is not.\n\n[pixman](http://pixman.org/) I feel like you could use them together or combine useful parts of pixman with PortableGL.\n\n[fauxgl](https://github.com/fogleman/fauxgl) \"3D software rendering in pure Go.  No OpenGL, no C extensions, no nothin'.\"\n\n[swGL](https://github.com/h0MER247/swGL) A GPL2 multithreaded software implementation of OpenGL 1.3(ish) in C++. x86 and Windows only.\n\n[SoftGLRender](https://github.com/keith2018/SoftGLRender) A OpenGL renderer/rasterizer in modern C++.  The very impressive\ndemo lets you toggle and change various features and settings including switching seamlessly between the GPU and the software\nrenderer.  AFAIK, this is the only project that lets you write shaders in C++ like PortableGL, however the process is more complicated\nsince it has to work with the same class/API structure as real OpenGL and can't take the shortcuts that PortableGL does.\nAn advantage of all the extra plumbing and complexity is the actual C++ shader code is more standardized, looks a little cleaner, and more like GLSL.\nBesides supporting many more features (though I didn't see gl_FragDepth?), it is also optimized with threading, and SIMD on x86.\nGiven all the abstraction and extra overhead necessary to do what it does, it's impressive it manages to still be as fast as it is.\nAs best I can tell, disabling features to get vaguely close to an apples to apples comparison, it's about as fast as PortableGL.\nSo if you want OpenGL, don't need to use C, like modern C++/OOP style, and want software rendering while still being able to write your\nown shaders and avoid the old fixed-function mess, this might be the best option on this list (or a generic C++ OpenGL wrapper library\nlinked with modern Mesa).\n\n\nLICENSE\n=======\nPortableGL is licensed under the MIT License (MIT)\n\nThe code used for clipping is copyright (c) Fabrice Bellard from TinyGL also under\nthe MIT License, see LICENSE.\n\n\nTODO/IDEAS\n==========\n- [ ] Render to texture; do I bother with FBOs/Renderbuffers/PixelBuffers etc.? See ch 8 of superbible 5\n- [x] Multitexture (pointsprites and shadertoy) and texture array (Texturing) examples\n- [ ] Render to texture example program\n- [x] Mapped buffers according to API (just wraps extensions; it's free and everything is really read/write)\n- [x] Extension functions that avoid unecessary copying, ie user owns buffer/texture data and gl doesn't free\n- [x] Unsafe mode (ie no gl error checking for speedup)\n- [ ] ~~Finish duplicating NeHe style tutorial programs from [learningwebgl](https://github.com/rswinkle/webgl-lessons) to [opengl_reference](https://github.com/rswinkle/opengl_reference) and then porting those to use PortableGL~~ Port [learnopengl](https://learnopengl.com/) instead, repo [here](https://github.com/rswinkle/LearnPortableGL) WIP.\n- [x] Port medium to large open source game project as correctness/performance/API coverage test (Craft done)\n- [x] Fix bug in cubemap demo\n- [ ] More texture and render target formats\n- [ ] Logo\n- [ ] Update premake scripts to Premake5 and handle other platforms once 5 is out of beta\n- [x] Formal regression testing (WIP)\n- [x] Formal performance testing (WIP)\n- [ ] Formal/organized documentation\n- [x] Integrated documentation, license etc. a la stb libraries"
}
