{
  "name": "cpp-httplib",
  "full_name": "cpp-httplib",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "C++ header-only HTTP/HTTPS server and client library",
  "license": "MIT",
  "homepage": "https://github.com/yhirose/cpp-httplib",
  "versions": {
    "stable": "0.13.2",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/yhirose/cpp-httplib/archive/refs/tags/v0.13.2.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "b7f64402082af7c42c0d370543cb294d82959ca7cf25b3ee7eb1306732bb27d4"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/cpp-httplib/blobs/sha256:3f2527cb43683c1b21c949f9f169c655c73714afc3b1e8c4333eb79068441302",
          "sha256": "3f2527cb43683c1b21c949f9f169c655c73714afc3b1e8c4333eb79068441302"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/cpp-httplib/blobs/sha256:3f2527cb43683c1b21c949f9f169c655c73714afc3b1e8c4333eb79068441302",
          "sha256": "3f2527cb43683c1b21c949f9f169c655c73714afc3b1e8c4333eb79068441302"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/cpp-httplib/blobs/sha256:3f2527cb43683c1b21c949f9f169c655c73714afc3b1e8c4333eb79068441302",
          "sha256": "3f2527cb43683c1b21c949f9f169c655c73714afc3b1e8c4333eb79068441302"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/cpp-httplib/blobs/sha256:3f2527cb43683c1b21c949f9f169c655c73714afc3b1e8c4333eb79068441302",
          "sha256": "3f2527cb43683c1b21c949f9f169c655c73714afc3b1e8c4333eb79068441302"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/cpp-httplib/blobs/sha256:3f2527cb43683c1b21c949f9f169c655c73714afc3b1e8c4333eb79068441302",
          "sha256": "3f2527cb43683c1b21c949f9f169c655c73714afc3b1e8c4333eb79068441302"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/cpp-httplib/blobs/sha256:3f2527cb43683c1b21c949f9f169c655c73714afc3b1e8c4333eb79068441302",
          "sha256": "3f2527cb43683c1b21c949f9f169c655c73714afc3b1e8c4333eb79068441302"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/cpp-httplib/blobs/sha256:7e36dc140280611df253110acf657c7f3650481c31f6536b2615dfe8e5f57f62",
          "sha256": "7e36dc140280611df253110acf657c7f3650481c31f6536b2615dfe8e5f57f62"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "meson",
    "ninja"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/cpp-httplib.rb",
  "ruby_source_checksum": {
    "sha256": "10844296a5d0043a2c26bf1e4ea3e5b3caf2d9455e2e52a0911dc303dfc995b3"
  },
  "date_added": "2022-08-01T15:01:53+00:00",
  "readme": "cpp-httplib\n===========\n\n[![](https://github.com/yhirose/cpp-httplib/workflows/test/badge.svg)](https://github.com/yhirose/cpp-httplib/actions)\n\nA C++11 single-file header-only cross platform HTTP/HTTPS library.\n\nIt's extremely easy to setup. Just include the **httplib.h** file in your code!\n\nNOTE: This library uses 'blocking' socket I/O. If you are looking for a library with 'non-blocking' socket I/O, this is not the one that you want.\n\nSimple examples\n---------------\n\n#### Server (Multi-threaded)\n\n```c++\n#define CPPHTTPLIB_OPENSSL_SUPPORT\n#include \"path/to/httplib.h\"\n\n// HTTP\nhttplib::Server svr;\n\n// HTTPS\nhttplib::SSLServer svr;\n\nsvr.Get(\"/hi\", [](const httplib::Request &, httplib::Response &res) {\n  res.set_content(\"Hello World!\", \"text/plain\");\n});\n\nsvr.listen(\"0.0.0.0\", 8080);\n```\n\n#### Client\n\n```c++\n#define CPPHTTPLIB_OPENSSL_SUPPORT\n#include \"path/to/httplib.h\"\n\n// HTTP\nhttplib::Client cli(\"http://cpp-httplib-server.yhirose.repl.co\");\n\n// HTTPS\nhttplib::Client cli(\"https://cpp-httplib-server.yhirose.repl.co\");\n\nauto res = cli.Get(\"/hi\");\nres->status;\nres->body;\n```\n\nSSL Support\n-----------\n\nSSL support is available with `CPPHTTPLIB_OPENSSL_SUPPORT`. `libssl` and `libcrypto` should be linked.\n\nNOTE: cpp-httplib currently supports only version 1.1.1 and 3.0.\n\nNOTE for macOS: cpp-httplib now can use system certs with `CPPHTTPLIB_USE_CERTS_FROM_MACOSX_KEYCHAIN`. `CoreFoundation` and `Security` should be linked with `-framework`.\n\n```c++\n#define CPPHTTPLIB_OPENSSL_SUPPORT\n#include \"path/to/httplib.h\"\n\n// Server\nhttplib::SSLServer svr(\"./cert.pem\", \"./key.pem\");\n\n// Client\nhttplib::Client cli(\"https://localhost:1234\"); // scheme + host\nhttplib::SSLClient cli(\"localhost:1234\"); // host\nhttplib::SSLClient cli(\"localhost\", 1234); // host, port\n\n// Use your CA bundle\ncli.set_ca_cert_path(\"./ca-bundle.crt\");\n\n// Disable cert verification\ncli.enable_server_certificate_verification(false);\n```\n\nNOTE: When using SSL, it seems impossible to avoid SIGPIPE in all cases, since on some operating systems, SIGPIPE can only be suppressed on a per-message basis, but there is no way to make the OpenSSL library do so for its internal communications. If your program needs to avoid being terminated on SIGPIPE, the only fully general way might be to set up a signal handler for SIGPIPE to handle or ignore it yourself.\n\nServer\n------\n\n```c++\n#include <httplib.h>\n\nint main(void)\n{\n  using namespace httplib;\n\n  Server svr;\n\n  svr.Get(\"/hi\", [](const Request& req, Response& res) {\n    res.set_content(\"Hello World!\", \"text/plain\");\n  });\n\n  // Match the request path against a regular expression\n  // and extract its captures\n  svr.Get(R\"(/numbers/(\\d+))\", [&](const Request& req, Response& res) {\n    auto numbers = req.matches[1];\n    res.set_content(numbers, \"text/plain\");\n  });\n\n  // Capture the second segment of the request path as \"id\" path param\n  svr.Get(\"/users/:id\", [&](const Request& req, Response& res) {\n    auto user_id = req.path_params.at(\"id\");\n    res.set_content(user_id, \"text/plain\");\n  });\n\n  // Extract values from HTTP headers and URL query params\n  svr.Get(\"/body-header-param\", [](const Request& req, Response& res) {\n    if (req.has_header(\"Content-Length\")) {\n      auto val = req.get_header_value(\"Content-Length\");\n    }\n    if (req.has_param(\"key\")) {\n      auto val = req.get_param_value(\"key\");\n    }\n    res.set_content(req.body, \"text/plain\");\n  });\n\n  svr.Get(\"/stop\", [&](const Request& req, Response& res) {\n    svr.stop();\n  });\n\n  svr.listen(\"localhost\", 1234);\n}\n```\n\n`Post`, `Put`, `Delete` and `Options` methods are also supported.\n\n### Bind a socket to multiple interfaces and any available port\n\n```cpp\nint port = svr.bind_to_any_port(\"0.0.0.0\");\nsvr.listen_after_bind();\n```\n\n### Static File Server\n\n```cpp\n// Mount / to ./www directory\nauto ret = svr.set_mount_point(\"/\", \"./www\");\nif (!ret) {\n  // The specified base directory doesn't exist...\n}\n\n// Mount /public to ./www directory\nret = svr.set_mount_point(\"/public\", \"./www\");\n\n// Mount /public to ./www1 and ./www2 directories\nret = svr.set_mount_point(\"/public\", \"./www1\"); // 1st order to search\nret = svr.set_mount_point(\"/public\", \"./www2\"); // 2nd order to search\n\n// Remove mount /\nret = svr.remove_mount_point(\"/\");\n\n// Remove mount /public\nret = svr.remove_mount_point(\"/public\");\n```\n\n```cpp\n// User defined file extension and MIME type mappings\nsvr.set_file_extension_and_mimetype_mapping(\"cc\", \"text/x-c\");\nsvr.set_file_extension_and_mimetype_mapping(\"cpp\", \"text/x-c\");\nsvr.set_file_extension_and_mimetype_mapping(\"hh\", \"text/x-h\");\n```\n\nThe followings are built-in mappings:\n\n| Extension  |          MIME Type          | Extension  |          MIME Type          |\n| :--------- | :-------------------------- | :--------- | :-------------------------- |\n| css        | text/css                    | mpga       | audio/mpeg                  |\n| csv        | text/csv                    | weba       | audio/webm                  |\n| txt        | text/plain                  | wav        | audio/wave                  |\n| vtt        | text/vtt                    | otf        | font/otf                    |\n| html, htm  | text/html                   | ttf        | font/ttf                    |\n| apng       | image/apng                  | woff       | font/woff                   |\n| avif       | image/avif                  | woff2      | font/woff2                  |\n| bmp        | image/bmp                   | 7z         | application/x-7z-compressed |\n| gif        | image/gif                   | atom       | application/atom+xml        |\n| png        | image/png                   | pdf        | application/pdf             |\n| svg        | image/svg+xml               | mjs, js    | application/javascript      |\n| webp       | image/webp                  | json       | application/json            |\n| ico        | image/x-icon                | rss        | application/rss+xml         |\n| tif        | image/tiff                  | tar        | application/x-tar           |\n| tiff       | image/tiff                  | xhtml, xht | application/xhtml+xml       |\n| jpeg, jpg  | image/jpeg                  | xslt       | application/xslt+xml        |\n| mp4        | video/mp4                   | xml        | application/xml             |\n| mpeg       | video/mpeg                  | gz         | application/gzip            |\n| webm       | video/webm                  | zip        | application/zip             |\n| mp3        | audio/mp3                   | wasm       | application/wasm            |\n\nNOTE: These static file server methods are not thread-safe.\n\n### File request handler\n\n```cpp\n// The handler is called right before the response is sent to a client\nsvr.set_file_request_handler([](const Request &req, Response &res) {\n  ...\n});\n```\n\n### Logging\n\n```cpp\nsvr.set_logger([](const auto& req, const auto& res) {\n  your_logger(req, res);\n});\n```\n\n### Error handler\n\n```cpp\nsvr.set_error_handler([](const auto& req, auto& res) {\n  auto fmt = \"<p>Error Status: <span style='color:red;'>%d</span></p>\";\n  char buf[BUFSIZ];\n  snprintf(buf, sizeof(buf), fmt, res.status);\n  res.set_content(buf, \"text/html\");\n});\n```\n\n### Exception handler\nThe exception handler gets called if a user routing handler throws an error.\n\n```cpp\nsvr.set_exception_handler([](const auto& req, auto& res, std::exception_ptr ep) {\n  auto fmt = \"<h1>Error 500</h1><p>%s</p>\";\n  char buf[BUFSIZ];\n  try {\n    std::rethrow_exception(ep);\n  } catch (std::exception &e) {\n    snprintf(buf, sizeof(buf), fmt, e.what());\n  } catch (...) { // See the following NOTE\n    snprintf(buf, sizeof(buf), fmt, \"Unknown Exception\");\n  }\n  res.set_content(buf, \"text/html\");\n  res.status = 500;\n});\n```\n\nNOTE: if you don't provide the `catch (...)` block for a rethrown exception pointer, an uncaught exception will end up causing the server crash. Be careful!\n\n### Pre routing handler\n\n```cpp\nsvr.set_pre_routing_handler([](const auto& req, auto& res) {\n  if (req.path == \"/hello\") {\n    res.set_content(\"world\", \"text/html\");\n    return Server::HandlerResponse::Handled;\n  }\n  return Server::HandlerResponse::Unhandled;\n});\n```\n\n### Post routing handler\n\n```cpp\nsvr.set_post_routing_handler([](const auto& req, auto& res) {\n  res.set_header(\"ADDITIONAL_HEADER\", \"value\");\n});\n```\n\n### 'multipart/form-data' POST data\n\n```cpp\nsvr.Post(\"/multipart\", [&](const auto& req, auto& res) {\n  auto size = req.files.size();\n  auto ret = req.has_file(\"name1\");\n  const auto& file = req.get_file_value(\"name1\");\n  // file.filename;\n  // file.content_type;\n  // file.content;\n});\n```\n\n### Receive content with a content receiver\n\n```cpp\nsvr.Post(\"/content_receiver\",\n  [&](const Request &req, Response &res, const ContentReader &content_reader) {\n    if (req.is_multipart_form_data()) {\n      // NOTE: `content_reader` is blocking until every form data field is read\n      MultipartFormDataItems files;\n      content_reader(\n        [&](const MultipartFormData &file) {\n          files.push_back(file);\n          return true;\n        },\n        [&](const char *data, size_t data_length) {\n          files.back().content.append(data, data_length);\n          return true;\n        });\n    } else {\n      std::string body;\n      content_reader([&](const char *data, size_t data_length) {\n        body.append(data, data_length);\n        return true;\n      });\n    }\n  });\n```\n\n### Send content with the content provider\n\n```cpp\nconst size_t DATA_CHUNK_SIZE = 4;\n\nsvr.Get(\"/stream\", [&](const Request &req, Response &res) {\n  auto data = new std::string(\"abcdefg\");\n\n  res.set_content_provider(\n    data->size(), // Content length\n    \"text/plain\", // Content type\n    [&, data](size_t offset, size_t length, DataSink &sink) {\n      const auto &d = *data;\n      sink.write(&d[offset], std::min(length, DATA_CHUNK_SIZE));\n      return true; // return 'false' if you want to cancel the process.\n    },\n    [data](bool success) { delete data; });\n});\n```\n\nWithout content length:\n\n```cpp\nsvr.Get(\"/stream\", [&](const Request &req, Response &res) {\n  res.set_content_provider(\n    \"text/plain\", // Content type\n    [&](size_t offset, DataSink &sink) {\n      if (/* there is still data */) {\n        std::vector<char> data;\n        // prepare data...\n        sink.write(data.data(), data.size());\n      } else {\n        sink.done(); // No more data\n      }\n      return true; // return 'false' if you want to cancel the process.\n    });\n});\n```\n\n### Chunked transfer encoding\n\n```cpp\nsvr.Get(\"/chunked\", [&](const Request& req, Response& res) {\n  res.set_chunked_content_provider(\n    \"text/plain\",\n    [](size_t offset, DataSink &sink) {\n      sink.write(\"123\", 3);\n      sink.write(\"345\", 3);\n      sink.write(\"789\", 3);\n      sink.done(); // No more data\n      return true; // return 'false' if you want to cancel the process.\n    }\n  );\n});\n```\n\nWith trailer:\n\n```cpp\nsvr.Get(\"/chunked\", [&](const Request& req, Response& res) {\n  res.set_header(\"Trailer\", \"Dummy1, Dummy2\");\n  res.set_chunked_content_provider(\n    \"text/plain\",\n    [](size_t offset, DataSink &sink) {\n      sink.write(\"123\", 3);\n      sink.write(\"345\", 3);\n      sink.write(\"789\", 3);\n      sink.done_with_trailer({\n        {\"Dummy1\", \"DummyVal1\"},\n        {\"Dummy2\", \"DummyVal2\"}\n      });\n      return true;\n    }\n  );\n});\n```\n\n### 'Expect: 100-continue' handler\n\nBy default, the server sends a `100 Continue` response for an `Expect: 100-continue` header.\n\n```cpp\n// Send a '417 Expectation Failed' response.\nsvr.set_expect_100_continue_handler([](const Request &req, Response &res) {\n  return 417;\n});\n```\n\n```cpp\n// Send a final status without reading the message body.\nsvr.set_expect_100_continue_handler([](const Request &req, Response &res) {\n  return res.status = 401;\n});\n```\n\n### Keep-Alive connection\n\n```cpp\nsvr.set_keep_alive_max_count(2); // Default is 5\nsvr.set_keep_alive_timeout(10);  // Default is 5\n```\n\n### Timeout\n\n```c++\nsvr.set_read_timeout(5, 0); // 5 seconds\nsvr.set_write_timeout(5, 0); // 5 seconds\nsvr.set_idle_interval(0, 100000); // 100 milliseconds\n```\n\n### Set maximum payload length for reading a request body\n\n```c++\nsvr.set_payload_max_length(1024 * 1024 * 512); // 512MB\n```\n\n### Server-Sent Events\n\nPlease see [Server example](https://github.com/yhirose/cpp-httplib/blob/master/example/ssesvr.cc) and [Client example](https://github.com/yhirose/cpp-httplib/blob/master/example/ssecli.cc).\n\n### Default thread pool support\n\n`ThreadPool` is used as a **default** task queue, and the default thread count is 8, or `std::thread::hardware_concurrency()`. You can change it with `CPPHTTPLIB_THREAD_POOL_COUNT`.\n\nIf you want to set the thread count at runtime, there is no convenient way... But here is how.\n\n```cpp\nsvr.new_task_queue = [] { return new ThreadPool(12); };\n```\n\n### Override the default thread pool with yours\n\nYou can supply your own thread pool implementation according to your need.\n\n```cpp\nclass YourThreadPoolTaskQueue : public TaskQueue {\npublic:\n  YourThreadPoolTaskQueue(size_t n) {\n    pool_.start_with_thread_count(n);\n  }\n\n  virtual void enqueue(std::function<void()> fn) override {\n    pool_.enqueue(fn);\n  }\n\n  virtual void shutdown() override {\n    pool_.shutdown_gracefully();\n  }\n\nprivate:\n  YourThreadPool pool_;\n};\n\nsvr.new_task_queue = [] {\n  return new YourThreadPoolTaskQueue(12);\n};\n```\n\nClient\n------\n\n```c++\n#include <httplib.h>\n#include <iostream>\n\nint main(void)\n{\n  httplib::Client cli(\"localhost\", 1234);\n\n  if (auto res = cli.Get(\"/hi\")) {\n    if (res->status == 200) {\n      std::cout << res->body << std::endl;\n    }\n  } else {\n    auto err = res.error();\n    std::cout << \"HTTP error: \" << httplib::to_string(err) << std::endl;\n  }\n}\n```\n\nNOTE: Constructor with scheme-host-port string is now supported!\n\n```c++\nhttplib::Client cli(\"localhost\");\nhttplib::Client cli(\"localhost:8080\");\nhttplib::Client cli(\"http://localhost\");\nhttplib::Client cli(\"http://localhost:8080\");\nhttplib::Client cli(\"https://localhost\");\nhttplib::SSLClient cli(\"localhost\");\n```\n\n### Error code\n\nHere is the list of errors from `Result::error()`.\n\n```c++\nenum Error {\n  Success = 0,\n  Unknown,\n  Connection,\n  BindIPAddress,\n  Read,\n  Write,\n  ExceedRedirectCount,\n  Canceled,\n  SSLConnection,\n  SSLLoadingCerts,\n  SSLServerVerification,\n  UnsupportedMultipartBoundaryChars,\n  Compression,\n  ConnectionTimeout,\n};\n```\n\n### GET with HTTP headers\n\n```c++\nhttplib::Headers headers = {\n  { \"Accept-Encoding\", \"gzip, deflate\" }\n};\nauto res = cli.Get(\"/hi\", headers);\n```\nor\n```c++\nauto res = cli.Get(\"/hi\", {{\"Accept-Encoding\", \"gzip, deflate\"}});\n```\nor\n```c++\ncli.set_default_headers({\n  { \"Accept-Encoding\", \"gzip, deflate\" }\n});\nauto res = cli.Get(\"/hi\");\n```\n\n### POST\n\n```c++\nres = cli.Post(\"/post\", \"text\", \"text/plain\");\nres = cli.Post(\"/person\", \"name=john1&note=coder\", \"application/x-www-form-urlencoded\");\n```\n\n### POST with parameters\n\n```c++\nhttplib::Params params;\nparams.emplace(\"name\", \"john\");\nparams.emplace(\"note\", \"coder\");\n\nauto res = cli.Post(\"/post\", params);\n```\n or\n\n```c++\nhttplib::Params params{\n  { \"name\", \"john\" },\n  { \"note\", \"coder\" }\n};\n\nauto res = cli.Post(\"/post\", params);\n```\n\n### POST with Multipart Form Data\n\n```c++\nhttplib::MultipartFormDataItems items = {\n  { \"text1\", \"text default\", \"\", \"\" },\n  { \"text2\", \"aωb\", \"\", \"\" },\n  { \"file1\", \"h\\ne\\n\\nl\\nl\\no\\n\", \"hello.txt\", \"text/plain\" },\n  { \"file2\", \"{\\n  \\\"world\\\", true\\n}\\n\", \"world.json\", \"application/json\" },\n  { \"file3\", \"\", \"\", \"application/octet-stream\" },\n};\n\nauto res = cli.Post(\"/multipart\", items);\n```\n\n### PUT\n\n```c++\nres = cli.Put(\"/resource/foo\", \"text\", \"text/plain\");\n```\n\n### DELETE\n\n```c++\nres = cli.Delete(\"/resource/foo\");\n```\n\n### OPTIONS\n\n```c++\nres = cli.Options(\"*\");\nres = cli.Options(\"/resource/foo\");\n```\n\n### Timeout\n\n```c++\ncli.set_connection_timeout(0, 300000); // 300 milliseconds\ncli.set_read_timeout(5, 0); // 5 seconds\ncli.set_write_timeout(5, 0); // 5 seconds\n```\n\n### Receive content with a content receiver\n\n```c++\nstd::string body;\n\nauto res = cli.Get(\"/large-data\",\n  [&](const char *data, size_t data_length) {\n    body.append(data, data_length);\n    return true;\n  });\n```\n\n```cpp\nstd::string body;\n\nauto res = cli.Get(\n  \"/stream\", Headers(),\n  [&](const Response &response) {\n    EXPECT_EQ(200, response.status);\n    return true; // return 'false' if you want to cancel the request.\n  },\n  [&](const char *data, size_t data_length) {\n    body.append(data, data_length);\n    return true; // return 'false' if you want to cancel the request.\n  });\n```\n\n### Send content with a content provider\n\n```cpp\nstd::string body = ...;\n\nauto res = cli.Post(\n  \"/stream\", body.size(),\n  [](size_t offset, size_t length, DataSink &sink) {\n    sink.write(body.data() + offset, length);\n    return true; // return 'false' if you want to cancel the request.\n  },\n  \"text/plain\");\n```\n\n### Chunked transfer encoding\n\n```cpp\nauto res = cli.Post(\n  \"/stream\",\n  [](size_t offset, DataSink &sink) {\n    sink.os << \"chunked data 1\";\n    sink.os << \"chunked data 2\";\n    sink.os << \"chunked data 3\";\n    sink.done();\n    return true; // return 'false' if you want to cancel the request.\n  },\n  \"text/plain\");\n```\n\n### With Progress Callback\n\n```cpp\nhttplib::Client client(url, port);\n\n// prints: 0 / 000 bytes => 50% complete\nauto res = cli.Get(\"/\", [](uint64_t len, uint64_t total) {\n  printf(\"%lld / %lld bytes => %d%% complete\\n\",\n    len, total,\n    (int)(len*100/total));\n  return true; // return 'false' if you want to cancel the request.\n}\n);\n```\n\n![progress](https://user-images.githubusercontent.com/236374/33138910-495c4ecc-cf86-11e7-8693-2fc6d09615c4.gif)\n\n### Authentication\n\n```cpp\n// Basic Authentication\ncli.set_basic_auth(\"user\", \"pass\");\n\n// Digest Authentication\ncli.set_digest_auth(\"user\", \"pass\");\n\n// Bearer Token Authentication\ncli.set_bearer_token_auth(\"token\");\n```\n\nNOTE: OpenSSL is required for Digest Authentication.\n\n### Proxy server support\n\n```cpp\ncli.set_proxy(\"host\", port);\n\n// Basic Authentication\ncli.set_proxy_basic_auth(\"user\", \"pass\");\n\n// Digest Authentication\ncli.set_proxy_digest_auth(\"user\", \"pass\");\n\n// Bearer Token Authentication\ncli.set_proxy_bearer_token_auth(\"pass\");\n```\n\nNOTE: OpenSSL is required for Digest Authentication.\n\n### Range\n\n```cpp\nhttplib::Client cli(\"httpbin.org\");\n\nauto res = cli.Get(\"/range/32\", {\n  httplib::make_range_header({{1, 10}}) // 'Range: bytes=1-10'\n});\n// res->status should be 206.\n// res->body should be \"bcdefghijk\".\n```\n\n```cpp\nhttplib::make_range_header({{1, 10}, {20, -1}})      // 'Range: bytes=1-10, 20-'\nhttplib::make_range_header({{100, 199}, {500, 599}}) // 'Range: bytes=100-199, 500-599'\nhttplib::make_range_header({{0, 0}, {-1, 1}})        // 'Range: bytes=0-0, -1'\n```\n\n### Keep-Alive connection\n\n```cpp\nhttplib::Client cli(\"localhost\", 1234);\n\ncli.Get(\"/hello\");         // with \"Connection: close\"\n\ncli.set_keep_alive(true);\ncli.Get(\"/world\");\n\ncli.set_keep_alive(false);\ncli.Get(\"/last-request\");  // with \"Connection: close\"\n```\n\n### Redirect\n\n```cpp\nhttplib::Client cli(\"yahoo.com\");\n\nauto res = cli.Get(\"/\");\nres->status; // 301\n\ncli.set_follow_location(true);\nres = cli.Get(\"/\");\nres->status; // 200\n```\n\n### Use a specific network interface\n\nNOTE: This feature is not available on Windows, yet.\n\n```cpp\ncli.set_interface(\"eth0\"); // Interface name, IP address or host name\n```\n\nCompression\n-----------\n\nThe server can apply compression to the following MIME type contents:\n\n  * all text types except text/event-stream\n  * image/svg+xml\n  * application/javascript\n  * application/json\n  * application/xml\n  * application/xhtml+xml\n\n### Zlib Support\n\n'gzip' compression is available with `CPPHTTPLIB_ZLIB_SUPPORT`. `libz` should be linked.\n\n### Brotli Support\n\nBrotli compression is available with `CPPHTTPLIB_BROTLI_SUPPORT`. Necessary libraries should be linked.\nPlease see https://github.com/google/brotli for more detail.\n\n### Compress request body on client\n\n```c++\ncli.set_compress(true);\nres = cli.Post(\"/resource/foo\", \"...\", \"text/plain\");\n```\n\n### Compress response body on client\n\n```c++\ncli.set_decompress(false);\nres = cli.Get(\"/resource/foo\", {{\"Accept-Encoding\", \"gzip, deflate, br\"}});\nres->body; // Compressed data\n```\n\nUse `poll` instead of `select`\n------------------------------\n\n`select` system call is used as default since it's more widely supported. If you want to let cpp-httplib use `poll` instead, you can do so with `CPPHTTPLIB_USE_POLL`.\n\n\nSplit httplib.h into .h and .cc\n-------------------------------\n\n```console\n$ ./split.py -h\nusage: split.py [-h] [-e EXTENSION] [-o OUT]\n\nThis script splits httplib.h into .h and .cc parts.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -e EXTENSION, --extension EXTENSION\n                        extension of the implementation file (default: cc)\n  -o OUT, --out OUT     where to write the files (default: out)\n\n$ ./split.py\nWrote out/httplib.h and out/httplib.cc\n```\n\nNOTE\n----\n\n### g++\n\ng++ 4.8 and below cannot build this library since `<regex>` in the versions are [broken](https://stackoverflow.com/questions/12530406/is-gcc-4-8-or-earlier-buggy-about-regular-expressions).\n\n### Windows\n\nInclude `httplib.h` before `Windows.h` or include `Windows.h` by defining `WIN32_LEAN_AND_MEAN` beforehand.\n\n```cpp\n#include <httplib.h>\n#include <Windows.h>\n```\n\n```cpp\n#define WIN32_LEAN_AND_MEAN\n#include <Windows.h>\n#include <httplib.h>\n```\n\nNOTE: cpp-httplib officially supports only the latest Visual Studio. It might work with former versions of Visual Studio, but I can no longer verify it. Pull requests are always welcome for the older versions of Visual Studio unless they break the C++11 conformance.\n\nNOTE: Windows 8 or lower, Visual Studio 2013 or lower, and Cygwin on Windows are not supported.\n\nLicense\n-------\n\nMIT license (© 2023 Yuji Hirose)\n\nSpecial Thanks To\n-----------------\n\n[These folks](https://github.com/yhirose/cpp-httplib/graphs/contributors) made great contributions to polish this library to totally another level from a simple toy!"
}
