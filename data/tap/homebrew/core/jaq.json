{
  "name": "jaq",
  "full_name": "jaq",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "JQ clone focussed on correctness, speed, and simplicity",
  "license": "MIT",
  "homepage": "https://github.com/01mf02/jaq",
  "versions": {
    "stable": "0.10.1",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/01mf02/jaq/archive/refs/tags/v0.10.1.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "cccac0263a7699347c40a596cc6855b02aa0ec8288901cde0214fc6ed6d811af"
    },
    "head": {
      "url": "https://github.com/01mf02/jaq.git",
      "branch": "main"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/jaq/blobs/sha256:e9901f4b60de7c279d9908107dfc91fd2d4221324b1df4dec846dfe4abca8c24",
          "sha256": "e9901f4b60de7c279d9908107dfc91fd2d4221324b1df4dec846dfe4abca8c24"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/jaq/blobs/sha256:20865f47966b40e3d5806159c34f94eea43199d64bfcd6604fa65e42b99f312a",
          "sha256": "20865f47966b40e3d5806159c34f94eea43199d64bfcd6604fa65e42b99f312a"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/jaq/blobs/sha256:272e7ba18bcf20e9439a3dd066b8a406ae3fb9ca7491ca8bad7aa6557d85dda0",
          "sha256": "272e7ba18bcf20e9439a3dd066b8a406ae3fb9ca7491ca8bad7aa6557d85dda0"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/jaq/blobs/sha256:011f7b48278df20e169909bc62f5d37fca3798c578af9097f8e5fa301add8ab3",
          "sha256": "011f7b48278df20e169909bc62f5d37fca3798c578af9097f8e5fa301add8ab3"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/jaq/blobs/sha256:ce2fbbc9e8a48878c62a57e5d5beaf14d1d9b9c6e934cc1bce7e757f029a80d3",
          "sha256": "ce2fbbc9e8a48878c62a57e5d5beaf14d1d9b9c6e934cc1bce7e757f029a80d3"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/jaq/blobs/sha256:a715672710c200a407107c951f72a384daf03708cd910f48c48b65789a833f49",
          "sha256": "a715672710c200a407107c951f72a384daf03708cd910f48c48b65789a833f49"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/jaq/blobs/sha256:32a06efa9973c86316c1702e3ba5155d0850338cbb21aa7bc1d93edfd26ecdf3",
          "sha256": "32a06efa9973c86316c1702e3ba5155d0850338cbb21aa7bc1d93edfd26ecdf3"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "rust"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/jaq.rb",
  "ruby_source_checksum": {
    "sha256": "fe5a1e307f35c14bfad0247ebc23e6a06f6616ce414307b90440efd50211f36f"
  },
  "date_added": "2022-06-19T08:39:47+00:00",
  "readme": "# jaq\n\n![Build status](https://github.com/01mf02/jaq/workflows/Rust/badge.svg)\n[![Crates.io](https://img.shields.io/crates/v/jaq-interpret.svg)](https://crates.io/crates/jaq-interpret)\n[![Documentation](https://docs.rs/jaq-interpret/badge.svg)](https://docs.rs/jaq-interpret)\n[![Rust 1.62+](https://img.shields.io/badge/rust-1.62+-orange.svg)](https://www.rust-lang.org)\n\njaq is a clone of the JSON data processing tool [jq].\njaq aims to support a large subset of jq's syntax and operations.\n\njaq focusses on three goals:\n\n* **Correctness**:\n  jaq aims to provide a more correct and predictable implementation of jq,\n  while preserving compatibility with jq in most cases.\n  <details><summary>Examples of surprising jq behaviour</summary>\n\n  * `nan > nan` is false, while `nan < nan` is true.\n  * `[[]] | implode` crashes jq, and this was not fixed at the time of writing despite\n    [being known since five years](https://github.com/stedolan/jq/issues/1160).\n  * The [jq manual] claims that `limit(n; exp)` \"extracts up to `n` outputs from `exp`\".\n    This holds for values of `n > 1`, e.g. `jq -n '[limit(2; 1, 2, 3)]'` yields\n    `[1, 2]`, but when `n == 0`, `jq -n '[limit(0; 1, 2, 3)]'` yields `[1]` instead of `[]`.\n    And perhaps even worse, when `n < 0`, then `limit` yields *all* outputs from `exp`,\n    which is not documented.\n\n  </details>\n* **Performance**:\n  I created jaq originally because I was bothered by\n  [jq's long start-up time](https://github.com/stedolan/jq/issues/1411),\n  which amounts to about 50ms on my machine.\n  This can particularly show when processing a large number of small files.\n  jaq starts up about 30 times faster than jq and\n  [outperforms jq also on many other benchmarks](#performance).\n* **Simplicity**:\n  jaq aims to have a simple and small implementation, in order to\n  reduce the potential for bugs and to\n  facilitate contributions.\n\nI drew inspiration from another Rust program, namely [jql].\nHowever, unlike jql, jaq aims to closely imitate jq's syntax and semantics.\nThis should allow users proficient in jq to easily use jaq.\n\n[jq]: https://stedolan.github.io/jq/\n[jql]: https://github.com/yamafaktory/jql\n\n\n\n# Installation\n\n\n## From Source\n\nTo compile jaq, you need a Rust toolchain.\nSee <https://rustup.rs/> for instructions.\n(Note that Rust compilers shipped with Linux distributions\nmay be too outdated to compile jaq.)\n\nAny of the following commands install jaq:\n\n    $ cargo install --locked jaq\n    $ cargo install --locked --git https://github.com/01mf02/jaq # latest development version\n\nOn my system, both commands place the executable at `~/.cargo/bin/jaq`.\n\nIf you have cloned this repository, you can also build jaq by executing one of the commands in the cloned repository:\n\n    $ cargo build --release # places binary into target/release/jaq\n    $ cargo install --locked --path jaq # installs binary\n\njaq should work on any system supported by Rust.\nIf it does not, please file an issue.\n\n\n## Binaries\n\nYou may also install jaq using [homebrew](https://formulae.brew.sh/formula/jaq) on macOS or Linux:\n\n    $ brew install jaq\n    $ brew install --HEAD jaq # latest development version\n\n\n\n# Examples\n\nThe following examples should give an impression of what jaq can currently do.\nYou should obtain the same outputs by replacing jaq with jq.\nIf not, your filing an issue would be appreciated. :)\nThe syntax is documented in the [jq manual].\n\n[jq manual]: https://stedolan.github.io/jq/manual/v1.6/\n\nAccess a field:\n\n    $ echo '{\"a\": 1, \"b\": 2}' | jaq '.a'\n    1\n\nAdd values:\n\n    $ echo '{\"a\": 1, \"b\": 2}' | jaq 'add'\n    3\n\nConstruct an array from an object in two ways and show that they are equal:\n\n    $ echo '{\"a\": 1, \"b\": 2}' | jaq '[.a, .b] == [.[]]'\n    true\n\nApply a filter to all elements of an array and filter the results:\n\n    $ echo '[0, 1, 2, 3]' | jaq 'map(.*2) | [.[] | select(. < 5)]'\n    [0, 2, 4]\n\nRead (slurp) input values into an array and get the average of its elements:\n\n    $ echo '1 2 3 4' | jaq -s 'add / length'\n    2.5\n\nRepeatedly apply a filter to itself and output the intermediate results:\n\n    $ echo '0' | jaq '[recurse(.+1; . < 3)]'\n    [0, 1, 2]\n\nLazily fold over inputs and output intermediate results:\n\n    $ seq 1000 | jaq -n 'foreach inputs as $x (0; . + $x)'\n    1 3 6 10 15 [...]\n\n\n\n# Performance\n\nThe following evaluation consists of several benchmarks that\nallow comparing the performance of jaq, jq, and [gojq].\nThe `empty` benchmark runs `n` times the filter `empty` with null input,\nserving to measure the startup time.\nThe `bf-fib` benchmark runs a Brainfuck interpreter written in jq,\ninterpreting a Brainfuck script that produces `n` Fibonacci numbers.\nThe other benchmarks evaluate various filters with `n` as input;\nsee [`bench.sh`](bench.sh) for details.\n\n[jq-cff5336] was compiled manually with disabled assertion checking,\nby adding `-DNDEBUG` to `DEFS` in `Makefile`.\nI generated the benchmark data with `bench.sh target/release/jaq jq-cff5336 gojq jq`,\nfollowed by `pandoc -t gfm`.\n\nTable: Evaluation results in seconds (\"N/A\" if more than 10 seconds).\n\n| Benchmark    |       n | jaq-0.9.0 | jq-cff5336 | gojq-0.12.9 | jq-1.6 |\n| ------------ | ------: | --------: | ---------: | ----------: | -----: |\n| empty        |     512 |      0.83 |       1.25 |        0.96 |    N/A |\n| bf-fib       |      13 |      0.92 |       1.30 |        2.52 |   3.16 |\n| reverse      | 1048576 |      0.08 |       1.09 |        1.16 |   1.54 |\n| sort         | 1048576 |      0.20 |       1.53 |        1.77 |   1.81 |\n| add          | 1048576 |      0.96 |       1.06 |        2.51 |   1.69 |\n| kv           |  131072 |      0.33 |       0.25 |        0.49 |   0.49 |\n| kv-update    |  131072 |      0.38 |       0.67 |         N/A |    N/A |\n| kv-entries   |  131072 |      1.23 |       1.29 |        2.23 |   2.50 |\n| ex-implode   | 1048576 |      1.32 |       1.59 |        1.73 |   2.77 |\n| reduce       | 1048576 |      1.60 |       1.34 |         N/A |   1.92 |\n| tree-flatten |      17 |      0.71 |       0.54 |        0.03 |   1.95 |\n| tree-update  |      17 |      0.47 |       1.43 |        4.58 |   2.73 |\n| to-fromjson  |   65536 |      0.09 |       1.59 |        0.16 |   1.69 |\n\nThe results show that jaq is\nfaster than jq-cff5336 on ten out of thirteen benchmarks and\nfaster than jq 1.6 on *all* benchmarks.\ngojq is faster than jaq only on one benchmark, namely \"tree-flatten\"\n(due to implementing the filter `flatten` natively instead of by definition).\n\n[jq-cff5336]: https://github.com/stedolan/jq/tree/cff5336ec71b6fee396a95bb0e4bea365e0cd1e8\n[gojq]: https://github.com/itchyny/gojq\n\n\n\n# Features\n\nHere is an overview that summarises:\n\n* [x] features already implemented, and\n* [ ] features not yet implemented.\n\n[Contributions to extend jaq are highly welcome.](#contributing)\n\n\n## Basics\n\n- [x] Identity (`.`)\n- [x] Recursion (`..`)\n- [x] Basic data types (null, boolean, number, string, array, object)\n- [x] if-then-else (`if .a < .b then .a else .b end`)\n- [x] Folding (`reduce .[] as $x (0; . + $x)`, `foreach .[] as $x (0; . + $x; . + .)`)\n- [x] Error handling (`try ... catch ...`) (see the [differences from jq](#error-handling))\n- [ ] String interpolation\n- [ ] Format strings (`@csv`, `@html`, `@json`)\n\n\n## Paths\n\n- [x] Indexing of arrays/objects (`.[0]`, `.a`, `.[\"a\"]`)\n- [x] Iterating over arrays/objects (`.[]`)\n- [x] Optional indexing/iteration (`.a?`, `.[]?`)\n- [x] Array slices (`.[3:7]`, `.[0:-1]`)\n- [x] String slices\n\n\n## Operators\n\n- [x] Composition (`|`)\n- [x] Binding (`. as $x | $x`)\n- [x] Concatenation (`,`)\n- [x] Plain assignment (`=`)\n- [x] Update assignment (`|=`, `+=`, `-=`)\n- [x] Alternation (`//`)\n- [x] Logic (`or`, `and`)\n- [x] Equality and comparison (`.a == .b`, `.a < .b`)\n- [x] Arithmetic (`+`, `-`, `*`, `/`, `%`)\n- [x] Negation (`-`)\n- [x] Error suppression (`?`)\n\n\n## Definitions\n\n- [x] Basic definitions (`def map(f): [.[] | f];`)\n- [x] Recursive definitions (`def r: r; r`)\n\n\n## Core filters\n\n- [x] Empty (`empty`)\n- [x] Errors (`error`)\n- [x] Input (`inputs`)\n- [x] Length (`length`, `utf8bytelength`)\n- [x] Rounding (`floor`, `round`, `ceil`)\n- [x] String <-> JSON (`fromjson`, `tojson`)\n- [x] String <-> integers (`explode`, `implode`)\n- [x] String normalisation (`ascii_downcase`, `ascii_upcase`)\n- [x] String prefix/postfix (`startswith`, `endswith`, `ltrimstr`, `rtrimstr`)\n- [x] String splitting (`split(\"foo\")`)\n- [x] Array filters (`reverse`, `sort`, `sort_by(-.)`, `group_by`, `min_by`, `max_by`)\n- [x] Stream consumers (`first`, `last`, `range`, `fold`)\n- [x] Stream generators (`range`, `recurse`)\n- [x] Time (`now`, `fromdateiso8601`, `todateiso8601`)\n- [x] More numeric filters (`sqrt`, `sin`, `log`, `pow`, ...) ([list of numeric filters](#numeric-filters))\n- [ ] More time filters (`strptime`, `strftime`, `strflocaltime`, `mktime`, `gmtime`, and `localtime`)\n\n## Standard filters\n\nThese filters are defined via more basic filters.\nTheir definitions are at [`std.jq`](jaq-std/src/std.jq).\n\n- [x] Undefined (`null`)\n- [x] Booleans (`true`, `false`, `not`)\n- [x] Special numbers (`nan`, `infinite`, `isnan`, `isinfinite`, `isfinite`, `isnormal`)\n- [x] Type (`type`)\n- [x] Filtering (`select(. >= 0)`)\n- [x] Selection (`values`, `nulls`, `booleans`, `numbers`, `strings`, `arrays`, `objects`, `iterables`, `scalars`)\n- [x] Conversion (`tostring`, `tonumber`)\n- [x] Iterable filters (`map(.+1)`, `map_values(.+1)`, `add`, `join(\"a\")`)\n- [x] Array filters (`transpose`, `first`, `last`, `nth(10)`, `flatten`, `min`, `max`)\n- [x] Object-array conversion (`to_entries`, `from_entries`, `with_entries`)\n- [x] Universal/existential (`all`, `any`)\n- [x] Recursion (`walk`)\n- [x] I/O (`input`)\n- [x] Regular expressions (`test`, `scan`, `match`, `capture`, `splits`, `sub`, `gsub`)\n- [x] Time (`fromdate`, `todate`)\n\n## Numeric filters\n\njaq imports many filters from [libm](https://crates.io/crates/libm)\nand follows their type signature.\n\n<details><summary>Full list of numeric filters defined in jaq</summary>\n\nZero-argument filters:\n\n- [x] `acos`\n- [x] `acosh`\n- [x] `asin`\n- [x] `asinh`\n- [x] `atan`\n- [x] `atanh`\n- [x] `cbrt`\n- [x] `cos`\n- [x] `cosh`\n- [x] `erf`\n- [x] `erfc`\n- [x] `exp`\n- [x] `exp10`\n- [x] `exp2`\n- [x] `expm1`\n- [x] `fabs`\n- [x] `frexp`, which returns pairs of (float, integer).\n- [x] `ilogb`, which returns integers.\n- [x] `j0`\n- [x] `j1`\n- [x] `lgamma`\n- [x] `log`\n- [x] `log10`\n- [x] `log1p`\n- [x] `log2`\n- [x] `logb`\n- [x] `modf`, which returns pairs of (float, float).\n- [x] `nearbyint`\n- [x] `pow10`\n- [x] `rint`\n- [x] `significand`\n- [x] `sin`\n- [x] `sinh`\n- [x] `sqrt`\n- [x] `tan`\n- [x] `tanh`\n- [x] `tgamma`\n- [x] `trunc`\n- [x] `y0`\n- [x] `y1`\n\nTwo-argument filters that ignore `.`:\n\n- [x] `atan2`\n- [x] `copysign`\n- [x] `drem`\n- [x] `fdim`\n- [x] `fmax`\n- [x] `fmin`\n- [x] `fmod`\n- [x] `hypot`\n- [x] `jn`, which takes an integer as first argument.\n- [x] `ldexp`, which takes an integer as second argument.\n- [x] `nextafter`\n- [x] `nexttoward`\n- [x] `pow`\n- [x] `remainder`\n- [x] `scalb`\n- [x] `scalbln`, which takes as integer as second argument.\n- [x] `yn`, which takes an integer as first argument.\n\nThree-argument filters that ignore `.`:\n\n- [x] `fma`\n\n</details>\n\n## Advanced features\n\njaq currently does *not* aim to support several features of jq, such as:\n\n- Modules\n- SQL-style operators\n- Streaming\n\n\n\n# Differences between jq and jaq\n\n\n## Numbers\n\njq uses 64-bit floating-point numbers (floats) for any number.\nBy contrast, jaq interprets\nnumbers such as 0   or -42 as machine-sized integers and\nnumbers such as 0.0 or 3e8 as 64-bit floats.\nMany operations in jaq, such as array indexing,\ncheck whether the passed numbers are indeed integer.\nThe motivation behind this is to avoid\nrounding errors that may silently lead to wrong results.\nFor example:\n\n    $ jq  -n '[0, 1, 2] | .[1.0000000000000001]'\n    1\n    $ jaq -n '[0, 1, 2] | .[1.0000000000000001]'\n    Error: cannot use 1.0 as integer\n    $ jaq -n '[0, 1, 2] | .[1]'\n    1\n\nThe rules of jaq are:\n\n* The sum, difference, product, and remainder of two integers is integer.\n* Any other operation between two numbers yields a float.\n\nExamples:\n\n    $ jaq -n '1 + 2'\n    3\n    $ jaq -n '10 / 2'\n    5.0\n    $ jaq -n '1.0 + 2'\n    3.0\n\nYou can convert an integer to a floating-point number e.g.\nby adding 0.0, by multiplying with 1.0, or by dividing with 1.\nYou can convert a floating-point number to an integer by\n`round`, `floor`, or `ceil`:\n\n    $ jaq -n '1.2 | [floor, round, ceil]'\n    [1, 1, 2]\n\n### NaN and infinity\n\nIn jq, division by 0 has some surprising properties; for example,\n`0 / 0` yields `nan`, whereas\n`0 as $n | $n / 0` yields an error.\nIn jaq, `n / 0` yields `nan` if `n == 0`, `infinite` if `n > 0`, and `-infinite` if `n < 0`.\njaq's behaviour is closer to the IEEE standard for floating-point arithmetic (IEEE 754).\n\njaq implements a total ordering on floating-point numbers to allow sorting values.\nTherefore, it unfortunately has to enforce that `nan == nan`.\n(jq gets around this by enforcing `nan < nan`, which breaks basic laws about total orders.)\n\nLike jq, jaq prints `nan` and `infinite` as `null` in JSON,\nbecause JSON does not support encoding these values as numbers.\n\n### Preservation of fractional numbers\n\njaq preserves fractional numbers coming from JSON data perfectly\n(as long as they are not used in some arithmetic operation),\nwhereas jq may silently convert to 64-bit floating-point numbers:\n\n    $ echo '1e500' | jq '.'\n    1.7976931348623157e+308\n    $ echo '1e500' | jaq '.'\n    1e500\n\nTherefore, unlike jq 1.6, jaq satisfies the following paragraph in the [jq manual]:\n\n> An important point about the identity filter is that\n> it guarantees to preserve the literal decimal representation of values.\n> This is particularly important when dealing with numbers which can't be\n> losslessly converted to an IEEE754 double precision representation.\n\nPlease note that newer development versions of jq (e.g. commit cff5336)\nseem to preserve the literal decimal representation,\neven if it is not stated in the manual.\n\n\n## Assignments\n\nLike jq, jaq allows for assignments of the form `p |= f`.\nHowever, jaq interprets these assignments differently.\nFortunately, in most cases, the result is the same.\n\nIn jq, an assignment `p |= f` first constructs paths to all values that match `p`.\n*Only then*, it applies the filter `f` to these values.\n\nIn jaq, an assignment `p |= f` applies `f` *immediately* to any value matching `p`.\nUnlike in jq, assignment does not explicitly construct paths.\n\njaq's implementation of assignment likely yields higher performance,\nbecause it does not construct paths.\nFurthermore, this also prevents several bugs in jq \"by design\".\nFor example, given the filter `[0, 1, 2, 3] | .[] |= empty`,\njq  yields `[1, 3]`, whereas\njaq yields `[]`.\nWhat happens here?\n\njq first constructs the paths corresponding to `.[]`, which are `.0, .1, .2, .3`.\nThen, it removes the element at each of these paths.\nHowever, each of these removals *changes* the value that the remaining paths refer to.\nThat is, after removing `.0` (value 0), `.1` does not refer to value 1, but value 2!\nThat is also why value 1 (and in consequence also value 3) is not removed.\n\nThere is more weirdness ahead in jq;\nfor example, `0 | 0 |= .+1` yields `1` in jq,\nalthough `0` is not a valid path expression.\nHowever, `1 | 0 |= .+1` yields an error.\nIn jaq, any such assignment yields an error.\n\njaq attempts to use multiple outputs of the right-hand side, whereas\njq uses only the first.\nFor example, `0 | (., .) |= (., .+1)` yields `0 1 1 2` in jaq,\nwhereas it yields only `0` in jq.\nHowever, `{a: 1} | .a |= (2, 3)` yields `{\"a\": 2}` in both jaq and jq,\nbecause an object can only associate a single value with any given key,\nso we cannot use multiple outputs in a meaningful way here.\n\nBecause jaq does not construct paths,\nit does not allow some filters on the left-hand side of assignments,\nfor example `first`, `last`, `limit`:\nFor example, `[1, 2, 3] | first(.[]) |= .-1`\nyields `[0, 2, 3]` in jq, but is invalid in jaq.\nSimilarly, `[1, 2, 3] | limit(2; .[]) |= .-1`\nyields `[0, 1, 3]` in jq, but is invalid in jaq.\n(Inconsequentially, jq also does not allow for `last`.)\n\n\n## Definitions\n\nLike jq, jaq allows for the definition of filters, such as:\n\n    def map(f): [.[] | f];\n\nArguments can also be passed *by value*, such as:\n\n    def cartesian($f; $g): [$f, $g];\n\nFilter definitions can be nested and recursive, i.e. refer to themselves.\nThat is, a filter such as `recurse` can be defined in jaq:\n\n    def recurse(f): def r: ., (f | r); r;\n\nHowever, note that unlike jq, jaq does not optimise tail calls.\nTherefore, using the above definition of `recurse`, e.g. by `last(recurse(.))`,\ngrows the stack in jaq (leading to a stack overflow), while it does not in jq.\nAs a remedy, jaq provides `recurse` as core filter,\nwhich tries to avoid growing the stack if possible.\n\nCompared to jq, jaq imposes an important syntactic restriction on recursive filters,\nnamely that *recursive filters may only have variable arguments*.\nThat is, in jaq, we cannot define a filter like:\n\n    def f(a): a, f(1+a);\n\nRecursive filters with non-variable arguments can yield surprising effects;\nfor example, a call `f(0)` builds up calls of the shape `f(1+(..(1+0)...))`,\nwhich leads to exponential execution times.\n\nRecursive filters with non-variable arguments can\nvery frequently be alternatively implemented by either:\n\n* A nested filter: for example, instead of\n  `def walk(f): (.[]? |= walk(f)) | f;`, you can use\n  `def walk(f): def rec: (.[]? |= rec) | f; rec;`.\n* A filter with variable arguments: for example, instead of\n  `def f(a): a, f(1+a);`, you can equally well write\n  `def f($a): $a, f(1+$a);`.\n* A filter with `recurse`: for example, you may write\n  `def f(a): a | recurse(1+.);`.\n  If you expect your filter to recurse deeply,\n  it is advised to implement it using `recurse`,\n  because jaq has an optimised implementation of `recurse`.\n\nAll of these options are supported by jaq.\n\n\n## Arguments\n\nLike jq, jaq allows to define arguments via the command line,\nin particular by the options `--arg`, `--rawfile`, `--slurpfile`.\nThis binds variables to values, and\nfor every variable `$x` bound to `v` this way,\n`$ARGS.named` contains an entry with key `x` and value `v`.\nFor example:\n\n~~~\n$ jaq -n --arg x 1 --arg y 2 '$x, $y, $ARGS.named'\n\"1\"\n\"2\"\n{\n  \"x\": \"1\",\n  \"y\": \"2\"\n}\n~~~\n\n\n## Folding\n\njq and jaq provide filters\n`reduce xs as $x (init; f)` and\n`foreach xs as $x (init; f)`.\n\nIn jaq, the output of these filters is defined very simply:\nAssuming that `xs` evaluates to `x0`, `x1`, ..., `xn`,\n`reduce xs as $x (init; f)` evaluates to\n\n~~~\ninit\n| x0 as $x | f\n| ...\n| xn as $x | f\n~~~\n\nand `foreach xs as $x (init; f)` evaluates to\n\n~~~ text\ninit\n| x0 as $x | f | (.,\n| ...\n| xn as $x | f | (.,\nempty)...)\n~~~\n\nAdditionally, jaq provides the filter `for xs as $x (init; f)` that evaluates to\n\n~~~ text\ninit\n| ., (x0 as $x | f\n| ...\n| ., (xn as $x | f\n)...)\n~~~\n\nThe difference between `foreach` and `for` is that\n`for` yields the output of `init`, whereas `foreach` omits it.\nFor example,\n`foreach (1, 2, 3) as $x (0; .+$x)` yields `1, 3, 6`, whereas\n`for (1, 2, 3) as $x (0; .+$x)` yields `0, 1, 3, 6`.\n\nThe interpretation of `reduce`/`foreach` in jaq has the following advantages over jq:\n\n* It deals very naturally with filters that yield multiple outputs.\n  In contrast, jq discriminates outputs of `f`,\n  because it recurses only on the last of them,\n  although it outputs all of them.\n  <details><summary>Example</summary>\n  `foreach (5, 10) as $x (1; .+$x, -.)` yields\n  `6, -1, 9, 1` in jq, whereas it yields\n  `6, 16, -6, -1, 9, 1` in jaq.\n  We can see that both jq and jaq yield the values `6` and `-1`\n  resulting from the first iteration (where `$x` is 5), namely\n  `1 | 5 as $x | (.+$x, -.)`.\n  However, jq performs the second iteration (where `$x` is 10)\n  *only on the last value* returned from the first iteration, namely `-1`,\n  yielding the values `9` and `1` resulting from\n  `-1 | 10 as $x | (.+$x, -.)`.\n  jaq yields these values too, but it also performs the second iteration\n  on all other values returned from the first iteration, namely `6`,\n  yielding the values `16` and `-6` that result from\n  ` 6 | 10 as $x | (.+$x, -.)`.\n  </details>\n* It makes the implementation of `reduce` and `foreach`\n  special cases of the same code, reducing the potential for bugs.\n\nCompared to `foreach ...`, the filter `for ...`\n(where `...` refers to `xs as $x (init; f)`)\nhas a stronger relationship with `reduce`.\nIn particular,\nthe values yielded by `reduce ...` are a subset of\nthe values yielded by `for ...`.\nThis does not hold if you replace `for` by `foreach`.\n<details>\nAs an example, if we set `...` to `empty as $x (0; .+$x)`, then\n`foreach ...` yields no value, whereas\n`for ...` and `reduce ...` yield `0`.\n</details>\n\nFurthermore, jq provides the filter\n`foreach xs as $x (init; f; proj)` (`foreach/3`) and interprets\n`foreach xs as $x (init; f)` (`foreach/2`) as\n`foreach xs as $x (init; f; .)`, whereas\njaq does *not* provide `foreach/3` because\nit requires completely separate logic from `foreach/2` and `reduce`\nin both the parser and the interpreter.\n\n\n## Error handling\n\nIn jq, the `try f catch g` expression breaks out of the `f` stream as\nsoon as an error occurs, ceding control to `g` after that. This is\nmentioned in its manual as a possible mechanism for breaking out of\nloops\n([here](https://jqlang.github.io/jq/manual/#breaking-out-of-control-structures)). jaq\nhowever doesn't interrupt the `f` stream, but instead sends _each_\nerror value emitted to the `g` filter; the result is a stream of\nvalues emitted from `f` with values emitted from `g` interspersed\nwhere errors ocurred.\n\nConsider the following example: this expression is `true` in jq,\nbecause the first `error(2)` interrupts the stream:\n\n```jq\n[try (1, error(2), 3, error(4)) catch .] == [1, 2]\n```\n\nIn jaq however, this holds:\n\n```jq\n[try (1, error(2), 3, error(4)) catch .] == [1, 2, 3, 4]\n```\n\n\n## Miscellaneous\n\n* Slurping: When files are slurped in (via the `-s` / `--slurp` option),\n  jq combines the inputs of all files into one single array, whereas\n  jaq yields an array for every file.\n  The behaviour of jq can be approximated in jaq;\n  for example, to achieve the output of\n  `jq -s . a b`, you may use\n  `jaq -s . <(cat a b)`.\n* Cartesian products:\n  In jq, `[(1,2) * (3,4)]` yields `[3, 6, 4, 8]`, whereas\n  `[{a: (1,2), b: (3,4)} | .a * .b]` yields `[3, 4, 6, 8]`.\n  jaq yields `[3, 4, 6, 8]` in both cases.\n* List updating:\n  In jq, `[0, 1] | .[3] = 3` yields `[0, 1, null, 3]`; that is,\n  jq fills up the list with `null`s if we update beyond its size.\n  In contrast, jaq fails with an out-of-bounds error in such a case.\n* Input reading:\n  When there is no more input value left,\n  in jq, `input` yields an error, whereas in jaq, it yields no output value.\n* Joining:\n  When given an array `[x0, x1, ..., xn]`,\n  in jq, `join(x)` converts all elements of the input array to strings and intersperses them with `x`, whereas\n  in jaq, `join(x)` simply calculates `x0 + x + x1 + x + ... + xn`.\n  When all elements of the input array and `x` are strings, jq and jaq yield the same output.\n* Ranges:\n  The filter `range(m; n)` constructs a sequence of numbers `m, m+1, ...`,\n  where any number must be smaller than `n`.\n  In jq,  `m` and `n` can be floating-point numbers, whereas\n  in jaq, `m` and `n` must be integers.\n  This is to avoid potential numerical stability problems.\n  That means that unlike in jq, you cannot use\n  `range(m; infinite)` to generate the infinite sequence `m, m+1, ...`.\n  However, you can use `m | recurse(.+1)` to achieve the same in jaq.\n\n\n\n# Contributing\n\nContributions to jaq are welcome.\nPlease make sure that after your change, `cargo test` runs successfully.\n\n\n\n# Acknowledgements\n\njaq has profited tremendously from:\n\n* [serde_json] to read and [colored_json] to output JSON,\n* [chumsky] to parse and [ariadne] to pretty-print parse errors,\n* [mimalloc] to boost the performance of memory allocation, and\n* the Rust standard library, in particular its awesome [Iterator],\n  which builds the rock-solid base of jaq's filter execution\n\n[serde_json]: https://docs.rs/serde_json/\n[colored_json]: https://docs.rs/colored_json/\n[chumsky]: https://docs.rs/chumsky/\n[ariadne]: https://docs.rs/ariadne/\n[mimalloc]: https://docs.rs/mimalloc/\n[Iterator]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"
}
