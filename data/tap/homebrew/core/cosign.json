{
  "name": "cosign",
  "full_name": "cosign",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Container Signing",
  "license": "Apache-2.0",
  "homepage": "https://github.com/sigstore/cosign",
  "versions": {
    "stable": "2.1.1",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/sigstore/cosign.git",
      "tag": "v2.1.1",
      "revision": "baf97ccb4926ed09c8f204b537dc0ee77b60d043",
      "checksum": null
    },
    "head": {
      "url": "https://github.com/sigstore/cosign.git",
      "branch": "main"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/cosign/blobs/sha256:f0bd4b24fdaac8bdcd953dba37bf4a6095a242080ef3f41113b2607143fbefb2",
          "sha256": "f0bd4b24fdaac8bdcd953dba37bf4a6095a242080ef3f41113b2607143fbefb2"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/cosign/blobs/sha256:f0bd4b24fdaac8bdcd953dba37bf4a6095a242080ef3f41113b2607143fbefb2",
          "sha256": "f0bd4b24fdaac8bdcd953dba37bf4a6095a242080ef3f41113b2607143fbefb2"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/cosign/blobs/sha256:f0bd4b24fdaac8bdcd953dba37bf4a6095a242080ef3f41113b2607143fbefb2",
          "sha256": "f0bd4b24fdaac8bdcd953dba37bf4a6095a242080ef3f41113b2607143fbefb2"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/cosign/blobs/sha256:607ca3c712b2da173946a586c73346c5c1af279e51add32ef3dd4b70341e5473",
          "sha256": "607ca3c712b2da173946a586c73346c5c1af279e51add32ef3dd4b70341e5473"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/cosign/blobs/sha256:e23dec10f6f6e8f747e1aaf2767a0aa6e67ead5df194e3401f3c0992d13380f6",
          "sha256": "e23dec10f6f6e8f747e1aaf2767a0aa6e67ead5df194e3401f3c0992d13380f6"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/cosign/blobs/sha256:0a5f7d30a7a7af9e6988c28ce394b238c3f8b0ec1eec4bdc3faa31e211ee7bbb",
          "sha256": "0a5f7d30a7a7af9e6988c28ce394b238c3f8b0ec1eec4bdc3faa31e211ee7bbb"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/cosign/blobs/sha256:16b8466b66123eb4bb56816578c95738fa815e9e5f254ccb909a133213f9d850",
          "sha256": "16b8466b66123eb4bb56816578c95738fa815e9e5f254ccb909a133213f9d850"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "go"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/cosign.rb",
  "ruby_source_checksum": {
    "sha256": "f7d3245bb170e5c2d58fbfc32342cb23d9182e9943264e0e86d54709ef7de697"
  },
  "date_added": "2021-09-06T20:05:02+00:00",
  "readme": "<p align=\"center\">\n  <img style=\"max-width: 100%;width: 300px;\" src=\"https://raw.githubusercontent.com/sigstore/community/main/artwork/cosign/horizontal/color/sigstore_cosign-horizontal-color.svg\" alt=\"Cosign logo\"/>\n</p>\n\n# cosign\n\nSigning OCI containers (and other artifacts) using [Sigstore](https://sigstore.dev/)!\n\n[![Go Report Card](https://goreportcard.com/badge/github.com/sigstore/cosign)](https://goreportcard.com/report/github.com/sigstore/cosign)\n[![e2e-tests](https://github.com/sigstore/cosign/actions/workflows/e2e-tests.yml/badge.svg)](https://github.com/sigstore/cosign/actions/workflows/e2e-tests.yml)\n[![CII Best Practices](https://bestpractices.coreinfrastructure.org/projects/5715/badge)](https://bestpractices.coreinfrastructure.org/projects/5715)\n[![OpenSSF Scorecard](https://api.securityscorecards.dev/projects/github.com/sigstore/cosign/badge)](https://api.securityscorecards.dev/projects/github.com/sigstore/cosign)\n\nCosign aims to make signatures **invisible infrastructure**.\n\nCosign supports:\n\n* \"Keyless signing\" with the Sigstore public good Fulcio certificate authority and Rekor transparency log (default)\n* Hardware and KMS signing\n* Signing with a cosign generated encrypted private/public keypair\n* Container Signing, Verification and Storage in an OCI registry.\n* Bring-your-own PKI\n\n## Info\n\n`Cosign` is developed as part of the [`sigstore`](https://sigstore.dev) project.\nWe also use a [slack channel](https://sigstore.slack.com)!\nClick [here](https://join.slack.com/t/sigstore/shared_invite/zt-mhs55zh0-XmY3bcfWn4XEyMqUUutbUQ) for the invite link.\n\n## Installation\n\nFor Homebrew, Arch, Nix, GitHub Action, and Kubernetes installs see the [installation docs](https://docs.sigstore.dev/system_config/installation/).\n\nFor Linux and macOS binaries see the [GitHub release assets](https://github.com/sigstore/cosign/releases/latest).\n\n:rotating_light: If you are downloading releases of cosign from our GCS bucket - please see more information on the July 31, 2023 [deprecation notice](https://blog.sigstore.dev/cosign-releases-bucket-deprecation/) :rotating_light:\n\n## Developer Installation\n\nIf you have Go 1.19+, you can setup a development environment:\n\n```shell\n$ git clone https://github.com/sigstore/cosign\n$ cd cosign\n$ go install ./cmd/cosign\n$ $(go env GOPATH)/bin/cosign\n```\n\n## Contributing\n\nIf you are interested in contributing to `cosign`, please read the [contributing documentation](./CONTRIBUTING.md).\n\n## Dockerfile\n\nHere is how to install and use cosign inside a Dockerfile through the gcr.io/projectsigstore/cosign image:\n\n```shell\nFROM gcr.io/projectsigstore/cosign:v1.13.0 as cosign-bin\n\n# Source: https://github.com/chainguard-images/static\nFROM cgr.dev/chainguard/static:latest\nCOPY --from=cosign-bin /ko-app/cosign /usr/local/bin/cosign\nENTRYPOINT [ \"cosign\" ]\n```\n\n## Quick Start\n\nThis shows how to:\n* sign a container image with the default \"keyless signing\" method (see [KEYLESS.md](./KEYLESS.md))\n* verify the container image\n\n### Sign a container and store the signature in the registry\n\nNote that you should always sign images based on their digest (`@sha256:...`)\nrather than a tag (`:latest`) because otherwise you might sign something you\ndidn't intend to!\n\n```shell\n cosign sign $IMAGE\n\nGenerating ephemeral keys...\nRetrieving signed certificate...\n\n\tNote that there may be personally identifiable information associated with this signed artifact.\n\tThis may include the email address associated with the account with which you authenticate.\n\tThis information will be used for signing this artifact and will be stored in public transparency logs and cannot be removed later.\n\nBy typing 'y', you attest that you grant (or have permission to grant) and agree to have this information stored permanently in transparency logs.\nAre you sure you would like to continue? [y/N] y\nYour browser will now be opened to:\nhttps://oauth2.sigstore.dev/auth/auth?access_type=online&client_id=sigstore&code_challenge=OrXitVKUZm2lEWHVt1oQWR4HZvn0rSlKhLcltglYxCY&code_challenge_method=S256&nonce=2KvOWeTFxYfxyzHtssvlIXmY6Jk&redirect_uri=http%3A%2F%2Flocalhost%3A57102%2Fauth%2Fcallback&response_type=code&scope=openid+email&state=2KvOWfbQJ1caqScgjwibzK2qJmb\nSuccessfully verified SCT...\ntlog entry created with index: 12086900\nPushing signature to: $IMAGE\n```\n\nCosign will prompt you to authenticate via OIDC, where you'll sign in with your email address.\nUnder the hood, cosign will request a code signing certificate from the Fulcio certificate authority.\nThe subject of the certificate will match the email address you logged in with.\nCosign will then store the signature and certificate in the Rekor transparency log, and upload the signature to the OCI registry alongside the image you're signing.\n\n\n### Verify a container\n\nTo verify the image, you'll need to pass in the expected certificate issuer and certificate subject via the `--certificate-identity` and `--certificate-oidc-issuer` flags:\n\n```\ncosign verify $IMAGE --certificate-identity=$IDENTITY --certificate-oidc-issuer=$OIDC_ISSUER\n```\n\nYou can also pass in a regex for the certificate identity and issuer flags, `--certificate-identity-regexp` and `--certificate-oidc-issuer-regexp`.\n\n### Verify a container against a public key\n\nThis command returns `0` if *at least one* `cosign` formatted signature for the image is found\nmatching the public key.\nSee the detailed usage below for information and caveats on other signature formats.\n\nAny valid payloads are printed to stdout, in json format.\nNote that these signed payloads include the digest of the container image, which is how we can be\nsure these \"detached\" signatures cover the correct image.\n\n```shell\n$ cosign verify --key cosign.pub $IMAGE_URI:1h\nThe following checks were performed on these signatures:\n  - The cosign claims were validated\n  - The signatures were verified against the specified public key\n{\"Critical\":{\"Identity\":{\"docker-reference\":\"\"},\"Image\":{\"Docker-manifest-digest\":\"sha256:87ef60f558bad79beea6425a3b28989f01dd417164150ab3baab98dcbf04def8\"},\"Type\":\"cosign container image signature\"},\"Optional\":null}\n```\n\n\n### What ** is not ** production ready?\n\nWhile parts of `cosign` are stable, we are continuing to experiment and add new features.\nThe following feature set is not considered stable yet, but we are committed to stabilizing it over time!\n\n#### Formats/Specifications\n\nWhile the `cosign` code for uploading, signing, retrieving, and verifying several artifact types is stable,\nthe format specifications for some of those types may not be considered stable yet.\nSome of these are developed outside of the `cosign` project, so we are waiting for them to stabilize first.\n\nThese include:\n\n* The SBOM specification for storing SBOMs in a container registry\n* The In-Toto attestation format\n\n## Working with Other Artifacts\n\nOCI registries are useful for storing more than just container images!\n`Cosign` also includes some utilities for publishing generic artifacts, including binaries, scripts, and configuration files using the OCI protocol.\n\nThis section shows how to leverage these for an easy-to-use, backwards-compatible artifact distribution system that integrates well with the rest of Sigstore.\n\n### Blobs\n\nYou can publish an artifact with `cosign upload blob`:\n\n```shell\n$ echo \"my first artifact\" > artifact\n$ BLOB_SUM=$(shasum -a 256 artifact | cut -d' ' -f 1)\nc69d72c98b55258f9026f984e4656f0e9fd3ef024ea3fac1d7e5c7e6249f1626  artifact\nBLOB_NAME=my-artifact-(uuidgen | head -c 8 | tr 'A-Z' 'a-z')\n$ BLOB_URI=ttl.sh/$BLOB_NAME:1h\n$ BLOB_URI_DIGEST=$(cosign upload blob -f artifact $BLOB_URI)\nUploading file from [artifact] to [ttl.sh/my-artifact-f42c22e0:5m] with media type [text/plain]\nFile [artifact] is available directly at [ttl.sh/v2/my-artifact-f42c22e0/blobs/sha256:c69d72c98b55258f9026f984e4656f0e9fd3ef024ea3fac1d7e5c7e6249f1626]\nUploaded image to:\nttl.sh/my-artifact-f42c22e0@sha256:790d47850411e902aabebc3a684eeb78fcae853d4dd6e1cc554d70db7f05f99f\n```\n\nYour users can download it from the \"direct\" url with standard tools like curl or wget:\n\n```shell\n$ curl -L ttl.sh/v2/$BLOB_NAME/blobs/sha256:$BLOB_SUM > artifact-fetched\n```\n\nThe digest is baked right into the URL, so they can check that as well:\n\n```shell\n$ cat artifact-fetched | shasum -a 256\nc69d72c98b55258f9026f984e4656f0e9fd3ef024ea3fac1d7e5c7e6249f1626  -\n```\n\nYou can sign it with the normal `cosign sign` command and flags:\n\n```shell\n$ cosign sign --key cosign.key $BLOB_URI_DIGEST\nEnter password for private key:\nPushing signature to: ttl.sh/my-artifact-f42c22e0\n```\n\nAs usual, make sure to reference any images you sign by their digest to make sure you don't sign the wrong thing!\n\n#### Tekton Bundles\n\n[Tekton](https://tekton.dev) bundles can be uploaded and managed within an OCI registry.\nThe specification is [here](https://tekton.dev/docs/pipelines/tekton-bundle-contracts/).\nThis means they can also be signed and verified with `cosign`.\n\nTekton Bundles can currently be uploaded with the [tkn cli](https://github.com/tektoncd/cli), but we may add this support to\n`cosign` in the future.\n\n```shell\n$ tkn bundle push us.gcr.io/dlorenc-vmtest2/pipeline:latest -f task-output-image.yaml\nCreating Tekton Bundle:\n        - Added TaskRun:  to image\n\nPushed Tekton Bundle to us.gcr.io/dlorenc-vmtest2/pipeline@sha256:124e1fdee94fe5c5f902bc94da2d6e2fea243934c74e76c2368acdc8d3ac7155\n$ cosign sign --key cosign.key us.gcr.io/dlorenc-vmtest2/pipeline@sha256:124e1fdee94fe5c5f902bc94da2d6e2fea243934c74e76c2368acdc8d3ac7155\nEnter password for private key:\ntlog entry created with index: 5086\nPushing signature to: us.gcr.io/dlorenc-vmtest2/demo:sha256-124e1fdee94fe5c5f902bc94da2d6e2fea243934c74e76c2368acdc8d3ac7155.sig\n```\n\n#### WASM\n\nWeb Assembly Modules can also be stored in an OCI registry, using this [specification](https://github.com/solo-io/wasm/tree/master/spec).\n\nCosign can upload these using the `cosign wasm upload` command:\n\n```shell\n$ cosign upload wasm -f hello.wasm us.gcr.io/dlorenc-vmtest2/wasm\n$ cosign sign --key cosign.key us.gcr.io/dlorenc-vmtest2/wasm@sha256:9e7a511fb3130ee4641baf1adc0400bed674d4afc3f1b81bb581c3c8f613f812\nEnter password for private key:\ntlog entry created with index: 5198\nPushing signature to: us.gcr.io/dlorenc-vmtest2/wasm:sha256-9e7a511fb3130ee4641baf1adc0400bed674d4afc3f1b81bb581c3c8f613f812.sig\n```\n#### eBPF\n\n[eBPF](https://ebpf.io) modules can also be stored in an OCI registry, using this [specification](https://github.com/solo-io/bumblebee/tree/main/spec).\n\nThe image below was built using the `bee` tool. More information can be found [here](https://github.com/solo-io/bumblebee/)\n\nCosign can then sign these images as they can any other OCI image.\n\n```shell\n$ bee build ./examples/tcpconnect/tcpconnect.c localhost:5000/tcpconnect:test\n$ bee push localhost:5000/tcpconnect:test\n$ cosign sign  --key cosign.key localhost:5000/tcpconnect@sha256:7a91c50d922925f152fec96ed1d84b7bc6b2079c169d68826f6cf307f22d40e6\nEnter password for private key:\nPushing signature to: localhost:5000/tcpconnect\n$ cosign verify --key cosign.pub localhost:5000/tcpconnect:test\n\nVerification for localhost:5000/tcpconnect:test --\nThe following checks were performed on each of these signatures:\n  - The cosign claims were validated\n  - The signatures were verified against the specified public key\n\n[{\"critical\":{\"identity\":{\"docker-reference\":\"localhost:5000/tcpconnect\"},\"image\":{\"docker-manifest-digest\":\"sha256:7a91c50d922925f152fec96ed1d84b7bc6b2079c169d68826f6cf307f22d40e6\"},\"type\":\"cosign container image signature\"},\"optional\":null}]\n\n```\n\n#### In-Toto Attestations\n\nCosign also has built-in support for [in-toto](https://in-toto.io) attestations.\nThe specification for these is defined [here](https://github.com/in-toto/attestation).\n\nYou can create and sign one from a local predicate file using the following commands:\n\n```shell\n$ cosign attest --predicate <file> --key cosign.key $IMAGE_URI_DIGEST\n```\n\nAll of the standard key management systems are supported.\nPayloads are signed using the DSSE signing spec, defined [here](https://github.com/secure-systems-lab/dsse).\n\nTo verify:\n\n```shell\n$ cosign verify-attestation --key cosign.pub $IMAGE_URI\n```\n\n## Detailed Usage\n\nSee the [Usage documentation](USAGE.md) for more commands!\n\n## Hardware-based Tokens\n\nSee the [Hardware Tokens documentation](TOKENS.md) for information on how to use `cosign` with hardware.\n\n## Keyless\n\nðŸš¨ ðŸš¨ ðŸš¨ See [here](KEYLESS.md) for info on the experimental Keyless signatures mode. ðŸš¨ ðŸš¨ ðŸš¨\n\n## Registry Support\n\n`cosign` uses [go-containerregistry](https://github.com/google/go-containerregistry) for registry\ninteractions, which has generally excellent compatibility, but some registries may have quirks.\n\nToday, `cosign` has been tested and works against the following registries:\n\n* AWS Elastic Container Registry\n* GCP's Artifact Registry and Container Registry\n* Docker Hub\n* Azure Container Registry\n* JFrog Artifactory Container Registry\n* The CNCF distribution/distribution Registry\n* GitLab Container Registry\n* GitHub Container Registry\n* The CNCF Harbor Registry\n* Digital Ocean Container Registry\n* Sonatype Nexus Container Registry\n* Alibaba Cloud Container Registry\n* Red Hat Quay Container Registry 3.6+ / Red Hat quay.io\n* Elastic Container Registry\n* IBM Cloud Container Registry\n* Cloudsmith Container Registry\n* The CNCF zot Registry\n\nWe aim for wide registry support. To `sign` images in registries which do not yet fully support [OCI media types](https://github.com/sigstore/cosign/blob/main/SPEC.md#object-types), one may need to use `COSIGN_DOCKER_MEDIA_TYPES` to fall back to legacy equivalents. For example:\n\n```shell\nCOSIGN_DOCKER_MEDIA_TYPES=1 cosign sign --key cosign.key legacy-registry.example.com/my/image@$DIGEST\n```\n\nPlease help test and file bugs if you see issues!\nInstructions can be found in the [tracking issue](https://github.com/sigstore/cosign/issues/40).\n\n\n## Caveats\n\n### Intentionally Missing Features\n\n`cosign` only generates ECDSA-P256 keys and uses SHA256 hashes.\nKeys are stored in PEM-encoded PKCS8 format.\nHowever, you can use `cosign` to store and retrieve signatures in any format, from any algorithm.\n\n### Unintentionally Missing Features\n\n`cosign` will integrate with transparency logs!\nSee https://github.com/sigstore/cosign/issues/34 for more info.\n\n`cosign` will integrate with even more transparency logs, and a PKI.\nSee https://github.com/sigStore/fulcio for more info.\n\n`cosign` will also support The Update Framework for delegations, key discovery and expiration.\nSee https://github.com/sigstore/cosign/issues/86 for more info!\n\n### Things That Should Probably Change\n\n#### Payload Formats\n\n`cosign` only supports Red Hat's [simple signing](https://www.redhat.com/en/blog/container-image-signing)\nformat for payloads.\nThat looks like:\n\n```json\n{\n    \"critical\": {\n           \"identity\": {\n               \"docker-reference\": \"testing/manifest\"\n           },\n           \"image\": {\n               \"Docker-manifest-digest\": \"sha256:20be...fe55\"\n           },\n           \"type\": \"cosign container image signature\"\n    },\n    \"optional\": {\n           \"creator\": \"Bob the Builder\",\n           \"timestamp\": 1458239713\n    }\n}\n```\n\n**Note:** This can be generated for an image reference using `cosign generate $IMAGE_URI_DIGEST`.\n\nI'm happy to switch this format to something else if it makes sense.\nSee https://github.com/notaryproject/nv2/issues/40 for one option.\n\n#### Registry Details\n\n`cosign` signatures are stored as separate objects in the OCI registry, with only a weak\nreference back to the object they \"sign\".\nThis means this relationship is opaque to the registry, and signatures *will not* be deleted\nor garbage-collected when the image is deleted.\nSimilarly, they **can** easily be copied from one environment to another, but this is not\nautomatic.\n\nMultiple signatures are stored in a list which is unfortunately a race condition today.\nTo add a signature, clients orchestrate a \"read-append-write\" operation, so the last write\nwill win in the case of contention.\n\n##### Specifying Registry\n\n`cosign` will default to storing signatures in the same repo as the image it is signing.\nTo specify a different repo for signatures, you can set the `COSIGN_REPOSITORY` environment variable.\n\nThis will replace the repo in the provided image like this:\n\n```shell\n$ export COSIGN_REPOSITORY=gcr.io/my-new-repo\n$ cosign sign --key cosign.key $IMAGE_URI_DIGEST\n```\n\nSo the signature for `gcr.io/dlorenc-vmtest2/demo` will be stored in `gcr.io/my-new-repo/demo:sha256-DIGEST.sig`.\n\nNote: different registries might expect different formats for the \"repository.\"\n\n* To use [GCR](https://cloud.google.com/container-registry), a registry name\n  like `gcr.io/$REPO` is sufficient, as in the example above.\n* To use [Artifact Registry](https://cloud.google.com/artifact-registry),\n  specify a full image name like\n  `$LOCATION-docker.pkg.dev/$PROJECT/$REPO/$STORAGE_IMAGE`, not just a\n  repository. For example,\n\n  ```shell\n  $ export COSIGN_REPOSITORY=us-docker.pkg.dev/my-new-repo/demo\n  $ cosign sign --key cosign.key $IMAGE_URI_DIGEST\n  ```\n\n  where the `sha256-DIGEST` will match the digest for\n  `gcr.io/dlorenc-vmtest2/demo`. Specifying just a repo like\n  `$LOCATION-docker.pkg.dev/$PROJECT/$REPO` will not work in Artifact Registry.\n\n\n## Signature Specification\n\n`cosign` is inspired by tools like [minisign](https://jedisct1.github.io/minisign/) and\n[signify](https://www.openbsd.org/papers/bsdcan-signify.html).\n\nGenerated private keys are stored in PEM format.\nThe keys encrypted under a password using scrypt as a KDF and nacl/secretbox for encryption.\n\nThey have a PEM header of `ENCRYPTED SIGSTORE PRIVATE KEY`:\n\n```shell\n-----BEGIN ENCRYPTED SIGSTORE PRIVATE KEY-----\n...\n-----END ENCRYPTED SIGSTORE PRIVATE KEY-----\n```\n\nPublic keys are stored on disk in PEM-encoded standard PKIX format with a header of `PUBLIC KEY`.\n```\n-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAELigCnlLNKgOglRTx1D7JhI7eRw99\nQolE9Jo4QUxnbMy5nUuBL+UZF9qqfm/Dg1BNeHRThHzWh2ki9vAEgWEDOw==\n-----END PUBLIC KEY-----\n```\n\n## Storage Specification\n\n`cosign` stores signatures in an OCI registry, and uses a naming convention (tag based\non the sha256 of what we're signing) for locating the signature index.\n\n<p align=\"center\">\n  <img src=\"/images/signatures.dot.svg\" />\n</p>\n\n`reg.example.com/ubuntu@sha256:703218c0465075f4425e58fac086e09e1de5c340b12976ab9eb8ad26615c3715` has signatures located at `reg.example.com/ubuntu:sha256-703218c0465075f4425e58fac086e09e1de5c340b12976ab9eb8ad26615c3715.sig`\n\nRoughly (ignoring ports in the hostname): `s/:/-/g` and `s/@/:/g` to find the signature index.\n\nSee [Race conditions](#registry-details) for some caveats around this strategy.\n\nAlternative implementations could use transparency logs, local filesystem, a separate repository\nregistry, an explicit reference to a signature index, a new registry API, grafeas, etc.\n\n### Signing subjects\n\n`cosign` only works for artifacts stored as \"manifests\" in the registry today.\nThe proposed mechanism is flexible enough to support signing arbitrary things.\n\n### KMS Support\n\n`cosign` supports using a KMS provider to generate and sign keys.\nRight now cosign supports Hashicorp Vault, AWS KMS, GCP KMS, Azure Key Vault and we are hoping to support more in the future!\n\nSee the [KMS docs](KMS.md) for more details.\n\n### OCI Artifacts\n\nPush an artifact to a registry using [oras](https://github.com/deislabs/oras) (in this case, `cosign` itself!):\n\n```shell\n$ oras push us-central1-docker.pkg.dev/dlorenc-vmtest2/test/artifact ./cosign\nUploading f53604826795 cosign\nPushed us-central1-docker.pkg.dev/dlorenc-vmtest2/test/artifact\nDigest: sha256:551e6cce7ed2e5c914998f931b277bc879e675b74843e6f29bc17f3b5f692bef\n```\n\nNow sign it! Using `cosign` of course:\n\n```shell\n$ cosign sign --key cosign.key us-central1-docker.pkg.dev/dlorenc-vmtest2/test/artifact@sha256:551e6cce7ed2e5c914998f931b277bc879e675b74843e6f29bc17f3b5f692bef\nEnter password for private key:\nPushing signature to: us-central1-docker.pkg.dev/dlorenc-vmtest2/test/artifact:sha256-551e6cce7ed2e5c914998f931b277bc879e675b74843e6f29bc17f3b5f692bef.sig\n```\n\nFinally, verify `cosign` with `cosign` again:\n\n```shell\n$ cosign verify --key cosign.pub  us-central1-docker.pkg.dev/dlorenc-vmtest2/test/artifact@sha256:551e6cce7ed2e5c914998f931b277bc879e675b74843e6f29bc17f3b5f692bef\nThe following checks were performed on each of these signatures:\n  - The cosign claims were validated\n  - The claims were present in the transparency log\n  - The signatures were integrated into the transparency log when the certificate was valid\n  - The signatures were verified against the specified public key\n  - The code-signing certificate was verified using trusted certificate authority certificates\n\n{\"Critical\":{\"Identity\":{\"docker-reference\":\"\"},\"Image\":{\"Docker-manifest-digest\":\"sha256:551e6cce7ed2e5c914998f931b277bc879e675b74843e6f29bc17f3b5f692bef\"},\"Type\":\"cosign container image signature\"},\"Optional\":null}\n```\n\n## FAQ\n\n### Why not use Notary v2\n\nIt's hard to answer this briefly.\nThis post contains some comparisons:\n\n[Notary V2 and Cosign](https://medium.com/@dlorenc/notary-v2-and-cosign-b816658f044d)\n\nIf you find other comparison posts, please send a PR here and we'll link them all.\n\n### Why not use containers/image signing\n\n`containers/image` signing is close to `cosign`, and we reuse payload formats.\n`cosign` differs in that it signs with ECDSA-P256 keys instead of PGP, and stores\nsignatures in the registry.\n\n### Why not use TUF?\n\nI believe this tool is complementary to TUF, and they can be used together.\nI haven't tried yet, but think we can also reuse a registry for TUF storage.\n\n### Why not use Blockchain?\n\nJust kidding. Nobody actually asked this. Don't be that person.\n\n### Why not use $FOO?\n\nSee the next section, [Requirements](#Requirements).\nI designed this tool to meet a few specific requirements, and didn't find\nanything else that met all of these.\nIf you're aware of another system that does meet these, please let me know!\n\n## Design Requirements\n\n* No external services for signature storage, querying, or retrieval\n* We aim for as much registry support as possible\n* Everything should work over the registry API\n* PGP should not be required at all.\n* Users must be able to find all signatures for an image\n* Signers can sign an image after push\n* Multiple entities can sign an image\n* Signing an image does not mutate the image\n* Pure-go implementation\n\n## Future Ideas\n\n### Registry API Changes\n\nThe naming convention and read-modify-write update patterns we use to store things in\na registry are a bit, well, \"hacky\".\nI think they're the best (only) real option available today, but if the registry API\nchanges we can improve these.\n\n### Other Types\n\n`cosign` can sign anything in a registry.\nThese examples show signing a single image, but you could also sign a multi-platform `Index`,\nor any other type of artifact.\nThis includes Helm Charts, Tekton Pipelines, and anything else currently using OCI registries\nfor distribution.\n\nThis also means new artifact types can be uploaded to a registry and signed.\nOne interesting type to store and sign would be TUF repositories.\nI haven't tried yet, but I'm fairly certain TUF could be implemented on top of this.\n\n### Tag Signing\n\n`cosign` signatures protect the digests of objects stored in a registry.\nThe optional `annotations` support (via the `-a` flag to `cosign sign`) can be used to add extra\ndata to the payload that is signed and protected by the signature.\nOne use-case for this might be to sign a tag->digest mapping.\n\nIf you would like to attest that a specific tag (or set of tags) should point at a digest, you can\nrun something like:\n\n```shell\n$ docker push $IMAGE_URI\nThe push refers to repository [dlorenc/demo]\n994393dc58e7: Pushed\n5m: digest: sha256:1304f174557314a7ed9eddb4eab12fed12cb0cd9809e4c28f29af86979a3c870 size: 528\n$ TAG=sign-me\n$ cosign sign --key cosign.key -a tag=$TAG $IMAGE_URI_DIGEST\nEnter password for private key:\nPushing signature to: dlorenc/demo:1304f174557314a7ed9eddb4eab12fed12cb0cd9809e4c28f29af86979a3c870.sig\n```\n\nThen you can verify that the tag->digest mapping is also covered in the signature, using the `-a` flag to `cosign verify`.\nThis example verifies that the digest `$TAG` which points to (`sha256:1304f174557314a7ed9eddb4eab12fed12cb0cd9809e4c28f29af86979a3c870`)\nhas been signed, **and also** that the `tag` annotation has the value `sign-me`:\n\n```shell\n$ cosign verify --key cosign.pub -a tag=$TAG $IMAGE_URI | jq .\n{\n  \"Critical\": {\n    \"Identity\": {\n      \"docker-reference\": \"\"\n    },\n    \"Image\": {\n      \"Docker-manifest-digest\": \"97fc222cee7991b5b061d4d4afdb5f3428fcb0c9054e1690313786befa1e4e36\"\n    },\n    \"Type\": \"cosign container image signature\"\n  },\n  \"Optional\": {\n    \"tag\": \"sign-me\"\n  }\n}\n```\n\nTimestamps could also be added here, to implement TUF-style freeze-attack prevention.\n\n### Base Image/Layer Signing\n\nAgain, `cosign` can sign anything in a registry.\nYou could use `cosign` to sign an image that is intended to be used as a base image,\nand include that provenance metadata in resulting derived images.\nThis could be used to enforce that an image was built from an authorized base image.\n\nRough Idea:\n* OCI manifests have an ordered list of `layer` `Descriptors`, which can contain annotations.\n  See [here](https://github.com/opencontainers/image-spec/blob/master/manifest.md) for the\n  specification.\n* A base image is an ordered list of layers to which other layers are appended, as well as an\n  initial configuration object that is mutated.\n  * A derived image is free to completely delete/destroy/recreate the config from its base image,\n    so signing the config would provided limited value.\n* We can sign the full set of ordered base layers, and attach that signature as an annotation to\n  the **last** layer in the resulting child image.\n\nThis example manifest manifest represents an image that has been built from a base image with two\nlayers.\nOne additional layer is added, forming the final image.\n\n```json\n{\n  \"schemaVersion\": 2,\n  \"config\": {\n    \"mediaType\": \"application/vnd.oci.image.config.v1+json\",\n    \"size\": 7023,\n    \"digest\": \"sha256:b5b2b2c507a0944348e0303114d8d93aaaa081732b86451d9bce1f432a537bc7\"\n  },\n  \"layers\": [\n    {\n      \"mediaType\": \"application/vnd.oci.image.layer.v1.tar+gzip\",\n      \"size\": 32654,\n      \"digest\": \"sha256:9834876dcfb05cb167a5c24953eba58c4ac89b1adf57f28f2f9d09af107ee8f0\"\n    },\n    {\n      \"mediaType\": \"application/vnd.oci.image.layer.v1.tar+gzip\",\n      \"size\": 16724,\n      \"digest\": \"sha256:3c3a4604a545cdc127456d94e421cd355bca5b528f4a9c1905b15da2eb4a4c6b\",\n      \"annotations\": {\n        \"dev.cosign.signature.baseimage\": \"Ejy6ipGJjUzMDoQFePWixqPBYF0iSnIvpMWps3mlcYNSEcRRZelL7GzimKXaMjxfhy5bshNGvDT5QoUJ0tqUAg==\"\n      }\n    },\n    {\n      \"mediaType\": \"application/vnd.oci.image.layer.v1.tar+gzip\",\n      \"size\": 73109,\n      \"digest\": \"sha256:ec4b8955958665577945c89419d1af06b5f7636b4ac3da7f12184802ad867736\"\n    }\n  ],\n}\n```\n\nNote that this could be applied recursively, for multiple intermediate base images.\n\n### Counter-Signing\n\nCosign signatures (and their protected payloads) are stored as artifacts in a registry.\nThese signature objects can also be signed, resulting in a new, \"counter-signature\" artifact.\nThis \"counter-signature\" protects the signature (or set of signatures) **and** the referenced artifact, which allows\nit to act as an attestation to the **signature(s) themselves**.\n\nBefore we sign the signature artifact, we first give it a memorable name so we can find it later.\n\n```shell\n$ cosign sign --key cosign.key -a sig=original $IMAGE_URI_DIGEST\nEnter password for private key:\nPushing signature to: dlorenc/demo:sha256-97fc222cee7991b5b061d4d4afdb5f3428fcb0c9054e1690313786befa1e4e36.sig\n$ cosign verify --key cosign.pub dlorenc/demo | jq .\n{\n  \"Critical\": {\n    \"Identity\": {\n      \"docker-reference\": \"\"\n    },\n    \"Image\": {\n      \"Docker-manifest-digest\": \"97fc222cee7991b5b061d4d4afdb5f3428fcb0c9054e1690313786befa1e4e36\"\n    },\n    \"Type\": \"cosign container image signature\"\n  },\n  \"Optional\": {\n    \"sig\": \"original\"\n  }\n}\n```\n\n<!-- TODO: https://github.com/sigstore/cosign/issues/2333 -->\n\nNow give that signature a memorable name, then sign that:\n\n```shell\n$ crane tag $(cosign triangulate $IMAGE_URI) mysignature\n2021/02/15 20:22:55 dlorenc/demo:mysignature: digest: sha256:71f70e5d29bde87f988740665257c35b1c6f52dafa20fab4ba16b3b1f4c6ba0e size: 556\n$ cosign sign --key cosign.key -a sig=counter dlorenc/demo:mysignature\nEnter password for private key:\nPushing signature to: dlorenc/demo:sha256-71f70e5d29bde87f988740665257c35b1c6f52dafa20fab4ba16b3b1f4c6ba0e.sig\n$ cosign verify --key cosign.pub dlorenc/demo:mysignature\n{\"Critical\":{\"Identity\":{\"docker-reference\":\"\"},\"Image\":{\"Docker-manifest-digest\":\"71f70e5d29bde87f988740665257c35b1c6f52dafa20fab4ba16b3b1f4c6ba0e\"},\"Type\":\"cosign container image signature\"},\"Optional\":{\"sig\":\"counter\"}}\n```\n\nFinally, check the original signature:\n\n```shell\n$ crane manifest dlorenc/demo@sha256:71f70e5d29bde87f988740665257c35b1c6f52dafa20fab4ba16b3b1f4c6ba0e\n{\n  \"schemaVersion\": 2,\n  \"config\": {\n    \"mediaType\": \"application/vnd.oci.image.config.v1+json\",\n    \"size\": 233,\n    \"digest\": \"sha256:3b25a088710d03f39be26629d22eb68cd277a01673b9cb461c4c24fbf8c81c89\"\n  },\n  \"layers\": [\n    {\n      \"mediaType\": \"application/vnd.oci.descriptor.v1+json\",\n      \"size\": 217,\n      \"digest\": \"sha256:0e79a356609f038089088ec46fd95f4649d04de989487220b1a0adbcc63fadae\",\n      \"annotations\": {\n        \"dev.sigstore.cosign/signature\": \"5uNZKEP9rm8zxAL0VVX7McMmyArzLqtxMTNPjPO2ns+5GJpBeXg+i9ILU+WjmGAKBCqiexTxzLC1/nkOzD4cDA==\"\n      }\n    }\n  ]\n}\n```\n\n## Release Cadence\n\nWe are intending to move to a monthly cadence for minor releases.\nMinor releases will be published around the beginning of the month.\nWe may cut a patch release instead, if the changes are small enough not to warrant a minor release.\nWe will also cut patch releases periodically as needed to address bugs.\n\n## Security\n\nShould you discover any security issues, please refer to sigstore's [security\nprocess](https://github.com/sigstore/.github/blob/main/SECURITY.md)\n\n## PEM files in GitHub Release Assets\n\nThe GitHub release assets for cosign contain a PEM file produced by [GoReleaser](https://github.com/sigstore/cosign/blob/ac999344eb381ae91455b0a9c5c267e747608d76/.goreleaser.yml#L166) while signing the cosign blob that is used to verify the integrity of the release binaries. This file is not used by cosign itself, but is provided for users who wish to verify the integrity of the release binaries. \n\nBy default, cosign output these PEM files in [base64 encoded format](https://github.com/sigstore/cosign/blob/main/doc/cosign_sign-blob.md#options), this approach might be good for air-gapped environments where the PEM file is stored in a file system. So, you should decode these PEM files before using them to verify the blobs."
}
