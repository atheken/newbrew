{
  "name": "x11vnc",
  "full_name": "x11vnc",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "VNC server for real X displays",
  "license": "GPL-2.0-or-later with openvpn-openssl-exception",
  "homepage": "https://github.com/LibVNC/x11vnc",
  "versions": {
    "stable": "0.9.16",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/LibVNC/x11vnc/archive/0.9.16.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "885e5b5f5f25eec6f9e4a1e8be3d0ac71a686331ee1cfb442dba391111bd32bd"
    },
    "head": {
      "url": "https://github.com/LibVNC/x11vnc.git",
      "branch": "master"
    }
  },
  "revision": 1,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/x11vnc/blobs/sha256:149fbe8e1ec220543b848e416642d67c02c291dff1d92be07ab795c5dcff68ae",
          "sha256": "149fbe8e1ec220543b848e416642d67c02c291dff1d92be07ab795c5dcff68ae"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/x11vnc/blobs/sha256:1a1da7cf49c8db71624ab470a44a19fadeb7a2c7097aee491b84dbd00cf6eae2",
          "sha256": "1a1da7cf49c8db71624ab470a44a19fadeb7a2c7097aee491b84dbd00cf6eae2"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/x11vnc/blobs/sha256:18957522ad8fcef3f0f402d9c83c0fcf7754af1f05a1319527c1794c59f333de",
          "sha256": "18957522ad8fcef3f0f402d9c83c0fcf7754af1f05a1319527c1794c59f333de"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/x11vnc/blobs/sha256:885177de8737aa58f7af2bbe1321aab8c68280237f2236df74810f1d5122245c",
          "sha256": "885177de8737aa58f7af2bbe1321aab8c68280237f2236df74810f1d5122245c"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/x11vnc/blobs/sha256:825a2a9601050e1b2170f75f3a3b994262ff973dbcb98fa74155e1a8f5d80260",
          "sha256": "825a2a9601050e1b2170f75f3a3b994262ff973dbcb98fa74155e1a8f5d80260"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/x11vnc/blobs/sha256:1f3fcfd70a28c8af3b95460611f7960c4c3092e8faf564110cd509e2ff9237ff",
          "sha256": "1f3fcfd70a28c8af3b95460611f7960c4c3092e8faf564110cd509e2ff9237ff"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/x11vnc/blobs/sha256:eccdb28862610ff2f7ab45c9fe0de824185981df75454c96fcd4f82532d11e79",
          "sha256": "eccdb28862610ff2f7ab45c9fe0de824185981df75454c96fcd4f82532d11e79"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "autoconf",
    "automake",
    "pkg-config"
  ],
  "dependencies": [
    "libvncserver",
    "openssl@3"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [
    "libxcrypt"
  ],
  "uses_from_macos_bounds": [
    {}
  ],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "aa66a84309b297ea296f7a4b9c424b5c0ec4875c",
  "ruby_source_path": "Formula/x11vnc.rb",
  "ruby_source_checksum": {
    "sha256": "40bbc1b7c12a80399cf451df560ea66e58d11cf27b26e58de4acdebb680b7f51"
  },
  "date_added": "2013-11-16T11:06:51-08:00",
  "readme": "[![Build Status](https://travis-ci.org/LibVNC/x11vnc.svg?branch=master)](https://travis-ci.org/LibVNC/x11vnc)\n\n**❗ The project currently is unmaintained and is looking for a new maintainer, please see\nhttps://github.com/LibVNC/x11vnc/issues/186 ❗**\n\nThis is x11vnc with its development continued by LibVNC and the GitHub community.\nWhile 0.9.13 was the last release by the original author Karl Runge, 0.9.14 was\nthe first community-based release here on GitHub.\n\nThis repo represents the x11vnc codebase that once resided in the LibVNCServer repo.\nIt was split off LibVNCServer and moved here with\nhttps://github.com/LibVNC/libvncserver/commit/498d222976975f53dea885cfe43ef0f805abd412.\n\nCopyright (C) 2002-2010 Karl J. Runge <runge@karlrunge.com>\nAll rights reserved.\n\n\n# x11vnc: a VNC server for real X displays\n\nx11vnc allows one to view remotely and interact with real X displays\n(i.e. a display corresponding to a physical monitor, keyboard, and\nmouse) with any VNC viewer. In this way it plays the role for Unix/X11\nthat WinVNC plays for Windows.\n\nIt has built-in SSL/TLS encryption and 2048 bit RSA authentication,\nincluding VeNCrypt support; UNIX account and password login support;\nserver-side scaling; single port HTTPS/HTTP+VNC; Zeroconf service\nadvertising; and TightVNC and UltraVNC file-transfer. It has also been\nextended to work with non-X devices: natively on Mac OS X Aqua/Quartz,\nwebcams and TV tuner capture devices, and embedded Linux systems such\nas Qtopia Core. Full IPv6 support is provided. More features are\ndescribed here.\n\nIt also provides an encrypted Terminal Services mode (-create, -svc,\nor -xdmsvc options) based on Unix usernames and Unix passwords where\nthe user does not need to memorize his VNC display/port number.\nNormally a virtual X session (Xvfb) is created for each user, but it\nalso works with X sessions on physical hardware. See the tsvnc\nterminal services mode of the SSVNC viewer for one way to take\nadvantage of this mode.\n\nI wrote x11vnc back in 2002 because x0rfbserver was basically\nimpossible to build on Solaris and had poor performance. The primary\nx0rfbserver build problems centered around esoteric C++ toolkits.\nx11vnc is written in plain C and needs only standard libraries and so\nshould work on nearly all Unixes, even very old ones. I also created\nenhancements to improve the interactive response, added many features,\nand etc.\n\nThis page including the FAQ contains much information [*]; solutions\nto many problems; and interesting applications, but nevertheless\nplease feel free to contact me if you have problems or questions (and\nif I save you time or expense by giving you some of my time, please\nconsider a PayPal Donation.) Do check the FAQ and this page first; I\nrealize the pages are massive, but you can often use your browser's\nfind-in-page search action using a keyword to find the answer to your\nproblem or question.\n\nSSVNC:  An x11vnc side-project provides an Enhanced TightVNC Viewer\npackage (SSVNC) for Unix, Windows, and Mac OS X with automatic SSL\nand/or SSH tunnelling support, SSL Certificate creation, Saved\nconnection profiles, Zeroconf, VeNCrypt, and built-in Proxy support.\nAdded features for the TightVNC Unix viewer: NewFBSize, ZRLE encoding,\nViewer-side Scaling, cursor alphablending, low color modes, and\nenhanced popup menu; UltraVNC extensions support for: File Transfer,\nText Chat, Single Window, Server Input, and 1/n Scaling extensions,\nand UltraVNC DSM encryption. The SSVNC bundle could be placed on, say,\na USB memory stick for SSL/SSH VNC viewing from nearly any networked\ncomputer.\n\n\n# Announcements\n\nImportant: If you created any permanent SSL certificates (e.g. via\n\"x11vnc -ssl SAVE ...\") on a Debian or Ubuntu system from Sept. 2006\nthrough May 2008, then those keys are likely extremely weak and can be\neasily cracked. The certificate files should be deleted and recreated\non a non-Debian system or an updated one. See\nhttp://www.debian.org/security/2008/dsa-1571 for details. The same\napplies to SSH keys (not used by x11vnc directly, but many people use\nSSH tunnels for VNC access.)\n\n# News\n\nSee [NEWS](NEWS)\n\n# Frequently Asked Questions (FAQs)\n\nSee [FAQ.md](doc/FAQ.md)\n\n\n# Background\n\nVNC (Virtual Network Computing) is a very useful network graphics\nprotocol (applications running on one computer but displaying their\nwindows on another) in the spirit of X, however, unlike X, the\nviewing-end is very simple and maintains no state. It is a remote\nframebuffer (RFB) protocol.\n\nSome VNC links:\n\n* http://www.realvnc.com\n* http://www.tightvnc.com\n* http://www.ultravnc.com/\n* http://www.testplant.com/products/vine_server/OS_X\n\nFor Unix, the traditional VNC implementation includes a \"virtual\" X11\nserver Xvnc (usually launched via the vncserver command) that is not\nassociated with a physical display, but provides a \"fake\" one X11\nclients (xterm, firefox, etc.) can attach to. A remote user then\nconnects to Xvnc via the VNC client vncviewer from anywhere on the\nnetwork to view and interact with the whole virtual X11 desktop.\n\nThe VNC protocol is in most cases better suited for remote connections\nwith low bandwidth and high latency than is the X11 protocol because\nit involves far fewer \"roundtrips\" (an exception is the cached pixmap\ndata on the viewing-end provided by X.) Also, with no state maintained\nthe viewing-end can crash, be rebooted, or relocated and the\napplications and desktop continue running. Not so with X11.\n\nSo the standard Xvnc/vncserver program is very useful, I use it for\nthings like:\n\n* Desktop conferencing with other users (e.g. code reviews.)\n* Long running apps/tasks I want to be able to view from many places\n  (e.g. from home and work.)\n* Motif, GNOME, and similar applications that would yield very poor\n  performance over a high latency link.\n\nHowever, sometimes one wants to connect to a real X11 display (i.e.\none attached to a physical monitor, keyboard, and mouse: a Workstation\nor a SunRay session) from far away. Maybe you want to close down an\napplication cleanly rather than using kill, or want to work a bit in\nan already running application, or would like to help a distant\ncolleague solve a problem with their desktop, or would just like to\nwork out on the deck for a while. This is where x11vnc is useful.\n\n# How to use x11vnc\n\nIn this basic example let's assume the remote machine with the X\ndisplay you wish to view is \"far-away.east:0\" and the workstation you\nare presently working at is \"sitting-here.west\".\n\nStep 0. Download x11vnc (see below) and have it available to run on\nfar-away.east (on some linux distros it is as easy as \"apt-get install\nx11vnc\", \"emerge x11vnc\", etc.) Similarly, have a VNC viewer (e.g.\nvncviewer) ready to run on sitting-here.west. We recommend TightVNC\nViewers (see also our SSVNC viewer.)\n\nStep 1. By some means log in to far-away.east and get a command shell\nrunning there. You can use ssh, or even rlogin, telnet, or any other\nmethod to do this. We do this because the x11vnc process needs to be\nrun on the same machine the X server process is running on (otherwise\nthings would be extremely slow.)\n\nStep 2. In that far-away.east shell (with command prompt \"far-away>\"\nin this example) run x11vnc directed at the far-away.east X session\ndisplay:\n\n```\nfar-away> x11vnc -display :0\n```\n\nYou could have also set the environment variable DISPLAY=:0 instead of\nusing \"-display :0\". This step attaches x11vnc to the far-away.east:0\nX display (i.e. no viewer clients yet.)\n\nCommon Gotcha: To get X11 permissions right, you may also need to set\nthe XAUTHORITY environment variable (or use the -auth option) to point\nto the correct MIT-MAGIC-COOKIE file (e.g. /home/joe/.Xauthority.) If\nx11vnc does not have the authority to connect to the display it exits\nimmediately. More on how to fix this below.\n\nIf you suspect an X11 permissions problem do this simple test: while\nsitting at the physical X display open a terminal window\n(gnome-terminal, xterm, etc.) You should be able to run x11vnc\nsuccessfully in that terminal without any need for command line\noptions. If that works OK then you know X11 permissions are the only\nthing preventing it from working when you try to start x11vnc via a\nremote shell. Then fix this with the tips below.\n\nNote as of Feb/2007 you can also try the -find option instead of\n\"-display ...\" and see if that finds your display and Xauthority. Note\nas of Dec/2009 the -findauth and \"-auth guess\" options may be helpful\nas well.\n(End of Common Gotcha)\n\nWhen x11vnc starts up there will then be much chatter printed out (use\n\"-q\" to quiet it), until it finally says something like:\n\n```\n.\n.\n13/05/2004 14:59:54 Autoprobing selected port 5900\n13/05/2004 14:59:54 screen setup finished.\n13/05/2004 14:59:54\n13/05/2004 14:59:54 The VNC desktop is far-away:0\nPORT=5900\n```\n\nwhich means all is OK, and we are ready for the final step.\n\nStep 3. At the place where you are sitting (sitting-here.west in this\nexample) you now want to run a VNC viewer program. There are VNC\nviewers for Unix, Windows, MacOS, Java-enabled web browsers, and even\nfor PDA's like the Palm Pilot and Cell Phones! You can use any of them\nto connect to x11vnc (see the above VNC links under \"Background:\" on\nhow to obtain a viewer for your platform or see this FAQ. For Solaris,\nvncviewer is available in the Companion CD package SFWvnc.)\n\nIn this example we'll use the Unix vncviewer program on sitting-here\nby typing the following command in a second terminal window:\n\n```\nsitting-here> vncviewer far-away.east:0\n```\n\nThat should pop up a viewer window on sitting-here.west showing and\nallowing interaction with the far-away.east:0  X11 desktop. Pretty\nnifty! When finished, exit the viewer: the remote x11vnc process will\nshutdown automatically (or you can use the -forever option to have it\nwait for additional viewer connections.)\n\nCommon Gotcha: Nowadays there will likely be a host-level firewall on\nthe x11vnc side that is blocking remote access to the VNC port (e.g.\n5900.) You will either have to open up that port (or a range of ports)\nin your firewall administration tool, or try the SSH tunnelling method\nbelow (even still the firewall must allow in the SSH port, 22.)\n\nShortcut: Of course if you left x11vnc running on far-away.east:0 in a\nterminal window with the -forever option or as a service, you'd only\nhave to do Step 3 as you moved around. Be sure to use a VNC Password\nor other measures if you do that.\n\nSuper Shortcut: Here is a potentially very easy way to get all of it\nworking.\n\n* Have x11vnc (0.9.3 or later) available to run on the remote host\n  (i.e. in $PATH.)\n* Download and unpack a SSVNC bundle (1.0.19 or later, e.g.\n  ssvnc_no_windows-1.0.28.tar.gz) on the Viewer-side machine.\n* Start the SSVNC Terminal Services mode GUI: ./ssvnc/bin/tsvnc\n* Enter your remote username@hostname (e.g. fred@far-away.east) in\n  the \"VNC Terminal Server\" entry.\n* Click \"Connect\".\n\nThat will do an SSH to username@hostname and start up x11vnc and then\nconnect a VNC Viewer through the SSH encrypted tunnel.\n\nThere are a number of things assumed here, first that you are able to\nSSH into the remote host; i.e. that you have a Unix account there and\nthe SSH server is running. On Unix and MacOS X it is assumed that the\nssh client command is available on the local machine (on Windows a\nplink binary is included in the SSVNC bundle.) Finally, it is assumed\nthat you are already logged into an X session on the remote machine,\ne.g. your workstation (otherwise, a virtual X server, e.g. Xvfb, will\nbe started for you.)\n\nIn some cases the remote SSH server will not run commands with the\nsame $PATH that you normally have in your shell there. In this case\nclick on Options -> Advanced -> X11VNC Options, and type in the\nlocation of the x11vnc binary under \"Full Path\". (End of Super\nShortcut)\n\nDesktop Sharing: The above more or less assumed nobody was sitting at\nthe workstation display \"far-away.east:0\". This is often the case: a\nuser wants to access her workstation remotely. Another usage pattern\nhas the user sitting at \"far-away.east:0\" and invites one or more\nother people to view and interact with his desktop. Perhaps the user\ngives a demo or presentation this way (using the telephone for vocal\ncommunication.) A \"Remote Help Desk\" mode would be similar: a\ntechnician connects remotely to the user's desktop to interactively\nsolve a problem the user is having.\n\nFor these cases it should be obvious how it is done. The above steps\nwill work, but more easily the user sitting at far-away.east:0 simply\nstarts up x11vnc from a terminal window, after which the guests would\nstart their VNC viewers. For this usage mode the \"-connect\nhost1,host2\" option may be of use to automatically connect to the\nvncviewers in \"-listen\" mode on the list of hosts.\n\n## Tunnelling x11vnc via SSH\n\nThe above example had no security or privacy at all. When logging into\nremote machines (certainly when going over the internet) it is best to\nuse ssh, or use a VPN (for a VPN, Virtual Private Network, the above\nexample should be pretty safe.)\n\nFor x11vnc one can tunnel the VNC protocol through an encrypted ssh\nchannel. It would look something like running the following commands:\n\n```\nsitting-here> ssh -t -L 5900:localhost:5900 far-away.east 'x11vnc -localhost -display :0'\n```\n\n(you will likely have to provide passwords/passphrases to login from\nsitting-here into your far-away.east Unix account; we assume you have\na login account on far-away.east and it is running the SSH server)\n\nAnd then in another terminal window on sitting-here run the command:\n\n```\nsitting-here> vncviewer -encodings \"copyrect tight zrle hextile\" localhost:0\n```\n\nNote: The -encodings option is very important: vncviewer will often\ndefault to \"raw\" encoding if it thinks the connection is to the local\nmachine, and so vncviewer gets tricked this way by the ssh\nredirection. \"raw\" encoding will be extremely slow over a networked\nlink, so you need to force the issue with -encodings \"copyrect tight\n...\". Nowadays, not all viewers use the -encodings option, try\n\"-PreferredEncoding=ZRLE\" (although the newer viewers seem to\nautodetect well when to use raw or not.)\n\nNote that \"x11vnc -localhost ...\" limits incoming vncviewer\nconnections to only those from the same machine. This is very natural\nfor ssh tunnelling (the redirection appears to come from the same\nmachine.) Use of a VNC password is also strongly recommended.\n\nNote also the -t we used above (force allocate pseudoterminal), it\nactually seems to improve interactive typing response via VNC!\n\nYou may want to add the -C option to ssh to enable compression. The\nVNC compression is not perfect, and so this may help a bit. However,\nover a fast LAN you probably don't want to enable SSH compression\nbecause it can slow things down. Try both and see which is faster.\n\nIf your username is different on the remote machine use something\nlike: \"fred@far-away.east\" in the above ssh command line.\n\nSome VNC viewers will do the ssh tunnelling for you automatically, the\nTightVNC Unix vncviewer does this when the \"-via far-away.east\" option\nis supplied to it (this requires x11vnc to be already running on\nfar-away.east or having it started by inetd(8).) See the 3rd script\nexample below for more info.\n\nSSVNC:  You may also want to look at the Enhanced TightVNC Viewer\n(ssvnc) bundles because they contain scripts and GUIs to automatically\nset up SSH tunnels (e.g. the GUI, \"ssvnc\", does it automatically and\nso does this command: \"ssvnc_cmd -ssh user@far-away.east:0\") and can\neven start up x11vnc as well.\n\nThe Terminal Services mode of SSVNC is perhaps the easiest way to use\nx11vnc. You just need to have x11vnc available in $PATH on the remote\nside (and can SSH to the host), and then on the viewer-side you type\nsomething like:\n\n```\ntsvnc fred@far-away.east\n```\n\neverything else is done automatically for you. Normally this will\nstart a virtual Terminal Services X session (RAM-only), but if you\nalready have a real X session up on the physical hardware it will find\nthat one for you.\n\nGateways:  If the machine you SSH into is not the same machine with\nthe X display you wish to view (e.g. your company provides incoming\nSSH access to a gateway machine), then you need to change the above\nto, e.g.: \"-L 5900:OtherHost:5900\":\n\n```\nsitting-here> ssh -t -L 5900:OtherHost:5900 gateway.east\n```\n\nWhere gateway.east is the internet hostname (or IP) of the gateway\nmachine (SSH server.) 'OtherHost' might be, e.g., freds-pc or\n192.168.2.33 (it is OK for these to be private hostnames or private IP\naddresses, the host in -L is relative to the remote server side.)\n\nOnce logged in, you'll need to do a second login (ssh, rsh, etc.) to\nthe workstation machine 'OtherHost' and then start up x11vnc on it (if\nit isn't already running.) (The \"-connect gateway:59xx\" option may be\nanother alternative here with the viewer already in -listen mode.) For\nan automatic way to use a gateway and have all the network traffic\nencrypted (including inside the firewall) see Chaining SSH's.\n\nThese gateway access modes also can be done automatically for you via\nthe \"Proxy/Gateway\" setting in SSVNC (including the Chaining SSH's\ncase, \"Double Proxy\".)\n\n## Chaining SSH's\n\nNote that for use of a ssh gateway and -L redirection\nto an internal host (e.g. \"-L 5900:otherhost:5900\") the VNC traffic\ninside the firewall is not encrypted and you have to manually log into\notherhost to start x11vnc. Kyle Amon shows a method where you chain\ntwo ssh's together that encrypts all network traffic and also\nautomatically starts up x11vnc on the internal workstation:\n\n```\n#!/bin/sh\n#\ngateway=\"example.com\"   # or \"user@example.com\"\nhost=\"labyrinth\"        # or \"user@hostname\"\nuser=\"kyle\"\n\n# Need to sleep long enough for all of the passwords and x11vnc to start up.\n# The </dev/null below makes the vncviewer prompt for passwd via popup window.\n#\n(sleep 10; vncviewer -encodings \"copyrect tight zrle zlib hextile\" \\\n    localhost:0 </dev/null >/dev/null) &\n\n# Chain the vnc connection thru 2 ssh's, and connect x11vnc to user's display:\n#\nexec /usr/bin/ssh -t -L 5900:localhost:5900 $gateway \\\n     /usr/bin/ssh -t -L 5900:localhost:5900 $host \\\n     sudo /usr/bin/x11vnc -localhost -auth /home/$user/.Xauthority \\\n         -rfbauth .vnc/passwd -display :0\n```\n\nAlso note the use of sudo(1) to switch to root so that the different\nuser's .Xauthority file can be accessed. See the visudo(8) manpage for\ndetails on how to set this up (remove the sudo if you do not want to\ndo this). One can also chain together ssh's for reverse connections\nwith vncviewers using the -listen option. For this case -R would\nreplace the -L (and 5500 the 5900, see the #2 example script above).\nIf the gateway machine's sshd is configured with GatewayPorts=no (the\ndefault) then the double chaining of \"ssh -R ...\" will be required for\nreverse connections to work.\n\n## Firewalls/Routers\n\nA lot of people have inexpensive devices for home or office that act\nas a Firewall and Router to the machines inside on a private LAN. One\ncan usually configure the Firewall/Router from inside the LAN via a\nweb browser.\n\nOften having a Firewall/Router sitting between the vncviewer and\nx11vnc will make it impossible for the viewer to connect to x11vnc.\n\nOne thing that can be done is to redirect a port on the\nFirewall/Router to, say, the SSH port (22) on an inside machine (how\nto do this depends on your particular Firewall/Router, often the\nrouter config URL is http://192.168.100.1 See www.portforward.com for\nmore info.) This way you reach these computers from anywhere on the\nInternet and use x11vnc to view X sessions running on them.\n\nSuppose you configured the Firewall/Router to redirect these ports to\ntwo internal machines:\n\n```\nPort 12300 -> 192.168.1.3, Port 22 (SSH)\nPort 12301 -> 192.168.1.4, Port 22 (SSH)\n\n(where 192.168.1.3 is \"jills-pc\" and 192.168.1.4 is \"freds-pc\".) Then the ssh's would look something like:\nsitting-here> ssh -t -p 12300 -L 5900:localhost:5900 jill@far-away.east 'x11v nc -localhost -display :0'\nsitting-here> ssh -t -p 12301 -L 5900:localhost:5900 fred@far-away.east 'x11v nc -localhost -display :0'\n```\n\nWhere far-away.east means the hostname (or IP) that the\nRouter/Firewall is using (for home setups this is usually the IP\ngotten from your ISP via DHCP, the site http://www.whatismyip.com/ is\na convenient way to determine what it is.)\n\nIt is a good idea to add some obscurity to accessing your system via\nSSH by using some high random port (e.g. 12300 in the above example.)\nIf you can't remember it, or are otherwise not worried about port\nscanners detecting the presence of your SSH server and there is just\none internal PC involved you could map 22:\n\n```\nPort 22 -> 192.168.1.3, Port 22 (SSH)\n```\n\nAgain, this SSH gateway access can be done automatically for you via\nthe \"Proxy/Gateway\" setting in SSVNC. And under the \"Remote SSH\nCommand\" setting you can enter the x11vnc -localhost -display :0.\n\nHost-Level-Firewalls: even with the hardware Firewall/Router problem\nsolved via a port redirection, most PC systems have their own Host\nlevel \"firewalls\" enabled to protect users from themselves. I.e. the\nsystem itself blocks all incoming connections. So you will need to see\nwhat is needed to configure it to allow in the port (e.g. 22) that you\ndesire. E.g. Yast, Firestarter, iptables(1), etc..\n\nVNC Ports and Firewalls: The above discussion was for configuring the\nFirewall/Router to let in port 22 (SSH), but the same thing can be\ndone for the default VNC port 5900:\n\n```\nPort 5900 -> 192.168.1.3, Port 5900 (VNC)\nPort 5901 -> 192.168.1.4, Port 5900 (VNC)\n```\n\n(where 192.168.1.3 is \"jills-pc\" and 192.168.1.4 is \"freds-pc\".) This\ncould be used for normal, unencrypted connections and also for SSL\nencrypted ones.\n\nThe VNC displays to enter in the VNC viewer would be, say,\n\"far-away.east:0\" to reach jills-pc and \"far-away.east:1\" to reach\nfreds-pc. We assume above that x11vnc is using port 5900 (and any\nHost-Level-firewalls on jills-pc has been configured to let that port\nin.) Use the \"-rfbport\" option to tell which port x11vnc should listen\non.\n\nFor a home system one likely does not have a hostname and would have\nto use the IP address, say, \"24.56.78.93:0\". E.g.:\n\n```\nvncviewer 24.56.78.93:0\n```\n\nYou may want to choose a more obscure port on the router side, e.g.\n5944, to avoid a lot of port scans finding your VNC server. For 5944\nyou would tell the viewer to use:\n\n```\nvncviewer 24.56.78.93:44\n```\n\nThe IP address would need to be communicated to the person running the\nVNC Viewer. The site http://www.whatismyip.com/ can help here.\n\nScripts to automate ssh tunneling: As discussed below, there may be\nsome problems with port 5900 being available. If that happens, the\nabove port and display numbers may change a bit (e.g. -> 5901 and :1).\nHowever, if you \"know\" port 5900 will be free on the local and remote\nmachines, you can easily automate the above two steps by using the\nx11vnc option -bg (forks into background after connection to the\ndisplay is set up) or using the -f option of ssh. Some example scripts\nare shown below. Feel free to try the ssh -C to enable its compression\nand see if that speeds things up noticeably.\n\n1. A simple example script, assuming no problems with port 5900 being\ntaken on the local or remote sides, looks like:\n\n    ```\n    #!/bin/sh\n    # usage: x11vnc_ssh <host>:<xdisplay>\n    #  e.g.: x11vnc_ssh snoopy.peanuts.com:0\n    #  (user@host:N also works)\n\n    host=`echo $1 | awk -F: '{print $1}'`\n    disp=`echo $1 | awk -F: '{print $2}'`\n    if [ \"x$disp\" = \"x\" ]; then disp=0; fi\n\n    cmd=\"x11vnc -display :$disp -localhost -rfbauth .vnc/passwd\"\n    enc=\"copyrect tight zrle hextile zlib corre rre raw\"\n\n    ssh -f -t -L 5900:localhost:5900 $host \"$cmd\"\n\n    for i in 1 2 3\n    do\n        sleep 2\n        if vncviewer -encodings \"$enc\" :0; then break; fi\n    done\n    ```\n\n    See also rx11vnc.pl below.\n\n2. Another method is to start the VNC viewer in listen mode\n\"vncviewer -listen\" and have x11vnc initiate a reverse connection\nusing the -connect option:\n\n    ```\n    #!/bin/sh\n    # usage: x11vnc_ssh <host>:<xdisplay>\n    #  e.g.: x11vnc_ssh snoopy.peanuts.com:0\n    #  (user@host:N also works)\n\n    host=`echo $1 | awk -F: '{print $1}'`\n    disp=`echo $1 | awk -F: '{print $2}'`\n    if [ \"x$disp\" = \"x\" ]; then disp=0; fi\n\n    cmd=\"x11vnc -display :$disp -localhost -connect localhost\"   # <== note new option\n    enc=\"copyrect tight zrle hextile zlib corre rre raw\"\n\n    vncviewer -encodings \"$enc\" -listen &\n    pid=$!\n    ssh -t -R 5500:localhost:5500 $host \"$cmd\"\n    kill $pid\n    ```\n\n    Note the use of the ssh option \"-R\" instead of \"-L\" to set up a remote\n    port redirection.\n\n3. A third way is specific to the TightVNC vncviewer special option\n-via for gateways. The only tricky part is we need to start up x11vnc\nand give it some time (5 seconds in this example) to start listening\nfor connections (so we cannot use the TightVNC default setting for\nVNC_VIA_CMD):\n\n    ```\n    #!/bin/sh\n    # usage: x11vnc_ssh <host>:<xdisplay>\n    #  e.g.: x11vnc_ssh snoopy.peanuts.com:0\n\n    host=`echo $1 | awk -F: '{print $1}'`\n    disp=`echo $1 | awk -F: '{print $2}'`\n    if [ \"x$disp\" = \"x\" ]; then disp=0; fi\n\n    VNC_VIA_CMD=\"ssh -f -t -L %L:%H:%R %G x11vnc -localhost -rfbport 5900 -display\n    :$disp; sleep 5\"\n    export VNC_VIA_CMD\n\n    vncviewer -via $host localhost:0      # must be TightVNC vncviewer.\n    ```\n\n    Of course if you already have the x11vnc running waiting for\n    connections (or have it started out of inetd(8)), you can simply use\n    the TightVNC \"vncviewer -via gateway host:port\" in its default mode to\n    provide secure ssh tunnelling.\n\nVNC password file: Also note in the #1. example script that the option\n\"-rfbauth .vnc/passwd\" provides additional protection by requiring a\nVNC password for every VNC viewer that connects. The vncpasswd or\nstorepasswd programs, or the x11vnc -storepasswd option can be used to\ncreate the password file. x11vnc also has the slightly less secure\n-passwdfile and \"-passwd XXXXX\" options to specify passwords.\n\nVery Important: It is up to YOU to tell x11vnc to use password\nprotection (-rfbauth or -passwdfile), it will NOT do it for you\nautomatically or force you to (use -usepw if you want to be forced\nto.) The same goes for encrypting the channel between the viewer and\nx11vnc: it is up to you to use ssh, stunnel, -ssl mode, a VPN, etc.\n(use the Enhanced TightVNC Viewer (SSVNC) GUI if you want to be forced\nto use SSL or SSH.) For additional safety, also look into the -allow\nand -localhost options and building x11vnc with tcp_wrappers support\nto limit host access.\n\n\n## Tunnelling x11vnc via SSL/TLS\n\nOne can also encrypt the VNC traffic using an SSL/TLS tunnel such as\nstunnel.mirt.net (also stunnel.org) or using the built-in (Mar/2006)\n-ssl openssl mode. A SSL-enabled Java applet VNC Viewer is also\nprovided in the x11vnc package (and https can be used to download it.)\n\nAlthough not as ubiquitous as ssh, SSL tunnelling still provides a\nuseful alternative. See this FAQ on -ssl and -stunnel modes for\ndetails and examples.\n\nThe Enhanced TightVNC Viewer (SSVNC) bundles contain some convenient\nutilities to automatically set up an SSL tunnel from the viewer-side\n(i.e. to connect to \"x11vnc -ssl ...\".) And many other enhancements\ntoo.\n\n# Downloading x11vnc\n\nx11vnc is a contributed program to the LibVNCServer project at\nSourceForge.net. I use libvncserver for all of the VNC aspects; I\ncouldn't have done without it. The full source code may be found and\ndownloaded (either file-release tarball or GIT tree) from the above\nlink. As of Sep 2010, the x11vnc-0.9.12.tar.gz source package is\nreleased (recommended download). The x11vnc 0.9.12 release notes.\n\nThe x11vnc package is the subset of the libvncserver package needed to\nbuild the x11vnc program. Also, you can get a copy of my latest,\nbleeding edge x11vnc-0.9.13-dev.tar.gz tarball to build the most up to\ndate one.\n\nPrecompiled Binaries/Packages:  See the FAQ below for information\nabout where you might obtain a precompiled x11vnc binary from 3rd\nparties and some ones I create.\n\nVNC Viewers:  To obtain VNC viewers for the viewing side (Windows, Mac\nOS, or Unix) try these links:\n\n* http://www.tightvnc.com/download.html\n* http://www.realvnc.com/download-free.html\n* http://sourceforge.net/projects/cotvnc/\n* http://www.ultravnc.com/\n* Our Enhanced TightVNC Viewer (SSVNC)[ssvnc.gif]\n\nMore tools: Here is a ssh/rsh wrapper script rx11vnc that attempts to\nautomatically do the above Steps 1-3 for you (provided you have\nssh/rsh login permission on the machine x11vnc is to be run on.) The\nabove example would be: \"rx11vnc far-away.east:0\" typed into a shell\non sitting-here.west. Also included is an experimental script\nrx11vnc.pl that attempts to tunnel the vnc traffic through an ssh port\nredirection (and does not assume port 5900 is free.) Have a look at\nthem to see what they do and customize as needed:\n\n* rx11vnc wrapper script\n* rx11vnc.pl wrapper script to tunnel traffic thru ssh\n\n\n# Building x11vnc\n\nMake sure you have all the needed build/compile/development packages\ninstalled. On a Debian-based distro you can simply do\n\n```\nsudo apt-get build-dep x11vnc\n```\n\nto install most of them.\n\nTo generate the build system, do a\n\n```\nautoreconf -fiv\n```\n\nAfter that, it's the usual\n\n```\n./configure\nmake\n```\n\nYou might want to take a look at the dfferent configure options\nprovided by `configure --help` to build without X11 or adapt the\nbuild to your needs in other ways.\n\n## Building on Solaris, FreeBSD, etc\n\nDepending on your version of\nSolaris or other Unix OS the jpeg and/or zlib libraries may be in\nnon-standard places (e.g. /usr/local, /usr/sfw, /opt/sfw, etc.)\n\nNote: If configure cannot find these two libraries then TightVNC and\nZRLE encoding support will be disabled, and you don't want that!!! The\nTightVNC encoding gives very good compression and performance, it even\nmakes a noticeable difference over a fast LAN.\n\nShortcuts: On Solaris 10 you can pick up almost everything just by\ninsuring that your PATH has /usr/sfw/bin (for gcc) and /usr/ccs/bin\n(for other build tools), e.g.:\n\n```\nenv PATH=/usr/sfw/bin:/usr/ccs/bin:$PATH sh -c './configure; make'\n```\n\n(The only thing this misses is /usr/X11/lib/libXrandr.so.2, which is\nfor the little used -xrandr option, see the script below to pick it up\nas well.)\n\n\nlibjpeg is included in Solaris 9 and later (/usr/sfw/include and\n/usr/sfw/lib), and zlib in Solaris 8 and later (/usr/include and\n/usr/lib.) So on Solaris 9 you can pick up everything with something\nlike this:\n\n```\nenv PATH=/usr/local/bin:/usr/ccs/bin:$PATH sh -c './configure --with-jpeg=/usr/sfw; make'\n```\n\nassuming your gcc is in /usr/local/bin and x11vnc 0.7.1 or later.\nThese are getting pretty long, see those assignments split up in the\nbuild script below.\n\nIf your system does not have these libraries at all you can get the\nsource for the libraries to build them: libjpeg is available at\nftp://ftp.uu.net/graphics/jpeg/ and zlib at http://www.gzip.org/zlib/.\nSee also http://www.sunfreeware.com/ for Solaris binary packages of\nthese libraries as well as for gcc. Normally they will install into\n/usr/local but you can install them anywhere with the\n--prefix=/path/to/anywhere, etc.\n\nHere is a build script that indicates one way to pass the library\nlocations information to the libvncserver configuration via the\nCPPFLAGS and LDFLAGS environment variables.\n\n```\n#!/bin/sh\n\n# Build script for Solaris, etc, with gcc, libjpeg and libz in\n# non-standard locations.\n\n# set to get your gcc, etc:\n#\nPATH=/path/to/gcc/bin:/usr/ccs/bin:/usr/sfw/bin:$PATH\n\nJPEG=/path/to/jpeg      # set to maybe \"/usr/local\", \"/usr/sfw\", or \"/opt/sfw\"\nZLIB=/path/to/zlib      # set to maybe \"/usr/local\", \"/usr/sfw\", or \"/opt/sfw\"\n\n# Below we assume headers in $JPEG/include and $ZLIB/include and the\n# shared libraries are in $JPEG/lib and $ZLIB/lib.  If your situation\n# is different change the locations in the two lines below.\n#\nCPPFLAGS=\"-I $JPEG/include -I $ZLIB/include\"\nLDFLAGS=\"-L$JPEG/lib -R $JPEG/lib -L$ZLIB/lib -R $ZLIB/lib\"\n\n# These two lines may not be needed on more recent Solaris releases:\n#\nCPPFLAGS=\"$CPPFLAGS -I /usr/openwin/include\"\nLDFLAGS=\"$LDFLAGS -L/usr/openwin/lib -R /usr/openwin/lib\"\n\n# These are for libXrandr.so on Solaris 10:\n#\nCPPFLAGS=\"$CPPFLAGS -I /usr/X11/include\"\nLDFLAGS=\"$LDFLAGS -L/usr/X11/lib -R /usr/X11/lib\"\n\n# Everything needs to built with _REENTRANT for thread safe errno:\n#\nCPPFLAGS=\"$CPPFLAGS -D_REENTRANT\"\n\nexport PATH CPPFLAGS LDFLAGS\n\n./configure\nmake\n\nls -l ./x11vnc/x11vnc\n```\n\nThen do make install or copy the x11vnc binary to your desired\ndestination.\n\nBTW, To run a shell script, just cut-and-paste the above into a file,\nsay \"myscript\", then modify the \"/path/to/...\" items to correspond to\nyour system/environment, and then type: \"sh myscript\" to run it.\n\nNote that on Solaris make is /usr/ccs/bin/make, so that is why the\nabove puts /usr/ccs/bin in PATH. Other important build utilities are\nthere too: ld, ar, etc. Also, it is probably a bad idea to have\n/usr/ucb in your PATH while building.\n\nStarting with the 0.7.1 x11vnc release the \"configure --with-jpeg=DIR\n--with-zlib=DIR\" options are handy if you want to avoid making a\nscript.\n\nIf you need to link OpenSSL libssl.a on Solaris see this method.\n\nIf you need to build on Solaris 2.5.1 or earlier or other older Unix\nOS's, see this workaround FAQ.\n\n## Building on FreeBSD, OpenBSD, ...\n\nThe jpeg libraries seem to be in\n/usr/local or /usr/pkg on these OS's. You won't need the openwin stuff\nin the above script (but you may need /usr/X11R6/....) Also starting\nwith the 0.7.1 x11vnc release, this usually works:\n\n```\n./configure --with-jpeg=/usr/local\nmake\n```\n\n## Building on HP-UX\n\nFor jpeg and zlib you will need to do the same\nsort of thing as described above for Solaris. You set CPPFLAGS and\nLDFLAGS to find them (see below for an example.) You do not need to do\nany of the above /usr/openwin stuff. Also, HP-UX does not seem to\nsupport -R, so get rid of the -R items in LDFLAGS. Because of this, at\nruntime you may need to set LD_LIBRARY_PATH or SHLIB_PATH to indicate\nthe directory paths so the libraries can be found. It is a good idea\nto have static archives, e.g. libz.a and libjpeg.a for the nonstandard\nlibraries so that they get bolted into the x11vnc binary (and so won't\nget \"lost\".)\n\nHere is what we recently did to build x11vnc 0.7.2 on HP-UX 11.11\n\n```\n./configure --with-jpeg=$HOME/hpux/jpeg --with-zlib=$HOME/hpux/zlib\nmake\n```\n\nWhere we had static archives (libjpeg.a, libz.a) only and header files\nin the $HOME/hpux/... directories as discussed for the build script.\n\nOn HP-UX 11.23 and 11.31 we have had problems compiling with gcc.\n\"/usr/include/rpc/auth.h:87: error: field 'syncaddr' has incomplete\ntype\". As a workaround for x11vnc 0.9.4 and later set your CPPFLAGS to\ninclude:\n\n```\nCPPFLAGS=\"-DIGNORE_GETSPNAM\"\nexport CPPFLAGS\n```\n\nThis disables a very rare usage mode for -unixpw_nis by not trying\ngetspnam(3).\n\nUsing HP-UX's C compiler on 11.23 and 11.31 we have some severe\ncompiler errors that have not been worked around yet. If you need to\ndo this, contact me and I will give you a drastic recipe that will\nproduce a working binary.\n\n## Building on AIX\n\nAIX: one user had to add the \"X11.adt\" package to\nAIX 4.3.3 and 5.2 to get build header files like XShm.h, etc. You may\nalso want to make sure that /usr/lpp/X11/include, etc is being picked\nup by the configure and make.\n\nFor a recent build on AIX 5.3 we needed to add these CFLAGS to be able\nto build with gcc:\nenv CFLAGS='-maix64 -Xlinker -bbigtoc' ./configure ...\n\nwe also built our own libjpeg and libz using -maix64.\n\nBTW, one way to run an Xvfb-like virtual X server for testing on AIX\nis something like \"/usr/bin/X11/X -force -vfb -ac :1\".\n\n## Building on Mac OS X\n\nThere is now native Mac OS X support for\nx11vnc by using the raw framebuffer feature. This mode does not use or\nneed X11 at all. To build you may need to disable X11:\n\n```\n./configure --without-x ...\nmake\n```\n\nHowever, if your system has the Mac OS X build package for X11 apps\nyou will not need to supply the \"--without-x\" option (in this case the\nresulting x11vnc would be able to export both the native Mac OS X\ndisplay and windows displayed in the XDarwin X server.) Be sure to\ninclude the ./configure option to find libjpeg on your system.\n\n## OpenSSL\n\nStarting with version 0.8.3 x11vnc can now be built with\nSSL/TLS support. For this to be enabled the libssl.so library needs to\nbe available at build time. So you may need to have additional\nCPPFLAGS and LDFLAGS items if your libssl.so is in a non-standard\nplace. As of x11vnc 0.9.4 there is also the --with-ssl=DIR configure\noption.\n\nNote that from OpenSSL 1.1.0 on SSLv2 support has been dropped and\nSSLv3 deactivated at build time per default. This means that unless\nexplicitly enabled, OpenSSL builds only support TLS (any version).\nSince there is a reason for dropping SSLv3 (heard of POODLE?), most\ndistributions do not enable it for their OpenSSL binary. In summary\nthis means compiling x11vnc against OpenSSL 1.1.0 or newer is no\nproblem, but using encryption will require a viewer with TLS support.\n\nOn Solaris using static archives libssl.a and libcrypto.a instead of\n.so shared libraries (e.g. from www.sunfreeware.com), we found we\nneeded to also set LDFLAGS as follows to get the configure to work:\n\n```\nenv LDFLAGS='-lsocket -ldl' ./configure --with-ssl=/path/to/openssl ...\nmake\n```\n\n## Misc. Build problems\n\nWe collect here rare build problems some users\nhave reported and the corresponding workarounds. See also the FAQ's on\nbuilding.\n\n---\n\nENV parameter: One user had a problem where the build script below was\nfailing because his work environment had the ENV variable set to a\nscript that was resetting his PATH so that gcc could no longer be\nfound. Make sure you do not have any ENV or BASH_ENV in your\nenvironment doing things like that. Typing \"unset ENV\", etc. before\nconfiguring and building should clear it.\n\n---\n\nBash xpg: One user had his bash shell compiled with\n--enable-xpg-echo-default that causes some strange behavior with\nthings like echo \"\\\\1 ...\" the configure script executes. In\nparticular instead of getting \"\\1\" the non-printable character \"^A\" is\nproduced, and causes failures at compile time like:\n\n```\n../rfb/rfbconfig.h:9:22: warning: extra tokens at end of #ifndef directive\n```\n\nThe workaround is to configure like this:\n\n```\nenv CONFIG_SHELL=/bin/sh /bin/sh ./configure\n```\n\ni.e. avoid using the bash with the misbehavior. A bug has been filed\nagainst autoconf to guard against this.\n\n---\n\nAIX: one user had to add the \"X11.adt\" package to AIX to get build\nheader files like XShm.h, etc.\n\n---\n\nUbuntu Feisty Fawn 7.04: In May/2007 one user said he needed to add\nthese packages to compile x11vnc on that Linux distro and version:\n\n```\napt-get install build-essential make bin86 libjpeg62-dev libssl-dev libxtst-dev\n```\n\nNote that Ubuntu is based on Debian, so perhaps this is the list\nneeded on Debian (testing?) as well. To build in Avahi (mDNS service\nadvertising) support it would appear that libavahi-client-dev is\nneeded as well.\n\n---\n\nExceedingly slow compilation: x11vnc has a couple of files which\ncontain very large \"case statements\" (over 100 cases) that on some\nplatforms can take a very long time to compile (in extreme cases over\nan hour). However on 32bit Linux with intel/amd processor and gcc\nthese files usually take less than 10 seconds to compile. For 64bit\nsystems using gcc the problem appears to be much worse.\n\nThe two files with the large number of cases, remote.c and x11vnc.c,\nhave no real need to be optimized (the code is used only very\ninfrequently). So it is fine to supply \"-O0\" (disables optimization)\nto CFLAGS when compiling them. However, it is tricky with\nautoconf/automake to do this (especially since both the compiler and\nmake versions have a big effect).\n\nSo if the compile times are getting too long for you for these two\nfiles you will need to manually change some things. First, run\nconfigure and when it has finished, edit the generated file\nx11vnc/Makefile and put these lines at the very top:\n\n```\nx11vnc-x11vnc.o :  CFLAGS += -O0\nx11vnc-remote.o :  CFLAGS += -O0\n```\n\nThose lines assume gnu make (gmake) is being used. If you are using\nanother make, say Solaris make, insert these instead:\n\n```\nx11vnc-x11vnc.o := CFLAGS += -O0\nx11vnc-remote.o := CFLAGS += -O0\n```\n\nYou could write a build shell script that modified the Makefile this\nway before running make.\n\nThe \"-O0\" (note it is \"capital Oh\" followed by \"zero\") assumes the gcc\ncompiler. If you are using a different compiler you will need to find\nthe command line option to disable optimization, or otherwise have the\nlines set CFLAGS to the empty string.\n\n---\n\nBroken Thread Local Storage on SuSE 9.2: Starting with x11vnc 0.9.8\nthe bundled libvncserver uses the __thread keyword to make some of the\nencodings (i.e. tight) thread safe (multiple VNC clients can be using\ntight at the same time in x11vnc -threads mode.) Evidently on the old\nSuSE 9.2 system the compiler does not support the thread local storage\nproperly. Here is an example build failure:\n\n```\ntight.c:1126: error: unrecognizable insn:\n(insn:HI 11 10 13 0 (nil) (set (reg/f:SI 59)\n        (const:SI (plus:SI (symbol_ref:SI (\"%lpalette\"))\n                (const_int 2048 [0x800])))) -1 (nil)\n    (expr_list:REG_EQUAL (const:SI (plus:SI (symbol_ref:SI (\"%lpalette\"))\n                (const_int 2048 [0x800])))\n        (nil)))\ntight.c:1126: internal compiler error: in extract_insn, at recog.c:2175\nPlease submit a full bug report,\nwith preprocessed source if appropriate.\nSee URL:http://www.suse.de/feedback for instructions.\n```\n\nThe workaround is to disable thread local storage at configure time\nlike this:\n\n```\nenv CPPFLAGS=\"-DTLS=''\" ./configure\n```\nand then build it.\n\n\n# Some Notes\n\n## Both a client and a server\n\nIt is sometimes confusing to people that\nx11vnc is both a client and a server at the same time. It is an X\nclient because it connects to the running X server to do the screen\npolls. Think of it as a rather efficient \"screenshot\" program running\ncontinuously. It is a server in the sense that it is a VNC server that\nVNC viewers on the network can connect to and view the screen\nframebuffer it manages.\n\nWhen trying to debug problems, remember to think of both roles. E.g.\n\"how is x11vnc connecting to the X server?\", \"how is the vncviewer\nconnecting to x11vnc?\", \"what permits/restricts the connection?\". Both\nlinks may have reachability, permission, and other issues.\n\n## Network performance\n\nWhether you are using Xvnc or x11vnc it is\nalways a good idea to have a solid background color instead of a\npretty background image. Each and every re-exposure of the background\nmust be resent over the network: better to have that background be a\nsolid color that compresses very well compared to a photo image. (This\nis one place where the X protocol has an advantage over the VNC\nprotocol.) I suggest using xsetroot, dtstyle or similar utility to set\na solid background while using x11vnc. You can turn the pretty\nbackground image back on when you are using the display directly.\nUpdate: As of Feb/2005 x11vnc has the -solid [color] option that works\non recent GNOME, KDE, and CDE and also on classic X (background image\nis on the root window.) Update: As of Oct/2007 x11vnc has the -ncache\noption that does a reasonable job caching the background (and other)\npixmap data on the viewer side.\n\nI also find the TightVNC encoding gives the best response for my usage\n(Unix <-> Unix over cable modem.) One needs a tightvnc-aware vncviewer\nto take advantage of this encoding.\n\n## TCP port issues\n\nNotice the lines\n\n```\n18/07/2003 14:36:31 Autoprobing selected port 5900\nPORT=5900\n```\n\nin the output. 5900 is the default VNC listening port (just like 6000\nis X11's default listening port.) Had port 5900 been taken by some\nother application, x11vnc would have next tried 5901. That would mean\nthe viewer command above should be changed to vncviewer\nfar-away.east:1. You can force the port with the \"-rfbport NNNN\"\noption where NNNN is the desired port number. If that port is already\ntaken, x11vnc will exit immediately. The \"-N\" option will try to match\nthe VNC display number to the X display.   (also see the \"SunRay\nGotcha\" note below)\n\n## Options\n\nx11vnc has (far too) many features that may be activated\nvia its command line options. Useful options are, e.g., -scale to do\nserver-side scaling, and -rfbauth passwd-file to use VNC password\nprotection (the vncpasswd or storepasswd programs, or the x11vnc\n-storepasswd option can be used to create the password file.)\n\n## Algorithm\n\nHow does x11vnc do it? Rather brute-forcedly: it\ncontinuously polls the X11 framebuffer for changes using\nXShmGetImage(). When changes are discovered, it instructs libvncserver\nwhich rectangular regions of the framebuffer have changed, and\nlibvncserver compresses the changes and sends them off to any\nconnected VNC viewers. A number of applications do similar things,\nsuch as x0rfbserver, krfb, x0vncserver, vino. x11vnc uses a 32 x 32\npixel tile model (the desktop is decomposed into roughly 1000 such\ntiles), where changed tiles are found by pseudo-randomly polling 1\npixel tall horizontal scanlines separated vertically by 32 pixels.\nThis is a surprisingly effective algorithm for finding changed\nregions. For keyboard and mouse user input the XTEST extension is used\nto pass the input events to the X server. To detect XBell \"beeps\" the\nXKEYBOARD extension is used. If available, the XFIXES extension is\nused to retrieve the current mouse cursor shape. Also, if available\nthe X DAMAGE extension is used to receive hints from the X server\nwhere modified regions on the screen are. This greatly reduces the\nsystem load when not much is changing on the screen and also improves\nhow quickly the screen is updated.\n\n## Barbershop mirrors effect\n\nWhat if x11vnc is started up, and\nvncviewer is then started up on the same machine and displayed on the\nsame display x11vnc is polling? One might \"accidentally\" do this when\nfirst testing out the programs. You get an interesting\nrecursive/feedback effect where vncviewer images keep popping up each\none contained in the previous one and slightly shifted a bit by the\nwindow manager decorations. There will be an even more interesting\neffect if -scale is used. Also, if the XKEYBOARD is supported and the\nXBell \"beeps\" once, you get an infinite loop of beeps going off.\nAlthough all of this is mildly exciting it is not much use: you will\nnormally run and display the viewer on a different machine!\n\n\n# Limitations\n\n* Due to the polling nature, some activities (opaque window moves,\n  scrolling), can be pretty choppy/ragged and others (exposures of\n  large areas) slow. Experiment with interacting a bit differently\n  than you normally do to minimize the effects (e.g. do fullpage\n  paging rather than line-by-line scrolling, and move windows in a\n  single, quick motion.) Recent work has provided the\n  -scrollcopyrect and -wireframe speedups using the CopyRect VNC\n  encoding and other things, but they only speed up some activities,\n  not all.\n* A rate limiting factor for x11vnc performance is that graphics\n  hardware is optimized for writing, not reading (x11vnc reads the\n  video framebuffer for the screen image data.) The difference can\n  be a factor of 10 to 1000, and so it usually takes about 0.5-1 sec\n  to read in the whole video hardware framebuffer (e.g. 5MB for\n  1280x1024 at depth 24 with a read rate of 5-10MB/sec.) So whenever\n  activity changes most of the screen (e.g. moving or iconifying a\n  large window) there is a delay of 0.5-1 sec while x11vnc reads the\n  changed regions in.\n  A slow framebuffer read rate will often be the performance\n  bottleneck on a fast LAN (whereas on slower links the reduced\n  network bandwidth becomes the bottleneck.)\n  Note: A quick way to get a 2X speedup of this for x11vnc is to\n  switch your X server from depth 24 (32bpp) to depth 16 (16bpp.)\n  You get a 4X speedup going to 8bpp, but the lack of color cells is\n  usually unacceptable.\n  To get a sense of the read and write speeds of your video card,\n  you can run benchmarks like: \"x11perf -getimage500\",  \"x11perf\n  -putimage500\",  \"x11perf -shmput500\" and for XFree86 displays with\n  direct graphics access the \"dga\" command (press \"b\" to run the\n  benchmark and then after a few seconds press \"q\" to quit.) Even\n  this \"dd if=/dev/fb0 of=/dev/null\" often gives a good estimate.\n  x11vnc also prints out its estimate:\n\n  ```\n  28/02/2009 11:11:07 Autoprobing TCP port\n  28/02/2009 11:11:07 Autoprobing selected port 5900\n  28/02/2009 11:11:08 fb read rate: 10 MB/sec\n  28/02/2009 11:11:08 screen setup finished.\n  ```\n\n  We have seen a few cases where the hardware fb read speed is\n  greater than 65 MB/sec: on high end graphics workstations from SGI\n  and Sun, and also from a Linux user using nvidia proprietary\n  drivers for his nvidia video card. Update 2008: thankfully, these\n  sped up drivers are becoming more common on Linux and *BSD systems\n  and that makes x11vnc run somewhat more quickly. Sometimes they\n  have a read rate of over 400 MB/sec.\n  On XFree86/Xorg it is actually possible to increase the\n  framebuffer read speed considerably (10-100 times) by using the\n  Shadow Framebuffer (a copy of the framebuffer is kept in main\n  memory and this can be read much more quickly.) To do this one\n  puts the line Option \"ShadowFB\" \"true\" in the Device section of\n  the /etc/X11/XF86Config or /etc/X11/xorg.conf file. Note that this\n  disables 2D acceleration at the physical display and so that might\n  be unacceptable if one plays games, etc. on the machine's local\n  display. Nevertheless this could be handy in some circumstances,\n  e.g. if the slower speed while sitting at the physical display was\n  acceptable (this seems to be true for most video cards these\n  days.) Unfortunately it does not seem shadowfb can be turned on\n  and off dynamically...\n  Another amusing thing one can do is use Xvfb as the X server, e.g.\n  \"xinit $HOME/.xinitrc -- /usr/X11R6/bin/Xvfb :1 -screen 0\n  1024x768x16\" x11vnc can poll Xvfb efficiently via main memory.\n  It's not exactly clear why one would want to do this instead of\n  using vncserver/Xvnc, (perhaps to take advantage of an x11vnc\n  feature, such as framebuffer scaling or built-in SSL encryption),\n  but we mention it because it may be of use for special purpose\n  applications. You may need to use the \"-cc 4\" option to force Xvfb\n  to use a TrueColor visual instead of DirectColor. See also the\n  description of the -create option that does all of this\n  automatically for you (be sure to install the Xvfb package, e.g.\n  apt-get install xvfb.)\n  Also, a faster and more accurate way is to use the \"dummy\"\n  Xorg/XFree86 device driver (or our Xdummy wrapper script.) See\n  this FAQ for details.\n* Somewhat surprisingly, the X11 mouse (cursor) shape is write-only\n  and cannot be queried from the X server. So traditionally in\n  x11vnc the cursor shape stays fixed at an arrow. (see the \"-cursor\n  X\" and \"-cursor some\" options, however, for a partial hack for the\n  root window, etc.) However, on Solaris using the SUN_OVL overlay\n  extension, x11vnc can show the correct mouse cursor when the\n  -overlay option is also supplied. A similar thing is done on IRIX\n  as well when -overlay is supplied.\n  More generally, as of Dec/2004 x11vnc supports the new XFIXES\n  extension (in Xorg and Solaris 10) to query the X server for the\n  exact cursor shape, this works pretty well except that cursors\n  with transparency (alpha channel) need to approximated to solid\n  RGB values (some cursors look worse than others.)\n* Audio from applications is of course not redirected (separate\n  redirectors do exist, e.g. esd, see the FAQ on this below.) The\n  XBell() \"beeps\" will work if the X server supports the XKEYBOARD\n  extension. (Note that on Solaris XKEYBOARD is disabled by default.\n  Passing +kb to Xsun enables it.)\n* The scroll detection algorithm for the -scrollcopyrect option can\n  give choppy or bunched up transient output and occasionally\n  painting errors.\n* Using -threads can expose some bugs/crashes in libvncserver."
}
