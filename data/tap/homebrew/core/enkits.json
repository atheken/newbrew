{
  "name": "enkits",
  "full_name": "enkits",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "C and C++ Task Scheduler for creating parallel programs",
  "license": "Zlib",
  "homepage": "https://github.com/dougbinks/enkiTS",
  "versions": {
    "stable": "1.11",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/dougbinks/enkiTS/archive/refs/tags/v1.11.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "b57a782a6a68146169d29d180d3553bfecb9f1a0e87a5159082331920e7d297e"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/enkits/blobs/sha256:3c5711ce533d47c9a34560e89fb023a33a55d795e73c9f1ecab5d1a6a759e656",
          "sha256": "3c5711ce533d47c9a34560e89fb023a33a55d795e73c9f1ecab5d1a6a759e656"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/enkits/blobs/sha256:d73910b2e106da68ef13675c76e4d18a265b2c514f898a1e3ab557a5a7d52caa",
          "sha256": "d73910b2e106da68ef13675c76e4d18a265b2c514f898a1e3ab557a5a7d52caa"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/enkits/blobs/sha256:6adefc872b396df076df8123bd17d61dd0fc1309dea9b3699df3ade05b28c578",
          "sha256": "6adefc872b396df076df8123bd17d61dd0fc1309dea9b3699df3ade05b28c578"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/enkits/blobs/sha256:b8ba0283e0455e191531f33ac60dab001f312386defc0d182cda14b062930530",
          "sha256": "b8ba0283e0455e191531f33ac60dab001f312386defc0d182cda14b062930530"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/enkits/blobs/sha256:cfd9a6e5f1c88e091ae948867231254e177bbce5c04acc48a05117dd16ff9ea8",
          "sha256": "cfd9a6e5f1c88e091ae948867231254e177bbce5c04acc48a05117dd16ff9ea8"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/enkits/blobs/sha256:d8a9e68c02f80beb48beb2f8b39bf12bebb5077682cc623fa25244ce9ca0364f",
          "sha256": "d8a9e68c02f80beb48beb2f8b39bf12bebb5077682cc623fa25244ce9ca0364f"
        },
        "catalina": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/enkits/blobs/sha256:675a3d006f1afd2efdcb396b178160fbfa64a40799e12d5a58364d6fa468cff7",
          "sha256": "675a3d006f1afd2efdcb396b178160fbfa64a40799e12d5a58364d6fa468cff7"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/enkits/blobs/sha256:fb5764d88d00d8df8970a0253f177b70a4d11535dfcf87a8f98a984cc81d0b1a",
          "sha256": "fb5764d88d00d8df8970a0253f177b70a4d11535dfcf87a8f98a984cc81d0b1a"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/enkits.rb",
  "ruby_source_checksum": {
    "sha256": "a3acfcf5b891ab9fb84feda139adb8cb219b0b90d3d76152fbeda961dc606f5a"
  },
  "date_added": "2021-04-07T15:55:09+00:00",
  "readme": "Support development of enkiTS through [Github Sponsors](https://github.com/sponsors/dougbinks) or [Patreon](https://www.patreon.com/enkisoftware)\n\n[<img src=\"https://img.shields.io/static/v1?logo=github&label=Github&message=Sponsor&color=#ea4aaa\" width=\"200\"/>](https://github.com/sponsors/dougbinks)    [<img src=\"https://c5.patreon.com/external/logo/become_a_patron_button@2x.png\" alt=\"Become a Patron\" width=\"150\"/>](https://www.patreon.com/enkisoftware)\n\n![enkiTS Logo](https://github.com/dougbinks/images/blob/master/enkiTS_logo_no_padding.png?raw=true)\n# enkiTS\n| [Master branch](https://github.com/dougbinks/enkiTS/) | [Dev branch](https://github.com/dougbinks/enkiTS/tree/dev) |\n| --- | --- |\n| [![Build Status for branch: master](https://github.com/dougbinks/enkiTS/actions/workflows/build.yml/badge.svg)](https://github.com/dougbinks/enkiTS/actions) | [![Build Status for branch: dev](https://github.com/dougbinks/enkiTS/actions/workflows/build.yml/badge.svg?branch=dev)](https://github.com/dougbinks/enkiTS/actions) |\n\n## enki Task Scheduler\n\nA permissively licensed C and C++ Task Scheduler for creating parallel programs. Requires C++11 support.\n\nThe primary goal of enkiTS is to help developers create programs which handle both data and task level parallelism to utilize the full performance of multicore CPUs, whilst being lightweight (only a small amount of code) and easy to use.\n\n* [C++ API via src/TaskScheduler.h](src/TaskScheduler.h)\n* [C API via src/TaskScheduler_c.h](src/TaskScheduler_c.h)\n\nenkiTS was developed for, and is used in [enkisoftware](http://www.enkisoftware.com/)'s Avoyd codebase.\n\n## Platforms\n\n- Windows, Linux, Mac OS, Android (should work on iOS) \n- x64 & x86, ARM\n\nenkiTS is primarily developed on x64 and x86 Intel architectures on MS Windows, with well tested support for Linux and somewhat less frequently tested support on Mac OS and ARM Android.\n\n## Examples\n\nSeveral examples exist in  the [example folder](https://github.com/dougbinks/enkiTS/tree/master/example).\n\nFor further examples, see https://github.com/dougbinks/enkiTSExamples\n\n## Building\n\nBuilding enkiTS is simple, just add the files in enkiTS/src to your build system (_c.* files can be ignored if you only need C++ interface), and add enkiTS/src to your include path. Unix / Linux builds will likely require the pthreads library.\n\nFor C++\n\n  - Use `#include \"TaskScheduler.h\"`\n  - Add enkiTS/src to your include path\n  - Compile / Add to project: \n    - `TaskScheduler.cpp`\n  - Unix / Linux builds will likely require the pthreads library.\n\nFor C\n\n  - Use `#include \"TaskScheduler_c.h\"`\n  - Add enkiTS/src to your include path\n  - Compile / Add to project:\n    - `TaskScheduler.cpp`\n    - `TaskScheduler_c.cpp`\n  - Unix / Linux builds will likely require the pthreads library.\n\nFor cmake, on Windows / Mac OS X / Linux with cmake installed, open a prompt in the enkiTS directory and:\n\n1. `mkdir build`\n1. `cd build`\n1. `cmake ..`\n1. either run `make all` or for Visual Studio open `enkiTS.sln`\n\n## Project Features\n\n1. *Lightweight* - enkiTS is designed to be lean so you can use it anywhere easily, and understand it.\n1. *Fast, then scalable* - enkiTS is designed for consumer devices first, so performance on a low number of threads is important, followed by scalability.\n1. *Braided parallelism* - enkiTS can issue tasks from another task as well as from the thread which created the Task System, and has a simple task interface for both data parallel and task parallelism.\n1. *Up-front Allocation friendly* - enkiTS is designed for zero allocations during scheduling.\n1. *Can pin tasks to a given thread* - enkiTS can schedule a task which will only be run on the specified thread.\n1. *Can set task priorities* - Up to 5 task priorities can be configured via define ENKITS_TASK_PRIORITIES_NUM (defaults to 3). Higher priority tasks are run before lower priority ones.\n1. *Can register external threads to use with enkiTS* - Can configure enkiTS with numExternalTaskThreads which can be registered to use with the enkiTS API.\n1. *Custom allocator API* - can configure enkiTS with custom allocators, see [example/CustomAllocator.cpp](example/CustomAllocator.cpp) and [example/CustomAllocator_c.c](example/CustomAllocator_c.c).\n1. *Dependencies* - can set dependendencies between tasks see [example/Dependencies.cpp](example/Dependencies.cpp) and [example/Dependencies_c.c](example/Dependencies_c.c).\n1. *Completion Actions* - can perform an action on task completion. This avoids the expensive action of adding the task to the scheduler, and can be used to safely delete a completed task. See [example/CompletionAction.cpp](example/CompletionAction.cpp) and [example/CompletionAction_c.c](example/CompletionAction_c.c)\n1. **NEW** *Can wait for pinned tasks* - Can wait for pinned tasks, useful for creating IO threads which do no other work. See [example/WaitForNewPinnedTasks.cpp](example/WaitForNewPinnedTasks.cpp) and [example/WaitForNewPinnedTasks_c.c](example/WaitForNewPinnedTasks_c.c).\n\n## Using enkiTS\n\n### C++ usage\n- full example in [example/ParallelSum.cpp](example/ParallelSum.cpp)\n- C example in [example/ParallelSum_c.c](example/ParallelSum_c.c)\n```C\n#include \"TaskScheduler.h\"\n\nenki::TaskScheduler g_TS;\n\n// define a task set, can ignore range if we only do one thing\nstruct ParallelTaskSet : enki::ITaskSet {\n    void ExecuteRange(  enki::TaskSetPartition range_, uint32_t threadnum_ ) override {\n        // do something here, can issue tasks with g_TS\n    }\n};\n\nint main(int argc, const char * argv[]) {\n    g_TS.Initialize();\n    ParallelTaskSet task; // default constructor has a set size of 1\n    g_TS.AddTaskSetToPipe( &task );\n\n    // wait for task set (running tasks if they exist)\n    // since we've just added it and it has no range we'll likely run it.\n    g_TS.WaitforTask( &task );\n    return 0;\n}\n```\n\n### C++ 11 lambda usage\n- full example in [example/LambdaTask.cpp](example/LambdaTask.cpp)\n```C\n#include \"TaskScheduler.h\"\n\nenki::TaskScheduler g_TS;\n\nint main(int argc, const char * argv[]) {\n   g_TS.Initialize();\n\n   enki::TaskSet task( 1, []( enki::TaskSetPartition range_, uint32_t threadnum_  ) {\n         // do something here\n      }  );\n\n   g_TS.AddTaskSetToPipe( &task );\n   g_TS.WaitforTask( &task );\n   return 0;\n}\n```\n\n### Task priorities usage in C++\n- full example in [example/Priorities.cpp](example/Priorities.cpp)\n- C example in [example/Priorities_c.c](example/Priorities_c.c)\n```C\n// See full example in Priorities.cpp\n#include \"TaskScheduler.h\"\n\nenki::TaskScheduler g_TS;\n\nstruct ExampleTask : enki::ITaskSet\n{\n    ExampleTask( ) { m_SetSize = size_; }\n\n    void ExecuteRange(  enki::TaskSetPartition range_, uint32_t threadnum_ ) override {\n        // See full example in Priorities.cpp\n    }\n};\n\n\n// This example demonstrates how to run a long running task alongside tasks\n// which must complete as early as possible using priorities.\nint main(int argc, const char * argv[])\n{\n    g_TS.Initialize();\n\n    ExampleTask lowPriorityTask( 10 );\n    lowPriorityTask.m_Priority  = enki::TASK_PRIORITY_LOW;\n\n    ExampleTask highPriorityTask( 1 );\n    highPriorityTask.m_Priority = enki::TASK_PRIORITY_HIGH;\n\n    g_TS.AddTaskSetToPipe( &lowPriorityTask );\n    for( int task = 0; task < 10; ++task )\n    {\n        // run high priority tasks\n        g_TS.AddTaskSetToPipe( &highPriorityTask );\n\n        // wait for task but only run tasks of the same priority or higher on this thread\n        g_TS.WaitforTask( &highPriorityTask, highPriorityTask.m_Priority );\n    }\n    // wait for low priority task, run any tasks on this thread whilst waiting\n    g_TS.WaitforTask( &lowPriorityTask );\n\n    return 0;\n}\n```\n\n### Pinned Tasks usage in C++\n- full example in [example/PinnedTask.cpp](example/PinnedTask.cpp)\n- C example in [example/PinnedTask_c.c](example/PinnedTask_c.c)\n```C\n#include \"TaskScheduler.h\"\n\nenki::TaskScheduler g_TS;\n\n// define a task set, can ignore range if we only do one thing\nstruct PinnedTask : enki::IPinnedTask {\n    void Execute() override {\n      // do something here, can issue tasks with g_TS\n    }\n};\n\nint main(int argc, const char * argv[]) {\n    g_TS.Initialize();\n    PinnedTask task; //default constructor sets thread for pinned task to 0 (main thread)\n    g_TS.AddPinnedTask( &task );\n\n    // RunPinnedTasks must be called on main thread to run any pinned tasks for that thread.\n    // Tasking threads automatically do this in their task loop.\n    g_TS.RunPinnedTasks();\n\n    // wait for task set (running tasks if they exist)\n    // since we've just added it and it has no range we'll likely run it.\n    g_TS.WaitforTask( &task );\n    return 0;\n}\n```\n\n### Dependency usage in C++\n- full example in [example/Dependencies.cpp](example/Dependencies.cpp)\n- C example in [example/Dependencies_c.c](example/Dependencies_c.c)\n```C\n#include \"TaskScheduler.h\"\n\nenki::TaskScheduler g_TS;\n\n// define a task set, can ignore range if we only do one thing\nstruct TaskA : enki::ITaskSet {\n    void ExecuteRange(  enki::TaskSetPartition range_, uint32_t threadnum_ ) override {\n        // do something here, can issue tasks with g_TS\n    }\n};\n\nstruct TaskB : enki::ITaskSet {\n    enki::Dependency m_Dependency;\n    void ExecuteRange(  enki::TaskSetPartition range_, uint32_t threadnum_ ) override {\n        // do something here, can issue tasks with g_TS\n    }\n};\n\nint main(int argc, const char * argv[]) {\n    g_TS.Initialize();\n    \n    // set dependencies once (can set more than one if needed).\n    TaskA taskA;\n    TaskB taskB;\n    taskB.SetDependency( taskB.m_Dependency, &taskA );\n\n    g_TS.AddTaskSetToPipe( &taskA ); // add first task\n    g_TS.WaitforTask( &taskB );      // wait for last\n    return 0;\n}\n```\n\n### External task thread usage in C++\n- full example in [example/ExternalTaskThread.cpp](example/ExternalTaskThread.cpp)\n- C example in [example/ExternalTaskThread_c.c](example/ExternalTaskThread_c.c)\n```C\n#include \"TaskScheduler.h\"\n\nenki::TaskScheduler g_TS;\nstruct ParallelTaskSet : ITaskSet\n{\n    void ExecuteRange(  enki::TaskSetPartition range_, uint32_t threadnum_ ) override {\n        // Do something\n    }\n};\n\nvoid threadFunction()\n{\n    g_TS.RegisterExternalTaskThread();\n\n    // sleep for a while instead of doing something such as file IO\n    std::this_thread::sleep_for( std::chrono::milliseconds( num_ * 100 ) );\n\n    ParallelTaskSet task;\n    g_TS.AddTaskSetToPipe( &task );\n    g_TS.WaitforTask( &task);\n\n    g_TS.DeRegisterExternalTaskThread();\n}\n\nint main(int argc, const char * argv[])\n{\n    enki::TaskSchedulerConfig config;\n    config.numExternalTaskThreads = 1; // we have one extra external thread\n\n    g_TS.Initialize( config );\n\n    std::thread exampleThread( threadFunction );\n\n    exampleThread.join();\n\n    return 0;\n}\n```\n\n### WaitForPinnedTasks thread usage in C++ (useful for IO threads)\n- full example in [example/WaitForNewPinnedTasks.cpp](example/WaitForNewPinnedTasks.cpp)\n- C example in [example/WaitForNewPinnedTasks_c.c](example/WaitForNewPinnedTasks_c.c)\n```C++\n#include \"TaskScheduler.h\"\n\nenki::TaskScheduler g_TS;\n\nstruct RunPinnedTaskLoopTask : enki::IPinnedTask\n{\n    void Execute() override\n    {\n        while( g_TS.GetIsRunning() )\n        {\n            g_TS.WaitForNewPinnedTasks(); // this thread will 'sleep' until there are new pinned tasks\n            g_TS.RunPinnedTasks();\n        }\n    }\n};\n\nstruct PretendDoFileIO : enki::IPinnedTask\n{\n    void Execute() override\n    {\n        // Do file IO\n    }\n};\n\nint main(int argc, const char * argv[])\n{\n    enki::TaskSchedulerConfig config;\n\n    // In this example we create more threads than the hardware can run,\n    // because the IO thread will spend most of it's time idle or blocked\n    // and therefore not scheduled for CPU time by the OS\n    config.numTaskThreadsToCreate += 1;\n\n    g_TS.Initialize( config );\n\n    // in this example we place our IO threads at the end\n    RunPinnedTaskLoopTask runPinnedTaskLoopTasks;\n    runPinnedTaskLoopTasks.threadNum = g_TS.GetNumTaskThreads() - 1;\n    g_TS.AddPinnedTask( &runPinnedTaskLoopTasks );\n\n    // Send pretend file IO task to external thread FILE_IO\n    PretendDoFileIO pretendDoFileIO;\n    pretendDoFileIO.threadNum = runPinnedTaskLoopTasks.threadNum;\n    g_TS.AddPinnedTask( &pretendDoFileIO );\n\n    // ensure runPinnedTaskLoopTasks complete by explicitly calling shutdown\n    g_TS.WaitforAllAndShutdown();\n\n    return 0;\n}\n```\n\n\n## Bindings\n\n- C# [EnkiTasks C#](https://github.com/nxrighthere/EnkiTasks-CSharp)\n\n## Deprecated\n\n[The C++98 compatible branch](https://github.com/dougbinks/enkiTS/tree/C++98) has been deprecated as I'm not aware of anyone needing it.\n\nThe user thread versions are no longer being maintained as they are no longer in use. Similar functionality can be obtained with the externalTaskThreads\n* [User thread version  on Branch UserThread](https://github.com/dougbinks/enkiTS/tree/UserThread) for running enkiTS on other tasking / threading systems, so it can be used as in other engines as well as standalone for example.\n* [C++ 11 version of user threads on Branch UserThread_C++11](https://github.com/dougbinks/enkiTS/tree/UserThread_C++11)\n\n## Projects using enkiTS\n\n### [Avoyd](https://www.avoyd.com)\nAvoyd is an abstract 6 degrees of freedom voxel game. enkiTS was developed for use in our [in-house engine powering Avoyd](https://www.enkisoftware.com/faq#engine). \n\n![Avoyd screenshot](https://github.com/juliettef/Media/blob/main/Avoyd_2019-06-22_enkiTS_microprofile.jpg?raw=true)\n\n### [Imogen](https://github.com/CedricGuillemet/Imogen)\nGPU/CPU Texture Generator\n\n![Imogen screenshot](https://camo.githubusercontent.com/28347bc0c1627aa4f289e1b2b769afcb3a5de370/68747470733a2f2f692e696d6775722e636f6d2f7351664f3542722e706e67)\n\n### [ToyPathRacer](https://github.com/aras-p/ToyPathTracer)\nAras Pranckevičius' code for his series on [Daily Path Tracer experiments with various languages](https://aras-p.info/blog/2018/03/28/Daily-Pathtracer-Part-0-Intro/).\n\n![ToyPathTracer screenshot](https://github.com/aras-p/ToyPathTracer/blob/main/Shots/screenshot.jpg?raw=true).\n\n### [Mastering Graphics Programming with Vulkan](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan)\nMarco Castorina and Gabriel Sassone's book on developing a modern rendering engine from first principles using the Vulkan API. enkiTS is used as the task library to distribute work across cores.\n\n![Mastering Graphics Programming with Vulkan](https://static.packt-cdn.com/products/9781803244792/cover/smaller)\n\n## License (zlib)\n\nCopyright (c) 2013-2020 Doug Binks\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must not\n   claim that you wrote the original software. If you use this software\n   in a product, an acknowledgement in the product documentation would be\n   appreciated but is not required.\n2. Altered source versions must be plainly marked as such, and must not be\n   misrepresented as being the original software.\n3. This notice may not be removed or altered from any source distribution."
}
