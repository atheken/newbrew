{
  "name": "packr",
  "full_name": "packr",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Easy way to embed static files into Go binaries",
  "license": "MIT",
  "homepage": "https://github.com/gobuffalo/packr",
  "versions": {
    "stable": "2.8.3",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/gobuffalo/packr/archive/v2.8.3.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "67352bb3a73f6b183d94dd94f1b5be648db6311caa11dcfd8756193ebc0e2db9"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 1,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/packr/blobs/sha256:012421ccb6766aa56682433e05e85b8c8b6afc1c2681edbc856a02c2fecc74d7",
          "sha256": "012421ccb6766aa56682433e05e85b8c8b6afc1c2681edbc856a02c2fecc74d7"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/packr/blobs/sha256:c7cf08f5bbb1612452c67526c02f0f9d48ca9837962c89ba6a60886280c61dc5",
          "sha256": "c7cf08f5bbb1612452c67526c02f0f9d48ca9837962c89ba6a60886280c61dc5"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/packr/blobs/sha256:da232cec4e97f9565bd16bb0e3e4d64abbd4699883a4c1b380217312674ad5a7",
          "sha256": "da232cec4e97f9565bd16bb0e3e4d64abbd4699883a4c1b380217312674ad5a7"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/packr/blobs/sha256:375adfa65193c1923987f2edabe0e145c98514eecabdf4b9868836ee1362e104",
          "sha256": "375adfa65193c1923987f2edabe0e145c98514eecabdf4b9868836ee1362e104"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/packr/blobs/sha256:035174493dcdafadae9f1c38c8e651f9d2511f37df2eeb9e9634e02dc5791f9c",
          "sha256": "035174493dcdafadae9f1c38c8e651f9d2511f37df2eeb9e9634e02dc5791f9c"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/packr/blobs/sha256:3ced81e9a80049d9f1c878cb7b5850c7d1fe61b93b9f1847e659180f9ed0c215",
          "sha256": "3ced81e9a80049d9f1c878cb7b5850c7d1fe61b93b9f1847e659180f9ed0c215"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/packr/blobs/sha256:526c8d9706b0b3c7d9538fc85db542cc5fe1041ebc5a5d2df7f3e2c2fd93d67a",
          "sha256": "526c8d9706b0b3c7d9538fc85db542cc5fe1041ebc5a5d2df7f3e2c2fd93d67a"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/packr/blobs/sha256:71f763effa24fad2ae09028ea1d87f351cf0425ca40f1c25b5ef974839088f62",
          "sha256": "71f763effa24fad2ae09028ea1d87f351cf0425ca40f1c25b5ef974839088f62"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "go"
  ],
  "dependencies": [],
  "test_dependencies": [
    "go"
  ],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": true,
  "deprecation_date": "2022-11-27",
  "deprecation_reason": "repo_archived",
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/packr.rb",
  "ruby_source_checksum": {
    "sha256": "535e3bf505b4ca02728ae356a373aa9ab9838054679356501e5eb94f65f86eef"
  },
  "date_added": "2020-06-02T13:54:35+00:00",
  "readme": "**NOTICE: Please consider migrating your projects to\n[embed](https://pkg.go.dev/embed) which is native file embedding feature of Go,\nor github.com/markbates/pkger. It has an idiomatic API, minimal dependencies, a stronger test suite (tested directly against the std lib counterparts), transparent tooling, and more.**\n\nhttps://blog.gobuffalo.io/introducing-pkger-static-file-embedding-in-go-1ce76dc79c65\n\n# Packr (v2)\n\n[![GoDoc](https://godoc.org/github.com/gobuffalo/packr/v2?status.svg)](https://godoc.org/github.com/gobuffalo/packr/v2)\n[![Actions Status](https://github.com/gobuffalo/packr/workflows/Tests/badge.svg)](https://github.com/gobuffalo/packr/actions)\n\nPackr is a simple solution for bundling static assets inside of Go binaries. Most importantly it does it in a way that is friendly to developers while they are developing.\n\nAt this moment, supported go versions are:\n\n* 1.16.x\n* 1.17.x\n\neven though it may (or may not) working well with older versions.\n\n## Intro Video\n\nTo get an idea of the what and why of Packr, please enjoy this short video: [https://vimeo.com/219863271](https://vimeo.com/219863271).\n\n## Library Installation\n\n### Go 1.16 and above\n\n```console\n$ go install github.com/gobuffalo/packr/v2@v2.8.3\n```\n\nor\n\n```console\n$ go install github.com/gobuffalo/packr/v2@latest\n```\n\n### Go 1.15 and below\n\n```console\n$ go get -u github.com/gobuffalo/packr/...\n```\n\n## Binary Installation\n\n### Go 1.16 and above\n\n```console\n$ go install github.com/gobuffalo/packr/v2/packr2@v2.8.3\n```\n\nor\n\n```console\n$ go install github.com/gobuffalo/packr/v2/packr2@latest\n```\n\n### Go 1.15 and below\n\n```console\n$ go get -u github.com/gobuffalo/packr/packr2\n```\n\n## New File Format FAQs\n\nIn version `v2.0.0` the file format changed and is not backward compatible with the `packr-v1.x` library.\n\n#### Can `packr-v1.x` read the new format?\n\nNo, it can not. Because of the way the new file format works porting it to `packr-v1.x` would be difficult. PRs are welcome though. :)\n\n#### Can `packr-v2.x` read `packr-v1.x` files?\n\nYes it can, but that ability will eventually be phased out. Because of that we recommend moving to the new format.\n\n#### Can `packr-v2.x` generate `packr-v1.x` files?\n\nYes it can, but that ability will eventually be phased out. Because of that we recommend moving to the new format.\n\nThe `--legacy` command is available on all commands that generate `-packr.go` files.\n\n```bash\n$ packr2 --legacy\n```\n\n## Usage\n\n### In Code\n\nThe first step in using Packr is to create a new box. A box represents a folder on disk. Once you have a box you can get `string` or `[]byte` representations of the file.\n\n```go\n// set up a new box by giving it a name and an optional (relative) path to a folder on disk:\nbox := packr.New(\"My Box\", \"./templates\")\n\n// Get the string representation of a file, or an error if it doesn't exist:\nhtml, err := box.FindString(\"index.html\")\n\n// Get the []byte representation of a file, or an error if it doesn't exist:\nhtml, err := box.Find(\"index.html\")\n```\n\n### What is a Box?\n\nA box represents a folder, and any sub-folders, on disk that you want to have access to in your binary. When compiling a binary using the `packr2` CLI the contents of the folder will be converted into Go files that can be compiled inside of a \"standard\" go binary. Inside of the compiled binary the files will be read from memory. When working locally the files will be read directly off of disk. This is a seamless switch that doesn't require any special attention on your part.\n\n#### Example\n\nAssume the follow directory structure:\n\n```\n├── main.go\n└── templates\n    ├── admin\n    │   └── index.html\n    └── index.html\n```\n\nThe following program will read the `./templates/admin/index.html` file and print it out.\n\n```go\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/gobuffalo/packr/v2\"\n)\n\nfunc main() {\n  box := packr.New(\"myBox\", \"./templates\")\n\n  s, err := box.FindString(\"admin/index.html\")\n  if err != nil {\n    log.Fatal(err)\n  }\n  fmt.Println(s)\n}\n```\n\n### Development Made Easy\n\nIn order to get static files into a Go binary, those files must first be converted to Go code. To do that, Packr, ships with a few tools to help build binaries. See below.\n\nDuring development, however, it is painful to have to keep running a tool to compile those files.\n\nPackr uses the following resolution rules when looking for a file:\n\n1. Look for the file in-memory (inside a Go binary)\n1. Look for the file on disk (during development)\n\nBecause Packr knows how to fall through to the file system, developers don't need to worry about constantly compiling their static files into a binary. They can work unimpeded.\n\nPackr takes file resolution a step further. When declaring a new box you use a relative path, `./templates`. When Packr receives this call it calculates out the absolute path to that directory. By doing this it means you can be guaranteed that Packr can find your files correctly, even if you're not running in the directory that the box was created in. This helps with the problem of testing, where Go changes the `pwd` for each package, making relative paths difficult to work with. This is not a problem when using Packr.\n\n---\n\n## Usage with HTTP\n\nA box implements the [`http.FileSystem`](https://golang.org/pkg/net/http/#FileSystem) interface, meaning it can be used to serve static files.\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gobuffalo/packr/v2\"\n)\n\nfunc main() {\n\tbox := packr.New(\"someBoxName\", \"./templates\")\n\n\thttp.Handle(\"/\", http.FileServer(box))\n\thttp.ListenAndServe(\":3000\", nil)\n}\n```\n\n---\n\n## Building a Binary\n\nBefore you build your Go binary, run the `packr2` command first. It will look for all the boxes in your code and then generate `.go` files that pack the static files into bytes that can be bundled into the Go binary.\n\n```\n$ packr2\n```\n\nThen run your `go build command` like normal.\n\n*NOTE*: It is not recommended to check-in these generated `-packr.go` files. They can be large, and can easily become out of date if not careful. It is recommended that you always run `packr2 clean` after running the `packr2` tool.\n\n#### Cleaning Up\n\nWhen you're done it is recommended that you run the `packr2 clean` command. This will remove all of the generated files that Packr created for you.\n\n```\n$ packr2 clean\n```\n\nWhy do you want to do this? Packr first looks to the information stored in these generated files, if the information isn't there it looks to disk. This makes it easy to work with in development.\n\n---\n\n## Debugging\n\nThe `packr2` command passes all arguments down to the underlying `go` command, this includes the `-v` flag to print out `go build` information. Packr looks for the `-v` flag, and will turn on its own verbose logging. This is very useful for trying to understand what the `packr` command is doing when it is run.\n\n---\n\n## FAQ\n\n### Compilation Errors with Go Templates\n\nQ: I have a program with Go template files, those files are named `foo.go` and look like the following:\n\n```\n// Copyright {{.Year}} {{.Author}}. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage {{.Project}}\n```\n\nWhen I run `packr2` I get errors like:\n\n```\nexpected 'IDENT', found '{'\n```\n\nA: Packr works by searching your `.go` files for [`github.com/gobuffalo/packr/v2#New`](https://godoc.org/github.com/gobuffalo/packr/v2#New) or [`github.com/gobuffalo/packr/v2#NewBox`](https://godoc.org/github.com/gobuffalo/packr/v2#NewBox) calls. Because those files aren't \"proper\" Go files, Packr can't parse them to find the box declarations. To fix this you need to tell Packr to ignore those files when searching for boxes. A couple solutions to this problem are:\n\n* Name the files something else. The `.tmpl` extension is the idiomatic way of naming these types of files.\n* Rename the folder containing these files to start with an `_`, for example `_templates`. Packr, like Go, will ignore folders starting with the `_` character when searching for boxes.\n\n### Dynamic Box Paths\n\nQ: I need to set the path of a box using a variable, but `packr.New(\"foo\", myVar)` doesn't work correctly.\n\nA: Packr attempts to \"automagically\" set it's resolution directory when using [`github.com/gobuffalo/packr/v2#New`](https://godoc.org/github.com/gobuffalo/packr/v2#New), however, for dynamic paths you need to set it manually:\n\n```go\nbox := packr.New(\"foo\", \"|\")\nbox.ResolutionDir = myVar\n```\n\n### I don't want to pack files, but still use the Packr interface.\n\nQ: I want to write code that using the Packr tools, but doesn't actually pack the files into my binary. How can I do that?\n\nA: Using [`github.com/gobuffalo/packr/v2#Folder`](https://godoc.org/github.com/gobuffalo/packr/v2#Folder) gives you back a `*packr.Box` that can be used as normal, but is excluded by the Packr tool when compiling.\n\n### Packr Finds No Boxes\n\nQ: I run `packr2 -v` but it doesn't find my boxes:\n\n```\nDEBU[2019-03-18T18:48:52+01:00] *parser.Parser#NewFromRoots found prospects=0\nDEBU[2019-03-18T18:48:52+01:00] found 0 boxes\n```\n\nA: Packr works by parsing `.go` files to find [`github.com/gobuffalo/packr/v2#Box`](https://godoc.org/github.com/gobuffalo/packr/v2#Box) and [`github.com/gobuffalo/packr/v2#NewBox`](https://godoc.org/github.com/gobuffalo/packr/v2#NewBox) declarations. If there aren't any `.go` in the folder that `packr2` is run in it can not find those declarations. To fix this problem run the `packr2` command in the directory containing your `.go` files.\n\n### Box Interfaces\n\nQ: I want to be able to easily test my applications by passing in mock boxes. How do I do that?\n\nA: Packr boxes and files conform to the interfaces found at [`github.com/gobuffalo/packd`](https://godoc.org/github.com/gobuffalo/packd). Change your application to use those interfaces instead of the concrete Packr types.\n\n```go\n// using concrete type\nfunc myFunc(box *packr.Box) {}\n\n// using interfaces\nfunc myFunc(box packd.Box) {}\n```"
}
