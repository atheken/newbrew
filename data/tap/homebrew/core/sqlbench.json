{
  "name": "sqlbench",
  "full_name": "sqlbench",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Measures and compares the execution time of one or more SQL queries",
  "license": "MIT",
  "homepage": "https://github.com/felixge/sqlbench",
  "versions": {
    "stable": "1.1.0",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/felixge/sqlbench/archive/v1.1.0.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "deaf4c299891ce75abff00429343eded76e8ddc8295d488938aa9ee418a7c9b3"
    },
    "head": {
      "url": "https://github.com/felixge/sqlbench.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/sqlbench/blobs/sha256:0598ce5d9b3c1aed37b1690a3e8357300b3ef8906ea2275fe1ee997375c09e98",
          "sha256": "0598ce5d9b3c1aed37b1690a3e8357300b3ef8906ea2275fe1ee997375c09e98"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/sqlbench/blobs/sha256:14d3a0b3a26e3291ae1039e67c72970b4a1b0388387b919f2c71e01e24e6a429",
          "sha256": "14d3a0b3a26e3291ae1039e67c72970b4a1b0388387b919f2c71e01e24e6a429"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/sqlbench/blobs/sha256:8373986acd8ee9e32df964c5bff6b365f29afa06fa256789017112d9b07ffcf2",
          "sha256": "8373986acd8ee9e32df964c5bff6b365f29afa06fa256789017112d9b07ffcf2"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/sqlbench/blobs/sha256:fafa90b195b10fa34a841acec103788f7e83277ca5b58c8a5763868857409dd1",
          "sha256": "fafa90b195b10fa34a841acec103788f7e83277ca5b58c8a5763868857409dd1"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/sqlbench/blobs/sha256:a59e25067b830b0062a0d3c7fa98da5c31ef16c0763303f5acf16238aead26a6",
          "sha256": "a59e25067b830b0062a0d3c7fa98da5c31ef16c0763303f5acf16238aead26a6"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/sqlbench/blobs/sha256:9a74a774e1c5c5512b9230713af78f3694d38f237241817740c8f244febe8e09",
          "sha256": "9a74a774e1c5c5512b9230713af78f3694d38f237241817740c8f244febe8e09"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/sqlbench/blobs/sha256:a138dbb8bf3fa6293e51b49e91e35078c8c2d7dc399c70a61705f047b519a8f1",
          "sha256": "a138dbb8bf3fa6293e51b49e91e35078c8c2d7dc399c70a61705f047b519a8f1"
        },
        "mojave": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/sqlbench/blobs/sha256:382ff90c210126e6803b47d1b267761d592b1d9898f6804730beb26df80af917",
          "sha256": "382ff90c210126e6803b47d1b267761d592b1d9898f6804730beb26df80af917"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/sqlbench/blobs/sha256:e0e961ada32e3e6588b0a328d3030f39e7bcc1457b63573608347e28cd5960cf",
          "sha256": "e0e961ada32e3e6588b0a328d3030f39e7bcc1457b63573608347e28cd5960cf"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "go"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/sqlbench.rb",
  "ruby_source_checksum": {
    "sha256": "ba72f343cc798c2043aeb7255174da7c714c110d2eb15299bb9594598ee0a1ca"
  },
  "date_added": "2021-06-09T15:46:51+00:00",
  "readme": "# sqlbench\n\nsqlbench measures and compares the execution time of one or more SQL queries.\n\n![screen recording](./recording/recording-min.gif)\n\nThe main use case is benchmarking simple CPU-bound query variants against each other during local development.\n\nOnly PostgreSQL is supported at this point, but pull requests for MySQL or other databases are welcome.\n\n## Install\n\nYou can download a binary from the [release page](https://github.com/felixge/sqlbench/releases).\n\nIf you have Go 1.16 or later installed, you can install or update sqlbench from source:\n\n```\n$ go get -u github.com/felixge/sqlbench\n```\n\n**Windows Users:** You may also install the [chocolatey package](https://chocolatey.org/packages/sqlbench) maintained by [picolino](https://github.com/picolino):\n\n```\n$ choco install sqlbench\n```\n\n### Install via brew\n\nIf you're macOS user and using [Homebrew](https://brew.sh/), you can install via brew command:\n\n```sh\n$ brew update\n$ brew install sqlbench\n```\n\n## Examples\n\nBelow are a few one-liners to get you started. They assume you're running sqlbench from the directory of a clone of this repo.\n\n```bash\n# Benchmark a few queries until ctrl+c is hit. Output results in realtime.\nsqlbench examples/sum/*.sql\n\n# Benchmark using client wallclock time (instead of explain) until ctrl+c.\nsqlbench -m client examples/sum/*.sql\n\n# Run for 3 seconds and only print results once at the end.\nsqlbench -t 3 -s examples/sum/*.sql\n\n# Run for 1000 iterations and only print verbose results once at the end\nsqlbench -n 1000 -s -v examples/sum/*.sql\n\n# Record the results for 1000 iterations into a csv file.\nsqlbench -n 1000 -o baseline.csv examples/sum/*.sql\n\n# Compare 1000 iterations to a baseline recording.\nsqlbench -n 1000 -i baseline.csv examples/sum/*.sql\n```\n\n## Usage\n\n```\nUsage of sqlbench:\n  -c string\n    \tConnection URL or DSN for connecting to PostgreSQL as understood by pgx [1].\n    \tE.g.: postgres://user:secret@localhost:5432/my_db?sslmode=disable\n\n    \tAlternatively you can use standard PostgreSQL environment variables [2] such as\n    \tPGHOST, PGPORT, PGPASSWORD, ... .\n\n    \t[1] https://pkg.go.dev/github.com/jackc/pgx/v4/stdlib?tab=doc\n    \t[2] https://www.postgresql.org/docs/current/libpq-envars.html\n    \t(default \"postgres://\")\n  -i string\n    \tInput path for CSV file with baseline measurements.\n  -m string\n    \tMethod for measuring the query time. One of: \"client\", \"explain\" (default \"explain\")\n  -n int\n    \tTerminate after the given number of iterations. (default -1)\n  -o string\n    \tOutput path for writing individual measurements in CSV format.\n  -p\tInclude the query planning time. For -m explain this is accomplished by adding\n    \tthe \"Planning Time\" to the measurement. For -m client this is done by not using\n    \tprepared statements.\n  -s\tSilent mode for non-interactive use, only prints stats once after terminating.\n  -t float\n    \tTerminate after the given number of seconds. (default -1)\n  -v\tVerbose output. Print the content of all SQL queries, as well as the\n    \tPostgreSQL version.\n  -version\n    \tPrint version and exit.\n```\n\n### How It Works\n\nsqlbench takes a list of SQL files and keeps executing them sequentially, measuring their execution times. By default the execution time is measured by prefixing the query with `EXPLAIN (ANALYZE, TIMING OFF)` and capturing the total `Execution Time` for it.\n\nThe query columns are ordered by mean execution time in ascending order, and the relative difference compared to the fastest query is shown in parentheses. If you provide a baseline csv via `-i`, the relative differences are comparing the corresponding queries in the baseline rather than the current queries with each other.\n\nIf the `-m client` flag is given, the time is measured using the wallclock time of sqlbench which includes network overhead.\n\nPlanning time is excluded by default, but can be included using the `-p` flag.\n\nThe filenames `init.sql` and `destroy.sql` are special, and are executed once before and after the benchmark respectively. They can be used to setup or teardown tables, indexes, etc..\n\n## Tutorial\n\nLet's say you want to compare three different queries for computing the running total of all numbers from 1 to 1000. Your first idea is to use a window function:\n\n```sql\nSELECT i, sum(i) OVER (ORDER BY i) AS sum\nFROM generate_series(1, 1000) g(i);\n```\n\nThen you decide to get fancy and implement it as a recursive CTE:\n\n```sql\nWITH RECURSIVE sums AS (\n\tSELECT 1 AS i, 1 AS sum\n\tUNION\n\tSELECT i+1, sum+i FROM sums WHERE i <= 1000\n)\n\nSELECT * FROM sums;\n```\n\nAnd finally you become wise and remember that [9 year old Gauss](https://www.nctm.org/Publications/Teaching-Children-Mathematics/Blog/The-Story-of-Gauss/) could probably beat both approaches:\n\n```sql\nSELECT i, (i * (i + 1)) / 2 AS sum\nFROM generate_series(1, 1000) g(i);\n```\n\nNow that you have your queries in `window.sql`, `recursive.sql`, `gauss.sql`, you want to summarize the performance differences for your colleagues. However, you know they're a pedantic bunch, and will ask you annoying questions such as:\n\n- How many times did you run each query?\n- Were you running other stuff on your laptop in the background?\n- How can I reproduce this on my local machine?\n- What version of PostgreSQL were you running on your local machine?\n- Are you sure you're not just measuring the overhead of `EXPLAIN ANALYZE`?\n\nThis could normally be quite annoying to deal with, but luckily there is sqlbench. The command below lets you run your three queries 1000 times with `EXPLAIN ANALYZE` and report the statistics, the PostgreSQL version and even the SQL of your queries:\n\n```\n$ sqlbench -v -s -n 1000 examples/sum/*.sql | tee explain-bench.txt\n```\n\n```\n         | gauss |    window     |   recursive\n---------+-------+---------------+----------------\n  n      |  1000 |          1000 |          1000\n  min    |  0.35 | 1.31 (3.79x)  | 1.80 (5.22x)\n  max    |  4.18 | 23.76 (5.68x) | 11.41 (2.73x)\n  mean   |  0.50 | 1.94 (3.85x)  | 2.67 (5.30x)\n  stddev |  0.16 | 0.81 (4.93x)  | 0.63 (3.87x)\n  median |  0.53 | 2.02 (3.80x)  | 2.91 (5.49x)\n  p90    |  0.67 | 2.53 (3.80x)  | 3.41 (5.12x)\n  p95    |  0.68 | 2.57 (3.81x)  | 3.50 (5.18x)\n\nStopping after 1000 iterations as requested.\n\npostgres version: PostgreSQL 11.6 on x86_64-apple-darwin16.7.0, compiled by Apple LLVM version 8.1.0 (clang-802.0.42), 64-bit\nsqlbench -v -s -n 1000 examples/sum/gauss.sql examples/sum/recursive.sql examples/sum/window.sql\n\n==> examples/sum/gauss.sql <==\nSELECT i, (i * (i + 1)) / 2 AS sum\nFROM generate_series(1, 1000) g(i);\n\n==> examples/sum/window.sql <==\nSELECT i, sum(i) OVER (ORDER BY i) AS sum\nFROM generate_series(1, 1000) g(i);\n\n==> examples/sum/recursive.sql <==\nWITH RECURSIVE sums AS (\n\tSELECT 1 AS i, 1 AS sum\n\tUNION\n\tSELECT i+1, sum+i FROM sums WHERE i <= 1000\n)\n\nSELECT * FROM sums;\n```\n\nAnd finally, you can use the `-m client` flag to measure the query times without `EXPLAIN ANALYZE` to see if that had a significant overhead:\n\n```\n$ sqlbench -s -n 1000 -m client examples/sum/*.sql | tee client-bench.txt\n```\n\n```\n         | gauss |    window    |  recursive\n---------+-------+--------------+---------------\n  n      |  1000 |         1000 |         1000\n  min    |  0.66 | 1.44 (2.18x) | 2.03 (3.08x)\n  max    |  5.66 | 7.31 (1.29x) | 4.34 (0.77x)\n  mean   |  0.83 | 1.72 (2.08x) | 2.35 (2.83x)\n  stddev |  0.23 | 0.33 (1.41x) | 0.27 (1.18x)\n  median |  0.78 | 1.65 (2.11x) | 2.26 (2.89x)\n  p90    |  0.98 | 1.98 (2.03x) | 2.68 (2.75x)\n  p95    |  1.05 | 2.13 (2.03x) | 2.89 (2.76x)\n\nStopping after 1000 iterations as requested.\n```\n\nIndeed, it appears that from the client's perspective the gauss query is a bit slower, while the others are a bit faster when measuring without `EXPLAIN ANALYZE`. Whether that's a rabbit hole worth exploring depends on you, but either way you now have a much better sense of the errors that might be contained in your measurements.\n\n## Todos\n\nBelow are a few ideas for todos that I might implement at some point or would welcome as pull requests.\n\n- [ ] Dynamically adjust unit between ms, s, etc.\n- [ ] Support specifying benchmarks using a single YAML file.\n- [ ] Support for other databases, e.g. MySQL.\n- [ ] Capture query plans for each query, ideally one close to the median execution time.\n- [ ] Provide an easy way to capture all inputs and outputs in a single tar.gz file or GitHub gist.\n- [ ] Plot query times as a histogram (made a proof of concept for this, but didn't like it enough yet to release)\n- [ ] Maybe add db name to verbose output, [see request](https://twitter.com/breinbaas1/status/1308138210606940160).\n- [x] Compare benchmark results between PG versions\n- [x] Oneliner examples for README\n- [x] Warmup phase (can be done via init.sql and pg_prewarm()\n- [x] Use `TIMING OFF` to reduce EXPLAIN overhead.\n- [x] A flag to include planning time in `-m explain` mode.\n- [x] A flag to use prepared queries in `-m client` mode.\n\n## License\n\nsqlbench is licensed under the MIT license."
}
