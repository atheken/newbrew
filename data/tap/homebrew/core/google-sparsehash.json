{
  "name": "google-sparsehash",
  "full_name": "google-sparsehash",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Extremely memory-efficient hash_map implementation",
  "license": "BSD-3-Clause",
  "homepage": "https://github.com/sparsehash/sparsehash",
  "versions": {
    "stable": "2.0.4",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/sparsehash/sparsehash/archive/sparsehash-2.0.4.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "8cd1a95827dfd8270927894eb77f62b4087735cbede953884647f16c521c7e58"
    },
    "head": {
      "url": "https://github.com/sparsehash/sparsehash.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/google-sparsehash/blobs/sha256:18714795cfeeeaed655d978a981e4c831fe39e46743ed79c0c219c695cf281e3",
          "sha256": "18714795cfeeeaed655d978a981e4c831fe39e46743ed79c0c219c695cf281e3"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/google-sparsehash/blobs/sha256:1cee10f1f45f9aa17c0a63573fb8065dea21f9f79c075fafeee699649d50f28d",
          "sha256": "1cee10f1f45f9aa17c0a63573fb8065dea21f9f79c075fafeee699649d50f28d"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/google-sparsehash/blobs/sha256:f24d74610bacd7a53f950e58f03b6d674d43a15495973d09c006e44e6721fde8",
          "sha256": "f24d74610bacd7a53f950e58f03b6d674d43a15495973d09c006e44e6721fde8"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/google-sparsehash/blobs/sha256:f9a98e3b018a0dfa4082ea14e434c6ad4f04465dd9a401f20b4de2c7e5dfc4fc",
          "sha256": "f9a98e3b018a0dfa4082ea14e434c6ad4f04465dd9a401f20b4de2c7e5dfc4fc"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/google-sparsehash/blobs/sha256:748df13f800d3d41d0c5c27f63cc349564b26029ba23659157f638e6753bfba1",
          "sha256": "748df13f800d3d41d0c5c27f63cc349564b26029ba23659157f638e6753bfba1"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/google-sparsehash/blobs/sha256:530dad7aa78d4420bbcbe5dbd6ab1a634acbc29a22576f19ec31af556ed4332c",
          "sha256": "530dad7aa78d4420bbcbe5dbd6ab1a634acbc29a22576f19ec31af556ed4332c"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/google-sparsehash/blobs/sha256:11390608ee72647c06a9735f89535604e6ed2b2531431f9eb81bdf423ab07620",
          "sha256": "11390608ee72647c06a9735f89535604e6ed2b2531431f9eb81bdf423ab07620"
        },
        "mojave": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/google-sparsehash/blobs/sha256:11390608ee72647c06a9735f89535604e6ed2b2531431f9eb81bdf423ab07620",
          "sha256": "11390608ee72647c06a9735f89535604e6ed2b2531431f9eb81bdf423ab07620"
        },
        "high_sierra": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/google-sparsehash/blobs/sha256:11390608ee72647c06a9735f89535604e6ed2b2531431f9eb81bdf423ab07620",
          "sha256": "11390608ee72647c06a9735f89535604e6ed2b2531431f9eb81bdf423ab07620"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/google-sparsehash/blobs/sha256:dc2afe1af778fc2217f2bc84ab4e38d0cdd96420ac08e4f9e909fa07e83efbdb",
          "sha256": "dc2afe1af778fc2217f2bc84ab4e38d0cdd96420ac08e4f9e909fa07e83efbdb"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/google-sparsehash.rb",
  "ruby_source_checksum": {
    "sha256": "43e4e6fbb1e311de08c0da783279f4840f4e0993efd2dd125f088f5ff2788e36"
  },
  "date_added": "2010-05-16T15:26:18+02:00",
  "readme": "This directory contains several hash-map implementations, similar in\nAPI to SGI's hash_map class, but with different performance\ncharacteristics.  sparse_hash_map uses very little space overhead, 1-2\nbits per entry.  dense_hash_map is very fast, particulary on lookup.\n(sparse_hash_set and dense_hash_set are the set versions of these\nroutines.)  On the other hand, these classes have requirements that\nmay not make them appropriate for all applications.\n\nAll these implementation use a hashtable with internal quadratic\nprobing.  This method is space-efficient -- there is no pointer\noverhead -- and time-efficient for good hash functions.\n\nCOMPILING\n---------\nTo compile test applications with these classes, run ./configure\nfollowed by make.  To install these header files on your system, run\n'make install'.  (On Windows, the instructions are different; see\nREADME_windows.txt.)  See INSTALL for more details.\n\nThis code should work on any modern C++ system.  It has been tested on\nLinux (Ubuntu, Fedora, RedHat, Debian), Solaris 10 x86, FreeBSD 6.0,\nOS X 10.3 and 10.4, and Windows under both VC++7 and VC++8.\n\nUSING\n-----\nSee the html files in the doc directory for small example programs\nthat use these classes.  It's enough to just include the header file:\n\n   #include <sparsehash/sparse_hash_map> // or sparse_hash_set, dense_hash_map, ...\n   google::sparse_hash_set<int, int> number_mapper;\n\nand use the class the way you would other hash-map implementations.\n(Though see \"API\" below for caveats.)\n\nBy default (you can change it via a flag to ./configure), these hash\nimplementations are defined in the google namespace.\n\nAPI\n---\nThe API for sparse_hash_map, dense_hash_map, sparse_hash_set, and\ndense_hash_set, are a superset of the API of SGI's hash_map class.\nSee doc/sparse_hash_map.html, et al., for more information about the\nAPI.\n\nThe usage of these classes differ from SGI's hash_map, and other\nhashtable implementations, in the following major ways:\n\n1) dense_hash_map requires you to set aside one key value as the\n   'empty bucket' value, set via the set_empty_key() method.  This\n   *MUST* be called before you can use the dense_hash_map.  It is\n   illegal to insert any elements into a dense_hash_map whose key is\n   equal to the empty-key.\n\n2) For both dense_hash_map and sparse_hash_map, if you wish to delete\n   elements from the hashtable, you must set aside a key value as the\n   'deleted bucket' value, set via the set_deleted_key() method.  If\n   your hash-map is insert-only, there is no need to call this\n   method.  If you call set_deleted_key(), it is illegal to insert any\n   elements into a dense_hash_map or sparse_hash_map whose key is\n   equal to the deleted-key.\n\n3) These hash-map implementation support I/O.  See below.\n\nThere are also some smaller differences:\n\n1) The constructor takes an optional argument that specifies the\n   number of elements you expect to insert into the hashtable.  This\n   differs from SGI's hash_map implementation, which takes an optional\n   number of buckets.\n\n2) erase() does not immediately reclaim memory.  As a consequence,\n   erase() does not invalidate any iterators, making loops like this\n   correct:\n      for (it = ht.begin(); it != ht.end(); ++it)\n        if (...) ht.erase(it);\n   As another consequence, a series of erase() calls can leave your\n   hashtable using more memory than it needs to.  The hashtable will\n   automatically compact at the next call to insert(), but to\n   manually compact a hashtable, you can call\n      ht.resize(0)\n\nI/O\n---\nIn addition to the normal hash-map operations, sparse_hash_map can\nread and write hashtables to disk.  (dense_hash_map also has the API,\nbut it has not yet been implemented, and writes will always fail.)\n\nIn the simplest case, writing a hashtable is as easy as calling two\nmethods on the hashtable:\n   ht.write_metadata(fp);\n   ht.write_nopointer_data(fp);\n\nReading in this data is equally simple:\n   google::sparse_hash_map<...> ht;\n   ht.read_metadata(fp);\n   ht.read_nopointer_data(fp);\n\nThe above is sufficient if the key and value do not contain any\npointers: they are basic C types or agglomorations of basic C types.\nIf the key and/or value do contain pointers, you can still store the\nhashtable by replacing write_nopointer_data() with a custom writing\nroutine.  See sparse_hash_map.html et al. for more information.\n\nSPARSETABLE\n-----------\nIn addition to the hash-map and hash-set classes, this package also\nprovides sparsetable.h, an array implementation that uses space\nproportional to the number of elements in the array, rather than the\nmaximum element index.  It uses very little space overhead: 2 to 5\nbits per entry.  See doc/sparsetable.html for the API.\n\nRESOURCE USAGE\n--------------\n* sparse_hash_map has memory overhead of about 4 to 10 bits per \n  hash-map entry, assuming a typical average occupancy of 50%.\n* dense_hash_map has a factor of 2-3 memory overhead: if your\n  hashtable data takes X bytes, dense_hash_map will use 3X-4X memory\n  total.\n\nHashtables tend to double in size when resizing, creating an\nadditional 50% space overhead.  dense_hash_map does in fact have a\nsignificant \"high water mark\" memory use requirement, which is 6 times\nthe size of hash entries in the table when resizing (when reaching \n50% occupancy, the table resizes to double the previous size, and the \nold table (2x) is copied to the new table (4x)).\n\nsparse_hash_map, however, is written to need very little space\noverhead when resizing: only a few bits per hashtable entry.\n\nPERFORMANCE\n-----------\nYou can compile and run the included file time_hash_map.cc to examine\nthe performance of sparse_hash_map, dense_hash_map, and your native\nhash_map implementation on your system.  One test against the\nSGI hash_map implementation gave the following timing information for\na simple find() call:\n   SGI hash_map:     22 ns\n   dense_hash_map:   13 ns\n   sparse_hash_map: 117 ns\n   SGI map:         113 ns\n\nSee doc/performance.html for more detailed charts on resource usage\nand performance data.\n\n---\n16 March 2005\n(Last updated: 12 September 2010)"
}
