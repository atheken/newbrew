{
  "name": "source-to-image",
  "full_name": "source-to-image",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Tool for building source and injecting into docker images",
  "license": "Apache-2.0",
  "homepage": "https://github.com/openshift/source-to-image",
  "versions": {
    "stable": "1.3.8",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/openshift/source-to-image.git",
      "tag": "v1.3.8",
      "revision": "980ca195116928b3beb61b25d5939d0044b3040b",
      "checksum": null
    },
    "head": {
      "url": "https://github.com/openshift/source-to-image.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/source-to-image/blobs/sha256:f50ed6d499d0123e959b5027f6897cfab3daeea0a8369f77d43090e7a8a8af86",
          "sha256": "f50ed6d499d0123e959b5027f6897cfab3daeea0a8369f77d43090e7a8a8af86"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/source-to-image/blobs/sha256:e70fe8a14ac7600b9d273343410dd40e0d7f75d8df041367f3a83598423fec36",
          "sha256": "e70fe8a14ac7600b9d273343410dd40e0d7f75d8df041367f3a83598423fec36"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/source-to-image/blobs/sha256:a234fec43b13d68d62d3827cb9c4f76820213b99f8b2203666b2d0632a62cbc7",
          "sha256": "a234fec43b13d68d62d3827cb9c4f76820213b99f8b2203666b2d0632a62cbc7"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/source-to-image/blobs/sha256:5a72887cdd4f0132ca6349e01a92c94e2d143a3b989b4b130c775a31a7b9369a",
          "sha256": "5a72887cdd4f0132ca6349e01a92c94e2d143a3b989b4b130c775a31a7b9369a"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/source-to-image/blobs/sha256:21f8b669dd230f4d8749b6da504453c3529d0322d3ea49824f0b82d272313eb3",
          "sha256": "21f8b669dd230f4d8749b6da504453c3529d0322d3ea49824f0b82d272313eb3"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/source-to-image/blobs/sha256:4c1b253eb3a2c8611cae470735df04eb0a73165acb9f5576236090381b56dc1d",
          "sha256": "4c1b253eb3a2c8611cae470735df04eb0a73165acb9f5576236090381b56dc1d"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/source-to-image/blobs/sha256:2d39b5f8f2348c6ff07fe3be0575f9df5e81a45704f84b58b9b556ab3dd55821",
          "sha256": "2d39b5f8f2348c6ff07fe3be0575f9df5e81a45704f84b58b9b556ab3dd55821"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "go"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/source-to-image.rb",
  "ruby_source_checksum": {
    "sha256": "dcc38bc75c0cb1c808eb02f01fc5b640c390444f55e555349cf83d58fb3dac2f"
  },
  "date_added": "2017-01-22T20:28:23-08:00",
  "readme": "[![Go Reference](https://pkg.go.dev/badge/github.com/openshift/source-to-image.svg)](https://pkg.go.dev/github.com/openshift/source-to-image)\n[![License](https://img.shields.io/github/license/openshift/source-to-image.svg)](https://www.apache.org/licenses/LICENSE-2.0.html)\n\n# Source-To-Image (S2I)\n\n## Overview\n\nSource-to-Image (S2I) is a toolkit and workflow for building reproducible container images from source code. S2I produces\nready-to-run images by injecting source code into a container image and letting the container prepare that source code for execution. By creating self-assembling **builder images**, you can version and control your build environments exactly like you use container images to version your runtime environments.\n\nFor a deep dive on S2I you can view [this presentation](https://www.youtube.com/watch?v=flI6zx9wH6M).\n\nWant to try it right now?  Download the [latest release](https://github.com/openshift/source-to-image/releases/latest) and run:\n\n\t$ s2i build https://github.com/sclorg/django-ex centos/python-35-centos7 hello-python\n\t$ docker run -p 8080:8080 hello-python\n\nNow browse to http://localhost:8080 to see the running application.\n\nYou've just built and run a new container image from source code in a git repository, no Dockerfile necessary.\n\n### How Source-to-Image works\n\nFor a dynamic language like Ruby, the build-time and run-time environments are typically the same. Starting with a **builder image** that describes this environment - with Ruby, Bundler, Rake, Apache, GCC, and other packages needed to set up and run a Ruby application installed - source-to-image performs the following steps:\n\n1. Start a container from the builder image with the application source injected into a known directory\n1. The container process transforms that source code into the appropriate runnable setup - in this case, by installing dependencies with Bundler and moving the source code into a directory where Apache has been preconfigured to look for the Ruby `config.ru` file.\n1. Commit the new container and set the image entrypoint to be a script (provided by the builder image) that will start Apache to host the Ruby application.\n\nFor compiled languages like C, C++, Go, or Java, the dependencies necessary for compilation might dramatically outweigh the size of the actual runtime artifacts. To keep runtime images slim, S2I enables a multiple-step build processes, where a binary artifact such as an executable or Java WAR file is created in the first builder image, extracted, and injected into a second runtime image that simply places the executable in the correct location for execution.\n\nFor example, to create a reproducible build pipeline for Tomcat (the popular Java webserver) and Maven:\n\n1. Create a builder image containing OpenJDK and Tomcat that expects to have a WAR file injected\n2. Create a second image that layers on top of the first image Maven and any other standard dependencies, and expects to have a Maven project injected\n3. Invoke source-to-image using the Java application source and the Maven image to create the desired application WAR\n4. Invoke source-to-image a second time using the WAR file from the previous step and the initial Tomcat image to create the runtime image\n\nBy placing our build logic inside of images, and by combining the images into multiple steps, we can keep our runtime environment close to our build environment (same JDK, same Tomcat JARs) without requiring build tools to be deployed to production.\n\n## Goals\n\n### Reproducibility\nAllow build environments to be tightly versioned by encapsulating them within a container image and defining a simple interface (injected source code) for callers. Reproducible builds are a key requirement to enabling security updates and continuous integration in containerized infrastructure, and builder images help ensure repeatability as well as the ability to swap runtimes.\n\n### Flexibility\nAny existing build system that can run on Linux can be run inside of a container, and each individual builder can also be part of a larger pipeline. In addition, the scripts that process the application source code can be injected into the builder image, allowing authors to adapt existing images to enable source handling.\n\n### Speed\nInstead of building multiple layers in a single Dockerfile, S2I encourages authors to represent an application in a single image layer. This saves time during creation and deployment, and allows for better control over the output of the final image.\n\n### Security\nDockerfiles are run without many of the normal operational controls of containers, usually running as root and having access to the container network. S2I can be used to control what permissions and privileges are available to the builder image since the build is launched in a single container. In concert with platforms like OpenShift, source-to-image can enable admins to tightly control what privileges developers have at build time.\n\n\n## Anatomy of a builder image\n\nCreating builder images is easy. `s2i` looks for you to supply the following scripts to use with an\nimage:\n\n1. `assemble` - builds and/or deploys the source\n1. `run`- runs the assembled artifacts\n1. `save-artifacts` (optional) - captures the artifacts from a previous build into the next incremental build\n1. `usage` (optional) - displays builder image usage information\n\nAdditionally for the best user experience and optimized `s2i` operation we suggest images\nto have `/bin/sh` and `tar` commands available.\n\nSee [a practical tutorial on how to create a builder image](examples/nginx-centos7/README.md) and read [a detailed description of the requirements and scripts along with examples of builder images](docs/builder_image.md).\n\n## Build workflow\n\nThe `s2i build` workflow is:\n\n1. `s2i` creates a container based on the build image and passes it a tar file that contains:\n    1. The application source in `src`, excluding any files selected by `.s2iignore`\n    1. The build artifacts in `artifacts` (if applicable - see [incremental builds](#incremental-builds))\n1. `s2i` sets the environment variables from `.s2i/environment` (optional)\n1. `s2i` starts the container and runs its `assemble` script\n1. `s2i` waits for the container to finish\n1. `s2i` commits the container, setting the CMD for the output image to be the `run` script and tagging the image with the name provided.\n\nFiltering the contents of the source tree is possible if the user supplies a\n`.s2iignore` file in the root directory of the source repository, where `.s2iignore` contains regular\nexpressions that capture the set of files and directories you want filtered from the image s2i produces.\n\nSpecifically:\n\n1. Specify one rule per line, with each line terminating in `\\n`.\n1. Filepaths are appended to the absolute path of the  root of the source tree (either the local directory supplied, or the target destination of the clone of the remote source repository s2i creates).\n1. Wildcards and globbing (file name expansion) leverage Go's `filepath.Match` and `filepath.Glob` functions.\n1. Search is not recursive.  Subdirectory paths must be specified (though wildcards and regular expressions can be used in the subdirectory specifications).\n1. If the first character is the `#` character, the line is treated as a comment.\n1. If the first character is the `!`, the rule is an exception rule, and can undo candidates selected for filtering by prior rules (but only prior rules).\n\nHere are some examples to help illustrate:\n\nWith specifying subdirectories, the `*/temp*` rule prevents the filtering of any files starting with `temp` that are in any subdirectory that is immediately (or one level) below the root directory.\nAnd the `*/*/temp*` rule prevents the filtering of any files starting with `temp` that are in any subdirectory that is two levels below the root directory.\n\nNext, to illustrate exception rules, first consider the following example snippet of a `.s2iignore` file:\n\n\n```\n*.md\n!README.md\n```\n\n\nWith this exception rule example, README.md will not be filtered, and remain in the image s2i produces.  However, with this snippet:\n\n\n```\n!README.md\n*.md\n```\n\n\n`README.md`, if filtered by any prior rules, but then put back in by `!README.md`, would be filtered, and not part of the resulting image s2i produces.  Since `*.md` follows `!README.md`, `*.md` takes precedence.\n\nUsers can also set extra environment variables in the application source code.\nThey are passed to the build, and the `assemble` script consumes them. All\nenvironment variables are also present in the output application image. These\nvariables are defined in the `.s2i/environment` file inside the application sources.\nThe format of this file is a simple key-value, for example:\n\n```\nFOO=bar\n```\n\nIn this case, the value of `FOO` environment variable will be set to `bar`.\n\n## Using ONBUILD images\n\nIn case you want to use one of the official Dockerfile language stack images for\nyour build you don't have do anything extra. S2I is capable of recognizing the\ncontainer image with [ONBUILD](https://docs.docker.com/engine/reference/builder/#/onbuild)\ninstructions and choosing the OnBuild strategy. This strategy will trigger all\nONBUILD instructions and execute the assemble script (if it exists) as the last\ninstruction.\n\nSince the ONBUILD images usually don't provide any entrypoint, in order to use\nthis build strategy you will have to provide one. You can either include the 'run',\n'start' or 'execute' script in your application source root folder or you can\nspecify a valid S2I script URL and the 'run' script will be fetched and set as\nan entrypoint in that case.\n\n### Incremental builds\n\n`s2i` automatically detects:\n\n* Whether a builder image is compatible with incremental building\n* Whether a previous image exists, with the same name as the output name for this build\n\nIf a `save-artifacts` script exists, a prior image already exists, and the `--incremental=true` option is used, the workflow is as follows:\n\n1. `s2i` creates a new container image from the prior build image\n1. `s2i` runs `save-artifacts` in this container - this script is responsible for streaming out\n   a tar of the artifacts to stdout\n1. `s2i` builds the new output image:\n    1. The artifacts from the previous build will be in the `artifacts` directory of the tar\n       passed to the build\n    1. The build image's `assemble` script is responsible for detecting and using the build\n       artifacts\n\n**NOTE**: The `save-artifacts` script is responsible for streaming out dependencies in a tar file.\n\n\n## Dependencies\n\n1. [docker](https://docker.com) >= 1.6\n1. [Go](https://golang.org/dl/) >= 1.7.1\n1. (optional) [Git](https://git-scm.com/)\n\n## Installation\n\n##### Using `go install`\n\nYou can install the s2i binary using `go install` which will download the source-to-image code to your Go module cache, build the s2i binary, and install it into your `$GOBIN`, or `$GOPATH/bin` if `$GOBIN` is not set, or `$HOME/go/bin` if the GOPATH environment variable is also not set.\n\n```$ go install github.com/openshift/source-to-image/cmd/s2i@latest```\n\n##### For Mac\n\nYou can either follow the installation instructions for Linux (and use the darwin-amd64 link) or you can just install source-to-image with Homebrew:\n\n```$ brew install source-to-image```\n\n##### For Linux\n\nGo to the [releases](https://github.com/openshift/source-to-image/releases/latest) page and download the correct distribution for your machine. Choose either the linux-386 or the linux-amd64 links for 32 and 64-bit, respectively.\n\nUnpack the downloaded tar with\n\n```$ tar -xvzf release.tar.gz```.\n\nYou should now see an executable called s2i.  Either add the location of s2i to your PATH environment variable, or move it to a pre-existing directory in your PATH.\nFor example,\n\n```# cp /path/to/s2i /usr/local/bin```\n\nwill work with most setups.\n\n##### For Windows\n\nDownload the latest [64-bit Windows release](https://github.com/openshift/source-to-image/releases/latest).\nExtract the zip file through a file browser.  Add the extracted directory to your PATH.  You can now use\ns2i from the command line.\n\nNote:  We have had some reports of Windows Defender falsely alerting reporting that the Windows binaries\ncontain \"Trojan:Win32/Azden.A!cl\".  This appears to be a common false alert for other applications as well.\n\n##### From source\n\nAssuming Go, Git, and Docker are installed and configured, execute the following commands:\n\n```\n$ git clone https://github.com/openshift/source-to-image\n$ cd source-to-image\n$ export PATH=${PATH}:`pwd`/_output/local/bin/`go env GOOS`/`go env GOHOSTARCH`/\n$ ./hack/build-go.sh\n```\n\n## Security\n\nSince the `s2i` command uses the Docker client library, it has to run in the same\nsecurity context as the `docker` command. For some systems, it is enough to add\nyourself into the 'docker' group to be able to work with Docker as 'non-root'.\nIn the latest versions of Fedora/RHEL, it is recommended to use the `sudo` command\nas this way is more auditable and secure.\n\nIf you are using the `sudo docker` command already, then you will have to also use\n`sudo s2i` to give S2I permission to work with Docker directly.\n\nBe aware that being a member of the 'docker' group effectively grants root access,\nas described [here](https://github.com/docker/docker/issues/9976).\n\n## Getting Started\n\nYou can start using `s2i` right away (see [releases](https://github.com/openshift/source-to-image/releases))\nwith the following test sources and publicly available images:\n\n```\n$ s2i build https://github.com/openshift/ruby-hello-world registry.redhat.io/ubi8/ruby-27 test-ruby-app\n$ docker run --rm -i -p :8080 -t test-ruby-app\n```\n\n```\n$ s2i build --ref=10.x --context-dir=helloworld https://github.com/wildfly/quickstart openshift/wildfly-101-centos7 test-jee-app\n$ docker run --rm -i -p 8080:8080 -t test-jee-app\n```\n\nWant to know more? Read the following resources:\n\n* [Descriptions and examples of the S2I commands](docs/cli.md)\n* [Instructions for using builder images](docs/user_guide.md)\n* [Guidance for S2I builder image creators](docs/builder_image.md)\n* [Using a non-builder image for the base of the application image](docs/runtime_image.md)\n* [Troubleshooting and debugging S2I problems](docs/debugging-s2i.md)"
}
