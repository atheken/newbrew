{
  "name": "feedgnuplot",
  "full_name": "feedgnuplot",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Tool to plot realtime and stored data from the command-line",
  "license": "GPL-1.0-or-later or Artistic-1.0",
  "homepage": "https://github.com/dkogan/feedgnuplot",
  "versions": {
    "stable": "1.61",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/dkogan/feedgnuplot/archive/v1.61.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "4239fe61a03232ea47909edd59af767b98481b205f58910b2e30d2d41f9caa80"
    }
  },
  "revision": 2,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/feedgnuplot/blobs/sha256:1c84ee60a6faa933c43c270489c546de007e29530353ba4969b82d7f7692f3b5",
          "sha256": "1c84ee60a6faa933c43c270489c546de007e29530353ba4969b82d7f7692f3b5"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/feedgnuplot/blobs/sha256:1c84ee60a6faa933c43c270489c546de007e29530353ba4969b82d7f7692f3b5",
          "sha256": "1c84ee60a6faa933c43c270489c546de007e29530353ba4969b82d7f7692f3b5"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/feedgnuplot/blobs/sha256:26299cc2f7edb31454e3a484328033d1da600aedb585860698ae5e079710e528",
          "sha256": "26299cc2f7edb31454e3a484328033d1da600aedb585860698ae5e079710e528"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/feedgnuplot/blobs/sha256:1c84ee60a6faa933c43c270489c546de007e29530353ba4969b82d7f7692f3b5",
          "sha256": "1c84ee60a6faa933c43c270489c546de007e29530353ba4969b82d7f7692f3b5"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/feedgnuplot/blobs/sha256:1c84ee60a6faa933c43c270489c546de007e29530353ba4969b82d7f7692f3b5",
          "sha256": "1c84ee60a6faa933c43c270489c546de007e29530353ba4969b82d7f7692f3b5"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/feedgnuplot/blobs/sha256:26299cc2f7edb31454e3a484328033d1da600aedb585860698ae5e079710e528",
          "sha256": "26299cc2f7edb31454e3a484328033d1da600aedb585860698ae5e079710e528"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/feedgnuplot/blobs/sha256:dd94ae98b5eea50d2d2a6c5437089d27522bb2111092581a8bfca2cd4d7b9373",
          "sha256": "dd94ae98b5eea50d2d2a6c5437089d27522bb2111092581a8bfca2cd4d7b9373"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/feedgnuplot/blobs/sha256:0e60aa54281c6660afa1d69e2c9ba3070d042e29fc46eff704f15f218c3d6925",
          "sha256": "0e60aa54281c6660afa1d69e2c9ba3070d042e29fc46eff704f15f218c3d6925"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [
    "gnuplot"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [
    "perl"
  ],
  "uses_from_macos_bounds": [
    {}
  ],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/feedgnuplot.rb",
  "ruby_source_checksum": {
    "sha256": "0c57571282b12c68b5175467bdd18eae286cadeb5098dfee039f6794fb51ba1d"
  },
  "date_added": "2016-08-21T12:00:51+01:00",
  "readme": "=head1 TALK\n\nI just gave a talk about this at L<SCaLE\n17x|https://www.socallinuxexpo.org/scale/17x>. Here are the L<video of the\ntalk|https://www.youtube.com/watch?v=Qvb_uNkFGNQ&t=12830s> and the\nL<\"slides\"|https://github.com/dkogan/talk-feedgnuplot-vnlog/blob/master/feedgnuplot-vnlog.org>.\n\n=head1 NAME\n\nfeedgnuplot - General purpose pipe-oriented plotting tool\n\n=head1 SYNOPSIS\n\nSimple plotting of piped data:\n\n $ seq 5 | awk '{print 2*$1, $1*$1}'\n 2 1\n 4 4\n 6 9\n 8 16\n 10 25\n\n $ seq 5 | awk '{print 2*$1, $1*$1}' |\n   feedgnuplot --lines --points --legend 0 \"data 0\" --title \"Test plot\" --y2 1\n               --unset grid --terminal 'dumb 80,40' --exit\n\n                                  Test plot\n\n  10 +-----------------------------------------------------------------+ 25\n     |       +        +       +       +       +        +       +    *##|\n     |                                                  data 0 ***A*#* |\n     |                                                          ** #   |\n   9 |-+                                                      ** ##    |\n     |                                                      **  #      |\n     |                                                    **   #       |\n     |                                                  **   ##      +-| 20\n   8 |-+                                               A    #          |\n     |                                               **    #           |\n     |                                             **    ##            |\n     |                                           **     #              |\n     |                                         **      B               |\n   7 |-+                                     **      ##                |\n     |                                     **      ##                +-| 15\n     |                                   **       #                    |\n     |                                 **       ##                     |\n   6 |-+                             *A       ##                       |\n     |                             **       ##                         |\n     |                           **        #                           |\n     |                         **        ##                          +-| 10\n   5 |-+                     **        ##                              |\n     |                     **        #B                                |\n     |                   **        ##                                  |\n     |                 **        ##                                    |\n   4 |-+              A       ###                                      |\n     |              **      ##                                         |\n     |            **      ##                                         +-| 5\n     |          **      ##                                             |\n     |        **    ##B#                                               |\n   3 |-+    **  ####                                                   |\n     |    **####                                                       |\n     |  ####                                                           |\n     |##     +        +       +       +       +        +       +       |\n   2 +-----------------------------------------------------------------+ 0\n     1      1.5       2      2.5      3      3.5       4      4.5      5\n\nHere we asked for ASCII plotting, which is useful for documentation.\n\nSimple real-time plotting example: plot how much data is received on the wlan0\nnetwork interface in bytes/second (uses bash, awk and Linux):\n\n $ while true; do sleep 1; cat /proc/net/dev; done |\n   gawk '/wlan0/ {if(b) {print $2-b; fflush()} b=$2}' |\n   feedgnuplot --lines --stream --xlen 10 --ylabel 'Bytes/sec' --xlabel seconds\n\n=head1 DESCRIPTION\n\nThis is a flexible, command-line-oriented frontend to Gnuplot. It creates plots\nfrom data coming in on STDIN or given in a filename passed on the commandline.\nVarious data representations are supported, as is hardcopy output and streaming\ndisplay of live data. For a tutorial and a gallery please see the guide at\nL<https://github.com/dkogan/feedgnuplot/blob/master/guide/guide.org>\n\nA simple example:\n\n $ seq 5 | awk '{print 2*$1, $1*$1}' | feedgnuplot\n\nYou should see a plot with two curves. The C<awk> command generates some data to\nplot and the C<feedgnuplot> reads it in from STDIN and generates the plot. The\nC<awk> invocation is just an example; more interesting things would be plotted\nin normal usage. No commandline-options are required for the most basic\nplotting. Input parsing is flexible; every line need not have the same number of\npoints. New curves will be created as needed.\n\nThe most commonly used functionality of gnuplot is supported directly by the\nscript. Anything not directly supported can still be done with options such as\nC<--set>, C<--cmds> C<--style>, etc. Arbitrary gnuplot commands can be passed in\nwith C<--cmds>. For example, to turn off the grid, you can pass in C<--cmds\n'unset grid'>. Commands C<--set> and C<--unset> exists to provide nicer syntax,\nso this is equivalent to passing C<--unset grid>. As many of these options as\nneeded can be passed in. To add arbitrary curve styles, use C<--style curveID\nextrastyle>. Pass these more than once to affect more than one curve.\n\nTo apply an extra style to I<all> the curves that lack an explicit C<--style>,\npass in C<--styleall extrastyle>. In the most common case, the extra style is\nC<with something>. To support this more simply, you can pass in C<--with\nsomething> instead of C<--styleall 'with something'>. C<--styleall> and\nC<--with> are mutually exclusive. Furthermore any curve-specific C<--style>\noverrides the global C<--styleall> or C<--with> setting.\n\n=head2 Data formats\n\nBy default, each value present in the incoming data represents a distinct data\npoint, as demonstrated in the original example above (we had 10 numbers in the\ninput and 10 points in the plot). If requested, the script supports more\nsophisticated interpretation of input data\n\n=head3 Domain selection\n\nIf C<--domain> is passed in, the first value on each line of input is\ninterpreted as the I<X>-value for the rest of the data on that line. Without\nC<--domain> the I<X>-value is the line number, and the first value on a line is\na plain data point like the others. Default is C<--nodomain>. Thus the original\nexample above produces 2 curves, with B<1,2,3,4,5> as the I<X>-values. If we run\nthe same command with C<--domain>:\n\n $ seq 5 | awk '{print 2*$1, $1*$1}' | feedgnuplot --domain\n\nwe get only 1 curve, with B<2,4,6,8,10> as the I<X>-values. As many points as\ndesired can appear on a single line, but all points on a line are associated\nwith the I<X>-value at the start of that line.\n\n=head3 Curve indexing\n\nWe index the curves in one of 3 ways: sequentially, explicitly with a\nC<--dataid> or by C<--vnlog> headers.\n\nBy default, each column represents a separate curve. The first column (after any\ndomain) is curve C<0>. The next one is curve C<1> and so on. This is fine unless\nsparse data is to be plotted. With the C<--dataid> option, each point is\nrepresented by 2 values: a string identifying the curve, and the value itself.\nIf we add C<--dataid> to the original example:\n\n $ seq 5 | awk '{print 2*$1, $1*$1}' | feedgnuplot --dataid --autolegend\n\nwe get 5 different curves with one point in each. The first column, as produced\nby C<awk>, is B<2,4,6,8,10>. These are interpreted as the IDs of the curves to\nbe plotted.\n\nIf we're plotting C<vnlog> data (L<https://www.github.com/dkogan/vnlog>) then we\ncan get the curve IDs from the vnlog header. Vnlog is a trivial data format\nwhere lines starting with C<#> are comments and the first comment contains\ncolumn labels. If we have such data, C<feedgnuplot --vnlog> can interpret these\ncolumn labels if the C<vnlog> perl modules are available.\n\nThe C<--autolegend> option adds a legend using the given IDs to\nlabel the curves. The IDs need not be numbers; generic strings are accepted. As\nmany points as desired can appear on a single line. C<--domain> can be used in\nconjunction with C<--dataid> or C<--vnlog>.\n\n=head3 Multi-value style support\n\nDepending on how gnuplot is plotting the data, more than one value may be needed\nto represent the range of a single point. Basic 2D plots have 2 numbers\nrepresenting each point: 1 domain and 1 range. But if plotting with\nC<--circles>, for instance, then there's an extra range value: the radius. Many\nother gnuplot styles require more data: errorbars, variable colors (C<with\npoints palette>), variable sizes (C<with points ps variable>), labels and so on.\nThe feedgnuplot tool itself does not know about all these intricacies, but they\ncan still be used, by specifying the specific style with C<--style>, and\nspecifying how many values are needed for each point with any of\nC<--rangesizeall>, C<--tuplesizeall>, C<--rangesize>, C<--tuplesize>. These\noptions are required I<only> for styles not explicitly supported by feedgnuplot;\nsupported styles do the right thing automatically.\n\nSpecific example: if making a 2d plot of y error bars, the exact format can be\nqueried by running C<gnuplot> and invoking C<help yerrorbars>. This tells us\nthat there's a 3-column form: C<x y ydelta> and a 4-column form: C<x y ylow\nyhigh>. With 2d plots feedgnuplot will always output the 1-value domain C<x>, so\nthe rangesize is 2 and 3 respectively. Thus the following are equivalent:\n\n $ echo '1 2 0.3\n         2 3 0.4\n         3 4 0.5' | feedgnuplot --domain --rangesizeall 2 --with 'yerrorbars'\n\n $ echo '1 2 0.3\n         2 3 0.4\n         3 4 0.5' | feedgnuplot --domain --tuplesizeall 3 --with 'yerrorbars'\n\n $ echo '1 2 1.7 2.3\n         2 3 2.6 3.4\n         3 4 3.5 4.5' | feedgnuplot --domain --rangesizeall 3 --with 'yerrorbars'\n\n=head3 3D data\n\nTo plot 3D data, pass in C<--3d>. C<--domain> MUST be given when plotting 3D\ndata to avoid domain ambiguity. If 3D data is being plotted, there are by\ndefinition 2 domain values instead of one (I<Z> as a function of I<X> and I<Y>\ninstead of I<Y> as a function of I<X>). Thus the first 2 values on each line are\ninterpreted as the domain instead of just 1. The rest of the processing happens\nthe same way as before.\n\n=head3 Time/date data\n\nIf the input data domain is a time/date, this can be interpreted with\nC<--timefmt>. This option takes a single argument: the format to use to parse\nthe data. The format is documented in 'set timefmt' in gnuplot, although the\ncommon flags that C<strftime> understands are generally supported. The backslash\nsequences in the format are I<not> supported, so if you want a tab, put in a tab\ninstead of \\t. Whitespace in the format I<is> supported. When this flag is\ngiven, some other options act a little bit differently:\n\n=over\n\n=item\n\nC<--xlen> and C<--binwidth> are I<integers> in seconds\n\n=item\n\nC<--xmin> and C<--xmax> I<must> use the format passed in to C<--timefmt>\n\n=back\n\nUsing this option changes both the way the input is parsed I<and> the way the\nx-axis tics are labelled. Gnuplot tries to be intelligent in this labelling, but\nit doesn't always do what the user wants. The labelling can be controlled with\nthe gnuplot C<set format> command, which takes the same type of format string as\nC<--timefmt>. Example:\n\n $ sar 1 -1 |\n   awk '$1 ~ /..:..:../ && $8 ~/^[0-9\\.]*$/ {print $1,$8; fflush()}' |\n   feedgnuplot --stream --domain\n                --lines --timefmt '%H:%M:%S'\n                --set 'format x \"%H:%M:%S\"'\n\nThis plots the 'idle' CPU consumption against time.\n\nNote that while gnuplot supports the time/date on any axis, I<feedgnuplot>\ncurrently supports it I<only> as the x-axis domain. This may change in the\nfuture.\n\n=head3 'using' expressions\n\nWe just described how feedgnuplot parses its input data. When passing this data\nto gnuplot, each curve is sent independently. The domain appears in the leading\ncolumns followed by C<--rangesize> columns to complete each row. Without\nC<--domain>, feedgnuplot explicitly writes out sequential integers. gnuplot then\nknows how many values it has for each point, and it knows which style we're\nusing, so it's able to interpret the data appropriately, and to make the correct\nplot.\n\nAs an example, if gnuplot is passed 2 columns of data, and it is plotting C<with\npoints>, it will use column 1 for the x coordinate and column 2 for the y\ncoordinate. This is the default behavior, but the meaning of each column can be\ncontrolled via a C<using> expression in gnuplot (not feedgnuplot; keep reading).\nThe default is sequential integers, so this example uses C<using 1:2> by\ndefault. We can flip the meaning of the columns by passing C<using 2:1>.\nArbitrary expressions may be specified by enclosing each field in C<()>, and\nusing C<$> to denote each data column. So to use the 2nd column as the x\ncoordinate and the sum of the two columns as the y coordinate, C<using\n2:($1+$2)> is passed. Furthermore, the number of columns can vary. For instance\ngnuplot can read the same two columns of data, but produce a plot with the extra\ncolumn encoding the sum as the color: C<using 1:2:($1+$2) with points palette>.\nPlease see the gnuplot documentation for lots of detail.\n\nThat's how I<gnuplot> works. Most of the time, I<feedgnuplot> doesn't pass any\nC<using> expressions at all, and gnuplot does the default thing. But if we want\nto do something fancy, feedgnuplot supports C<--using curveID expression> and\nC<--usingall expression>. So we can plot a parabola:\n\n  seq 100 | feedgnuplot --lines --usingall '1:($2*$2)'\n\nThis is powerful, but there are some things to keep in mind:\n\n=over\n\n=item\n\nC<--using> overrides whatever C<using> expression feedgnuplot was going to pass.\nfeedgnuplot passes a C<using> expression only if C<--histogram> or C<--timefmt>\nor C<--xticlabels> are given. So if C<--using> is given together with any of\nthese, the user must take care to do the right thing (whatever that means at\nthat time).\n\n=item\n\nThe C<--tuplesize> controls the data passed to feedgnuplot and the data then\npassed to gnuplot. It does I<not> directly control how gnuplot eventually\ninterprets the data: C<--using> does that. So for instance we can plot\ncolor-coded points:\n\n  seq 10 | feedgnuplot --with 'points pt 7 palette' --usingall '1:2:2'\n\nHere feedgnuplot read 1 column of data. It defauled to C<--tuplesize 2>, so it\npassed 2 columns of data to gnuplot. gnuplot then produced 3 values for each\npoint, and plotted them as indicated with the C<points palette> style.\n\n=item\n\nYou I<always> need a column of data to generate a curve. You might want to use a\nC<using> expression to plot a time series I<and> its cumulative integral. The\nC<using> expression can compute the integral, but you I<must> pass in the data\ntwice; once for each curve to plot:\n\n  seq 100 |                           \\\n    awk '{print $1,$1}' |             \\\n    feedgnuplot                       \\\n      --cmds 'sum=0'                  \\\n      --cmds 'accum(x) = (sum=sum+x)' \\\n      --using 1 '1:(accum($2))'       \\\n      --lines --y2 1\n\n=back\n\n=head2 Real-time streaming data\n\nTo plot real-time data, pass in the C<--stream [refreshperiod]> option. Data\nwill then be plotted as it is received. The plot will be updated every\nC<refreshperiod> seconds. If the period isn't specified, a 1Hz refresh rate is\nused. To refresh at specific intervals indicated by the data, set the\nrefreshperiod to 0 or to 'trigger'. The plot will then I<only> be refreshed when\na data line 'replot' is received. This 'replot' command works in both triggered\nand timed modes, but in triggered mode, it's the only way to replot. Look in\nL</\"Special data commands\"> for more information.\n\nTo plot only the most recent data (instead of I<all> the data), C<--xlen\nwindowsize> can be given. This will create an constantly-updating, scrolling\nview of the recent past. C<windowsize> should be replaced by the desired length\nof the domain window to plot, in domain units (passed-in values if C<--domain>\nor line numbers otherwise). If the domain is a time/date via C<--timefmt>, then\nC<windowsize> is and I<integer> in seconds. If we're plotting a histogram, then\nC<--xlen> causes a histogram over a moving window to be computed. The subtlely\nhere is that with a histogram you don't actually I<see> the domain since only\nthe range is analyzed. But the domain is still there, and can be utilized with\nC<--xlen>. With C<--xlen> we can plot I<only> histograms or I<only>\nI<non>-histograms.\n\n=head3 Special data commands\n\nIf we are reading streaming data, the input stream can contain special commands\nin addition to the raw data. Feedgnuplot looks for these at the start of every\ninput line. If a command is detected, the rest of the line is discarded. These\ncommands are\n\n=over\n\n=item C<replot>\n\nThis command refreshes the plot right now, instead of waiting for the next\nrefresh time indicated by the timer. This command works in addition to the timed\nrefresh, as indicated by C<--stream [refreshperiod]>.\n\n=item C<clear>\n\nThis command clears out the current data in the plot. The plotting process\ncontinues, however, to any data following the C<clear>.\n\n=item C<exit>\n\nThis command causes feedgnuplot to exit.\n\n=back\n\n=head2 Hardcopy output\n\nThe script is able to produce hardcopy output with C<--hardcopy outputfile>. The\noutput type can be inferred from the filename, if B<.ps>, B<.eps>, B<.pdf>,\nB<.svg>, B<.png> or B<.gp> is requested. If any other file type is requested,\nC<--terminal> I<must> be passed in to tell gnuplot how to make the plot. If\nC<--terminal> is passed in, then the C<--hardcopy> argument only provides the\noutput filename.\n\nThe B<.gp> output is special. Instead of asking gnuplot to plot to a particular\nterminal, writing to a B<.gp> simply dumps a self-executable gnuplot script into\nthe given file. This is similar to what C<--dump> does, but writes to a file,\nand makes sure that the file can be self-executing.\n\n=head2 Self-plotting data files\n\nThis script can be used to enable self-plotting data files. There are several\nways of doing this: with a shebang (#!) or with inline perl data.\n\n=head3 Self-plotting data with a #!\n\nA self-plotting, executable data file C<data> is formatted as\n\n $ cat data\n #!/usr/bin/feedgnuplot --lines --points\n 2 1\n 4 4\n 6 9\n 8 16\n 10 25\n 12 36\n 14 49\n 16 64\n 18 81\n 20 100\n 22 121\n 24 144\n 26 169\n 28 196\n 30 225\n\nThis is the shebang (#!) line followed by the data, formatted as before. The\ndata file can be plotted simply with\n\n $ ./data\n\nThe caveats here are that on Linux the whole #! line is limited to 127\ncharacters and that the full path to feedgnuplot must be given. The 127\ncharacter limit is a serious limitation, but this can likely be resolved with a\nkernel patch. I have only tried on Linux 2.6.\n\n=head3 Self-plotting data with gnuplot\n\nRunning C<feedgnuplot --hardcopy plotdata.gp ....> will create a self-executable\ngnuplot script in C<plotdata.gp>\n\n=head3 Self-plotting data with perl inline data\n\nPerl supports storing data and code in the same file. This can also be used to\ncreate self-plotting files:\n\n $ cat plotdata.pl\n #!/usr/bin/perl\n use strict;\n use warnings;\n\n open PLOT, \"| feedgnuplot --lines --points\" or die \"Couldn't open plotting pipe\";\n while( <DATA> )\n {\n   my @xy = split;\n   print PLOT \"@xy\\n\";\n }\n __DATA__\n 2 1\n 4 4\n 6 9\n 8 16\n 10 25\n 12 36\n 14 49\n 16 64\n 18 81\n 20 100\n 22 121\n 24 144\n 26 169\n 28 196\n 30 225\n\nThis is especially useful if the logged data is not in a format directly\nsupported by feedgnuplot. Raw data can be stored after the __DATA__ directive,\nwith a small perl script to manipulate the data into a useable format and send\nit to the plotter.\n\n=head1 ARGUMENTS\n\n=over\n\n=item\n\n--C<[no]domain>\n\nIf enabled, the first element of each line is the domain variable. If not, the\npoint index is used\n\n=item\n\n--C<[no]dataid>\n\nIf enabled, each data point is preceded by the ID of the data set that point\ncorresponds to. This ID is interpreted as a string, NOT as just a number. If not\nenabled, the order of the point is used.\n\nAs an example, if line 3 of the input is \"0 9 1 20\" then\n\n=over\n\n=item\n\nC<--nodomain --nodataid> would parse the 4 numbers as points in 4 different\ncurves at x=3\n\n=item\n\nC<--domain --nodataid> would parse the 4 numbers as points in 3 different\ncurves at x=0. Here, 0 is the x-variable and 9,1,20 are the data values\n\n=item\n\nC<--nodomain --dataid> would parse the 4 numbers as points in 2 different\ncurves at x=3. Here 0 and 1 are the data IDs and 9 and 20 are the\ndata values\n\n=item\n\nC<--domain --dataid> would parse the 4 numbers as a single point at\nx=0. Here 9 is the data ID and 1 is the data value. 20 is an extra\nvalue, so it is ignored. If another value followed 20, we'd get another\npoint in curve ID 20\n\n=back\n\n=item\n\nC<--vnlog>\n\nVnlog is a trivial data format where lines starting with C<#> are comments and\nthe first comment contains column labels. Some tools for working with such data\nare available from the C<vnlog> project: L<https://www.github.com/dkogan/vnlog>.\nWith the C<vnlog> perl modules installed, we can read the vnlog column headers\nwith C<feedgnuplot --vnlog>. This replaces C<--dataid>, and we can do all the\nnormal things with these headers. For instance C<feedgnuplot --vnlog\n--autolegend> will generate plot legends for each column in the vnlog, using the\nvnlog column label in the legend.\n\n=item\n\nC<--[no]3d>\n\nDo [not] plot in 3D. This only makes sense with C<--domain>. Each domain here is\nan (x,y) tuple\n\n=item\n\n--C<timefmt [format]>\n\nInterpret the X data as a time/date, parsed with the given format\n\n=item\n\nC<--colormap>\n\nShow a colormapped xy plot. Requires extra data for the color. zmin/zmax can be\nused to set the extents of the colors. Automatically sets the\nC<--rangesize>/C<--tuplesize>.\n\n=item\n\nC<--stream [period]>\n\nPlot the data as it comes in, in realtime. If period is given, replot every\nperiod seconds. If no period is given, replot at 1Hz. If the period is given as\n0 or 'trigger', replot I<only> when the incoming data dictates this. See the\nL</\"Real-time streaming data\"> section of the man page.\n\n=item\n\nC<--[no]lines>\n\nDo [not] draw lines to connect consecutive points\n\n=item\n\nC<--[no]points>\n\nDo [not] draw points\n\n=item\n\nC<--circles>\n\nPlot with circles. This requires a radius be specified for each point.\nAutomatically sets the C<--rangesize>/C<--tuplesize>. C<Not> supported for 3d\nplots.\n\n=item\n\nC<--title xxx>\n\nSet the title of the plot\n\n=item\n\nC<--legend curveID legend>\n\nSet the label for a curve plot. Use this option multiple times for multiple\ncurves. With C<--dataid>, curveID is the ID. Otherwise, it's the index of the\ncurve, starting at 0\n\n=item\n\nC<--autolegend>\n\nUse the curve IDs for the legend. Titles given with C<--legend> override these\n\n=item\n\nC<--xlen xxx>\n\nWhen using C<--stream>, sets the size of the x-window to plot. Omit this or set\nit to 0 to plot ALL the data. Does not make sense with 3d plots. Implies\nC<--monotonic>. If we're plotting a histogram, then C<--xlen> causes a histogram\nover a moving window to be computed. The subtlely here is that with a histogram\nyou don't actually I<see> the domain since only the range is analyzed. But the\ndomain is still there, and can be utilized with C<--xlen>. With C<--xlen> we can\nplot I<only> histograms or I<only> I<non>-histograms.\n\n\n=item\n\nC<--xmin/xmax/x2min/x2max/ymin/ymax/y2min/y2max/zmin/zmax xxx>\n\nSet the range for the given axis. These x-axis bounds are ignored in a streaming\nplot. The x2/y2-axis bounds do not apply in 3d plots. The z-axis bounds apply\nI<only> to 3d plots or colormaps. Note that there is no C<--xrange> to set both\nsides at once or C<--xinv> to flip the axis around: anything more than the\nbasics supported in this option is clearly obtainable by talking to gnuplot, for\ninstance C<--set 'xrange [20:10]'> to set the given inverted bounds.\n\n=item\n\nC<--xlabel/x2label/ylabel/y2label/zlabel xxx>\n\nLabel the given axis. The x2/y2-axis labels do not apply to 3d plots while the\nz-axis label applies I<only> to 3d plots.\n\n=item\n\nC<--x2/--y2/--x1y2/--x2y1/--x2y2 xxx>\n\nBy default data is plotted against the x1 and y1 axes (the left and bottom one\nrespectively). If we want a particular curve plotted against a different axis,\nwe can specify that with these options. You pass C<--AXIS ID> where C<AXIS>\ndefines the axis (C<x2> or C<y2> or C<x1y2> or C<x2y1> or C<x2y2>) and the C<ID>\nis the curve ID. C<--x2> is a synonym for C<--x2y1> and C<--y2> is a synonym for\nC<--x1y2>. The curve ID is an ordered 0-based index or a specific ID if\nC<--dataid> or C<--vnlog>. None of these apply to 3d plots. Can be passed\nmultiple times for different curve IDs, multiple IDs can be passed in as a\ncomma-separated list. By default the curves plotted against the various axes\naren not drawn in any differentiated way: the viewer of the resulting plot has\nto be told which is which via an axes label, legend, colors, etc. Prior to\nversion 1.25 of C<feedgnuplot> the curves plotted on the y2 axis were drawn with\na thicker line. This is no longer the case, but that behavior can be brought\nback by passing something like\n\n --y2 curveid --style curveid 'linewidth 3'\n\n=item\n\nC<--histogram curveID>\n\nSet up a this specific curve to plot a histogram. The bin width is given with\nthe C<--binwidth> option (assumed 1.0 if omitted). If a drawing style is not\nspecified for this curve (C<--curvestyle>) or all curves (C<--with>,\nC<--curvestyleall>) then the default histogram style is set: filled boxes with\nborders. This is what the user generally wants. This works with C<--domain>\nand/or C<--stream>, but in those cases the x-value is used I<only> to cull old\ndata because of C<--xlen> or C<--monotonic>. I.e. the domain values are I<not>\ndrawn in any way. Can be passed multiple times, or passed a comma- separated\nlist\n\n=item\n\nC<--xticlabels>\n\nIf given, the x-axis tic labels are not numerical, but are read from the data.\nThis changes the interpretation of the input data: with C<--domain>, each line\nbegins with C<x label ....>. Without C<--domain>, each line begins with C<label\n...>. Clearly, the labels may not contain whitespace. This does I<not> affect\nthe tuple size. This makes sense only without C<--3d>. Please see the guide\n(L<https://github.com/dkogan/feedgnuplot/blob/master/guide/guide.org>) for usage\nexamples.\n\n=item\n\nC<--binwidth width>\n\nThe width of bins when making histograms. This setting applies to ALL histograms\nin the plot. Defaults to 1.0 if not given.\n\n=item\n\nC<--histstyle style>\n\nNormally, histograms are generated with the 'smooth frequency' gnuplot style.\nC<--histstyle> can be used to select different C<smooth> settings (see the\ngnuplot C<help smooth> page for more info). Allowed values are 'frequency' (the\ndefault), 'fnormal' (available in very recent gnuplots), 'unique', 'cumulative'\nand 'cnormal'. 'fnormal' is a normalized histogram. 'unique' indicates whether a\nbin has at least one item in it: instead of counting the items, it'll always\nreport 0 or 1. 'cumulative' is the integral of the 'frequency' histogram.\n'cnormal' is like 'cumulative', but rescaled to end up at 1.0.\n\n=item\n\nC<--style curveID style>\n\nAdditional styles per curve. With C<--dataid>, curveID is the ID. Otherwise,\nit's the index of the curve, starting at 0. curveID can be a comma-separated\nlist of IDs to which the given style should apply. Use this option multiple\ntimes for multiple curves. C<--styleall> does I<not> apply to curves that have a\nC<--style>.\n\n=item\n\nC<--curvestyle curveID>\n\nSynonym for C<--style>\n\n=item\n\nC<--styleall xxx>\n\nAdditional styles for all curves that have no C<--style>. This is overridden by\nany applicable C<--style>. Exclusive with C<--with>.\n\n=item\n\nC<--curvestyleall xxx>\n\nSynonym for C<--styleall>\n\n=item\n\nC<--with xxx>\n\nSame as C<--styleall>, but prefixed with \"with\". Thus\n\n --with boxes\n\nis equivalent to\n\n --styleall 'with boxes'\n\nExclusive with C<--styleall>.\n\n=item\n\nC<--every curveID factor>\n\nDecimates the input. Instead of plotting every point in the given curve, plot\none point per factor. This is useful to quickly process huge datasets. For\ninstance, to plot 1% of the data, pass a factor of 100.\n\n=item\n\nC<--everyall factor>\n\nDecimates the input. This works exactly like C<--every>, except it applies to\nI<all> the curves.\n\n=item\n\nC<--using curveID expression>\n\nSpecifies a C<using> expression to micromanage the plot. This is a powerful\noption that allows gnuplot to interpret the input data in arbitrary ways. A\nC<using> expression tells gnuplot how to map the input columns of data to tuples\nexpected by the plotting style. Please see the L</\"'using' expressions\"> section above for more detail.\n\n=item\n\nC<--usingall expression>\n\nGlobal \"using\" expressions. This works exactly like C<--using>, except it\napplies to I<all> the curves.\n\n=item\n\nC<--cmds xxx>\n\nAdditional commands to pass on to gnuplot verbatim. These could contain extra\nglobal styles for instance. Can be passed multiple times.\n\n=item\n\nC<--extracmds xxx>\n\nSynonym for C<--cmds xxx>\n\n=item\n\nC<--set xxx>\n\nAdditional 'set' commands to pass on to gnuplot verbatim. C<--set 'a b c'> will\nresult in gnuplot seeing a C<set a b c> command. Can be passed multiple times.\n\n=item\n\nC<--unset xxx>\n\nAdditional 'unset' commands to pass on to gnuplot verbatim. C<--unset 'a b c'>\nwill result in gnuplot seeing a C<unset a b c> command. Can be passed multiple\ntimes.\n\n=item\n\nC<--image filename>\n\nOverlays the data on top of a raster image given in C<filename>. This is passed\nthrough to gnuplot via C<--equation>, and is not interpreted by C<feedgnuplot>\nother than checking for existence. Usually images have their origin at the\ntop-left corner, while plots have it in the bottom-left corner instead. Thus if\nthe y-axis extents are not specified (C<--ymin>, C<--ymax>, C<--set 'yrange\n...'>) this option will also flip around the y axis to make the image appear\nproperly. Since this option is just a passthrough to gnuplot, finer control can\nbe achieved by passing in C<--equation> and C<--set yrange ...> directly.\n\n=item\n\nC<--equation xxx>\n\nGnuplot can plot both data and symbolic equations. C<feedgnuplot> generally\nplots data, but with this option can plot symbolic equations I<also>. This is\ngenerally intended to augment data plots, since for equation-only plots you\ndon't need C<feedgnuplot>. C<--equation> can be passed multiple times for\nmultiple equations. The given strings are passed to gnuplot directly without\nanything added or removed, so styling and such should be applied in the string.\nA basic example:\n\n seq 100 | awk '{print $1/10, $1/100}' |\n   feedgnuplot --with 'lines lw 3' --domain --ymax 1\n               --equation 'sin(x)/x' --equation 'cos(x)/x with lines lw 4'\n\nHere I plot the incoming data (points along a line) with the given style (a line\nwith thickness 3), I<and> I plot two damped sinusoids on the same plot. The\nsinusoids are not affected by C<feedgnuplot> styling, so their styles are set\nseparately, as in this example. More complicated example:\n\n seq 360 | perl -nE '$th=$_/360 * 3.14*2; $c=cos($th); $s=sin($th); say \"$c $s\"' |\n   feedgnuplot --domain --square\n               --set parametric --set \"trange [0:2*3.14]\" --equation \"sin(t),cos(t)\"\n\nHere the data I generate is points along the unit circle. I plot these as\npoints, and I I<also> plot a true circle as a parametric equation.\n\n=item\n\nC<--equation-below xxx>\n\nSynonym for C<--equation>. These are rendered I<below> all the other data.\n\n=item\n\nC<--equation-above xxx>\n\nLike C<--equation>, but is rendered I<on top> of all the other data.\n\n=item\n\nC<--square>\n\nPlot data with aspect ratio 1. For 3D plots, this controls the aspect ratio for\nall 3 axes\n\n=item\n\nC<--square-xy>\n\nFor 3D plots, set square aspect ratio for ONLY the x,y axes\n\n=item\n\nC<--hardcopy xxx>\n\nIf not streaming, output to a file specified here. Format inferred from\nfilename, unless specified by C<--terminal>. If C<--terminal> is given,\nC<--hardcopy> sets I<only> the output filename.\n\n=item\n\nC<--terminal xxx>\n\nString passed to 'set terminal'. No attempts are made to validate this.\nC<--hardcopy> sets this to some sensible defaults if C<--hardcopy> is set to a\nfilename ending in C<.png>, C<.pdf>, C<.ps>, C<.eps> or C<.svg>. If any other\nfile type is desired, use both C<--hardcopy> and C<--terminal>\n\n=item\n\nC<--maxcurves N>\n\nThe maximum allowed number of curves. This is 100 by default, but can be reset\nwith this option. This exists purely to prevent perl from allocating all of the\nsystem's memory when reading bogus data\n\n=item\n\nC<--monotonic>\n\nIf C<--domain> is given, checks to make sure that the x-coordinate in the input\ndata is monotonically increasing. If a given x-variable is in the past, all data\ncurrently cached for this curve is purged. Without C<--monotonic>, all data is\nkept. Does not make sense with 3d plots. No C<--monotonic> by default. The data\nis replotted before being purged. This is useful in streaming plots where the\nincoming data represents multiple iterations of the same process (repeated\nsimulations of the same period in time, for instance).\n\n=item\n\nC<--rangesize curveID N>\n\nThe options C<--rangesizeall> and C<--rangesize> set the number of values are\nneeded to represent each point being plotted (see L</\"Multi-value style\nsupport\"> above). These options are I<only> needed if unknown styles are used,\nwith C<--styleall> or C<--with> for instance.\n\nC<--rangesize> is used to set how many values are needed to represent the range\nof a point for a particular curve. This overrides any defaults that may exist\nfor this curve only.\n\nWith C<--dataid>, curveID is the ID. Otherwise, it's the index of the curve,\nstarting at 0. curveID can be a comma-separated list of IDs to which the given\nrangesize should apply.\n\n=item\n\nC<--tuplesize curveID N>\n\nVery similar to C<--rangesize>, but instead of specifying the I<range> only,\nthis specifies the whole tuple. For instance if we're plotting circles, the\ntuplesize is 3: C<x,y,radius>. In a 2D plot there's a 1-dimensional domain:\nC<x>, so the rangesize is 2: C<y,radius>. This dimensionality can be given\neither way.\n\n=item\n\nC<--rangesizeall N>\n\nLike C<--rangesize>, but applies to I<all> the curves.\n\n=item\n\nC<--tuplesizeall N>\n\nLike C<--tuplesize>, but applies to I<all> the curves.\n\n=item\n\nC<--dump>\n\nInstead of printing to gnuplot, print to STDOUT. Very useful for debugging. It\nis possible to send the output produced this way to gnuplot directly.\n\n=item\n\nC<--exit>\n\nThis controls what happens when the input data is exhausted, or when some part\nof the C<feedgnuplot> pipeline is killed. This option does different things\ndepending on whether C<--stream> is active, so read this closely.\n\nWith interactive gnuplot terminals (qt, x11, wxt), the plot windows live in a\nseparate process from the main C<gnuplot> process. It is thus possible for the\nmain C<gnuplot> process to exit, while leaving the plot windows up (a caveat is\nthat such decapitated windows aren't interactive). There are 3 possible states\nof the polotting pipeline:\n\n=over\n\n=item Alive: C<feedgnuplot>, C<gnuplot> alive, plot window process alive, no\nshell prompt (shell busy with C<feedgnuplot>)\n\n=item Half-alive: C<feedgnuplot>, C<gnuplot> dead, plot window process alive\n(but non-interactive), shell prompt available\n\n=item Dead: C<feedgnuplot>, C<gnuplot> dead, plot window process dead, shell\nprompt available\n\n=back\n\nThe possibilities are:\n\n=over\n\n=item No C<--stream>, all data read in\n\n=over\n\n=item no C<--exit> (default)\n\nAlive. Need to Ctrl-C to get back into the shell\n\n=item C<--exit>\n\nHalf-alive. Non-interactive prompt up, and the shell accepts new commands.\nWithout C<--stream> the goal is to show a plot, so a Dead state would not be\nuseful.\n\n=back\n\n=item C<--stream>, all data read in or the C<feedgnuplot> process terminated\n\n=over\n\n=item no C<--exit> (default)\n\nAlive. Need to Ctrl-C to get back into the shell. This means that when making\nlive plots, the first Ctrl-C kills the data feeding process, but leaves the\nfinal plot up for inspection. A second Ctrl-C kills feedgnuplot as well.\n\n=item C<--exit>\n\nDead. No plot is shown, and the shell accepts new commands. With C<--stream> the\ngoal is to show a plot as the data comes in, which we have been doing. Now that\nwe're done, we can clean up everything.\n\n=back\n\n=back\n\nNote that one usually invokes C<feedgnuplot> as a part of a shell pipeline:\n\n $ write_data | feedgnuplot\n\nIf the user terminates this pipeline with ^C, then I<all> the processes in the\npipeline receive SIGINT. This normally kills C<feedgnuplot> and all its\nC<gnuplot> children, and we let this happen unless C<--stream> and no C<--exit>.\nIf C<--stream> and no C<--exit>, then we ignore the first ^C. The data feeder\ndies, and we behave as if the input data was exhausted. A second ^C kills us\nalso.\n\n=item\n\nC<--geometry>\n\nSpecifies the size, position of the plot window. This applies I<only> to the\nC<x11> gnuplot terminal, and has no effect otherwise. To control the window size\nfor any other terminal, ask for the terminal explicitly, with the options\nspecifying the size. For instance C<--terminal 'qt size 1024,768'>\n\n=item\n\nC<--version>\n\nPrint the version and exit\n\n=back\n\n=head1 RECIPES\n\nFor a tutorial and a gallery please see the guide at\nL<https://github.com/dkogan/feedgnuplot/blob/master/guide/guide.org>\n\n=head2 Basic plotting of piped data\n\n $ seq 5 | awk '{print 2*$1, $1*$1}'\n 2 1\n 4 4\n 6 9\n 8 16\n 10 25\n\n $ seq 5 | awk '{print 2*$1, $1*$1}' |\n   feedgnuplot --lines --points --legend 0 \"data 0\" --title \"Test plot\" --y2 1\n\n=head2 Realtime plot of network throughput\n\nLooks at wlan0 on Linux.\n\n $ while true; do sleep 1; cat /proc/net/dev; done |\n   gawk '/wlan0/ {if(b) {print $2-b; fflush()} b=$2}' |\n   feedgnuplot --lines --stream --xlen 10 --ylabel 'Bytes/sec' --xlabel seconds\n\n=head2 Realtime plot of battery charge in respect to time\n\nUses the result of the C<acpi> command.\n\n $ while true; do acpi; sleep 15; done |\n   perl -nE 'BEGIN{ $| = 1; } /([0-9]*)%/; say join(\" \", time(), $1);' |\n   feedgnuplot --stream --ymin 0 --ymax 100 --lines --domain --xlabel 'Time' --timefmt '%s' --ylabel \"Battery charge (%)\"\n\n=head2 Realtime plot of temperatures in an IBM Thinkpad\n\nUses C</proc/acpi/ibm/thermal>, which reports temperatures at various locations\nin a Thinkpad.\n\n $ while true; do cat /proc/acpi/ibm/thermal | awk '{$1=\"\"; print}' ; sleep 1; done |\n   feedgnuplot --stream --xlen 100 --lines --autolegend --ymax 100 --ymin 20 --ylabel 'Temperature (deg C)'\n\n=head2 Plotting a histogram of file sizes in a directory, granular to 10MB\n\n $ ls -l | awk '{print $5/1e6}' |\n   feedgnuplot --histogram 0\n     --binwidth 10\n     --ymin 0 --xlabel 'File size (MB)' --ylabel Frequency\n\n=head2 Plotting a live histogram of the ping round-trip times for the past 20 seconds\n\n $ ping -D 8.8.8.8 |\n   perl -anE 'BEGIN { $| = 1; }\n              $F[0] =~ s/[\\[\\]]//g or next;\n              $F[7] =~ s/.*=//g    or next;\n              say \"$F[0] $F[7]\"' |\n   feedgnuplot --stream --domain --histogram 0 --binwidth 10 \\\n               --xlabel 'Ping round-trip time (s)'  \\\n               --ylabel Frequency --xlen 20\n\n=head2 Plotting points on top of an existing image\n\nThis can be done with C<--image>:\n\n $ < features_xy.data\n   feedgnuplot --points --domain --image \"image.png\"\n\nor with C<--equation>:\n\n $ < features_xy.data\n   feedgnuplot --points --domain\n     --equation '\"image.png\" binary filetype=auto flipy with rgbimage'\n     --set 'yrange [:] reverse'\n\nThe C<--image> invocation is a convenience wrapper for the C<--equation>\nversion. Finer control is available with C<--equation>.\n\n\nHere an existing image is given to gnuplot verbatim, and data to plot on top of\nit is interpreted by feedgnuplot as usual. C<flipy> is useful here because\nusually the y axis points up, but when looking at images, this is usually\nreversed: the origin is the top-left pixel.\n\n=head1 ACKNOWLEDGEMENT\n\nThis program is originally based on the driveGnuPlots.pl script from\nThanassis Tsiodras. It is available from his site at\nL<http://users.softlab.ece.ntua.gr/~ttsiod/gnuplotStreaming.html>\n\n=head1 REPOSITORY\n\nL<https://github.com/dkogan/feedgnuplot>\n\n=head1 AUTHOR\n\nDima Kogan, C<< <dima@secretsauce.net> >>\n\n=head1 LICENSE AND COPYRIGHT\n\nCopyright 2011-2021 Dima Kogan.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of either: the GNU General Public License as published\nby the Free Software Foundation; or the Artistic License.\n\nSee http://dev.perl.org/licenses/ for more information.\n\n=cut"
}
