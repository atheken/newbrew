{
  "name": "rargs",
  "full_name": "rargs",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Util like xargs + awk with pattern matching support",
  "license": "MIT",
  "homepage": "https://github.com/lotabout/rargs",
  "versions": {
    "stable": "0.3.0",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/lotabout/rargs/archive/v0.3.0.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "22d9aa4368a0f9d1fd82391439d3aabf4ddfb24ad674a680d6407c9e22969da3"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 1,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/rargs/blobs/sha256:db39ea8042e8c099c423325bf28e62fddcd985312dc39f2f9f7f4cee307b23f6",
          "sha256": "db39ea8042e8c099c423325bf28e62fddcd985312dc39f2f9f7f4cee307b23f6"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/rargs/blobs/sha256:63a38fdbffaba3ef942b5f7d29c093cf995f4ea1c3bef35f5194ad0a32b9d306",
          "sha256": "63a38fdbffaba3ef942b5f7d29c093cf995f4ea1c3bef35f5194ad0a32b9d306"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/rargs/blobs/sha256:4513c4e3dd9b6623322227d52001579b10bfb651a645ce143bd3927903d94e1e",
          "sha256": "4513c4e3dd9b6623322227d52001579b10bfb651a645ce143bd3927903d94e1e"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/rargs/blobs/sha256:a1030b51564a181c68ce37cc615ae774b53f72e24c9f0949a0fd5024f21996cc",
          "sha256": "a1030b51564a181c68ce37cc615ae774b53f72e24c9f0949a0fd5024f21996cc"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/rargs/blobs/sha256:ec12b996841e633e647a60d753e7a52b6d654f4d13755fd0ab509d7b75666c2c",
          "sha256": "ec12b996841e633e647a60d753e7a52b6d654f4d13755fd0ab509d7b75666c2c"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/rargs/blobs/sha256:5b385f4ac72270f54bf30989cbe1a12dc5a2ad4c78f67445f386b774b30456c9",
          "sha256": "5b385f4ac72270f54bf30989cbe1a12dc5a2ad4c78f67445f386b774b30456c9"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/rargs/blobs/sha256:32591f33510d8ead309401f8da9c91690830919c717d84b913a7ec7dbd764624",
          "sha256": "32591f33510d8ead309401f8da9c91690830919c717d84b913a7ec7dbd764624"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/rargs/blobs/sha256:5986e0f6b1f35cf2cb8b2113965c30895942c065dfe24d61a17c5497de6f9f02",
          "sha256": "5986e0f6b1f35cf2cb8b2113965c30895942c065dfe24d61a17c5497de6f9f02"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "rust"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/rargs.rb",
  "ruby_source_checksum": {
    "sha256": "55f78e14a0c9ce612043e26d5fde12aac2b763f1f5a87ccfa53246bf218756b5"
  },
  "date_added": "2018-12-01T19:06:34+01:00",
  "readme": "**Rargs** is kind of `xargs` + `awk` with pattern-matching support.\n\n[![Crates.io](https://img.shields.io/crates/v/rargs.svg)](https://crates.io/crates/rargs) [![Build Status](https://travis-ci.org/lotabout/rargs.svg?branch=master)](https://travis-ci.org/lotabout/rargs)\n\n## Installation\n\n### Mac OS\n\n```\nbrew install rargs\n```\n\n### Nix\n\n```\nnix-env -i rargs\n```\n(Currently available in unstable channel)\n\n### Binary\n\nDownload in the [Release Page](https://github.com/lotabout/rargs/releases) and\nput it in your `PATH` after uncompress.\n\n### Using Cargo\n\n```\ncargo install --git https://github.com/lotabout/rargs.git\n```\n\n## Example usage\n\n### Batch rename files\n\nSuppose you have several backup files whose names match the pattern `<scriptname>.sh.bak`, and you want to map each filename back to `<scriptname>.sh`. We want to do it in a batch, so `xargs` is a natural choice, but how do we specify the name for each file? I believe there is no easy way.\n\nWith `rargs`, however, you are able to do:\n\n```sh\nls *.bak | rargs -p '(.*)\\.bak' mv {0} {1}\n```\n\nHere `{0}` refers to the whole input line, while `{1}` refers to the first group captured in the regular expression.\n\n### Batch download\n\nI had a bunch of URLs and their corresponding target filenames stored in a CSV file:\n\n```\nURL1,filename1\nURL2,filename2\n```\n\nI hoped there was a simple way to download and save each URL with its specified filename. With `rargs` there is:\n\n```sh\ncat download-list.csv | rargs -p '(?P<url>.*),(?P<filename>.*)' wget {url} -O {filename}\n```\n\nHere `(?P<group_name>...)` assigns the name `group_name` to the captured group. This can then be referred to as `{group_name}` in the command.\n\n### AWK replacement?\n\nSuppose you have an xSV file with lots of columns, and you only want to extract and format some of them, e.g.:\n\n```\nnobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false\nroot:*:0:0:System Administrator:/var/root:/bin/sh\ndaemon:*:1:1:System Services:/var/root:/usr/bin/false\n```\n\nHere's an example of how `rargs` can be used to process it:\n\n```\n$ cat /etc/passwd | rargs -d: echo -e 'id: \"{1}\"\\t name: \"{5}\"\\t rest: \"{6..::}\"'\nid: \"nobody\"     name: \"Unprivileged User\"       rest: \"/var/empty:/usr/bin/false\"\nid: \"root\"       name: \"System Administrator\"    rest: \"/var/root:/bin/sh\"\nid: \"daemon\"     name: \"System Services\"         rest: \"/var/root:/usr/bin/false\"\n```\n\n`rargs` allow you to specify the delimiter (regex) to split the input on, and allows you to refer to the corresponding fields or field ranges. This allows it to be used as an AWK replacement for some simple but common cases.\n\n## How does it work?\n\n1. receive the input on stdin and split it into lines\n2. split (`-d`) or extract (`-p`) the input into named or numbered groups, with `{0}` matching the whole line\n3. map the named and numbered groups into a command passed as the remaining arguments, and execute the command\n\n## Features\n\n### Regexp captures\n\n`rargs` allows you to use any regular expression to match the input, and captures anything you are interested in. The syntax is the standard, mostly Perl-compatible [Rust regex syntax](https://docs.rs/regex/0.2.10/regex/#syntax) used by tools such as [ripgrep](https://github.com/BurntSushi/ripgrep).\n- positional (numbered) groups are captured with parentheses, e.g. `'(\\w+):(\\d+)'`, and the corresponding groups are referred to by `{1}`, `{2}` etc. in the command\n- named groups are captured with `(?P<name>...)` and referred to by `{name}` in the command\n\n### Delimiter captures\n\nFor simple usage, you might not want to write the whole regular expression to extract parts of the line. All you want is to split the groups by some delimiter. With `rargs` you can achieve this by using the `-d` (delimiter) option.\n\n### Field ranges\n\nWe already know how to refer to captures by number (`{1}`) or by name (`{name}`). There are also cases where you might want to substitute multiple fields at the same time. `rargs` also supports this with field-range expressions.\n\nSuppose we have already captured 5 groups representing the strings `1`, `2`, `3`, `4` and `5`\n\n- `{..}` gathers them all into `1 2 3 4 5` (note that they are separated by a space; this can be overridden by the `-s` option)\n- `{..3}` results in `1 2 3`\n- `{4..}` results in `4 5`\n- `{2..4}` results in `2 3 4`\n- `{3..3}` results in `3`\n\nYou can also specify a \"local\" separator (which will not affect the global setting):\n\n- `{..3:-}` results in `1-2-3`\n- `{..3:/}` results in `1/2/3`\n\n### Negative field\n\nSometimes you may want to refer to the last few fields but have no way to predict the total number of fields of the input. `rargs` offer negative fields.\n\nSuppose we have already captured 5 groups representing the strings `1`, `2`, `3`, `4` and `5`:\n\n- `{-1}` results in `5`\n- `{-5}` results in `1`\n- `{-6}` results in nothing\n- `{-3..}` results in `3 4 5`\n\n### Multiple threading\n\nYou can run commands in multiple threads to improve performance:\n\n- `-w <num>` specifies the number of workers you want to run simultaneously\n- `-w 0` defaults the number of workers to the number of CPUs on your system\n\n### Special Variables\n\n- `{LINENUM}` or `{LN}` to refer to current line number.\n\n## Interested?\n\nAll feedback and PRs are welcome!"
}
