{
  "name": "density",
  "full_name": "density",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Superfast compression library",
  "license": "BSD-3-Clause",
  "homepage": "https://github.com/k0dai/density",
  "versions": {
    "stable": "0.14.2",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/k0dai/density/archive/density-0.14.2.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "0b130ea9da3ddaad78810a621a758b47c4135d91d5b5fd22d60bbaf04bc147da"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/density/blobs/sha256:f7edf808c014e5ea5050f60258767bdbe1b2b1a0f5b977486e89c219ef11e3ca",
          "sha256": "f7edf808c014e5ea5050f60258767bdbe1b2b1a0f5b977486e89c219ef11e3ca"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/density/blobs/sha256:3c7879e53bde3927486a7ce07426c32a43057341ac351ef7af58c983b93a1be9",
          "sha256": "3c7879e53bde3927486a7ce07426c32a43057341ac351ef7af58c983b93a1be9"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/density/blobs/sha256:1a4efa81a981da64d95dd3c323e0e7ee8fd78c80f7bbcc103e301772e2efb1d7",
          "sha256": "1a4efa81a981da64d95dd3c323e0e7ee8fd78c80f7bbcc103e301772e2efb1d7"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/density/blobs/sha256:730ea7ccf46655378d9c449b705d883061f359259594f3cfd01b5e2d3e3328c8",
          "sha256": "730ea7ccf46655378d9c449b705d883061f359259594f3cfd01b5e2d3e3328c8"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/density/blobs/sha256:a37ef9a77b7e322d50e86cd94f10a7d1513b4f103b14a9beb03435ae49603af7",
          "sha256": "a37ef9a77b7e322d50e86cd94f10a7d1513b4f103b14a9beb03435ae49603af7"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/density/blobs/sha256:c262dbf150942de16d4054010d40622491eeba19c7f273d64a5675de9bf50024",
          "sha256": "c262dbf150942de16d4054010d40622491eeba19c7f273d64a5675de9bf50024"
        },
        "catalina": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/density/blobs/sha256:1d7dee6e22957cd5d755b11628e9a64d2233ef4abcb27e6aea15cbc9313b057e",
          "sha256": "1d7dee6e22957cd5d755b11628e9a64d2233ef4abcb27e6aea15cbc9313b057e"
        },
        "mojave": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/density/blobs/sha256:a123e229e87c6acb5e38292e35671f71e49d0cd0afbb1a315d941a49ab3ec8e4",
          "sha256": "a123e229e87c6acb5e38292e35671f71e49d0cd0afbb1a315d941a49ab3ec8e4"
        },
        "high_sierra": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/density/blobs/sha256:798b64ce99c516e735c76aea05944869124634488c82af5ba3f2930f60d83de3",
          "sha256": "798b64ce99c516e735c76aea05944869124634488c82af5ba3f2930f60d83de3"
        },
        "sierra": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/density/blobs/sha256:7740a6a2ba8aa701025c01553c57051e72b49e2f8f0774f064ca98832e1e58e9",
          "sha256": "7740a6a2ba8aa701025c01553c57051e72b49e2f8f0774f064ca98832e1e58e9"
        },
        "el_capitan": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/density/blobs/sha256:6853e909ed8057817becb03cbb5dbfdd3d4e2ea35348bf562e86dc51aed11a78",
          "sha256": "6853e909ed8057817becb03cbb5dbfdd3d4e2ea35348bf562e86dc51aed11a78"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/density/blobs/sha256:5d9f255bfbb15a12094a5b19036358a207019e041fe0a6f5a13365debffdeb9a",
          "sha256": "5d9f255bfbb15a12094a5b19036358a207019e041fe0a6f5a13365debffdeb9a"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": true,
  "deprecation_date": "2022-12-07",
  "deprecation_reason": "repo_archived",
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/density.rb",
  "ruby_source_checksum": {
    "sha256": "9f227e48b56d469d70014de133e64e1adeb301f0b443bd47cf7e55f99be77e58"
  },
  "date_added": "2018-05-24T02:22:59-07:00",
  "readme": "﻿DENSITY\n========\nSuperfast compression library\n\nDENSITY is a free C99, open-source, BSD licensed compression library.\n\nIt is focused on high-speed compression, at the best ratio possible. **All three** of DENSITY's algorithms are currently at the **pareto frontier** of compression speed vs ratio (cf. [here](https://github.com/inikep/lzbench/blob/master/lzbench18_sorted.md) for an independent benchmark).\n\nDENSITY features a simple API to enable quick integration in any project.\n\nBranch|Linux & MacOS|Windows\n--- | --- | ---\nmaster|[![Build Status](https://travis-ci.org/k0dai/density.svg?branch=master)](https://travis-ci.org/k0dai/density)|[![Build status](https://ci.appveyor.com/api/projects/status/rf7x3x829il72cii/branch/master?svg=true)](https://ci.appveyor.com/project/gpnuma/density/branch/master)\ndev|[![Build Status](https://travis-ci.org/k0dai/density.svg?branch=dev)](https://travis-ci.org/k0dai/density)|[![Build status](https://ci.appveyor.com/api/projects/status/rf7x3x829il72cii/branch/dev?svg=true)](https://ci.appveyor.com/project/gpnuma/density/branch/dev)\n\nWhy is it so fast ?\n-------------------\n\nOne of the biggest assets of DENSITY is that its work unit is **not a byte** like other libraries, but **a group of 4 bytes**.\n\nWhen other libraries consume one byte of data and then apply an algorithmic processing to it, DENSITY consumes 4 bytes and then applies its algorithmic processing.\n\nThat's why DENSITY's algorithms were designed from scratch. They have to alleviate for 4-byte work units and still provide interesting compression ratios.\n\n**Speed pedigree traits**\n\n*   4-byte work units\n*   heavy use of registers as opposed to memory for processing\n*   avoidance of or use of minimal branching when possible\n*   use of low memory data structures to favor processor cache Lx accesses\n*   library wide inlining\n*   specific unrollings\n*   prefetching and branching hints\n*   restricted pointers to maximize compiler optimizations\n\nA \"blowup protection\" is provided, dramatically increasing the processing speed of incompressible input data. Also, the output, compressed data size will **never exceed** the original uncompressed data size by more than 1% in case of incompressible, reasonably-sized inputs.\n\nBenchmarks\n----------\n\n**Quick benchmark**\n\nDENSITY features an **integrated in-memory benchmark**. After building the project (see [build](#build)), a *benchmark* executable will be present in the build directory. If run without arguments, usage help will be displayed.\n\nFile used : enwik8 (100 MB)\n\nPlatform : MacBook Pro, MacOS 10.13.3, 2.3 GHz Intel Core i7, 8Gb 1600 MHz DDR, SSD, compiling with Clang/LLVM 9.0.0\n\nTiming : using the *time* function, and taking the best *user* output after multiple runs. In the case of density, the in-memory integrated benchmark's best value (which uses the same usermode CPU timing) is used.\n\n<sub>Library</sub>|<sub>Algorithm</sub>|<sub>Compress</sub>|<sub>Decompress</sub>|<sub>Size</sub>|<sub>Ratio</sub>|<sub>Round trip</sub>\n---|---|---|---|---|---|---\n<sub>**density** 0.14.2</sub>|<sub>Chameleon</sub>|<sub>0.092s (1085 MB/s)</sub>|<sub>0.059s (1684 MB/s)</sub>|<sub>61 524 084</sub>|<sub>61,52%</sub>|<sub>0.151s</sub>\n<sub>lz4 r129</sub>|<sub>-1</sub>|<sub>0.468s (214 MB/s)</sub>|<sub>0.115s (870 MB/s)</sub>|<sub>57 285 990</sub>|<sub>57,29%</sub>|<sub>0.583s</sub>\n<sub>lzo 2.08</sub>|<sub>-1</sub>|<sub>0.367s (272 MB/s)</sub>|<sub>0.309s (324 MB/s)</sub>|<sub>56 709 096</sub>|<sub>56,71%</sub>|<sub>0.676s</sub>\n<sub>**density** 0.14.2</sub>|<sub>Cheetah</sub>|<sub>0.170s (587 MB/s)</sub>|<sub>0.126s (796 MB/s)</sub>|<sub>53 156 668</sub>|<sub>53,16%</sub>|<sub>0.296s</sub>\n<sub>**density** 0.14.2</sub>|<sub>Lion</sub>|<sub>0.303s (330 MB/s)</sub>|<sub>0.288s (347 MB/s)</sub>|<sub>47 817 692</sub>|<sub>47,82%</sub>|<sub>0.591s</sub>\n<sub>lz4 r129</sub>|<sub>-3</sub>|<sub>1.685s (59 MB/s)</sub>|<sub>0.118s (847 MB/s)</sub>|<sub>44 539 940</sub>|<sub>44,54%</sub>|<sub>1.803s</sub>\n<sub>lzo 2.08</sub>|<sub>-7</sub>|<sub>9.562s (10 MB/s)</sub>|<sub>0.319s (313 MB/s)</sub>|<sub>41 720 721</sub>|<sub>41,72%</sub>|<sub>9.881s</sub>\n\n**Other benchmarks**\n\nHere are a few other benchmarks featuring DENSITY (non exhaustive list) :\n\n*   [**squash**](https://github.com/quixdb/squash) is an abstraction layer for compression algorithms, and has an extremely exhaustive set of benchmark results, including density's, [available here](https://quixdb.github.io/squash-benchmark/?dataset=dickens&machine=s-desktop).\n\n*   [**lzbench**](https://github.com/inikep/lzbench) is an in-memory benchmark of open-source LZ77/LZSS/LZMA compressors.\n\n*   [**fsbench**](https://github.com/gpnuma/fsbench-density) is a command line utility that enables real-time testing of compression algorithms, but also hashes and much more. A fork with density releases is [available here](https://github.com/gpnuma/fsbench-density) for easy access.\nThe original author's repository [can be found here](https://chiselapp.com/user/Justin_be_my_guide/repository/fsbench/).\n\nBuild\n-----\nDENSITY can be built on a number of platforms, via the provided makefiles.\n\nIt was developed and optimized against Clang/LLVM which makes it the preferred compiler, but GCC and MSVC are also supported. Please use the latest compiler versions for best performance.\n\n**MacOS**\n\nOn MacOS, Clang/LLVM is the default compiler, which makes things simpler.\n\n1) Get the source code :\n\n```\n    git clone https://github.com/k0dai/density.git\n    cd density\n```\n\n2) Build and test :\n\n```\n    make\n    build/benchmark -f\n```\n\nAlternatively, thanks to the [Homebrew project](https://brew.sh), DENSITY can also be installed with a single command on MacOS:\n\n```\n    brew install density\n```\n\n**Linux**\n\nOn Linux, Clang/LLVM is not always available by default, but can be easily added thanks to the provided package managers.\nThe following example assumes a Debian or Ubuntu distribution with *apt-get*.\n\n1) From the command line, install Clang/LLVM (*optional*, GCC is also supported if Clang/LLVM can't be used) and other prerequisites.\n\n```\n    sudo apt-get install clang git\n```\n\n2) Get the source code :\n\n```\n    git clone https://github.com/k0dai/density.git\n    cd density\n```\n\n3) Build and test :\n\n```\n    make\n```\nor\n```\n    make CC=gcc-... AR=gcc-ar-...\n```\nor\n```\n    make CC=clang-... AR=llvm-ar-...\n```\nto choose alternative compilers. For a quick test of resulting binaries, run\n```\n    build/benchmark -f\n```\n\n**Windows**\n\nPlease install [git for Windows](https://git-scm.com/download/win) to begin with.\n\nOn Windows, density can be built in different ways.\nThe **first method** is to use mingw's gcc compiler; for that it is necessary to download and install [mingw-w64](https://sourceforge.net/projects/mingw-w64/).\n\n1) Once mingw-w64 is installed, get the source :\n\n```\n    git clone https://github.com/k0dai/density.git\n    cd density\n```\n\n2) Build and test :\n\n```\n    mingw32-make.exe\n    build/benchmark.exe -f\n```\n\nAs an alternative, [MSYS2](http://www.msys2.org/) also offers a linux-like environment for Windows.\n\nThe **second method** is to download and install Microsoft's [Visual Studio IDE community edition](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community). It comes with Microsoft's own compilers and is free.\n\n1) Once Visual Studio is installed, open a [developer command prompt](https://docs.microsoft.com/en-us/dotnet/framework/tools/developer-command-prompt-for-vs) and type :\n\n```\n    git clone https://github.com/k0dai/density.git\n    cd density\\msvc\n```\n\n2) Build and test :\n\n```\n    msbuild Density.sln\n    bin\\Release\\benchmark.exe -f\n```\n\nAn extra **recommended step** would be to install *Clang/LLVM* for Windows. It is downloadable from [this link](http://releases.llvm.org/5.0.1/LLVM-5.0.1-win64.exe). Once installed, open the Visual Studio IDE by double-clicking on *Density.sln*, then right-click on project names and change the platform toolsets to *LLVM*. Rebuild the solution to generate binaries with Clang/LLVM.\n\nOutput format\n-------------\nDENSITY outputs compressed data in a simple format, which enables file storage and optional parallelization for both compression and decompression.\n\nA very short header holding vital informations (like DENSITY version and algorithm used) precedes the binary compressed data.\n\nAPIs\n----\nDENSITY features a straightforward *API*, simple yet powerful enough to keep users' creativity unleashed.\n\nFor advanced developers, it allows use of custom dictionaries and exportation of generated dictionaries after a compression session. Although using the default, blank dictionary is perfectly fine in most cases, setting up your own, tailored dictionaries could somewhat improve compression ratio especially for low sized input datum.\n\nPlease see the [*quick start*](#quick-start-a-simple-example-using-the-api) at the bottom of this page.\n\nAbout the algorithms\n--------------------\n\n**Chameleon** ( *DENSITY_ALGORITHM_CHAMELEON* )\n\nChameleon is a dictionary lookup based compression algorithm. It is designed for absolute speed and usually reaches a 60% compression ratio on compressible data.\nDecompression is just as fast. This algorithm is a great choice when main concern is speed.\n\n**Cheetah** ( *DENSITY_ALGORITHM_CHEETAH* )\n\nCheetah was developed with inputs from [Piotr Tarsa](https://github.com/tarsa).\nIt is derived from chameleon and uses swapped double dictionary lookups and predictions. It can be extremely good with highly compressible data (ratio reaching 10% or less).\nOn typical compressible data compression ratio is about 50% or less. It is still extremely fast for both compression and decompression and is a great, efficient all-rounder algorithm.\n\n**Lion** ( *DENSITY_ALGORITHM_LION* )\n\nLion is a multiform compression algorithm derived from cheetah. It goes further in the areas of dynamic adaptation and fine-grained analysis.\nIt uses multiple swapped dictionary lookups and predictions, and forms rank entropy coding.\nLion provides the best compression ratio of all three algorithms under any circumstance, and is still very fast.\n\nQuick start (a simple example using the API)\n--------------------------------------------\nUsing DENSITY in your application couldn't be any simpler.\n\nFirst you need to include this file in your project :\n\n*   density_api.h\n\nWhen this is done you can start using the **DENSITY API** :\n\n```C\n    #include <string.h>\n    #include \"density_api.h\"\n\n    char* text = \"This is a simple example on how to use the simple Density API.  This is a simple example on how to use the simple Density API.\";\n    uint64_t text_length = (uint64_t)strlen(text);\n\n    // Determine safe buffer sizes\n    uint_fast64_t compress_safe_size = density_compress_safe_size(text_length);\n    uint_fast64_t decompress_safe_size = density_decompress_safe_size(text_length);\n\n    // Allocate required memory\n    uint8_t *outCompressed   = malloc(compress_safe_size * sizeof(char));\n    uint8_t *outDecompressed = malloc(decompress_safe_size * sizeof(char));\n    density_processing_result result;\n\n    // Compress\n    result = density_compress(text, text_length, outCompressed, compress_safe_size, DENSITY_COMPRESSION_MODE_CHAMELEON_ALGORITHM);\n    if(!result.state)\n        printf(\"Compressed %llu bytes to %llu bytes\\n\", result.bytesRead, result.bytesWritten);\n\n    // Decompress\n    result = density_decompress(outCompressed, result.bytesWritten, outDecompressed, decompress_safe_size);\n    if(!result.state)\n        printf(\"Decompressed %llu bytes to %llu bytes\\n\", result.bytesRead, result.bytesWritten);\n\n    // Free memory_allocated\n    free(outCompressed);\n    free(outDecompressed);\n```\n\nAnd that's it ! We've done a compression/decompression round trip with a few lines !\n\nRelated projects\n----------------\n\n*   **SHARC** (archiver using density algorithms) [https://github.com/gpnuma/sharc](https://github.com/gpnuma/sharc)\n*   **fsbench-density** (in-memory transformations benchmark) [https://github.com/gpnuma/fsbench-density](https://github.com/gpnuma/fsbench-density)\n*   **densityxx** (c++ port of density) [https://github.com/charlesw1234/densityxx](https://github.com/charlesw1234/densityxx)"
}
