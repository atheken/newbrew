{
  "name": "magic_enum",
  "full_name": "magic_enum",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Static reflection for enums (to string, from string, iteration) for modern C++",
  "license": "MIT",
  "homepage": "https://github.com/Neargye/magic_enum",
  "versions": {
    "stable": "0.9.3",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/Neargye/magic_enum/archive/v0.9.3.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "3cadd6a05f1bffc5141e5e731c46b2b73c2dbff025e723c8abaa659e0a24f072"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "all": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/magic_enum/blobs/sha256:d106a548298cae974bd65aded36cc2812bfefaa4d5bd111a50cbb3235dc49336",
          "sha256": "d106a548298cae974bd65aded36cc2812bfefaa4d5bd111a50cbb3235dc49336"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/magic_enum.rb",
  "ruby_source_checksum": {
    "sha256": "195ed1879e8ba61ba9684657e732d6e1821b65353a5b563419b47457b7430553"
  },
  "date_added": "2020-12-03T14:56:47+00:00",
  "readme": "[![Stand With Ukraine](https://raw.githubusercontent.com/vshymanskyy/StandWithUkraine/main/banner2-direct.svg)](https://bit.ly/3OMysM8)\n\n```text\n __  __             _        ______                          _____\n|  \\/  |           (_)      |  ____|                        / ____|_     _\n| \\  / | __ _  __ _ _  ___  | |__   _ __  _   _ _ __ ___   | |   _| |_ _| |_\n| |\\/| |/ _` |/ _` | |/ __| |  __| | '_ \\| | | | '_ ` _ \\  | |  |_   _|_   _|\n| |  | | (_| | (_| | | (__  | |____| | | | |_| | | | | | | | |____|_|   |_|\n|_|  |_|\\__,_|\\__, |_|\\___| |______|_| |_|\\__,_|_| |_| |_|  \\_____|\n               __/ |\n              |___/\n```\n\n[![Github releases](https://img.shields.io/github/release/Neargye/magic_enum.svg)](https://github.com/Neargye/magic_enum/releases)\n[![Conan package](https://img.shields.io/badge/Conan-package-blueviolet)](https://conan.io/center/magic_enum)\n[![Vcpkg package](https://img.shields.io/badge/Vcpkg-package-blueviolet)](https://github.com/microsoft/vcpkg/tree/master/ports/magic-enum)\n[![Build2 package](https://img.shields.io/badge/Build2-package-blueviolet)](https://www.cppget.org/magic_enum?q=magic_enum)\n[![Meson wrap](https://img.shields.io/badge/Meson-wrap-blueviolet)](https://github.com/mesonbuild/wrapdb/blob/master/subprojects/magic_enum.wrap)\n[![License](https://img.shields.io/github/license/Neargye/magic_enum.svg)](LICENSE)\n[![Try online](https://img.shields.io/badge/try-online-blue.svg)](https://wandbox.org/permlink/JPMZqT9mgaUdooyC)\n[![Compiler explorer](https://img.shields.io/badge/compiler_explorer-online-blue.svg)](https://godbolt.org/z/BxfmsH)\n\n# Magic Enum C++\n\nHeader-only C++17 library provides static reflection for enums, work with any enum type without any macro or boilerplate code.\n\n## Documentation\n\n* [Reference](doc/reference.md)\n* [Limitations](doc/limitations.md)\n* [Integration](#Integration)\n\n## [Examples](example/)\n\n* Enum value to string\n\n  ```cpp\n  Color color = Color::RED;\n  auto color_name = magic_enum::enum_name(color);\n  // color_name -> \"RED\"\n  ```\n\n* String to enum value\n\n  ```cpp\n  std::string color_name{\"GREEN\"};\n  auto color = magic_enum::enum_cast<Color>(color_name);\n  if (color.has_value()) {\n    // color.value() -> Color::GREEN\n  }\n\n  // case insensitive enum_cast\n  auto color = magic_enum::enum_cast<Color>(value, magic_enum::case_insensitive);\n\n  // enum_cast with BinaryPredicate\n  auto color = magic_enum::enum_cast<Color>(value, [](char lhs, char rhs) { return std::tolower(lhs) == std::tolower(rhs); }\n\n  // enum_cast with default\n  auto color_or_default = magic_enum::enum_cast<Color>(value).value_or(Color::NONE);\n  ```\n\n* Integer to enum value\n\n  ```cpp\n  int color_integer = 2;\n  auto color = magic_enum::enum_cast<Color>(color_integer);\n  if (color.has_value()) {\n    // color.value() -> Color::BLUE\n  }\n\n  auto color_or_default = magic_enum::enum_cast<Color>(value).value_or(Color::NONE);\n  ```\n\n* Indexed access to enum value\n\n  ```cpp\n  std::size_t i = 0;\n  Color color = magic_enum::enum_value<Color>(i);\n  // color -> Color::RED\n  ```\n\n* Enum value sequence\n\n  ```cpp\n  constexpr auto colors = magic_enum::enum_values<Color>();\n  // colors -> {Color::RED, Color::BLUE, Color::GREEN}\n  // colors[0] -> Color::RED\n  ```\n\n* Number of enum elements\n\n  ```cpp\n  constexpr std::size_t color_count = magic_enum::enum_count<Color>();\n  // color_count -> 3\n  ```\n\n* Enum value to integer\n\n  ```cpp\n  Color color = Color::RED;\n  auto color_integer = magic_enum::enum_integer(color); // or magic_enum::enum_underlying(color);\n  // color_integer -> 1\n  ```\n\n* Enum names sequence\n\n  ```cpp\n  constexpr auto color_names = magic_enum::enum_names<Color>();\n  // color_names -> {\"RED\", \"BLUE\", \"GREEN\"}\n  // color_names[0] -> \"RED\"\n  ```\n\n* Enum entries sequence\n\n  ```cpp\n  constexpr auto color_entries = magic_enum::enum_entries<Color>();\n  // color_entries -> {{Color::RED, \"RED\"}, {Color::BLUE, \"BLUE\"}, {Color::GREEN, \"GREEN\"}}\n  // color_entries[0].first -> Color::RED\n  // color_entries[0].second -> \"RED\"\n  ```\n\n* Enum fusion for multi-level switch/case statements\n\n  ```cpp\n  switch (magic_enum::enum_fuse(color, direction).value()) {\n    case magic_enum::enum_fuse(Color::RED, Directions::Up).value(): // ...\n    case magic_enum::enum_fuse(Color::BLUE, Directions::Down).value(): // ...\n  // ...\n  }\n  ```\n\n* Enum switch runtime value as constexpr constant\n  ```cpp\n  Color color = Color::RED;\n  magic_enum::enum_switch([] (auto val) {\n    constexpr Color c_color = val;\n    // ...\n  }, color);\n  ```\n\n* Enum iterate for each enum as constexpr constant\n  ```cpp\n  magic_enum::enum_for_each<Color>([] (auto val) {\n    constexpr Color c_color = val;\n    // ...\n  });\n  ```\n\n* Check if enum contains\n\n  ```cpp\n  magic_enum::enum_contains(Color::GREEN); // -> true\n  magic_enum::enum_contains<Color>(2); // -> true\n  magic_enum::enum_contains<Color>(123); // -> false\n  magic_enum::enum_contains<Color>(\"GREEN\"); // -> true\n  magic_enum::enum_contains<Color>(\"fda\"); // -> false\n  ```\n\n* Enum index in sequence\n\n  ```cpp\n  constexpr auto color_index = magic_enum::enum_index(Color::BLUE);\n  // color_index.value() -> 1\n  // color_index.has_value() -> true\n  ```\n\n* Functions for flags\n\n  ```cpp\n  enum Directions : std::uint64_t {\n    Left = 1,\n    Down = 2,\n    Up = 4,\n    Right = 8,\n  };\n  template <>\n  struct magic_enum::customize::enum_range<Directions> {\n    static constexpr bool is_flags = true;\n  };\n\n  magic_enum::enum_flags_name(Directions::Up | Directions::Right); // directions_name -> \"Directions::Up|Directions::Right\"\n  magic_enum::enum_flags_contains(Directions::Up | Directions::Right); // -> true\n  magic_enum::enum_flags_cast(3); // -> \"Directions::Left|Directions::Down\"\n  ```\n\n* Enum type name\n\n  ```cpp\n  Color color = Color::RED;\n  auto type_name = magic_enum::enum_type_name<decltype(color)>();\n  // type_name -> \"Color\"\n  ```\n\n* IOstream operator for enum\n\n  ```cpp\n  using namespace magic_enum::ostream_operators; // out-of-the-box ostream operators for enums.\n  Color color = Color::BLUE;\n  std::cout << color << std::endl; // \"BLUE\"\n\n  using namespace magic_enum::ostream_operators; // out-of-the-box ostream operators for enums.\n  Color color = Color::BLUE;\n  std::cout << color << std::endl; // \"BLUE\"\n  ```\n\n* Bitwise operator for enum\n\n  ```cpp\n  enum class Flags { A = 1 << 0, B = 1 << 1, C = 1 << 2, D = 1 << 3 };\n  using namespace magic_enum::bitwise_operators; // out-of-the-box bitwise operators for enums.\n  // Support operators: ~, |, &, ^, |=, &=, ^=.\n  Flags flags = Flags::A | Flags::B & ~Flags::C;\n  ```\n\n* Checks whether type is an [Unscoped enumeration](https://en.cppreference.com/w/cpp/language/enum#Unscoped_enumeration).\n\n  ```cpp\n  enum color { red, green, blue };\n  enum class direction { left, right };\n\n  magic_enum::is_unscoped_enum<color>::value -> true\n  magic_enum::is_unscoped_enum<direction>::value -> false\n  magic_enum::is_unscoped_enum<int>::value -> false\n\n  // Helper variable template.\n  magic_enum::is_unscoped_enum_v<color> -> true\n  ```\n\n* Checks whether type is an [Scoped enumeration](https://en.cppreference.com/w/cpp/language/enum#Scoped_enumerations).\n\n  ```cpp\n  enum color { red, green, blue };\n  enum class direction { left, right };\n\n  magic_enum::is_scoped_enum<color>::value -> false\n  magic_enum::is_scoped_enum<direction>::value -> true\n  magic_enum::is_scoped_enum<int>::value -> false\n\n  // Helper variable template.\n  magic_enum::is_scoped_enum_v<direction> -> true\n  ```\n\n* Static storage enum variable to string\n  This version is much lighter on the compile times and is not restricted to the enum_range [limitation](doc/limitations.md).\n\n  ```cpp\n  constexpr Color color = Color::BLUE;\n  constexpr auto color_name = magic_enum::enum_name<color>();\n  // color_name -> \"BLUE\"\n  ```\n\n* `containers::array` array container for enums.\n\n  ```cpp\n  magic_enum::containers::array<Color, RGB> color_rgb_array {};\n  color_rgb_array[Color::RED] = {255, 0, 0};\n  color_rgb_array[Color::GREEN] = {0, 255, 0};\n  color_rgb_array[Color::BLUE] = {0, 0, 255};\n  std::get<Color::BLUE>(color_rgb_array) // -> RGB{0, 0, 255}\n  ```\n\n* `containers::bitset` bitset container for enums.\n\n  ```cpp\n  constexpr magic_enum::containers::bitset<Color> color_bitset_red_green {Color::RED|Color::GREEN};\n  bool all = color_bitset_red_green.all();\n  // all -> false\n  // Color::BLUE is missing\n  bool test = color_bitset_red_green.test(Color::RED);\n  // test -> true\n  ```\n\n* `containers::set` set container for enums.\n\n  ```cpp\n  auto color_set = magic_enum::containers::set<Color>();\n  bool empty = color_set.empty();\n  // empty -> true\n  color_set.insert(Color::GREEN);\n  color_set.insert(Color::BLUE);\n  color_set.insert(Color::RED);\n  std::size_t size = color_set.size();\n  // size -> 3\n  ```\n\n* Improved UB-free \"SFINAE-friendly\" [underlying_type](https://en.cppreference.com/w/cpp/types/underlying_type).\n\n  ```cpp\n  magic_enum::underlying_type<color>::type -> int\n\n  // Helper types.\n  magic_enum::underlying_type_t<Direction> -> int\n  ```\n## Remarks\n\n* `magic_enum` does not pretend to be a silver bullet for reflection for enums, it was originally designed for small enum.\n\n* Before use, read the [limitations](doc/limitations.md) of functionality.\n\n## Integration\n\n* You should add the required file [magic_enum.hpp](include/magic_enum.hpp), and optionally other headers from [include dir](include/) or [release archive](https://github.com/Neargye/magic_enum/releases/latest). Alternatively, you can build the library with CMake.\n\n* If you are using [vcpkg](https://github.com/Microsoft/vcpkg/) on your project for external dependencies, then you can use the [magic-enum package](https://github.com/microsoft/vcpkg/tree/master/ports/magic-enum).\n\n* If you are using [Conan](https://www.conan.io/) to manage your dependencies, merely add `magic_enum/x.y.z` to your conan's requires, where `x.y.z` is the release version you want to use.\n\n* If you are using [Build2](https://build2.org/) to build and manage your dependencies, add `depends: magic_enum ^x.y.z` to the manifest file where `x.y.z` is the release version you want to use. You can then import the target using `magic_enum%lib{magic_enum}`.\n\n* Alternatively, you can use something like [CPM](https://github.com/TheLartians/CPM) which is based on CMake's `Fetch_Content` module.\n\n  ```cmake\n  CPMAddPackage(\n      NAME magic_enum\n      GITHUB_REPOSITORY Neargye/magic_enum\n      GIT_TAG x.y.z # Where `x.y.z` is the release version you want to use.\n  )\n  ```\n\n* Bazel is also supported, simply add to your WORKSPACE file:\n\n  ```\n  http_archive(\n      name = \"magic_enum\",\n      strip_prefix = \"magic_enum-<commit>\",\n      urls = [\"https://github.com/Neargye/magic_enum/archive/<commit>.zip\"],\n  )\n  ```\n\n  To use bazel inside the repository it's possible to do:\n\n  ```\n  bazel build //...\n  bazel test //...\n  bazel run //example\n  ```\n\n  (Note that you must use a supported compiler or specify it with `export CC= <compiler>`.)\n\n* If you are using [Ros](https://www.ros.org/), you can include this package by adding `<depend>magic_enum</depend>` to your package.xml and include this package in your workspace. In your CMakeLists.txt add the following:\n  ```cmake\n  find_package(magic_enum CONFIG REQUIRED)\n  ...\n  target_link_libraries(your_executable magic_enum::magic_enum)\n  ```\n\n## Compiler compatibility\n\n* Clang/LLVM >= 5\n* MSVC++ >= 14.11 / Visual Studio >= 2017\n* Xcode >= 10\n* GCC >= 9\n* MinGW >= 9\n\n## Licensed under the [MIT License](LICENSE)"
}
