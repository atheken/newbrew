{
  "name": "bic",
  "full_name": "bic",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "C interpreter and API explorer",
  "license": "GPL-2.0",
  "homepage": "https://github.com/hexagonal-sun/bic",
  "versions": {
    "stable": "1.0.0",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/hexagonal-sun/bic/releases/download/v1.0.0/bic-v1.0.0.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "553324e39d87df59930d093a264c14176d5e3aaa24cd8bff276531fb94775100"
    },
    "head": {
      "url": "https://github.com/hexagonal-sun/bic.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/bic/blobs/sha256:b2949645cf730b7d5b1a9286c5134775190c8353a9e8dbc28af7414b97f63253",
          "sha256": "b2949645cf730b7d5b1a9286c5134775190c8353a9e8dbc28af7414b97f63253"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/bic/blobs/sha256:cfa83a9ccd1d192b77af48d3198acf0f082d9f929a6256bb978f293543210940",
          "sha256": "cfa83a9ccd1d192b77af48d3198acf0f082d9f929a6256bb978f293543210940"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/bic/blobs/sha256:36f71fa3f987da036e8bf8cefd3e640479868f2eb033f307848679b41d7ee393",
          "sha256": "36f71fa3f987da036e8bf8cefd3e640479868f2eb033f307848679b41d7ee393"
        },
        "catalina": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/bic/blobs/sha256:41d1871d125642f8437b5bb7b74f205b0eee956be0ad46b7677680b76764c0cb",
          "sha256": "41d1871d125642f8437b5bb7b74f205b0eee956be0ad46b7677680b76764c0cb"
        },
        "mojave": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/bic/blobs/sha256:36575a3c3444985140e94eba8fe8f6711fff5433eb7f17141c4b4ae30e1f2bf7",
          "sha256": "36575a3c3444985140e94eba8fe8f6711fff5433eb7f17141c4b4ae30e1f2bf7"
        },
        "high_sierra": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/bic/blobs/sha256:23f308f2bfda3b9ee498680e08565997818570d74d1280137ef940f70801b8d9",
          "sha256": "23f308f2bfda3b9ee498680e08565997818570d74d1280137ef940f70801b8d9"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/bic/blobs/sha256:2744bafd1615ee75b148b2b4ef18a3acdb0cf7a33c71014b541cb3f820c1b38f",
          "sha256": "2744bafd1615ee75b148b2b4ef18a3acdb0cf7a33c71014b541cb3f820c1b38f"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [
    "gmp",
    "readline"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [
    {
      "name": "arch",
      "cask": null,
      "download": null,
      "version": "x86_64",
      "contexts": [],
      "specs": [
        "stable",
        "head"
      ]
    }
  ],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "2706c66e8def3eeba4d9bf1adf66221c8ad70701",
  "ruby_source_path": "Formula/bic.rb",
  "ruby_source_checksum": {
    "sha256": "d0f8987c3bc39d77fb0105a802bd86f99c38ef244e249fd190704f40ad47df46"
  },
  "head_dependencies": {
    "build_dependencies": [
      "autoconf",
      "autoconf-archive",
      "automake",
      "bison",
      "libtool"
    ],
    "dependencies": [
      "gmp",
      "readline"
    ],
    "test_dependencies": [],
    "recommended_dependencies": [],
    "optional_dependencies": [],
    "uses_from_macos": [
      {
        "flex": "build"
      }
    ],
    "uses_from_macos_bounds": [
      {}
    ]
  },
  "date_added": "2020-02-21T12:26:23-05:00",
  "readme": "* ~bic~: A C interpreter and API explorer\n\n  [[https://travis-ci.org/hexagonal-sun/bic][https://travis-ci.org/hexagonal-sun/bic.svg?branch=master]]\n\n  This a project that allows developers to explore and test C-APIs using a read\n  eval print loop, also known as a REPL.\n\n  [[file:doc/img/hello-world.gif]]\n\n** Dependencies\n   BIC's run-time dependencies are as follows:\n   - [[https://tiswww.case.edu/php/chet/readline/rltop.html][GNU Readline]]\n   - [[https://gmplib.org/][GNU MP]]\n\n   To build BIC, you'll need:\n   - [[https://github.com/westes/flex][Flex]]\n   - [[https://www.gnu.org/software/bison/][GNU Bison]]\n   - [[https://www.gnu.org/software/automake/][GNU Automake]]\n   - [[https://www.gnu.org/software/m4/][GNU M4]]\n   - [[https://www.gnu.org/software/autoconf-archive/][GNU Autoconf Archive]]\n\n   Please ensure you have these installed before building bic. The following\n   command should install these on a Debian/Ubuntu system:\n\n   #+begin_example\napt-get install build-essential libreadline-dev autoconf-archive libgmp-dev expect flex bison automake m4 libtool pkg-config\n   #+end_example\n\n   You can also use the following command to install the required dependencies\n   via [[https://brew.sh/][Homebrew]] on a MacOS system.\n   #+begin_example\nbrew install bison flex gmp readline autoconf-archive\n   #+end_example\n\n** Installation\n   You can compile and install bic with the following commands:\n\n#+begin_example\nautoreconf -i\n./configure --enable-debug\nmake\nmake install\n#+end_example\n\n    For building on a MacOS system, you need to change the configure line to:\n#+begin_example\nYACC=\"$(brew --prefix bison)/bin/bison -y\" ./configure --enable-debug\n#+end_example\n\n*** Docker\n    You can use docker to build and run bic with the following command:\n\n#+begin_example\ndocker build -t bic https://github.com/hexagonal-sun/bic.git#master\n#+end_example\n\n    Once the image is build you can then run bic with:\n#+begin_example\ndocker run -i bic\n#+end_example\n\n*** Arch Linux\n    If you are using Arch Linux, you can install bic from AUR:\n\n#+begin_example\nyay -S bic\n#+end_example\n\n** Usage\n*** REPL\n    When invoking bic with no arguments the user is presented with a REPL prompt:\n\n    #+begin_example\nBIC>\n    #+end_example\n\n    Here you can type C statements and =#include= various system headers to\n    provide access to different APIs on the system. Statements can be entered\n    directly into the REPL; there is no need to define a function for them to be\n    evaluated. Say we wish to execute the following C program:\n\n    #+begin_src C\n#include <stdio.h>\n\nint main()\n{\n    FILE *f = fopen(\"out.txt\", \"w\");\n    fputs(\"Hello, world!\\n\", f);\n    return 0;\n}\n    #+end_src\n\n    We can do this on the REPL with BIC using the following commands:\n\n    #+begin_example\nBIC> #include <stdio.h>\nBIC> FILE *f;\nf\nBIC> f = fopen(\"test.txt\", \"w\");\nBIC> fputs(\"Hello, World!\\n\", f);\n1\nBIC>\n    #+end_example\n\n    This will cause bic to call out to the C-library =fopen()= and =fputs()=\n    functions to create a file and write the hello world string into it. If you\n    now exit bic, you should see a file ~test.txt~ in the current working\n    directory with the string ~Hello, World\\n~ contained within it.\n\n    Notice that after evaluating an expression bic will print the result of\n    evaluation. This can be useful for testing out simple expressions:\n\n    #+begin_example\nBIC> 2 * 8 + fileno(f);\n19\n    #+end_example\n\n**** The Inspector\n\n     You can use bic to obtain information about any variable or type that has\n     been declared by prefixing it's name with a ~?~. This special syntax only\n     works in the REPL but will allow you to obtain various characteristics\n     about types and variables. For example:\n\n     #+begin_example\nBIC> #include <stdio.h>\nBIC> ?stdout\nstdout is a pointer to a struct _IO_FILE.\nvalue of stdout is 0x7ff1325bc5c0.\nsizeof(stdout) = 8 bytes.\nstdout was declared at: /usr/include/stdio.h:138.\n     #+end_example\n\n**** Startup Files\n\n     When the REPL starts, bic will see if =~/.bic= exists. If it does it is\n     automatically evaluated and the resulting enviroment is used by the REPL.\n     This can be useful for defining functions or varibles that are commonly\n     used. For instance, say our =~/.bic= file contains:\n\n     #+begin_src c\n#include <stdio.h>\n\nint increment(int a)\n{\n    return a + 1;\n}\n\nputs(\"Good morning, Dave.\");\n     #+end_src\n     \n     When we launch the REPL we get:\n\n     #+begin_example\n$ bic\nGood morning, Dave.\nBIC> increment(2);\n3\n     #+end_example\n\n*** Evaluating Files\n\n    If you pass bic a source file, along with =-s=, as a command line argument\n    it will evaluate it, by calling a =main()= function. For example, suppose we\n    have the file ~test.c~ that contains the following:\n\n    #+begin_src c\n#include <stdio.h>\n\nint factorial(int n)\n{\n  if (!n)\n  {\n    return 1;\n  }\n\n  return n * factorial(n - 1);\n}\n\nint main()\n{\n  printf(\"Factorial of 4 is: %d\\n\", factorial(4));\n\n  return 0;\n}\n    #+end_src\n\n    We can then invoke bic with ~-s test.c~ to evaluate it:\n\n    #+begin_example\n$ bic -s test.c\nFactorial of 4 is: 24\n    #+end_example\n    \n    \n**** Passing Arguments\n\n     If you wish to pass arguments to a C file, append them to bic's command\n     line. Once bic has processed the ~-s~ argument all other arguments are\n     treated as parameters to be passed to the program. These parameters are\n     created as =argc= and =argv= variables and passed to =main()=. The value of\n     =argv[0]= is the name of the C file that bic is executing. Consider the\n     following C program:\n\n     #+begin_src C\n#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n    for (int i = 0; i < argc; i++)\n        printf(\"argv[%d] = %s\\n\", i, argv[i]);\n\n    return 0;\n}\n     #+end_src\n     \n     If we don't pass any arguments:\n\n     #+begin_example\n$ bic -s test.c\nargv[0] = test.c\n    #+end_example\n     \n    Whereas if we invoke bic with more arguments, they are passed to the\n    program:\n\n    #+begin_example\n$ bic -s test.c -a foo -s bar a b c\nargv[0] = test.c\nargv[1] = -a\nargv[2] = foo\nargv[3] = -s\nargv[4] = bar\nargv[5] = a\nargv[6] = b\nargv[7] = c\n    #+end_example\n    \n**** Dropping Into a REPL\n\n    You can also use a special expression: =<REPL>;= in your source code to make\n    bic drop you into the repl at a particular point in the file evaluation:\n\n    [[file:doc/img/repl-interrupt.gif]]\n\n*** Exploring external libraries with the REPL\n\n    You can use bic to explore the APIs of other libraries other than libc. Let's\n    suppose we wish to explore the [[https://github.com/aquynh/capstone][Capstone]] library, we pass in a ~-l~ option to\n    make bic load that library when it starts.  For example:\n\n    [[file:doc/img/capstone.gif]]\n\n    Notice that when bic prints a compound data type (a =struct= or a =union=),\n    it shows all member names and their corresponding values.\n\n\n** Implementation Overview\n\n*** Tree Objects\n    At the heart of bic's implementation is the =tree= object. These are generic\n    objects that can be used to represent an entire program as well as the\n    current evaluator state. It is implemented in ~tree.h~ and ~tree.c~. Each\n    tree type is defined in ~c.lang~. The ~c.lang~ file is a lisp-like\n    specification of:\n\n    - Object name, for example =T_ADD=.\n    - A human readable name, such as ~Addition~.\n    - A property name prefix, such as ~tADD~.\n    - A list of properties for this type, such as ~LHS~ and ~RHS~.\n\n    The code to create an object with the above set of attributes would be:\n\n    #+begin_src lisp\n(deftype T_ADD \"Addition\" \"tADD\"\n         (\"LHS\" \"RHS\"))\n    #+end_src\n\n    Once defined, we can use this object in our C code in the following way:\n\n    #+begin_src C\ntree make_increment(tree number)\n{\n    tree add = tree_make(T_ADD);\n\n    tADD_LHS(add) = number;\n    tADD_RHS(add) = tree_make_const_int(1);\n\n    return add;\n}\n    #+end_src\n\n    Notice that a set of accessor macros, =tADD_LHS()= and =tADD_RHS()=, have\n    been generated for us to access the different property slots. When\n    ~--enable-debug~ is set during compilation each one of these macros expands\n    to a check to ensure that when setting the =tADD_LHS= property of an object\n    that the object is indeed an instance of a =T_ADD=.\n\n    The ~c.lang~ file is read by numerous source-to-source compilers that\n    generate code snippets. These utilities include:\n\n    - ~gentype~: Generates a list of tree object types.\n    - ~gentree~: Generates a structure that contains all the property data for\n      tree objects.\n    - ~genctypes~: Generates a list of C-Type tree objects - these represent the\n      fundamental data types in C.\n    - ~genaccess~: Generate accessor macros for tree object properties.\n    - ~gengc~: Generate a mark function for each tree object, this allows the\n      garbage collector to traverse object trees.\n    - ~gendump~: Generate code to dump out tree objects recursively.\n    - ~gendot~: Generate a dot file for a given =tree= hierarchy, allowing it to\n      be visualised.\n\n*** Evaluator\n\n    The output of the lexer & parser is a =tree= object hierarchy which is then\n    passed into the evaluator (~evaluator.c~). The evaluator will then\n    recursively evaluate each tree element, updating internal evaluator state,\n    thereby executing a program.\n\n    Calls to functions external to the evaluator are handled in a\n    platform-dependent way. Currently x86_64 and aarch64 are the only supported\n    platforms and the code to handle this is in the ~x86_64~ and ~aarch64~\n    folders respectively. This works by taking a function call =tree= object\n    (represented by a =T_FN_CALL=) from the evaluator with all arguments\n    evaluated and marshalling them into a simple linked-list. This is then\n    traversed in assembly to move the value into the correct register according\n    to the x86_64 or aarch64 calling-conventions and then branching to the\n    function address.\n\n*** Parser & Lexer\n    The parser and lexer are implemented in ~parser.m4~ and ~lex.m4~\n    respectively. After passing through M4 the output is two bison parsers and\n    two flex lexers.\n\n    The reason for two parsers is that the grammar for a C REPL is very\n    different than that of a C file. For example, we want the user to be able to\n    type in statements to be evaluated on the REPL without the need for wrapping\n    them in a function. Unfortunately writing a statement that is outside a\n    function body isn't valid C. As such, we don't want the user to be able to\n    write bare statements in a C file. To achieve this we have two different set\n    of grammar rules which produces two parsers. Most of the grammar rules do\n    overlap and therefore we use a single M4 file to take care of the\n    differences."
}
