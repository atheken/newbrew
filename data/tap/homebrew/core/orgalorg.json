{
  "name": "orgalorg",
  "full_name": "orgalorg",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Parallel SSH commands executioner and file synchronization tool",
  "license": "MIT",
  "homepage": "https://github.com/reconquest/orgalorg",
  "versions": {
    "stable": "1.2.0",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/reconquest/orgalorg.git",
      "tag": "1.2.0",
      "revision": "5024122fb3efaad577fa509e2d17aab1f12217de",
      "checksum": null
    },
    "head": {
      "url": "https://github.com/reconquest/orgalorg.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 1,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/orgalorg/blobs/sha256:96c0e16b29df9e9001a2dfa6b52f75ed29a6c1f0364c471ee8d2bbe6d219d7ed",
          "sha256": "96c0e16b29df9e9001a2dfa6b52f75ed29a6c1f0364c471ee8d2bbe6d219d7ed"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/orgalorg/blobs/sha256:94c8876f125804235f739721fd76b638142a2d201efa722f80ed9dca67a2bc71",
          "sha256": "94c8876f125804235f739721fd76b638142a2d201efa722f80ed9dca67a2bc71"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/orgalorg/blobs/sha256:d351128a7c84c2719ab26b2ff7f4188d8cc511bdd05a9abccaf674ded52baf7f",
          "sha256": "d351128a7c84c2719ab26b2ff7f4188d8cc511bdd05a9abccaf674ded52baf7f"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/orgalorg/blobs/sha256:b1c2fb13e6c3b0764c4b7fbf450b5d5c71e39def12efb6685ab281e4f1df3ad0",
          "sha256": "b1c2fb13e6c3b0764c4b7fbf450b5d5c71e39def12efb6685ab281e4f1df3ad0"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/orgalorg/blobs/sha256:04019263a064a9c259854951945c31a84ded8847475f607e1452cfaf3d003ed9",
          "sha256": "04019263a064a9c259854951945c31a84ded8847475f607e1452cfaf3d003ed9"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/orgalorg/blobs/sha256:a8263d34464253c4bf541e8ad30e1a42fa62c41ec3e1827300fa46192bcb8140",
          "sha256": "a8263d34464253c4bf541e8ad30e1a42fa62c41ec3e1827300fa46192bcb8140"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/orgalorg/blobs/sha256:3a76493500a6daa3401c0dba2107f63811794913d621150d391069c44ca9a7a7",
          "sha256": "3a76493500a6daa3401c0dba2107f63811794913d621150d391069c44ca9a7a7"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/orgalorg/blobs/sha256:4612ae3bbd7a798fe80217712774e26bc96b044de4b8aa147baa2e6b93e0dea2",
          "sha256": "4612ae3bbd7a798fe80217712774e26bc96b044de4b8aa147baa2e6b93e0dea2"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "go"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/orgalorg.rb",
  "ruby_source_checksum": {
    "sha256": "bfe08228a09a806b8d912c68a7c678ef3a2a999581c1cceea5e5442fb95ca207"
  },
  "date_added": "2021-03-25T05:54:23+00:00",
  "readme": "# orgalorg [![goreport](https://goreportcard.com/badge/github.com/reconquest/orgalorg)](https://goreportcard.com/report/github.com/reconquest/orgalorg) [![MIT](https://img.shields.io/badge/license-MIT-blue.svg)](https://raw.githubusercontent.com/reconquest/orgalorg/master/LICENSE)\n\n<p align=\"center\">\n<b>orgalorg can run command and upload files in parallel by SSH on many hosts</b>\n</p>\n\n<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/reconquest/orgalorg/master/demo.gif\" />\n</p>\n\n# Features\n\n* Zero-configuration. No config files. Everything is done via command line\n  flags.\n\n* Running SSH commands or shell scripts on any number of hosts in parallel. All\n  output from nodes will be returned back, keeping stdout and stderr streams\n  mapping of original commands.\n\n* Synchronizing files and directories across cluster with prior global cluster\n  locking.\n  After synchronization is done, arbitrary command can be evaluated.\n\n* Synchronizing files and directories with subsequent run of complex multi-step\n  scenario with steps synchronization across cluster.\n\n* User-friendly progress indication.\n\n* Both strict or loose modes of failover to be sure that everything will either\n  fail on any error or try to complete, no matter of what.\n\n* Interactive password authentication as well as SSH public key authentication.\n  Will use ssh-agent if present. On Windows, orgalorg can connect to\n  **pageant** or **openssh agent**.\n\n* Ability to run commands through `sudo`.\n\n* Grouped mode of output, so stdout and stderr from nodes will be grouped by\n  node name. Alternatively, output can be returned as soon as node returns\n  something.\n\n# Installation\n\n## go get\n\n```bash\ngo get github.com/reconquest/orgalorg\n```\n\n# Alternatives\n\n* ansible: intended to apply complex DSL-based scenarios of actions;\n  orgalorg aimed only on running commands and synchronizing files in parallel.\n  orgalorg can accept target hosts list on stdin and can provide realtime\n  output from commands, which ansible can't do (like running `tail -f`).\n  orgalorg also uses same argument semantic as `ssh`:\n  `orgalorg ... -C tail -f '/var/log/*.log'` will do exactly the same.\n\n* clusterssh / cssh: will open number of xterm terminals to all nodes.\n  orgalorg intended to use in batch mode, no GUI is assumed. orgalorg, however,\n  can be used in interactive mode (see example section below).\n\n* pssh: buggy, uses binary ssh, which is not resource efficient.\n  orgalorg uses native SSH protocol implementation, so safe and fast to use\n  on thousand of nodes.\n\n* dsh / gsh / pdsh: not maintained.\n\n# Example usages\n\n`-o <host>...` in later examples will mean any supported combination of\nhost-specification arguments, like\n`-o node1.example.com -o node2.example.com`.\n\n## Evaluating command on hosts in parallel\n\n```bash\norgalorg -o <host>... -C uptime\n```\n\n## Evaluating command on hosts given by stdin\n\n`axfr` is a tool of your choice for retrieving domain information from your\ninfrastructure DNS.\n\n```bash\naxfr | grep phpnode | orgalorg -s -C uptime\n```\n\n## Evaluate command under root (passwordless sudo required)\n\n```bash\norgalorg -o <host>... -x -C whoami\n```\n\n## Tailing logs from many hosts in realtime\n\n```bash\norgalorg -o <host>... -C tail -f /var/log/syslog\n```\n\n## Copying SSH public key for remote authentication\n\n```bash\norgalorg -o <host>... -p -i ~/.ssh/id_rsa.pub -C tee -a ~/.ssh/authorized_keys\n```\n\n## Synchronizing configs and then reloading service (like nginx)\n\n```bash\norgalorg -o <host>... -xn 'systemctl reload nginx' -S /etc/nginx.conf\n```\n\n## Evaluating shell script\n\n```bash\norgalorg -o <host>... -i script.bash -C bash\n```\n\n## Install package on all nodes and get combined output from each node\n\n```bash\norgalorg -o <host>... -lx -C pacman -Sy my-package --noconfirm\n```\n\n## Evaluating shell oneliner\n\n```bash\norgalorg -o <host>... -C sleep '$(($RANDOM % 10))' '&&' echo done\n```\n\n## Running poor-man interactive parallel shell\n\n```bash\norgalorg -o <host>... -i /dev/stdin -C bash -s\n```\n\n## Obtaining global cluster lock\n\n```bash\norgalorg -o <host>... -L\n```\n\nNext orgalorg calls will fail with message, that lock is already acquired,\nuntil first instance will be stopped.\n\nUseful for setting cluster into maintenance state.\n\n## Obtaining global cluster lock on custom directory\n\n```bash\norgalorg -o <host>... -L -r /etc\n```\n\n# Description\n\norgalorg provides easy way of synchronizing files across cluster and running\narbitrary SSH commands.\n\norgalorg works through SSH & tar, so no unexpected protocol errors will arise.\n\nIn default mode of operation (lately referred as sync mode) orgalorg will\nperform steps in the following order:\n\n1. Acquire global cluster lock (check more detailed info above).\n2. Create, upload and extract specified files in streaming mode to the\n   specified nodes into temporary run directory.\n3. Start synchronization tool on each node, that should relocate files from\n   temporary run directory to the destination.\n\nSo, orgalorg expected to work with third-party synchronization tool, that\nwill do actual files relocation and can be quite intricate, **but orgalorg can\nwork without that tool and perform simple files sync (more on this later)**.\n\n## Global Cluster Lock\n\nBefore doing anything else orgalorg will perform global cluster lock. That lock\nis acquired atomically, and no other orgalorg instance can acquire lock if it\nis already acquired.\n\nLocking is done via flock'ing specified file or directory on each of target\nnodes, and will fail, if flock fails on at least one node.\n\nDirectory can be used as lock target as well as ordinary file. `--lock-file`\ncan be used to specify lock target different from `/`.\n\nAfter acquiring lock, orgalorg will run heartbeat process, which will check,\nthat lock is still intact. By default, that check will be performed every 10\nseconds. If at least one heartbeat is failed, then orgalorg will abort entire\nsync procedure.\n\nUser can stop there by using `--lock` or `-L` flag, effectively transform\norgalorg to the distributed locking tool.\n\n## File Upload\n\nFiles will be sent from local node to the amount of specified nodes.\n\norgalorg will perform streaming transfer, so it's safe to synchronize large\nfiles without major memory consumption.\n\nBy default, orgalorg will upload files to the temporary run directory. That\nbehaviour can be changed by using `--root` or `-r` flag. Then, files will be\nuploaded to the specified directory.\n\nUser can specify `--upload` or `-U` flag to transform orgalorg to the simple\nfile upload tool. In that mode orgalorg will upload files to the specified\ndirectory and then exit.\n\norgalorg preserves all file attributes while transfer as well as user and group\nIDs. That behaviour can be changed by using `--no-preserve-uid` and\n`--no-preseve-gid` command line options. These flags are ignored when orgalorg\nis ran from Windows.\n\nBy default, orgalorg will keep source file paths as is, creating same directory\nlayout on the target nodes. E.g., if orgalorg told to upload file `a` while\ncurrent working directory is `/b/c/`, orgalorg will upload file to the\n`<root>/b/c/a` on the remote nodes. That behaviour can be changed by\nspecifying `--relative` or `-e` flag. Then, orgalorg will not preserve source\nfile base directory.\n\norgalorg will try to upload files under specified user (current user by\ndefault). However, if user has `NOPASSWD` record in the sudoers file on the\nremote nodes, `--sudo` or `-x` can be used to elevate to root before uploading\nfiles. It makes possible to login to the remote nodes under normal user and\nrewrite system files.\n\n## Synchronization Tool\n\nAfter file upload orgalorg will execute synchronization tool\n(`/usr/lib/orgalorg/sync`). That tool is expected to relocate synced files from\ntemporary directory to the target directory. However, that tool can perform\narbitrary actions, like reloading system services.\n\nTo specify custom synchronization tool user can use `--sync-cmd` or `-n` flag.\nFull shell syntax is supported in the argument to that option.\n\nTool is also expected to communicate with orgalorg using sync protocol\n(described below), however, it's not required. If not specified, orgalorg will\ncommunicate with that tool using stdin/stdout streams. User can change that\nbehaviour using `--simple` or `-m` flag, which will cause orgalorg to treat\nspecified sync tool as simple shell command. User can even provide stdin\nto that program by using `--stdin` or `-i` flag.\n\nTool can accept number of arguments, which can be specified  by using `-g` or\n`--arg` flags.\n\n# Synchronization Protocol\n\norgalorg will communicate with given sync tool using special sync protocol,\nwhich gives possibility to perform some actions with synchronization across\nentire cluster.\n\norgalorg will start sync tool as it specified in the command line, without\nany modification.\n\nAfter start, orgalorg will communicate with running sync tool using stdin\nand stdout streams. stderr will be passed to user untouched.\n\nAll communication messages should be prefixed by special prefix, which is\nsend by orgalorg in the hello message. All lines on stdout that are not match\ngiven prefix will be printed as is, untouched.\n\nCommunication begins from the hello message.\n\n## Protocol\n\n### HELLO\n\n`orgalorg -> sync tool`\n\n```\n<prefix> HELLO\n```\n\nStart communication session. All further messages should be prefixed with given\nprefix.\n\n### NODE\n\n`orgalorg -> sync tool`\n\n```\n<prefix> NODE <node> [CURRENT]\n```\n\norgalorg will send node list to the sync tools on each running node.\n\n`CURRENT` flag will be present next to the node which is currently receiving\nprotocol messages.\n\n### START\n\n`orgalorg -> sync tool`\n\n```\n<prefix> START\n```\n\nStart messages will be sent at the end of the nodes list and means that sync\ntool can start doing actions.\n\n### SYNC\n\n`sync tool -> orgalorg`\n\n```\n<prefix> SYNC <description>\n```\n\nSync tool can send sync messages after some steps are done to be sure, that\nevery node in cluster are performing steps gradually, in order.\n\nWhen orgalorg receives sync message, it will be broadcasted to every connected\nsync tool.\n\n### SYNC (broadcasted)\n\n`orgalorg -> sync tool`\n\n```\n<prefix> SYNC <node> <description>\n```\n\norgalorg will retransmit incoming sync message from one node to every connected\nnode (including node, that is sending sync).\n\nSync tools can wait for specific number of the incoming sync messages to\ncontinue to the next step of execution process.\n\n## Example\n\n`<-` are outgoing messages (from orgalorg to sync tools).\n\n```\n<- ORGALORG:132464327653 HELLO\n<- ORGALORG:132464327653 NODE [user@node1:22]\n<- ORGALORG:132464327653 NODE [user@node2:1234] CURRENT\n<- ORGALORG:132464327653 START\n-> (from node1) ORGALORG:132464327653 SYNC phase 1 completed\n<- ORGALORG:132464327653 SYNC [user@node1:22] phase 1 completed\n-> (from node2) ORGALORG:132464327653 SYNC phase 1 completed\n<- ORGALORG:132464327653 SYNC [user@node2:1234] phase 1 completed\n```\n\n# Testing\n\nTo run tests it's enough to:\n\n```\n./run_tests\n```\n\n## Requirements\n\nTestcases are run through [tests.sh](https://github.com/reconquest/tests.sh)\nlibrary.\n\nFor every testcase new set of temporary containers will be initialized through\n[hastur](https://github.com/seletskiy/hastur), so `systemd` is required for\nrunning test suite.\n\norgalorg testcases are close to reality as possible, so orgalorg will really\nconnect via SSH to cluster of containers in each testcase.\n\n## Coverage\n\nRun following command to calculate total coverage (available after running\ntestsuite):\n\n```bash\nmake coverage.total\n```\n\nCurrent coverage level is something about **85%**."
}
