{
  "name": "gprof2dot",
  "full_name": "gprof2dot",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Convert the output from many profilers into a Graphviz dot graph",
  "license": "LGPL-3.0-or-later",
  "homepage": "https://github.com/jrfonseca/gprof2dot",
  "versions": {
    "stable": "2022.7.29",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://files.pythonhosted.org/packages/ab/0b/fc056b26a90c1836aa6c6e1332372dc13050d384f017e388131854ead8cf/gprof2dot-2022.7.29.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "45b4d298bd36608fccf9511c3fd88a773f7a1abc04d6cd39445b11ba43133ec5"
    },
    "head": {
      "url": "https://github.com/jrfonseca/gprof2dot.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 1,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gprof2dot/blobs/sha256:54d2c550983bcbc7d974c926f90f95a9d339db13551790772149aa94b5b1d47e",
          "sha256": "54d2c550983bcbc7d974c926f90f95a9d339db13551790772149aa94b5b1d47e"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gprof2dot/blobs/sha256:68791ba75d96fce85372e3fc54cd25576b38a6fbea077032096b7f297c3b26e7",
          "sha256": "68791ba75d96fce85372e3fc54cd25576b38a6fbea077032096b7f297c3b26e7"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gprof2dot/blobs/sha256:5b50a7ebf952acaf260fabef9c6a8e2dd64cd2fa5b0c8f526b126eed6036aa91",
          "sha256": "5b50a7ebf952acaf260fabef9c6a8e2dd64cd2fa5b0c8f526b126eed6036aa91"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gprof2dot/blobs/sha256:baeaf28578b2f2c920fc45bddd496c797aba212eebd07ffdc3e70be04d423455",
          "sha256": "baeaf28578b2f2c920fc45bddd496c797aba212eebd07ffdc3e70be04d423455"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gprof2dot/blobs/sha256:dabb15b4183ef5c1094a36f8efe73f9c3e722aee48b749b9c0b7e37e396031c2",
          "sha256": "dabb15b4183ef5c1094a36f8efe73f9c3e722aee48b749b9c0b7e37e396031c2"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gprof2dot/blobs/sha256:a5eb84239ac7fb8d99effac8c63952dafccd7458173dc29222d5df693b3cf50a",
          "sha256": "a5eb84239ac7fb8d99effac8c63952dafccd7458173dc29222d5df693b3cf50a"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gprof2dot/blobs/sha256:da12fce96bf11d5c06a5c93ae9b1ca4faa317997dd588951166377a114e0328e",
          "sha256": "da12fce96bf11d5c06a5c93ae9b1ca4faa317997dd588951166377a114e0328e"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gprof2dot/blobs/sha256:fd505c606eed32d550e8ac628f596aec1d88cb6c09ea7dbe95a712164d6e3f09",
          "sha256": "fd505c606eed32d550e8ac628f596aec1d88cb6c09ea7dbe95a712164d6e3f09"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [
    "graphviz",
    "python@3.11",
    "libx11"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/gprof2dot.rb",
  "ruby_source_checksum": {
    "sha256": "03ef9675d6ef6ae8fd958cf09f7db9e85be266d039488c87115e3989b54ad779"
  },
  "date_added": "2015-09-11T15:16:06+01:00",
  "readme": "# About _gprof2dot_\n\nThis is a Python script to convert the output from many profilers into a [dot graph](https://www.graphviz.org/doc/info/lang.html).\n\nIt can:\n\n  * read output from:\n    * [Linux perf](https://perf.wiki.kernel.org/)\n    * [Valgrind's callgrind tool](https://valgrind.org/docs/manual/cl-manual.html)\n    * [oprofile](https://oprofile.sourceforge.net/)\n    * [sysprof](http://www.sysprof.com/)\n    * [xperf](https://learn.microsoft.com/en-us/windows-hardware/test/wpt/)\n    * [VTune](https://www.intel.com/content/www/us/en/developer/tools/oneapi/vtune-profiler.html)\n    * [Very Sleepy](https://www.codersnotes.com/sleepy/)\n    * [python profilers](https://docs.python.org/3/library/profile.html#profile-stats)\n    * [Java's HPROF](https://docs.oracle.com/javase/7/docs/technotes/samples/hprof.html)\n    * prof, [gprof](https://sourceware.org/binutils/docs/gprof/)\n    * [DTrace](https://en.wikipedia.org/wiki/DTrace)\n  * prune nodes and edges below a certain threshold;\n  * use an heuristic to propagate time inside mutually recursive functions;\n  * use color efficiently to draw attention to hot-spots;\n  * work on any platform where Python and Graphviz is available, i.e, virtually anywhere.\n\n**If you want an interactive viewer for the graphs generated by _gprof2dot_, check [xdot.py](https://github.com/jrfonseca/xdot.py).**\n\n\n# Status\n\n_gprof2dot_ currently fulfills my needs, and I have little or no time for its\nmaintenance.  So I'm afraid that any requested features are unlikely to be\nimplemented, and I might be slow processing issue reports or pull requests.\n\n[![Build Status](https://github.com/jrfonseca/gprof2dot/actions/workflows/build.yml/badge.svg?branch=master)](https://github.com/jrfonseca/gprof2dot/actions/workflows/build.yml)\n[![codecov](https://codecov.io/gh/jrfonseca/gprof2dot/branch/master/graph/badge.svg?token=pBvnAuazx0)](https://codecov.io/gh/jrfonseca/gprof2dot)\n\n\n# Example\n\nThis is the result from the [example data](https://linuxgazette.net/100/misc/vinayak/overall-profile.txt) in the [Linux Gazette article](https://linuxgazette.net/100/vinayak.html) with the default settings:\n\n![Sample](./sample.svg)\n\n# Requirements\n\n  * [Python](https://www.python.org/download/): known to work with version 2.7 and 3.3; it will most likely _not_ work with earlier releases.\n  * [Graphviz](https://www.graphviz.org/Download.php): tested with version 2.26.3, but should work fine with other versions.\n\n## Windows users\n\n  * Download and install [Python for Windows](https://www.python.org/download/)\n  * Download and install [Graphviz for Windows](https://www.graphviz.org/Download_windows.php)\n\n## Linux users\n\nOn Debian/Ubuntu run:\n\n    apt-get install python3 graphviz\n\nOn RedHat/Fedora run\n\n    yum install python3 graphviz\n\n\n# Download\n\n  * [PyPI](https://pypi.python.org/pypi/gprof2dot/)\n\n        pip install gprof2dot\n\n  * [Standalone script](https://raw.githubusercontent.com/jrfonseca/gprof2dot/master/gprof2dot.py)\n\n  * [Git repository](https://github.com/jrfonseca/gprof2dot)\n\n\n# Documentation\n\n## Usage\n\n```\nUsage: \n\tgprof2dot.py [options] [file] ...\n\nOptions:\n  -h, --help            show this help message and exit\n  -o FILE, --output=FILE\n                        output filename [stdout]\n  -n PERCENTAGE, --node-thres=PERCENTAGE\n                        eliminate nodes below this threshold [default: 0.5]\n  -e PERCENTAGE, --edge-thres=PERCENTAGE\n                        eliminate edges below this threshold [default: 0.1]\n  -f FORMAT, --format=FORMAT\n                        profile format: axe, callgrind, dtrace, hprof, json,\n                        oprofile, perf, prof, pstats, sleepy, sysprof or xperf\n                        [default: prof]\n  --total=TOTALMETHOD   preferred method of calculating total time: callratios\n                        or callstacks (currently affects only perf format)\n                        [default: callratios]\n  -c THEME, --colormap=THEME\n                        color map: bw, color, gray, pink or print [default:\n                        color]\n  -s, --strip           strip function parameters, template parameters, and\n                        const modifiers from demangled C++ function names\n  --color-nodes-by-selftime\n                        color nodes by self time, rather than by total time\n                        (sum of self and descendants)\n  -w, --wrap            wrap function names\n  --show-samples        show function samples\n  --node-label=MEASURE  measurements to on show the node (can be specified\n                        multiple times): self-time, self-time-percentage,\n                        total-time or total-time-percentage [default: total-\n                        time-percentage, self-time-percentage]\n  --list-functions=LIST_FUNCTIONS\n                        list functions available for selection in -z or -l,\n                        requires selector argument ( use '+' to select all).\n                        Recall that the selector argument is used with\n                        Unix/Bash globbing/pattern matching, and that entries\n                        are formatted '<pkg>:<linenum>:<function>'. When\n                        argument starts with '%', a dump of all available\n                        information is performed for selected entries,  after\n                        removal of leading '%'.\n  -z ROOT, --root=ROOT  prune call graph to show only descendants of specified\n                        root function\n  -l LEAF, --leaf=LEAF  prune call graph to show only ancestors of specified\n                        leaf function\n  --depth=DEPTH         prune call graph to show only descendants or ancestors\n                        until specified depth\n  --skew=THEME_SKEW     skew the colorization curve.  Values < 1.0 give more\n                        variety to lower percentages.  Values > 1.0 give less\n                        variety to lower percentages\n  -p FILTER_PATHS, --path=FILTER_PATHS\n                        Filter all modules not in a specified path\n```\n\n## Examples\n\n### Linux perf\n\n    perf record -g -- /path/to/your/executable\n    perf script | c++filt | gprof2dot.py -f perf | dot -Tpng -o output.png\n\n### oprofile\n\n    opcontrol --callgraph=16\n    opcontrol --start\n    /path/to/your/executable arg1 arg2\n    opcontrol --stop\n    opcontrol --dump\n    opreport -cgf | gprof2dot.py -f oprofile | dot -Tpng -o output.png\n\n### xperf\n\nIf you're not familiar with xperf then read [this excellent article](https://blogs.msdn.com/b/pigscanfly/archive/2009/08/06/stack-walking-in-xperf.aspx) first. Then do:\n\n  * Start xperf as\n\n        xperf -on Latency -stackwalk profile\n\n  * Run your application.\n\n  * Save the data.\n`\n        xperf -d output.etl\n\n  * Start the visualizer:\n\n        xperf output.etl\n\n  * In _Trace_ menu, select _Load Symbols_. _Configure Symbol Paths_ if necessary.\n\n  * Select an area of interest on the _CPU sampling graph_, right-click, and select _Summary Table_.\n\n  * In the _Columns_ menu, make sure the _Stack_ column is enabled and visible.\n\n  * Right click on a row, choose _Export Full Table_, and save to _output.csv_.\n\n  * Then invoke gprof2dot as\n\n        gprof2dot.py -f xperf output.csv | dot -Tpng -o output.png\n\n### VTune Amplifier XE\n\n  * Collect profile data as (also can be done from GUI):\n\n        amplxe-cl -collect hotspots -result-dir output -- your-app\n\n  * Visualize profile data as:\n\n        amplxe-cl -report gprof-cc -result-dir output -format text -report-output output.txt\n        gprof2dot.py -f axe output.txt | dot -Tpng -o output.png\n\nSee also [Kirill Rogozhin's blog post](http://web.archive.org/web/20130506045856/http://software.intel.com:80/en-us/blogs/2013/04/05/making-visualized-call-graph-from-intel-vtune-amplifier-xe-results).\n\n### gprof\n\n    /path/to/your/executable arg1 arg2\n    gprof path/to/your/executable | gprof2dot.py | dot -Tpng -o output.png\n\n### python profile\n\n    python -m profile -o output.pstats path/to/your/script arg1 arg2\n    gprof2dot.py -f pstats output.pstats | dot -Tpng -o output.png\n\n### python cProfile (formerly known as lsprof)\n\n    python -m cProfile -o output.pstats path/to/your/script arg1 arg2\n    gprof2dot.py -f pstats output.pstats | dot -Tpng -o output.png\n\n### Java HPROF\n\n    java -agentlib:hprof=cpu=samples ...\n    gprof2dot.py -f hprof java.hprof.txt | dot -Tpng -o output.png\n\nSee [Russell Power's blog post](http://web.archive.org/web/20220122110828/http://rjp.io/2012/07/03/java-profiling/) for details.\n\n### DTrace\n\n    dtrace -x ustackframes=100 -n 'profile-97 /pid == 12345/ { @[ustack()] = count(); } tick-60s { exit(0); }' -o out.user_stacks\n    gprof2dot.py -f dtrace out.user_stacks | dot -Tpng -o output.png\n\n    # Notice: sometimes, the dtrace outputs format may be latin-1, and gprof2dot will fail to parse it.\n    # To solve this problem, you should use iconv to convert to UTF-8 explicitly.\n    # TODO: add an encoding flag to tell gprof2dot how to decode the profile file.\n    iconv -f ISO-8859-1 -t UTF-8 out.user_stacks | gprof2dot.py -f dtrace\n\n## Output\n\nA node in the output graph represents a function and has the following layout:\n\n    +------------------------------+\n    |        function name         |\n    | total time % ( self time % ) |\n    |         total calls          |\n    +------------------------------+\n\nwhere:\n\n  * _total time %_ is the percentage of the running time spent in this function and all its children;\n  * _self time %_ is the percentage of the running time spent in this function alone;\n  * _total calls_ is the total number of times this function was called (including recursive calls).\n\nAn edge represents the calls between two functions and has the following layout:\n\n               total time %\n                  calls\n    parent --------------------> children\n\nWhere:\n\n  * _total time %_ is the percentage of the running time transfered from the children to this parent (if available);\n  * _calls_ is the number of calls the parent function called the children.\n\nNote that in recursive cycles, the _total time %_ in the node is the same for the whole functions in the cycle, and there is no _total time %_ figure in the edges inside the cycle, since such figure would make no sense.\n\nThe color of the nodes and edges varies according to the _total time %_ value. In the default _temperature-like_ color-map, functions where most time is spent (hot-spots) are marked as saturated red, and functions where little time is spent are marked as dark blue. Note that functions where negligible or no time is spent do not appear in the graph by default.\n\n## Listing functions\n\nThe flag `--list-functions` permits listing the function entries found in the `gprof` input.\nThis is intended as a tool to prepare for utilisations with the `--leaf` (`-l`) \nor `--root` (`-z`) flags.\n\n  ~~~\n  prof2dot.py -f pstats /tmp/myLog.profile  --list-functions \"test_segments:*:*\" \n    \n  test_segments:5:<module>,\n  test_segments:206:TestSegments,\n  test_segments:46:<lambda>\n  ~~~\n\n  - The selector argument is used with Unix/Bash globbing/pattern matching, in the same\n    fashion as performed by the `-l` and `-z` flags.\n\t  \n  - Entries are formatted '\\<pkg\\>:\\<linenum\\>:\\<function\\>'. \n\t\n  - When selector argument starts with '%', a dump of all available information is \n\tperformed for selected entries,   after removal of selector's leading '%'. If \n\tselector is \"+\" or \"*\", the full list of functions is printed.\n\n\n## Frequently Asked Questions\n\n### How can I generate a complete call graph?\n\nBy default `gprof2dot.py` generates a _partial_ call graph, excluding nodes and edges with little or no impact in the total computation time. If you want the full call graph then set a zero threshold for nodes and edges via the `-n` / `--node-thres`  and `-e` / `--edge-thres` options, as:\n\n    gprof2dot.py -n0 -e0\n\n### The node labels are too wide. How can I narrow them?\n\nThe node labels can get very wide when profiling C++ code, due to inclusion of scope, function arguments, and template arguments in demangled C++ function names.\n\nIf you do not need function and template arguments information, then pass the `-s` / `--strip` option to strip them.\n\nIf you want to keep all that information, or if the labels are still too wide, then you can pass the `-w` / `--wrap`, to wrap the labels. Note that because `dot` does not wrap labels automatically the label margins will not be perfectly aligned.\n\n### Why there is no output, or it is all in the same color?\n\nLikely, the total execution time is too short, so there is not enough precision in the profile to determine where time is being spent.\n\nYou can still force displaying the whole graph by setting a zero threshold for nodes and edges via the `-n` / `--node-thres`  and `-e` / `--edge-thres` options, as:\n\n    gprof2dot.py -n0 -e0\n\nBut to get meaningful results you will need to find a way to run the program for a longer time period (aggregate results from multiple runs).\n\n### Why don't the percentages add up?\n\nYou likely have an execution time too short, causing the round-off errors to be large.\n\nSee question above for ways to increase execution time.\n\n### Which options should I pass to gcc when compiling for profiling?\n\nOptions which are _essential_ to produce suitable results are:\n\n  * **`-g`** : produce debugging information\n  * **`-fno-omit-frame-pointer`** : use the frame pointer (frame pointer usage is disabled by default in some architectures like x86\\_64 and for some optimization levels; it is impossible to walk the call stack without it)\n\n_If_ you're using gprof you will also need `-pg` option, but nowadays you can get much better results with other profiling tools, most of which require no special code instrumentation when compiling.\n\nYou want the code you are profiling to be as close as possible as the code that you will\nbe releasing. So you _should_ include all options that you use in your release code, typically:\n\n  * **`-O2`** : optimizations that do not involve a space-speed tradeoff\n  * **`-DNDEBUG`** : disable debugging code in the standard library (such as the assert macro)\n\nHowever many of the optimizations performed by gcc interfere with the accuracy/granularity of the profiling results.  You _should_ pass these options to disable those particular optimizations:\n\n  * **`-fno-inline-functions`** : do not inline functions into their parents (otherwise the time spent on these functions will be attributed to the caller)\n  * **`-fno-inline-functions-called-once`** : similar to above\n  * **`-fno-optimize-sibling-calls`** : do not optimize sibling and tail recursive calls (otherwise tail calls may be attributed to the parent function)\n\nIf the granularity is still too low, you _may_ pass these options to achieve finer granularity:\n\n  * **`-fno-default-inline`** : do not make member functions inline by default merely because they are defined inside the class scope\n  * **`-fno-inline`** : do not pay attention to the inline keyword\nNote however that with these last options the timings of functions called many times will be distorted due to the function call overhead. This is particularly true for typical C++ code which _expects_ that these optimizations to be done for decent performance.\n\nSee the [full list of gcc optimization options](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html) for more information.\n\n# Links\n\nSee the [wiki](https://github.com/jrfonseca/gprof2dot/wiki) for external resources, including complementary/alternative tools."
}
