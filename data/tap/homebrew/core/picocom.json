{
  "name": "picocom",
  "full_name": "picocom",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Minimal dumb-terminal emulation program",
  "license": "GPL-2.0-or-later",
  "homepage": "https://github.com/npat-efault/picocom",
  "versions": {
    "stable": "3.1",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/npat-efault/picocom/archive/3.1.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "e6761ca932ffc6d09bd6b11ff018bdaf70b287ce518b3282d29e0270e88420bb"
    }
  },
  "revision": 1,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/picocom/blobs/sha256:10704a0718469ac5d0d1b0774341b0c24d9ddeb1a5e6d2d12deb916d27bc3506",
          "sha256": "10704a0718469ac5d0d1b0774341b0c24d9ddeb1a5e6d2d12deb916d27bc3506"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/picocom/blobs/sha256:f286430d43b8e36f2abefdf1765e960f76e2bf2c3e04f3e6fa500fa0b8dafeb2",
          "sha256": "f286430d43b8e36f2abefdf1765e960f76e2bf2c3e04f3e6fa500fa0b8dafeb2"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/picocom/blobs/sha256:ea502c2c427d1e389d7dd0822e6f01d6ac7b7eed6f856ee9f9e60fbd598ee845",
          "sha256": "ea502c2c427d1e389d7dd0822e6f01d6ac7b7eed6f856ee9f9e60fbd598ee845"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/picocom/blobs/sha256:7e0e2b6e676423624e67f67a7f509332b6aa118e860c92f32308f9399405d87c",
          "sha256": "7e0e2b6e676423624e67f67a7f509332b6aa118e860c92f32308f9399405d87c"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/picocom/blobs/sha256:0b964f92ff9ba91ad3107dc9c435de2198bf8f37f72414ec71d6f269293144a3",
          "sha256": "0b964f92ff9ba91ad3107dc9c435de2198bf8f37f72414ec71d6f269293144a3"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/picocom/blobs/sha256:bcf999f8a55184741845fe1dbab36597c3be6723f4fa4f603ee453558bfd6170",
          "sha256": "bcf999f8a55184741845fe1dbab36597c3be6723f4fa4f603ee453558bfd6170"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/picocom/blobs/sha256:dbbf7829cd18b6fc0b4cf2296de575e7399702fcad52a6da94280e30e3abc341",
          "sha256": "dbbf7829cd18b6fc0b4cf2296de575e7399702fcad52a6da94280e30e3abc341"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/picocom/blobs/sha256:c765edf56732a7dd0631c12068fd17ba7800c98ceb24f98fa65990e7fa13dadc",
          "sha256": "c765edf56732a7dd0631c12068fd17ba7800c98ceb24f98fa65990e7fa13dadc"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/picocom.rb",
  "ruby_source_checksum": {
    "sha256": "4fdd80abe5823102f0725fc7fbe696209a1b09daa69a7cd047517002bf486d68"
  },
  "date_added": "2009-12-05T16:11:12+00:00",
  "readme": "# picocom\nMinimal dumb-terminal emulator\n\nby Nick Patavalis (npat@efault.net)\n\nThe latest release can be downloaded from:\n\n> https://github.com/npat-efault/picocom/releases\n\nAs its name suggests, *picocom* is a minimal dumb-terminal emulation\nprogram. It is, in principle, very much like minicom, only it's \"pico\"\ninstead of \"mini\"!\n\nIt was designed to serve as a simple, manual, modem configuration,\ntesting, and debugging tool. It has also served (quite well) as a\nlow-tech serial communications program to allow access to all types of\ndevices that provide serial consoles. It could also prove useful in\nmany other similar tasks. It can be used in embedded systems, since\nits memory footprint is rather small (approximately 40K, when stripped\nand minimally configured).\n\n*Picocom* runs and is primarily tested on Linux. With no, or with\nminor, modifications it will run (and most of its features will work)\non any Unix-like system with a reasonably POSIX-compatible termios(3)\ninterface. Patches to support idiosyncrasies of specific Unix-like\noperating systems are very welcome.\n\nFor a description of picocom's operation, its command line options,\nand usage examples, see the manual page included in the source\ndistribution as \"picocom.1\", and also html-ized as \"picocom.1.html\".\n\nPeople who have contributed to picocom, by offering feature\nimplementations, bug-fixes, corrections, and suggestions are listed in\nthe \"CONTRIBUTORS\" file.\n\nPlease feel free to send comments, requests for new features (no\npromises, though!), bug-fixes and rants, to the author's email\naddress shown at the top of this file.\n\n## Compilation / Installation\n\nChange into picocom's source directory and say:\n\n    make\n\nThis will be enough to compile picocom for most modern Unix-like\nsystems. If you want, you can then strip the resulting binary like\nthis:\n\n    strip picocom\n\nStriping the binary is not required, it just reduces its size by a few\nkilobytes. Then you can copy the picocom binary, as well as the\nman-page, to wherever you put your binaries and man-pages. For\nexample:\n\n\n    cp picocom ~/bin\n    cp picocom.1 ~/man/man1\n\nAgain, this is not strictly necessary. You can run picocom and read\nits man-page directly from the source directory.\n\nIf something goes wrong and picocom can't compile cleanly, or if it's\nlacking a feature you need, take a look at the included Makefile. It's\nvery simple and easy to understand. It allows you to select\ncompile-time options and enable or disable some compile-time features\nby commenting in or out the respective lines. Once you edit the\nMakefile, to recompile say:\n\n\n    make clean\n    make\n\nIf your system's default make(1) command is not GNU Make (or\ncompatible enough), find out how you can run GNU Make on your\nsystem. For example:\n\n    gmake clean\n    gmake\n\nAlternatively, you might have to make some trivial edits to the\nMakefile for it to work with your system's make(1) command.\n\n## Using picocom\n\nIf your computer is a PC and has the standard on-board RS-233 ports\n(usually accessible as two male DB9 connectors at the back) then under\nLinux these are accessed through device nodes most likely named:\n`/dev/ttyS0` and `/dev/ttyS1`. If your computer has no on-board serial\nports, then you will need a USB-to-Serial adapter (or something\nsimilar). Once inserted to a USB port and recognized by Linux, a\ndevice node is created for each serial port accessed through the\nadapter(s). These nodes are most likely named `/dev/ttyUSB0`,\n`/dev/ttyUSB1`, and so on. For other systems and other Unix-like OSes\nyou will have to consult their documentation as to how the serial port\ndevice nodes are named.  Lets assume your serial port is accessed\nthrough a device node named `/dev/ttyS0`.\n\nYou can start picocom with its default option values (default serial\nport settings) like this:\n\n    picocom /dev/ttyS0\n\nIf you have not installed the picocom binary to a suitable place, then\nyou can run it directly from the source distribution directory like\nthis:\n\n    ./picocom /dev/ttyS0\n\nIf this fails with a message like:\n\n    FATAL: cannot open /dev/ttyS0: Permission denied\n\nThis means that you do not have permissions to access the serial\nport's device node. To overcome this you can run picocom as root:\n\n    sudo picocom /dev/ttyS0\n\nAlternatively, and preferably, you can add yourself to the user-group\nthat your system has for allowing access to serial ports. For most\nUnix-like systems this group is called \"dialout\". Consult you system's\ndocumentation to find out how you can do this (as it differs form\nsystem to system). On most Linux systems you can do it like this:\n\n    sudo usermod -a -G dialout username\n\nYou will need to log-out and then log-in back again for this change to\ntake effect.\n\nYou can explicitly set one or more of the serial port settings to the\ndesired values using picocom's command line options. For example, to\nset the baud-rate to 115200bps (the default is 9600bps), and enable\nhardware flow-control (RTS/CTS handshake) you can say:\n\n    picocom -b 115200 -f h /dev/ttyS0\n\nor:\n\n    picocom --baud 115200 --flow h /dev/ttyS0\n\nTo see all available options run picocom like this:\n\n    picocom --help\n\nOnce picocom starts, it initializes the serial port and prints the\nmessage:\n\n    Terminal is ready\n\nFrom now on, every character you type is sent to the serial port, and\nevery character received from the serial port is sent ro your\nterminal.  Including control and special characters. Assuming that\nthere is nothing connected to the other end of your serial port, to\nrespond to the characters you send to it (e.g. echo them back to you),\nthen nothing that you type in picocom will appear on your\nterminal. This is normal.\n\nTo exit picocom you have to type:\n\n    C-a, C-x\n\nWhich means you have to type [Control-A] followed by [Control-X]. You\ncan do this by pressing and holding down the [Control] key, then\npressing (and releasing) the [A] key and then pressing (and releasing)\nthe [X] key (while you still keep [Control] held down).\n\nThis `C-a` is called the \"escape character\". It is used to inform\npicocom that the next character typed is to be interpreted as a\ncommand to picocom itself (in this case the exit command) and not to\nbe sent-down to the serial port. There are several other commands\n(other than `C-a`, `C-x`), all prefixed by `C-a`.\n\nNext you should take a look at the very detailed picocom manual\npage. It can be accessed like this (assuming you are inside the\npicocom distribution source directory):\n\n    man ./picocom.1\n\nor (assuming you have installed the manual page to a suitable place):\n\n    man picocom\n\nThanks for using picocom\n\n## Custom Bash completion\n\nStarting with release 3.2, picocom includes support for custom\nBash-shell completion. With this you can press the [TAB] key, and the\nbash shell will complete command-line option names and values and\npropose valid selections for both. This makes the experience of using\npicocom more pleasant.\n\nCustom completion works only with recent versions of the Bash shell\n(>= 4.3). *It is in no way mandatory in order to use\npicocom*. Here's how you can enable it, if you wish.\n\nTo manually enable custom completion support you need to source the\nfile (custom completion script):\n\n    <picocom source dir>/bash_completion/picocom\n\nAssuming you are inside the picocom source directory, you can do it\nlike this:\n\n    . ./bash_completion/picocom\n\nThis will enable custom completion support for the current shell\nsession only. Use it for a while and see if you like it.\n\nTo enable support automatically for all Bash-shell sessions, you have\nthe following options:\n\n1. If you are running a relatively modern Debian or Ubuntu or other\n   Debian-based distribution, and you have package bash-completion\n   installed, you can simply copy the custom completion script to the\n   directory:\n\n       /etc/bash_completion.d/\n\n   Obviously, you need to be root to do this. Assuming you are inside\n   the picocom source directory, something like this will do it:\n\n       sudo cp ./bash_completion/picocom /etc/bash_completion.d/\n\n   This will enable custom completion support for picocom, globaly\n   (for all Bash-shell users).\n\n   *NOTICE:* If you have another version of picocom already installed,\n   there may already be a `picocom` completion script in\n   `/etc/bash_completion.d`. The command above will obviously\n   overwrite it with the new one. So be careful if this is not what\n   you want.\n\n   For other distributions and operating systems you have to check\n   their documentation to see if they provide a similar mechanism for\n   automatically sourcing custom completion scripts.\n\n2. If you want to automatically enable support *only for the current\n   user*, you must arange for your user's `.bashrc` to source the\n   custom completion script. There are, obviously, many ways to do\n   this, so the following *is only a suggestion*:\n\n   Create a directory to keep the custom completion scripts\n\n       mkdir ~/.bash_completion.d\n\n   Copy the picocom completion script to the directory you\n   created. Assuming you are inside the picocom source directory:\n\n       cp ./bash_completion/picocom ~/.bash_completion.d\n\n   Add the following (or similar) to the end of your `.bashrc`\n\n       # Source custom bash completions\n       if [ -d \"$HOME\"/.bash_completion.d ]; then\n           for c in \"$HOME\"/.bash_completion.d/*; do\n               [ -r \"$c\" ] && . \"$c\"\n           done\n       fi\n\n   From now on every new shell session you start will load (source)\n   all the custom completion scripts you have put in\n   `~/.bash_completion.d`\n\n## A low-tech terminal server\n\nYou can use *picocom* to patch-together a very simple, *very\nlow-tech*, terminal server.\n\nThe situation is like this: You have, in your lab, a box with several\nserial ports on it, where you connect the console ports of embedded\ndevices, development boards, etc. Let's call it \"termbox\". You want to\naccess these console ports remotely.\n\nIf you provide shell-access to termbox for your users, then it's as\nsimple as having the users say (from their remote workstations):\n\n    $ ssh -t user@termbox picocom -b 115200 /dev/ttyS0\n\nOr make a convenient script/alias for this. Remember the `-t` switch\nwhich instructs ssh to create a pseudo-tty, otherwise picocom won't\nwork.\n\nWhat if you *don't* want to give users shell-access to termbox? Then\nyou can use picocom in a setup like the one described below. Just\nremember, there are countless variations to this theme, the one below\nis just one of them. Also, keep in mind that some of the commands\nshown may have small differences from system to system; more so if you\ngo from Linux to other Unix-like systems.\n\nLogin to termbox and create a user called _termbox_:\n\n    $ sudo useradd -r -m termbox\n\nThe `-r` means \"system account\", and the `-m` means *do* make the\nhome-directory. Mostly we need this account's home-directory as a\nconvenient place to keep stuff; so it doesn't need a login shell or a\npassword.\n\nSwitch to the _termbox_ account and create a `bin` directory in its\nhome-dir.\n\n    $ sudo su termbox\n    $ cd ~\n    $ mkdir bin\n\nCopy the picocom binary in `~termbox/bin` (if you don't have it\nglobally installed):\n\n    $ cp /path/to/picocom ./bin\n\nFor every serial port you want to provide access to, create a file\nnamed after the port and put it in `~termbox/bin`. It should look like\nthis:\n\n    $ cat ./bin/ttyS0\n    #!/bin/sh\n    exec /home/termbox/bin/picocom \\\n      --send-cmd '' \\\n      --receive-cmd '' \\\n      -b 115200 \\\n      /dev/ttyS0\n\nAnd make it executable:\n\n    $ chmod +x ./bin/ttyS0\n\nRepeat accordingly for every other port. Now the contents of\n`~termbox/bin` should look like this:\n\n    $ ls -l ./bin\n    -rwxrwxr-x 1 termbox termbox 102128 Aug 29 13:56 picocom*\n    -rwxrwxr-x 1 termbox termbox    108 Aug 29 14:07 ttyS0*\n    -rwxrwxr-x 1 termbox termbox    108 Aug 29 14:07 ttyS1*\n    ... and so on ...\n\nExit the _termbox_ account:\n\n    $ exit\n\nNow, for every serial port, create a user account named after the\nport, like this:\n\n    $ sudo useradd -r -g dialout -d ~termbox -M -s ~termbox/bin/ttyS0 ttyS0\n\nObserve that we make `dialout` the default group for this account, so\nthe account has access to the serial ports. Also observe that we make\nthe script we just wrote (`~termbox/bin/ttyS0`) the login-shell for\nthe account. The `-d` option instructs useradd to use `/home/termbox`\nas the user's home directory, and the `-M` switch instructs it *not*\nto create the home-directory. We don't really need a home directory\nfor the _ttyS0_ account, since picocom will not read or write any\nfiles; but we provide one, regardless, because *some* systems need a\nvalid home-directory to cd-into on login (else they choke). We could\nas well have used `/` as the home directory, or we could have let\nuseradd create the usual `/home/ttyS0`.\n\nThen set a password for the newly created account:\n\n    $ sudo passwd ttyS0\n    Enter new UNIX password: ******\n    Retype new UNIX password: ******\n\nRepeat (create user account, set password) for every port you want to\ngive access to.\n\nYou 're set. All a user has to do to remotely access the console\nconnected to termbox's `/dev/ttyS0` port, is:\n\n    ssh ttyS0@termbox\n\nSome interesting points:\n\n- If the default port settings you specified as command-line arguments\n  to picocom in `~termbox/bin/ttySx` do not match the settings of the\n  device connected to the port, the user can easily change them from\n  within picocom, using picocom commands.\n\n- If a second user tries to remotely access the same port, at the same\n  time, picocom won't let him (picocom will find the port locked and\n  exit).\n\n- In the example `~termbox/bin/ttySx` scripts we have completely\n  disabled the send- and receive-file picocom commands. This\n  guarantees that picocom won't execute any external commands. If you\n  want, you can enable the commands by providing specific file-upload\n  and file-download programs as the arguments to the `--send-cmd` and\n  `--receive-cmd` picocom command-line options (provided, of-course,\n  that you trust these programs). Picocom (starting with release 2.0)\n  does not use `/bin/sh` to execute the file-upload and file-download\n  programs and *will not* let the user inject shell-commands when\n  supplying additional arguments to them.\n\n- If you allow send- and receive-file operations as described above,\n  you will, most likely, also need a way for your users to put files\n  on termbox, and get files back from it. There are many ways to\n  arrange for this, but they are beyond the scope of this simple\n  example.\n\nAgain, this is only *one* possible setup. There are countless other\nvariations and elaborations you can try. Be creative!\n\n## Some notes on custom baudrate support\n\nCustom baudrate support gives you the ability to set arbitrary\nbaudrate values (like 1234, or 42000, etc) to a serial port, provided\nthat the underlying driver can handle this. Since release 2.0, picocom\ncan be compiled with custom baudrate support for some systems. Since\nrelease 3.1 picocom is compiled with support enabled *by default* on\nsome systems (like Linux, kernels > 2.6, on x86 and x86_64, modern\nIntel Macs, and some BSDs). In any case, you can explicitly ask for\nsupport to be *enabled* by compiling picocom like this:\n\n    CPPFLAGS=-DUSE_CUSTOM_BAUD make clean\n    CPPFLAGS=-DUSE_CUSTOM_BAUD make\n\nIf custom baudrate support is not available for your system, the\ncompilation will fail. Similarly, you can ask for support to be\n*disabled* by compiling like:\n\n    CPPFLAGS=-DNO_CUSTOM_BAUD make clean\n    CPPFLAGS=-DNO_CUSTOM_BAUD make\n\n(or you can comment in or out the respective lines in the Makefile)\n\nWhen picocom is compiled with custom baudrate support *on Linux*, it\nuses a new set of ioctl's (`TCGETS2`, `TCSETSF2` vs `TCGETS`,\n`TCSETSF`, etc) to access the serial ports. It is not impossible that\nsome systems or some serial devices may not accept these new ioctl's\n(though they should). In order to be able to use picocom even in this\ncase, and without recompiling it, you can disable the custom baudrate\nsupport at runtime, and force picocom to use the \"old\" ioctls. To do\nthis (starting with release 3.2) just define the environment variable\n`NO_CUSTOM_BAUD` before running picocom. Something like this:\n\n    NO_CUSTOM_BAUD=1 picocom ...\n\nThis only applies to Linux, and to picocom binaries that have been\ncompiled with custom baudrate support.\n\nTo see if your binary has been compiled with custom baudrate support,\nand / or if it has detected the `NO_CUSTOM_BAUD` variable, run it with\nthe **--help** option, and take a look at the first few lines of\noutput."
}
