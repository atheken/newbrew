{
  "name": "simdutf",
  "full_name": "simdutf",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Unicode conversion routines, fast",
  "license": "Apache-2.0 or MIT",
  "homepage": "https://github.com/simdutf/simdutf",
  "versions": {
    "stable": "3.2.14",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/simdutf/simdutf/archive/refs/tags/v3.2.14.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "6bd6cd41e0e588312c3ae24adb297454bd9bd9622ed7443f41300d7201f233a1"
    },
    "head": {
      "url": "https://github.com/simdutf/simdutf.git",
      "branch": "master"
    }
  },
  "revision": 1,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/simdutf/blobs/sha256:64933933f84cdb4685f060b3950d8821d78a2c091ab8f1c3a8e2ea5036cc4881",
          "sha256": "64933933f84cdb4685f060b3950d8821d78a2c091ab8f1c3a8e2ea5036cc4881"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/simdutf/blobs/sha256:a126718094b9ec42eeb7eb4d38863fa1eb0e6d724f3eb3996c5bbb30daa8a9fe",
          "sha256": "a126718094b9ec42eeb7eb4d38863fa1eb0e6d724f3eb3996c5bbb30daa8a9fe"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/simdutf/blobs/sha256:8c3c74eca19712b6917a54a8fa186df4e2c0befc70b0ec7b1831084c2ff1caa2",
          "sha256": "8c3c74eca19712b6917a54a8fa186df4e2c0befc70b0ec7b1831084c2ff1caa2"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/simdutf/blobs/sha256:aaf181bc8a294cf41164422a1ff77c56530f3509a792be442a102bee15b38950",
          "sha256": "aaf181bc8a294cf41164422a1ff77c56530f3509a792be442a102bee15b38950"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/simdutf/blobs/sha256:2b2d5e8584054943669f59d480cba4a5281f58288f42918fa5a811ef3251da82",
          "sha256": "2b2d5e8584054943669f59d480cba4a5281f58288f42918fa5a811ef3251da82"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/simdutf/blobs/sha256:2807927d8f31266248795838f5efcfcb8ae4b91f485ceed6303625f0421580b1",
          "sha256": "2807927d8f31266248795838f5efcfcb8ae4b91f485ceed6303625f0421580b1"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake",
    "python@3.11"
  ],
  "dependencies": [
    "icu4c"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [
    {
      "name": "macos",
      "cask": null,
      "download": null,
      "version": "10.15",
      "contexts": [],
      "specs": [
        "stable",
        "head"
      ]
    }
  ],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/simdutf.rb",
  "ruby_source_checksum": {
    "sha256": "7dd3d9234dcbb069c37bda7769d86c836141a015edda11b14be1d535b48e29cc"
  },
  "date_added": "2023-01-07T04:57:04+00:00",
  "readme": "[![Alpine Linux](https://github.com/simdutf/simdutf/actions/workflows/alpine.yml/badge.svg)](https://github.com/lemire/simdutf/actions/workflows/alpine.yml)\n[![MSYS2-CI](https://github.com/simdutf/simdutf/actions/workflows/msys2.yml/badge.svg)](https://github.com/lemire/simdutf/actions/workflows/msys2.yml)\n[![MSYS2-CLANG-CI](https://github.com/simdutf/simdutf/actions/workflows/msys2-clang.yml/badge.svg)](https://github.com/lemire/simdutf/actions/workflows/msys2-clang.yml)\n[![Ubuntu 20.04 CI (GCC 9)](https://github.com/simdutf/simdutf/actions/workflows/ubuntu20sani.yml/badge.svg)](https://github.com/lemire/simdutf/actions/workflows/ubuntu20sani.yml)\n[![Fuzzing Status](https://oss-fuzz-build-logs.storage.googleapis.com/badges/simdutf.svg)](https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&can=1&q=proj:simdutf)\n\n# Table of contents\n\n- [Table of contents](#table-of-contents)\n- [simdutf: Unicode validation and transcoding at billions of characters per second](#simdutf-unicode-validation-and-transcoding-at-billions-of-characters-per-second)\n  - [How fast is it?](#how-fast-is-it)\n  - [Real-World Usage](#real-world-usage)\n  - [Requirements](#requirements)\n  - [Usage (Usage)](#usage-usage)\n  - [Usage (CMake)](#usage-cmake)\n  - [Single-header version](#single-header-version)\n  - [Example](#example)\n  - [API](#api)\n  - [The sutf command-line tool](#the-sutf-command-line-tool)\n  - [Manual implementation selection](#manual-implementation-selection)\n  - [References](#references)\n  - [License](#license)\n\nsimdutf: Unicode validation and transcoding at billions of characters per second\n===============================================\n\nMost modern software relies on the [Unicode standard](https://en.wikipedia.org/wiki/Unicode).\nIn memory, Unicode strings are represented using either\nUTF-8 or UTF-16. The UTF-8 format is the de facto standard on the web (JSON, HTML, etc.) and it has been adopted as the default in many popular\nprogramming languages (Go, Rust, Swift, etc.). The UTF-16 format is standard in Java, C# and in many Windows technologies.\n\nNot all sequences of bytes are valid Unicode strings. It is unsafe to use Unicode strings in UTF-8 and UTF-16LE without first validating them. Furthermore, we often need to convert strings from one encoding to another, by a process called [transcoding](https://en.wikipedia.org/wiki/Transcoding). For security purposes, such transcoding should be validating: it should refuse to transcode incorrect strings.\n\nThis library provide fast Unicode functions such as\n\n- ASCII, UTF-8, UTF-16LE/BE and UTF-32 validation, with and without error identification,\n- Latin1 to UTF-8 transcoding,\n- Latin1 to UTF-16LE/BE transcoding\n- Latin1 to UTF-32 transcoding\n- UTF-8 to Latin1 transcoding, with or without validation, with and without error identification,\n- UTF-8 to UTF-16LE/BE transcoding, with or without validation, with and without error identification,\n- UTF-8 to UTF-32 transcoding, with or without validation, with and without error identification,\n- UTF-16LE/BE to Latin1 transcoding, with or without validation, with and without error identification,\n- UTF-16LE/BE to UTF-8 transcoding, with or without validation, with and without error identification,\n- UTF-32 to Latin1 transcoding, with or without validation, with and without error identification,\n- UTF-32 to UTF-8 transcoding, with or without validation, with and without error identification,\n- UTF-32 to UTF-16LE/BE transcoding, with or without validation, with and without error identification,\n- UTF-16LE/BE to UTF-32 transcoding, with or without validation, with and without error identification,\n- From an UTF-8 string, compute the size of the Latin1 equivalent string,\n- From an UTF-8 string, compute the size of the UTF-16 equivalent string,\n- From an UTF-8 string, compute the size of the UTF-32 equivalent string (equivalent to UTF-8 character counting),\n- From an UTF-16LE/BE string, compute the size of the Latin1 equivalent string,\n- From an UTF-16LE/BE string, compute the size of the UTF-8 equivalent string,\n- From an UTF-32 string, compute the size of the UTF-8 or UTF-16LE equivalent string,\n- From an UTF-16LE/BE string, compute the size of the UTF-32 equivalent string (equivalent to UTF-16 character counting),\n- UTF-8 and UTF-16LE/BE character counting.\n- UTF-16 endianness change (UTF16-LE/BE to UTF-16-BE/LE)\n\nThe functions are accelerated using SIMD instructions (e.g., ARM NEON, SSE, AVX, AVX-512, etc.). When your strings contain hundreds of characters, we can often transcode them at speeds exceeding a billion characters per second. You should expect high speeds not only with English strings (ASCII) but also Chinese, Japanese, Arabic, and so forth. We handle the full character range (including, for example, emojis).\n\nThe library compiles down to a small library of a few hundred kilobytes. Our functions are exception-free and non allocating. We have extensive tests and extensive benchmarks.\n\nHow fast is it?\n-----------------\n\nThe adoption of the simdutf library by the popular Node.js JavaScript runtime lead to a significant\nperformance gain:\n\n> Decoding and Encoding becomes considerably faster than in Node.js 18. With the addition of simdutf for UTF-8 parsing the observed benchmark, results improved by 364% (an extremely impressive leap) when decoding in comparison to Node.js 16. ([State of Node.js Performance 2023](https://blog.rafaelgss.dev/state-of-nodejs-performance-2023))\n\n\n<img src=\"doc/node2023.png\" width=\"70%\" />\n\n\nOver a wide range of realistic data sources, the simdutf library transcodes a billion characters per second or more. Our approach can be 3 to 10 times faster than the popular ICU library on difficult (non-ASCII) strings. We can be 20x faster than ICU when processing easy strings (ASCII). Our good results apply to both recent x64 and ARM processors.\n\n\nTo illustrate, we present a benchmark result with values are in billions of characters processed by second. Consider the following figures.\n\n\n\n<img src=\"doc/utf8utf16.png\" width=\"70%\" />\n\n<img src=\"doc/utf16utf8.png\" width=\"70%\" />\n\nIf your system supports AVX-512, the simdutf library can provide very high performance. We get the following speed results on an Ice Lake Intel processor (both AVX2 and AVX-512) are simdutf kernels:\n\n<img src=\"doc/avx512.png\" width=\"70%\" />\n\n\nDatasets: https://github.com/lemire/unicode_lipsum\n\nPlease refer to our benchmarking tool for a proper interpretation of the numbers. Our results are reproducible.\n\n\nReal-World Usage\n-----\n\nThe simdutf library is used by:\n- [Node.js](https://nodejs.org/en/) (19.4.0 or better), a standard JavaScript runtime environment (e.g., `buffer.isUtf8(...)`, `buffer.isAscii(...)`, `TextDecoder` calls `simdutf`),\n- [Bun](https://bun.sh), a fast JavaScript runtime environment,\n- [haskell/text](https://github.com/haskell/text), a library for fast operations over Unicode text,\n- [klogg](https://github.com/variar/klogg), a Really fast log explorer,\n- [Pixie](https://github.com/pixie-io/pixie), observability tool for Kubernetes applications.\n\n\n\n\nRequirements\n-------\n\n- C++11 compatible compiler. We support LLVM clang, GCC, Visual Studio. (Our optional benchmark tool requires C++17.)\n- For high speed, you should have a recent 64-bit system (e.g., ARM or x64).\n- If you rely on CMake, you should use a recent CMake (at least 3.15) ; otherwise you may use the [single header version](#single-header-version). The library is also available from Microsoft's vcpkg.\n- AVX-512 support require a processor with AVX512-VBMI2 (Ice Lake or better) and a recent compiler (GCC 8 or better, Visual Studio 2019 or better, LLVM clang 6 or better). You need a correspondingly recent assembler such as gas (2.30+) or nasm (2.14+): recent compilers usually come with recent assemblers. If you mix a recent compiler with an incompatible/old assembler (e.g., when using a recent compiler with an old Linux distribution), you may get errors at build time because the compiler produces instructions that the assembler does not recognize: you should update your assembler to match your compiler (e.g., upgrade binutils to version 2.30 or better under Linux) or use an older compiler matching the capabilities of your assembler.\n\nUsage (Usage)\n-------\n\n\nWe made a video to help you get started with the library.\n\n[![the simdutf library](http://img.youtube.com/vi/H9NZtb7ykYs/0.jpg)](https://www.youtube.com/watch?v=H9NZtb7ykYs)<br />\n\n\n\nUsage (CMake)\n-------\n\n```\ncmake -B build\ncmake --build build\ncd build\nctest .\n```\n\nVisual Studio users must specify whether they want to build the Release or Debug version.\n\nTo run benchmarks, execute the `benchmark` command. You can get help on its\nusage by first building it and then calling it with the `--help` flag.\nE.g., under Linux you may do the following:\n\n```\ncmake -B build\ncmake --build build\n./build/benchmarks/benchmark --help\n```\n\nInstructions are similar for Visual Studio users.\n\nTo use the library as a CMake dependency in your project, please see `tests/installation_tests/from_fetch` for\nan example.\n\nSince ICU is so common and popular, we assume that you may have it already on your system. When\nit is not found, it is simply omitted from the benchmarks. Thus, to benchmark against ICU, make\nsure you have ICU installed on your machine and that cmake can find it. For macOS, you may\ninstall it with brew using `brew install icu4c`. If you have ICU on your system but cmake cannot\nfind it, you may need to provide cmake with a path to ICU, such as `ICU_ROOT=/usr/local/opt/icu4c cmake -B build`.\n\nSingle-header version\n----------------------\n\nYou can create a single-header version of the library where\nall of the code is put into two files (`simdutf.h` and `simdutf.cpp`).\nWe publish a zip archive containing these files, e.g., see\nhttps://github.com/simdutf/simdutf/releases/download/v3.2.15/singleheader.zip\n\nYou may generate it on your own using a Python script.\n\n```\npython3 ./singleheader/amalgamate.py\n```\n\nWe require Python 3 or better.\n\nUnder Linux and macOS, you may test it as follows:\n\n```\ncd singleheader\nc++ -o amalgamation_demo amalgamation_demo.cpp -std=c++17\n./amalgamation_demo\n```\n\nExample\n---------\n\nUsing the single-header version, you could compile the following program.\n\n```C++\n#include <iostream>\n#include <memory>\n\n#include \"simdutf.cpp\"\n#include \"simdutf.h\"\n\nint main(int argc, char *argv[]) {\n  const char *source = \"1234\";\n  // 4 == strlen(source)\n  bool validutf8 = simdutf::validate_utf8(source, 4);\n  if (validutf8) {\n    std::cout << \"valid UTF-8\" << std::endl;\n  } else {\n    std::cerr << \"invalid UTF-8\" << std::endl;\n    return EXIT_FAILURE;\n  }\n  // We need a buffer of size where to write the UTF-16LE words.\n  size_t expected_utf16words = simdutf::utf16_length_from_utf8(source, 4);\n  std::unique_ptr<char16_t[]> utf16_output{new char16_t[expected_utf16words]};\n  // convert to UTF-16LE\n  size_t utf16words =\n      simdutf::convert_utf8_to_utf16le(source, 4, utf16_output.get());\n  std::cout << \"wrote \" << utf16words << \" UTF-16LE words.\" << std::endl;\n  // It wrote utf16words * sizeof(char16_t) bytes.\n  bool validutf16 = simdutf::validate_utf16le(utf16_output.get(), utf16words);\n  if (validutf16) {\n    std::cout << \"valid UTF-16LE\" << std::endl;\n  } else {\n    std::cerr << \"invalid UTF-16LE\" << std::endl;\n    return EXIT_FAILURE;\n  }\n  // convert it back:\n  // We need a buffer of size where to write the UTF-8 words.\n  size_t expected_utf8words =\n      simdutf::utf8_length_from_utf16le(utf16_output.get(), utf16words);\n  std::unique_ptr<char[]> utf8_output{new char[expected_utf8words]};\n  // convert to UTF-8\n  size_t utf8words = simdutf::convert_utf16le_to_utf8(\n      utf16_output.get(), utf16words, utf8_output.get());\n  std::cout << \"wrote \" << utf8words << \" UTF-8 words.\" << std::endl;\n  std::string final_string(utf8_output.get(), utf8words);\n  std::cout << final_string << std::endl;\n  if (final_string != source) {\n    std::cerr << \"bad conversion\" << std::endl;\n    return EXIT_FAILURE;\n  } else {\n    std::cerr << \"perfect round trip\" << std::endl;\n  }\n  return EXIT_SUCCESS;\n}\n```\n\nAPI\n-----\n\nOur API is made of a few non-allocating function. They typically take a pointer and a length as a parameter,\nand they sometimes take a pointer to an output buffer. Users are responsible for memory allocation.\n\nWe use three types of data pointer types:\n- `char*` for UTF-8 or indeterminate Unicode formats,\n- `char16_t*` for UTF-16 (both UTF-16LE and UTF-16BE),\n- `char32_t*` for UTF-32. UTF-32 is primarily used for internal use, not data interchange. Thus, unless otherwise stated, `char32_t` refers to the native type and is typically UTF-32LE since virtually all systems are little-endian today.\n\nOur functions and declarations are all in the `simdutf` namespace. Thus you should prefix our functions\nand types with `simdutf::` as required.\n\n\nWe have basic functions to detect the type of an input. They return an integer defined by\nthe following `enum`.\n\n```c++\nenum encoding_type {\n        UTF8 = 1,       // BOM 0xef 0xbb 0xbf\n        UTF16_LE = 2,   // BOM 0xff 0xfe\n        UTF16_BE = 4,   // BOM 0xfe 0xff\n        UTF32_LE = 8,   // BOM 0xff 0xfe 0x00 0x00\n        UTF32_BE = 16,   // BOM 0x00 0x00 0xfe 0xff\n\n        unspecified = 0\n};\n```\n\n```C++\n\n/**\n * Autodetect the encoding of the input, a single encoding is recommended.\n * E.g., the function might return simdutf::encoding_type::UTF8,\n * simdutf::encoding_type::UTF16_LE, simdutf::encoding_type::UTF16_BE, or\n * simdutf::encoding_type::UTF32_LE.\n *\n * @param input the string to analyze.\n * @param length the length of the string in bytes.\n * @return the detected encoding type\n */\nsimdutf_warn_unused simdutf::encoding_type autodetect_encoding(const char * input, size_t length) noexcept;\n\n/**\n * Autodetect the possible encodings of the input in one pass.\n * E.g., if the input might be UTF-16LE or UTF-8, this function returns\n * the value (simdutf::encoding_type::UTF8 | simdutf::encoding_type::UTF16_LE).\n *\n * Overriden by each implementation.\n *\n * @param input the string to analyze.\n * @param length the length of the string in bytes.\n * @return the detected encoding type\n */\nsimdutf_warn_unused int detect_encodings(const char * input, size_t length) noexcept;\n```\n\n\n\nFor validation and transcoding, we also provide functions that will stop on error and return a result struct which is a pair of two fields:\n```c++\nstruct result {\n  error_code error; // see `struct error_code`.\n  size_t count; // In case of error, indicates the position of the error in the input.\n  // In case of success, indicates the number of words validated/written.\n};\n```\nOn error, the `error` field indicates the type of error encountered and the `position` field indicates its word position in the input string.\nWe report six types of errors related to Latin1,UTF-8, UTF-16 and UTF-32 encodings:\n```c++\nenum error_code {\n  SUCCESS = 0,\n  HEADER_BITS,  // Any byte must have fewer than 5 header bits.\n  TOO_SHORT,    // The leading byte must be followed by N-1 continuation bytes, where N is the UTF-8 character length\n                // This is also the error when the input is truncated.\n  TOO_LONG,     // We either have too many consecutive continuation bytes or the string starts with a continuation byte.\n  OVERLONG,     // The decoded character must be above U+7F for two-byte characters, U+7FF for three-byte characters,\n                // and U+FFFF for four-byte characters.\n  TOO_LARGE,    // The decoded character must be less than or equal to U+10FFFF,less than or equal than U+7F for ASCII OR less than equal than U+FF for Latin1\n  SURROGATE,    // The decoded character must be not be in U+D800...DFFF (UTF-8 or UTF-32) OR\n                // a high surrogate must be followed by a low surrogate and a low surrogate must be preceded by a high surrogate (UTF-16) OR\n                // there must be no surrogate at all (Latin1)\n  OTHER         // Not related to validation/transcoding.\n};\n\n```\nOn success, the `error` field is set to `SUCCESS` and the `position` field indicates either the number of words validated for validation functions or the number of written\nwords in the output format for transcoding functions.\n\nGenerally speaking, functions that report errors always stop soon after an error is\nencountered and might therefore be faster on inputs where an error occurs early in the input.\nThe functions that return a boolean indicating whether or not an error has been encountered\nare meant to be used in an *optimistic setting*---when we expect that inputs will almost always\nbe correct.\n\nWe have fast validation functions.\n\n```c++\n/**\n * Validate the ASCII string.\n *\n * Overridden by each implementation.\n *\n * @param buf the ASCII string to validate.\n * @param len the length of the string in bytes.\n * @return true if and only if the string is valid ASCII.\n */\nsimdutf_warn_unused bool validate_ascii(const char *buf, size_t len) noexcept;\n\n/**\n * Validate the ASCII string and stop on error.\n *\n * Overridden by each implementation.\n *\n * @param buf the ASCII string to validate.\n * @param len the length of the string in bytes.\n * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.\n */\nsimdutf_warn_unused result validate_ascii_with_errors(const char *buf, size_t len) noexcept;\n\n/**\n * Validate the UTF-8 string. This function may be best when you expect\n * the input to be almost always valid. Otherwise, consider using\n * validate_utf8_with_errors.\n *\n * Overridden by each implementation.\n *\n * @param buf the UTF-8 string to validate.\n * @param len the length of the string in bytes.\n * @return true if and only if the string is valid UTF-8.\n */\nsimdutf_warn_unused bool validate_utf8(const char *buf, size_t len) noexcept;\n\n/**\n * Validate the UTF-8 string and stop on error. It might be faster than\n * validate_utf8 when an error is expected to occur early.\n *\n * Overridden by each implementation.\n *\n * @param buf the UTF-8 string to validate.\n * @param len the length of the string in bytes.\n * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.\n */\nsimdutf_warn_unused result validate_utf8_with_errors(const char *buf, size_t len) noexcept;\n\n/**\n * Using native endianness; Validate the UTF-16 string.\n * This function may be best when you expect the input to be almost always valid.\n * Otherwise, consider using validate_utf16_with_errors.\n *\n * Overridden by each implementation.\n *\n * This function is not BOM-aware.\n *\n * @param buf the UTF-16 string to validate.\n * @param len the length of the string in number of 2-byte words (char16_t).\n * @return true if and only if the string is valid UTF-16.\n */\nsimdutf_warn_unused bool validate_utf16(const char16_t *buf, size_t len) noexcept;\n\n/**\n * Validate the UTF-16LE string. This function may be best when you expect\n * the input to be almost always valid. Otherwise, consider using\n * validate_utf16le_with_errors.\n *\n * Overridden by each implementation.\n *\n * This function is not BOM-aware.\n *\n * @param buf the UTF-16LE string to validate.\n * @param len the length of the string in number of 2-byte words (char16_t).\n * @return true if and only if the string is valid UTF-16LE.\n */\nsimdutf_warn_unused bool validate_utf16le(const char16_t *buf, size_t len) noexcept;\n\n/**\n * Validate the UTF-16BE string. This function may be best when you expect\n * the input to be almost always valid. Otherwise, consider using\n * validate_utf16be_with_errors.\n *\n * Overridden by each implementation.\n *\n * This function is not BOM-aware.\n *\n * @param buf the UTF-16BE string to validate.\n * @param len the length of the string in number of 2-byte words (char16_t).\n * @return true if and only if the string is valid UTF-16BE.\n */\nsimdutf_warn_unused bool validate_utf16be(const char16_t *buf, size_t len) noexcept;\n\n/**\n * Using native endianness; Validate the UTF-16 string and stop on error.\n * It might be faster than validate_utf16 when an error is expected to occur early.\n *\n * Overridden by each implementation.\n *\n * This function is not BOM-aware.\n *\n * @param buf the UTF-16 string to validate.\n * @param len the length of the string in number of 2-byte words (char16_t).\n * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.\n */\nsimdutf_warn_unused result validate_utf16_with_errors(const char16_t *buf, size_t len) noexcept;\n\n/**\n * Validate the UTF-16LE string and stop on error. It might be faster than\n * validate_utf16le when an error is expected to occur early.\n *\n * Overridden by each implementation.\n *\n * This function is not BOM-aware.\n *\n * @param buf the UTF-16LE string to validate.\n * @param len the length of the string in number of 2-byte words (char16_t).\n * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.\n */\nsimdutf_warn_unused result validate_utf16le_with_errors(const char16_t *buf, size_t len) noexcept;\n\n/**\n * Validate the UTF-16BE string and stop on error. It might be faster than\n * validate_utf16be when an error is expected to occur early.\n *\n * Overridden by each implementation.\n *\n * This function is not BOM-aware.\n *\n * @param buf the UTF-16BE string to validate.\n * @param len the length of the string in number of 2-byte words (char16_t).\n * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.\n */\nsimdutf_warn_unused result validate_utf16be_with_errors(const char16_t *buf, size_t len) noexcept;\n\n/**\n * Validate the UTF-32 string.\n *\n * Overridden by each implementation.\n *\n * This function is not BOM-aware.\n *\n * @param buf the UTF-32 string to validate.\n * @param len the length of the string in number of 4-byte words (char32_t).\n * @return true if and only if the string is valid UTF-32.\n */\nsimdutf_warn_unused bool validate_utf32(const char32_t *buf, size_t len) noexcept;\n\n/**\n * Validate the UTF-32 string and stop on error.\n *\n * Overridden by each implementation.\n *\n * This function is not BOM-aware.\n *\n * @param buf the UTF-32 string to validate.\n * @param len the length of the string in number of 4-byte words (char32_t).\n * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.\n */\nsimdutf_warn_unused result validate_utf32_with_errors(const char32_t *buf, size_t len) noexcept;\n\n```\n\nGiven a valid UTF-8 or UTF-16 input, you may count the number Unicode characters using\nfast functions. For UTF-32, there is no need for a function given that each character\nrequires a flat 4 bytes. Likewise for Latin1: one byte will always equal one character.\n\n```c++\n/**\n * Count the number of code points (characters) in the string assuming that\n * it is valid.\n *\n * This function assumes that the input string is valid UTF-16 (native endianness).\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-16 string to process\n * @param length        the length of the string in 2-byte words (char16_t)\n * @return number of code points\n */\nsimdutf_warn_unused size_t count_utf16(const char16_t * input, size_t length) noexcept;\n\n/**\n * Count the number of code points (characters) in the string assuming that\n * it is valid.\n *\n * This function assumes that the input string is valid UTF-16LE.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-16LE string to process\n * @param length        the length of the string in 2-byte words (char16_t)\n * @return number of code points\n */\nsimdutf_warn_unused size_t count_utf16le(const char16_t * input, size_t length) noexcept;\n\n/**\n * Count the number of code points (characters) in the string assuming that\n * it is valid.\n *\n * This function assumes that the input string is valid UTF-16BE.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-16BE string to process\n * @param length        the length of the string in 2-byte words (char16_t)\n * @return number of code points\n */\nsimdutf_warn_unused size_t count_utf16be(const char16_t * input, size_t length) noexcept;\n\n/**\n * Count the number of code points (characters) in the string assuming that\n * it is valid.\n *\n * This function assumes that the input string is valid UTF-8.\n *\n * @param input         the UTF-8 string to process\n * @param length        the length of the string in bytes\n * @return number of code points\n */\nsimdutf_warn_unused size_t count_utf8(const char * input, size_t length) noexcept;\n\n```\n\nPrior to transcoding an input, you need to allocate enough memory to receive the result.\nWe have fast function that scan the input and compute the size of the output. These functions\nare fast and non-validating.\n\n\n\n```c++\n\n /**\n   * Return the number of bytes that this Latin1 string would require in UTF-8 format.\n   *\n   * @param input         the Latin1 string to convert\n   * @param length        the length of the string bytes\n   * @return the number of bytes required to encode the Latin1 string as UTF-8\n   */\n    simdutf_warn_unused size_t utf8_length_from_latin1(const char * input, size_t length) noexcept;\n\n  /**\n   * Compute the number of bytes that this UTF-8 string would require in Latin1 format.\n   *\n   * This function does not validate the input.\n   *\n   * This function is not BOM-aware.\n   *\n   * @param input         the UTF-8 string to convert\n   * @param length        the length of the string in byte\n   * @return the number of bytes required to encode the UTF-8 string as Latin1\n   */\n    simdutf_warn_unused size_t latin1_length_from_utf8(const char * input, size_t length) noexcept;\n\n/*\n   * Compute the number of bytes that this UTF-16LE/BE string would require in Latin1 format.\n   *\n   * This function does not validate the input.\n   *\n   * This function is not BOM-aware.\n   *\n   * @param input         the UTF-16LE string to convert\n   * @param length        the length of the string in 2-byte words (char16_t)\n   * @return the number of bytes required to encode the UTF-16LE string as Latin1\n   */\n  simdutf_warn_unused size_t latin1_length_from_utf16(size_t length) noexcept;\n\n  /**\n   * Compute the number of bytes that this UTF-32 string would require in Latin1 format.\n   *\n   * This function does not validate the input.\n   *\n   * This function is not BOM-aware.\n   *\n   * @param input         the UTF-32 string to convert\n   * @param length        the length of the string in 4-byte words (char32_t)\n   * @return the number of bytes required to encode the UTF-32 string as Latin1\n   */\n    simdutf_warn_unused size_t latin1_length_from_utf32( size_t length) noexcept;\n\n/**\n * Compute the number of 2-byte words that this UTF-8 string would require in UTF-16 format.\n *\n * This function does not validate the input.\n *\n * @param input         the UTF-8 string to process\n * @param length        the length of the string in bytes\n * @return the number of char16_t words required to encode the UTF-8 string as UTF-16\n */\nsimdutf_warn_unused size_t utf16_length_from_utf8(const char * input, size_t length) noexcept;\n\n\n/**\n * Compute the number of 4-byte words that this UTF-8 string would require in UTF-32 format.\n *\n * This function is equivalent to count_utf8\n *\n * This function does not validate the input.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-8 string to process\n * @param length        the length of the string in bytes\n * @return the number of char32_t words required to encode the UTF-8 string as UTF-32\n */\nsimdutf_warn_unused size_t utf32_length_from_utf8(const char * input, size_t length) noexcept;\n\n/**\n * Using native endianness; Compute the number of bytes that this UTF-16\n * string would require in UTF-8 format.\n *\n * This function does not validate the input.\n *\n * @param input         the UTF-16 string to convert\n * @param length        the length of the string in 2-byte words (char16_t)\n * @return the number of bytes required to encode the UTF-16LE string as UTF-8\n */\nsimdutf_warn_unused size_t utf8_length_from_utf16(const char16_t * input, size_t length) noexcept;\n\n/**\n * Compute the number of bytes that this UTF-16LE string would require in UTF-8 format.\n *\n * This function does not validate the input.\n *\n * @param input         the UTF-16LE string to convert\n * @param length        the length of the string in 2-byte words (char16_t)\n * @return the number of bytes required to encode the UTF-16LE string as UTF-8\n */\nsimdutf_warn_unused size_t utf8_length_from_utf16le(const char16_t * input, size_t length) noexcept;\n\n/**\n * Compute the number of bytes that this UTF-16BE string would require in UTF-8 format.\n *\n * This function does not validate the input.\n *\n * @param input         the UTF-16BE string to convert\n * @param length        the length of the string in 2-byte words (char16_t)\n * @return the number of bytes required to encode the UTF-16BE string as UTF-8\n */\nsimdutf_warn_unused size_t utf8_length_from_utf16be(const char16_t * input, size_t length) noexcept;\n\n/**\n * Compute the number of bytes that this UTF-32 string would require in UTF-8 format.\n *\n * This function does not validate the input.\n *\n * @param input         the UTF-32 string to convert\n * @param length        the length of the string in 4-byte words (char32_t)\n * @return the number of bytes required to encode the UTF-32 string as UTF-8\n */\nsimdutf_warn_unused size_t utf8_length_from_utf32(const char32_t * input, size_t length) noexcept;\n\n/**\n * Compute the number of two-byte words that this UTF-32 string would require in UTF-16 format.\n *\n * This function does not validate the input.\n *\n * @param input         the UTF-32 string to convert\n * @param length        the length of the string in 4-byte words (char32_t)\n * @return the number of bytes required to encode the UTF-32 string as UTF-16\n */\nsimdutf_warn_unused size_t utf16_length_from_utf32(const char32_t * input, size_t length) noexcept;\n\n/**\n * Using native endianness; Compute the number of bytes that this UTF-16\n * string would require in UTF-32 format.\n *\n * This function is equivalent to count_utf16.\n *\n * This function does not validate the input.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-16 string to convert\n * @param length        the length of the string in 2-byte words (char16_t)\n * @return the number of bytes required to encode the UTF-16LE string as UTF-32\n */\nsimdutf_warn_unused size_t utf32_length_from_utf16(const char16_t * input, size_t length) noexcept;\n\n/**\n * Compute the number of bytes that this UTF-16LE string would require in UTF-32 format.\n *\n * This function is equivalent to count_utf16le.\n *\n * This function does not validate the input.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-16LE string to convert\n * @param length        the length of the string in 2-byte words (char16_t)\n * @return the number of bytes required to encode the UTF-16LE string as UTF-32\n */\nsimdutf_warn_unused size_t utf32_length_from_utf16le(const char16_t * input, size_t length) noexcept;\n\n/**\n * Compute the number of bytes that this UTF-16BE string would require in UTF-32 format.\n *\n * This function is equivalent to count_utf16be.\n *\n * This function does not validate the input.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-16BE string to convert\n * @param length        the length of the string in 2-byte words (char16_t)\n * @return the number of bytes required to encode the UTF-16BE string as UTF-32\n */\nsimdutf_warn_unused size_t utf32_length_from_utf16be(const char16_t * input, size_t length) noexcept;\n```\n\n\n\nWe have a wide range of conversion between Latin1, UTF-8, UTF-16 and UTF-32. They assume\nthat you are allocated sufficient memory for the input. The simplest conversin\nfunction output a single integer representing the size of the input, with a value of zero\nindicating an error (e.g., `convert_utf8_to_utf16le`). They are well suited in the\nscenario where you expect the input to be valid most of the time.\n\n\n\n```c++\n\n  /**\n   * Convert Latin1 string into UTF8 string.\n   *\n   * This function is suitable to work with inputs from untrusted sources.\n   *\n   * @param input         the Latin1 string to convert\n   * @param length        the length of the string in bytes\n   * @param latin1_output  the pointer to buffer that can hold conversion result\n   * @return the number of written char; 0 if conversion is not possible\n   */\n  simdutf_warn_unused size_t convert_latin1_to_utf8(const char * input, size_t length, char* utf8_output) noexcept;\n\n\n    /**\n   * Convert possibly Latin1 string into UTF-16LE string.\n   *\n   * This function is suitable to work with inputs from untrusted sources.\n   *\n   * @param input         the Latin1  string to convert\n   * @param length        the length of the string in bytes\n   * @param utf16_buffer  the pointer to buffer that can hold conversion result\n   * @return the number of written char16_t; 0 if conversion is not possible\n   */\n  simdutf_warn_unused size_t convert_latin1_to_utf16le(const char * input, size_t length, char16_t* utf16_output) noexcept;\n\n  /**\n   * Convert Latin1 string into UTF-16BE string.\n   *\n   * This function is suitable to work with inputs from untrusted sources.\n   *\n   * @param input         the Latin1 string to convert\n   * @param length        the length of the string in bytes\n   * @param utf16_buffer  the pointer to buffer that can hold conversion result\n   * @return the number of written char16_t; 0 if conversion is not possible\n   */\n  simdutf_warn_unused size_t convert_latin1_to_utf16be(const char * input, size_t length, char16_t* utf16_output) noexcept;\n\n  /**\n   * Convert Latin1 string into UTF-32 string.\n   *\n   * This function is suitable to work with inputs from untrusted sources.\n   *\n   * @param input         the Latin1 string to convert\n   * @param length        the length of the string in bytes\n   * @param utf32_buffer  the pointer to buffer that can hold conversion result\n   * @return the number of written char32_t; 0 if conversion is not possible\n   */\n  simdutf_warn_unused size_t convert_latin1_to_utf32(const char * input, size_t length, char32_t* utf32_buffer) noexcept;\n\n /**\n   * Convert possibly broken UTF-8 string into latin1 string.\n   *\n   * During the conversion also validation of the input string is done.\n   * This function is suitable to work with inputs from untrusted sources.\n   *\n   * @param input         the UTF-8 string to convert\n   * @param length        the length of the string in bytes\n   * @param latin1_output  the pointer to buffer that can hold conversion result\n   * @return the number of written char; 0 if the input was not valid UTF-8 string\n   */\n  simdutf_warn_unused size_t convert_utf8_to_latin1(const char * input, size_t length, char* latin1_output) noexcept;\n\n/**\n * Using native endianness; Convert possibly broken UTF-8 string into UTF-16 string.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * @param input         the UTF-8 string to convert\n * @param length        the length of the string in bytes\n * @param utf16_buffer  the pointer to buffer that can hold conversion result\n * @return the number of written char16_t; 0 if the input was not valid UTF-8 string\n */\nsimdutf_warn_unused size_t convert_utf8_to_utf16(const char * input, size_t length, char16_t* utf16_output) noexcept;\n\n/**\n * Convert possibly broken UTF-8 string into UTF-16LE string.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * @param input         the UTF-8 string to convert\n * @param length        the length of the string in bytes\n * @param utf16_buffer  the pointer to buffer that can hold conversion result\n * @return the number of written char16_t; 0 if the input was not valid UTF-8 string\n */\nsimdutf_warn_unused size_t convert_utf8_to_utf16le(const char * input, size_t length, char16_t* utf16_output) noexcept;\n\n/**\n * Convert possibly broken UTF-8 string into UTF-16BE string.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * @param input         the UTF-8 string to convert\n * @param length        the length of the string in bytes\n * @param utf16_buffer  the pointer to buffer that can hold conversion result\n * @return the number of written char16_t; 0 if the input was not valid UTF-8 string\n */\nsimdutf_warn_unused size_t convert_utf8_to_utf16be(const char * input, size_t length, char16_t* utf16_output) noexcept;\n\n/**\n * Convert possibly broken UTF-8 string into UTF-32 string.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * @param input         the UTF-8 string to convert\n * @param length        the length of the string in bytes\n * @param utf32_buffer  the pointer to buffer that can hold conversion result\n * @return the number of written char32_t; 0 if the input was not valid UTF-8 string\n */\nsimdutf_warn_unused size_t convert_utf8_to_utf32(const char * input, size_t length, char32_t* utf32_output) noexcept;\n\n\n  /**\n   * Convert possibly broken UTF-16LE string into Latin1 string.\n   *\n   * During the conversion also validation of the input string is done.\n   * This function is suitable to work with inputs from untrusted sources.\n   *\n   * This function is not BOM-aware.\n   *\n   * @param input         the UTF-16LE string to convert\n   * @param length        the length of the string in 2-byte words (char16_t)\n   * @param latin1_buffer   the pointer to buffer that can hold conversion result\n   * @return number of written words; 0 if input is not a valid UTF-16LE string\n   */\n  simdutf_warn_unused size_t convert_utf16le_to_latin1(const char16_t * input, size_t length, char* latin1_buffer) noexcept;\n\n  /**\n   * Convert possibly broken UTF-16BE string into Latin1 string.\n   *\n   * During the conversion also validation of the input string is done.\n   * This function is suitable to work with inputs from untrusted sources.\n   *\n   * This function is not BOM-aware.\n   *\n   * @param input         the UTF-16BE string to convert\n   * @param length        the length of the string in 2-byte words (char16_t)\n   * @param latin1_buffer   the pointer to buffer that can hold conversion result\n   * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.\n   */\n  simdutf_warn_unused size_t convert_utf16be_to_latin1(const char16_t * input, size_t length, char* latin1_buffer) noexcept;\n\n/**\n * Convert possibly broken UTF-16LE string into UTF-8 string.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-16LE string to convert\n * @param length        the length of the string in 2-byte words (char16_t)\n * @param utf8_buffer   the pointer to buffer that can hold conversion result\n * @return number of written words; 0 if input is not a valid UTF-16LE string\n */\nsimdutf_warn_unused size_t convert_utf16le_to_utf8(const char16_t * input, size_t length, char* utf8_buffer) noexcept;\n\n/**\n * Convert possibly broken UTF-16BE string into UTF-8 string.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-16BE string to convert\n * @param length        the length of the string in 2-byte words (char16_t)\n * @param utf8_buffer   the pointer to buffer that can hold conversion result\n * @return number of written words; 0 if input is not a valid UTF-16LE string\n */\nsimdutf_warn_unused size_t convert_utf16be_to_utf8(const char16_t * input, size_t length, char* utf8_buffer) noexcept;\n\n\n  /**\n   * Convert possibly broken UTF-32 string into Latin1 string.\n   *\n   * During the conversion also validation of the input string is done.\n   * This function is suitable to work with inputs from untrusted sources.\n   *\n   * This function is not BOM-aware.\n   *\n   * @param input         the UTF-32 string to convert\n   * @param length        the length of the string in 4-byte words (char32_t)\n   * @param latin1_buffer   the pointer to buffer that can hold conversion result\n   * @return number of written words; 0 if input is not a valid UTF-32 string\n   */\n\n  simdutf_warn_unused size_t convert_utf32_to_latin1(const char32_t * input, size_t length, char* latin1_buffer) noexcept;\n\n/**\n * Convert possibly broken UTF-32 string into UTF-8 string.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-32 string to convert\n * @param length        the length of the string in 4-byte words (char32_t)\n * @param utf8_buffer   the pointer to buffer that can hold conversion result\n * @return number of written words; 0 if input is not a valid UTF-32 string\n */\nsimdutf_warn_unused size_t convert_utf32_to_utf8(const char32_t * input, size_t length, char* utf8_buffer) noexcept;\n\n/**\n * Using native endianness; Convert possibly broken UTF-32 string into UTF-16 string.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-32 string to convert\n * @param length        the length of the string in 4-byte words (char32_t)\n * @param utf16_buffer   the pointer to buffer that can hold conversion result\n * @return number of written words; 0 if input is not a valid UTF-32 string\n */\nsimdutf_warn_unused size_t convert_utf32_to_utf16(const char32_t * input, size_t length, char16_t* utf16_buffer) noexcept;\n\n/**\n * Convert possibly broken UTF-32 string into UTF-16LE string.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-32 string to convert\n * @param length        the length of the string in 4-byte words (char32_t)\n * @param utf16_buffer   the pointer to buffer that can hold conversion result\n * @return number of written words; 0 if input is not a valid UTF-32 string\n */\nsimdutf_warn_unused size_t convert_utf32_to_utf16le(const char32_t * input, size_t length, char16_t* utf16_buffer) noexcept;\n\n/**\n * Convert possibly broken UTF-32 string into UTF-16BE string.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-32 string to convert\n * @param length        the length of the string in 4-byte words (char32_t)\n * @param utf16_buffer   the pointer to buffer that can hold conversion result\n * @return number of written words; 0 if input is not a valid UTF-32 string\n */\nsimdutf_warn_unused size_t convert_utf32_to_utf16be(const char32_t * input, size_t length, char16_t* utf16_buffer) noexcept;\n\n/**\n * Using native endianness; Convert possibly broken UTF-16 string into UTF-32 string.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-16 string to convert\n * @param length        the length of the string in 2-byte words (char16_t)\n * @param utf32_buffer   the pointer to buffer that can hold conversion result\n * @return number of written words; 0 if input is not a valid UTF-16LE string\n */\nsimdutf_warn_unused size_t convert_utf16_to_utf32(const char16_t * input, size_t length, char32_t* utf32_buffer) noexcept;\n\n/**\n * Convert possibly broken UTF-16LE string into UTF-32 string.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-16LE string to convert\n * @param length        the length of the string in 2-byte words (char16_t)\n * @param utf32_buffer   the pointer to buffer that can hold conversion result\n * @return number of written words; 0 if input is not a valid UTF-16LE string\n */\nsimdutf_warn_unused size_t convert_utf16le_to_utf32(const char16_t * input, size_t length, char32_t* utf32_buffer) noexcept;\n\n/**\n * Convert possibly broken UTF-16BE string into UTF-32 string.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-16BE string to convert\n * @param length        the length of the string in 2-byte words (char16_t)\n * @param utf32_buffer   the pointer to buffer that can hold conversion result\n * @return number of written words; 0 if input is not a valid UTF-16LE string\n */\nsimdutf_warn_unused size_t convert_utf16be_to_utf32(const char16_t * input, size_t length, char32_t* utf32_buffer) noexcept;\n```\n\nWe have more advanced conversion functions which output a `simdutf::result` structure with\nan indication of the error type and a `count` entry (e.g., `convert_utf8_to_utf16le_with_errors`).\nThey are well suited when you expect that there might be errors in the input that require\nfurther investigation.\n\n```c++\n\n  /**\n   * Convert possibly broken UTF-8 string into latin1 string. with errors\n   *\n   * During the conversion also validation of the input string is done.\n   * This function is suitable to work with inputs from untrusted sources.\n   *\n   * @param input         the UTF-8 string to convert\n   * @param length        the length of the string in bytes\n   * @param latin1_output  the pointer to buffer that can hold conversion result\n   * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.\n   */\n  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(const char * input, size_t length, char* latin1_output) noexcept;\n\n  /**\n   * Convert possibly broken UTF-16LE string into Latin1 string.\n   *\n   * During the conversion also validation of the input string is done.\n   * This function is suitable to work with inputs from untrusted sources.\n   * This function is not BOM-aware.\n   *\n   * @param input         the UTF-16LE string to convert\n   * @param length        the length of the string in 2-byte words (char16_t)\n   * @param latin1_buffer   the pointer to buffer that can hold conversion result\n   * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.\n   */\n  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(const char16_t * input, size_t length, char* latin1_buffer) noexcept;\n\n  /**\n   * Convert possibly broken UTF-16BE string into Latin1 string.\n   *\n   * During the conversion also validation of the input string is done.\n   * This function is suitable to work with inputs from untrusted sources.\n   * This function is not BOM-aware.\n   *\n   * @param input         the UTF-16BE string to convert\n   * @param length        the length of the string in 2-byte words (char16_t)\n   * @param latin1_buffer   the pointer to buffer that can hold conversion result\n   * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.\n   */\n  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(const char16_t * input, size_t length, char* latin1_buffer) noexcept;\n\n\n/**\n * Using native endianness; Convert possibly broken UTF-8 string into UTF-16\n * string and stop on error.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * @param input         the UTF-8 string to convert\n * @param length        the length of the string in bytes\n * @param utf16_buffer  the pointer to buffer that can hold conversion result\n * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.\n */\nsimdutf_warn_unused result convert_utf8_to_utf16_with_errors(const char * input, size_t length, char16_t* utf16_output) noexcept;\n\n/**\n * Convert possibly broken UTF-8 string into UTF-16LE string and stop on error.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * @param input         the UTF-8 string to convert\n * @param length        the length of the string in bytes\n * @param utf16_buffer  the pointer to buffer that can hold conversion result\n * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.\n */\nsimdutf_warn_unused result convert_utf8_to_utf16le_with_errors(const char * input, size_t length, char16_t* utf16_output) noexcept;\n\n/**\n * Convert possibly broken UTF-8 string into UTF-16BE string and stop on error.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * @param input         the UTF-8 string to convert\n * @param length        the length of the string in bytes\n * @param utf16_buffer  the pointer to buffer that can hold conversion result\n * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.\n */\nsimdutf_warn_unused result convert_utf8_to_utf16be_with_errors(const char * input, size_t length, char16_t* utf16_output) noexcept;\n\n/**\n * Convert possibly broken UTF-8 string into UTF-32 string and stop on error.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * @param input         the UTF-8 string to convert\n * @param length        the length of the string in bytes\n * @param utf32_buffer  the pointer to buffer that can hold conversion result\n * @return a result pair struct with an error code and either the position of the error if any or the number of char32_t written if successful.\n */\nsimdutf_warn_unused result convert_utf8_to_utf32_with_errors(const char * input, size_t length, char32_t* utf32_output) noexcept;\n\n\n/**\n * Convert possibly broken UTF-16LE string into UTF-8 string and stop on error.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-16LE string to convert\n * @param length        the length of the string in 2-byte words (char16_t)\n * @param utf8_buffer   the pointer to buffer that can hold conversion result\n * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.\n */\nsimdutf_warn_unused result convert_utf16le_to_utf8_with_errors(const char16_t * input, size_t length, char* utf8_buffer) noexcept;\n\n/**\n * Convert possibly broken UTF-16BE string into UTF-8 string and stop on error.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-16BE string to convert\n * @param length        the length of the string in 2-byte words (char16_t)\n * @param utf8_buffer   the pointer to buffer that can hold conversion result\n * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.\n */\nsimdutf_warn_unused result convert_utf16be_to_utf8_with_errors(const char16_t * input, size_t length, char* utf8_buffer) noexcept;\n\n\n  /**\n   * Convert possibly broken UTF-32 string into Latin1 string and stop on error.\n   *\n   * During the conversion also validation of the input string is done.\n   * This function is suitable to work with inputs from untrusted sources.\n   *\n   * This function is not BOM-aware.\n   *\n   * @param input         the UTF-32 string to convert\n   * @param length        the length of the string in 4-byte words (char32_t)\n   * @param latin1_buffer   the pointer to buffer that can hold conversion result\n   * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.\n   */\n\n  simdutf_warn_unused result convert_utf32_to_latin1_with_errors(const char32_t * input, size_t length, char* latin1_buffer) noexcept;\n\n\n/**\n * Convert possibly broken UTF-32 string into UTF-8 string and stop on error.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-32 string to convert\n * @param length        the length of the string in 4-byte words (char32_t)\n * @param utf8_buffer   the pointer to buffer that can hold conversion result\n * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.\n */\nsimdutf_warn_unused result convert_utf32_to_utf8_with_errors(const char32_t * input, size_t length, char* utf8_buffer) noexcept;\n\n/**\n * Using native endianness; Convert possibly broken UTF-32 string into UTF-16\n * string and stop on error.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-32 string to convert\n * @param length        the length of the string in 4-byte words (char32_t)\n * @param utf16_buffer   the pointer to buffer that can hold conversion result\n * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.\n */\nsimdutf_warn_unused result convert_utf32_to_utf16_with_errors(const char32_t * input, size_t length, char16_t* utf16_buffer) noexcept;\n\n/**\n * Convert possibly broken UTF-32 string into UTF-16LE string and stop on error.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-32 string to convert\n * @param length        the length of the string in 4-byte words (char32_t)\n * @param utf16_buffer   the pointer to buffer that can hold conversion result\n * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.\n */\nsimdutf_warn_unused result convert_utf32_to_utf16le_with_errors(const char32_t * input, size_t length, char16_t* utf16_buffer) noexcept;\n\n/**\n * Convert possibly broken UTF-32 string into UTF-16BE string and stop on error.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-32 string to convert\n * @param length        the length of the string in 4-byte words (char32_t)\n * @param utf16_buffer   the pointer to buffer that can hold conversion result\n * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.\n */\nsimdutf_warn_unused result convert_utf32_to_utf16be_with_errors(const char32_t * input, size_t length, char16_t* utf16_buffer) noexcept;\n\n/**\n * Using native endianness; Convert possibly broken UTF-16 string into\n * UTF-32 string and stop on error.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-16 string to convert\n * @param length        the length of the string in 2-byte words (char16_t)\n * @param utf32_buffer   the pointer to buffer that can hold conversion result\n * @return a result pair struct with an error code and either the position of the error if any or the number of char32_t written if successful.\n */\nsimdutf_warn_unused result convert_utf16_to_utf32_with_errors(const char16_t * input, size_t length, char32_t* utf32_buffer) noexcept;\n\n/**\n * Convert possibly broken UTF-16LE string into UTF-32 string and stop on error.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-16LE string to convert\n * @param length        the length of the string in 2-byte words (char16_t)\n * @param utf32_buffer   the pointer to buffer that can hold conversion result\n * @return a result pair struct with an error code and either the position of the error if any or the number of char32_t written if successful.\n */\nsimdutf_warn_unused result convert_utf16le_to_utf32_with_errors(const char16_t * input, size_t length, char32_t* utf32_buffer) noexcept;\n\n/**\n * Convert possibly broken UTF-16BE string into UTF-32 string and stop on error.\n *\n * During the conversion also validation of the input string is done.\n * This function is suitable to work with inputs from untrusted sources.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-16BE string to convert\n * @param length        the length of the string in 2-byte words (char16_t)\n * @param utf32_buffer   the pointer to buffer that can hold conversion result\n * @return a result pair struct with an error code and either the position of the error if any or the number of char32_t written if successful.\n */\nsimdutf_warn_unused result convert_utf16be_to_utf32_with_errors(const char16_t * input, size_t length, char32_t* utf32_buffer) noexcept;\n\n```\n\nIf you have a UTF-16 input, you may change its endianess with a fast function.\n\n```c++\n/**\n * Change the endianness of the input. Can be used to go from UTF-16LE to UTF-16BE or\n * from UTF-16BE to UTF-16LE.\n *\n * This function does not validate the input.\n *\n * This function is not BOM-aware.\n *\n * @param input         the UTF-16 string to process\n * @param length        the length of the string in 2-byte words (char16_t)\n * @param output        the pointer to buffer that can hold the conversion result\n */\nvoid change_endianness_utf16(const char16_t * input, size_t length, char16_t * output) noexcept;\n\n```\n\n\nThe sutf command-line tool\n------\nWe also provide a command-line tool which can be build as follows:\n```\ncmake -B build && cmake --build build --target sutf\n```\nThis command builds the executable in `./build/tool/` under most platforms. The sutf tool enables the user to easily transcode files from one encoding to another directly from the command line.\nThe usage is similar to [iconv](https://www.gnu.org/software/libiconv/) (see `sutf --help` for more details). The sutf command-line tool relies on the simdutf library functions for fast transcoding of supported\nformats (UTF-8, UTF-16LE, UTF-16BE and UTF-32). If iconv is found on the system and simdutf does not support a conversion, the sutf tool falls back on iconv: a message lets the user know if iconv is available\nduring compilation. The following is an example of transcoding two input files to an output file, from UTF-8 to UTF-16LE:\n```\nsutf -f UTF-8 -t UTF-16LE -o output_file.txt first_input_file.txt second_input_file.txt\n```\n\nManual implementation selection\n-------------------------------\n\nWhen compiling the llibrary for x64 processors, we build several implementations of each functions. At runtime, the best\nimplementation is picked automatically. Advanced users may want to pick a particular implementation, thus bypassing our\nruntime detection. It is possible and even relatively convenient to do so. The following C++ program checks all the available\nimplementation, and selects one as the default:\n\n```C++\n#include \"simdutf.h\"\n#include <cstdlib>\n#include <iostream>\n#include <string>\n\nint main() {\n  // This is just a demonstration, not actual testing required.\n  std::string source = \"La vie est belle.\";\n  std::string chosen_implementation;\n  for (auto &implementation : simdutf::get_available_implementations()) {\n    if (!implementation->supported_by_runtime_system()) {\n      continue;\n    }\n    bool validutf8 = implementation->validate_utf8(source.c_str(), source.size());\n    if (!validutf8) {\n      return EXIT_FAILURE;\n    }\n    std::cout << implementation->name() << \": \" << implementation->description()\n              << std::endl;\n    chosen_implementation = implementation->name();\n  }\n  auto my_implementation =\n      simdutf::get_available_implementations()[chosen_implementation];\n  if (!my_implementation) {\n    return EXIT_FAILURE;\n  }\n  if (!my_implementation->supported_by_runtime_system()) {\n    return EXIT_FAILURE;\n  }\n  simdutf::get_active_implementation() = my_implementation;\n  bool validutf8 = simdutf::validate_utf8(source.c_str(), source.size());\n  if (!validutf8) {\n    return EXIT_FAILURE;\n  }\n  if (simdutf::get_active_implementation()->name() != chosen_implementation) {\n    return EXIT_FAILURE;\n  }\n  std::cout << \"I have manually selected: \" << simdutf::get_active_implementation()->name() << std::endl;\n  return EXIT_SUCCESS;\n}\n```\n\nWithin the simdutf library,\n\nReferences\n-----------\n\n* Robert Clausecker, Daniel Lemire, Transcoding Unicode Characters with AVX-512 Instructions (in preparation).\n* Daniel Lemire, Wojciech Mua,  [Transcoding Billions of Unicode Characters per Second with SIMD Instructions](https://arxiv.org/abs/2109.10433), Software: Practice and Experience52 (2), 2022.\n* John Keiser, Daniel Lemire, [Validating UTF-8 In Less Than One Instruction Per Byte](https://arxiv.org/abs/2010.03090), Software: Practice and Experience 51 (5), 2021.\n\nLicense\n-------\n\nThis code is made available under the [Apache License 2.0](https://www.apache.org/licenses/LICENSE-2.0.html) as well as the MIT license. As a user, you can pick the license you prefer.\n\nWe include a few competitive solutions under the benchmarks/competition directory. They are provided for\nresearch purposes only."
}
