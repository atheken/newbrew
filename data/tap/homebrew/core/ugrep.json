{
  "name": "ugrep",
  "full_name": "ugrep",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Ultra fast grep with query UI, fuzzy search, archive search, and more",
  "license": "BSD-3-Clause",
  "homepage": "https://github.com/Genivia/ugrep",
  "versions": {
    "stable": "3.12.6",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/Genivia/ugrep/archive/v3.12.6.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "96415667f88f32bf2cd478db8f488e29ff293576e66f2d39e223a3bae1a15eb4"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": "/opt/homebrew/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/ugrep/blobs/sha256:170bfb22f6317ac9fe07987974d750633e16ae020a45823d51011f49d2bcf958",
          "sha256": "170bfb22f6317ac9fe07987974d750633e16ae020a45823d51011f49d2bcf958"
        },
        "arm64_monterey": {
          "cellar": "/opt/homebrew/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/ugrep/blobs/sha256:d3e964503174214090c40dfe892701966467fd3998d9c7f3eaf271987811f7e7",
          "sha256": "d3e964503174214090c40dfe892701966467fd3998d9c7f3eaf271987811f7e7"
        },
        "arm64_big_sur": {
          "cellar": "/opt/homebrew/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/ugrep/blobs/sha256:168f7fb943f6ab19e6dff43067e40a922a0c17e40aea65af0f65dae69a68f441",
          "sha256": "168f7fb943f6ab19e6dff43067e40a922a0c17e40aea65af0f65dae69a68f441"
        },
        "ventura": {
          "cellar": "/usr/local/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/ugrep/blobs/sha256:cecb6b8178a9e9cb98f5ce20880828cb3df30a21813963a01e0d9a3955b8c1e4",
          "sha256": "cecb6b8178a9e9cb98f5ce20880828cb3df30a21813963a01e0d9a3955b8c1e4"
        },
        "monterey": {
          "cellar": "/usr/local/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/ugrep/blobs/sha256:e28c1a07996921bd7b576041e2e0abfbb7345a6f1aa44b08369f398ac272ce4a",
          "sha256": "e28c1a07996921bd7b576041e2e0abfbb7345a6f1aa44b08369f398ac272ce4a"
        },
        "big_sur": {
          "cellar": "/usr/local/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/ugrep/blobs/sha256:d96548272b9352215775c41b4bc30f93d6e33d68a5ad393f13ceec6ee2bedcb9",
          "sha256": "d96548272b9352215775c41b4bc30f93d6e33d68a5ad393f13ceec6ee2bedcb9"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/ugrep/blobs/sha256:a1496346ffd80b425457c17d73e0781d4db1f9ab44085299ccf242892298c205",
          "sha256": "a1496346ffd80b425457c17d73e0781d4db1f9ab44085299ccf242892298c205"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [
    "pcre2",
    "xz"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "aa66a84309b297ea296f7a4b9c424b5c0ec4875c",
  "ruby_source_path": "Formula/ugrep.rb",
  "ruby_source_checksum": {
    "sha256": "92a75b401e337a271a7a305ac1a394a31a6cf1ade9cb26572c30de0db770083f"
  },
  "date_added": "2020-08-11T00:31:39+00:00",
  "readme": "[![build status][ci-image]][ci-url] [![license][bsd-3-image]][bsd-3-url]\n\nNew ugrep 4.0\n-------------\n\nUgrep is like grep, but faster, user-friendly, and equipped with must-have features.  Ugrep's speed and features beat grep, ripgrep, silver searcher, ack, sift, etc.\n\nNew faster ugrep 4.0 and new **ugrep-indexer** tool to speed up search with file system indexing.  Visit [GitHub ugrep-indexer](https://github.com/Genivia/ugrep-indexer) for details.\n\nSee [how to install ugrep](#install) on your system.  Ugrep is always free.\n\nThe ugrep tools include the following powerful commands:\n\n- **ug** for interactive use with a .ugrep configuration file with your preferences located in the working directory or home directory (run 'ug --save-config' to create a .ugrep file you can edit)\n- **ugrep** for batch use\n- **ug+** for interactive use, also searches pdfs, documents, e-books, image metadata\n- **ugrep+** for batch use, also searches pdfs, documents, e-books, image metadata\n\n*Option -Q opens a query TUI to search files as you type!*\n<br>\n<img src=\"https://www.genivia.com/images/scranim.gif\" width=\"438\" alt=\"\">\n\nDevelopment roadmap\n-------------------\n\n- my highest priority is testing and quality assurance to continue to make sure ugrep has no bugs and is reliable\n- listen to users to continue to add new and updated features\n- improve the interactive TUI with a split screen\n- make ugrep even faster and report on progress, see [my latest article](https://www.genivia.com/ugrep.html)\n- share [reproducible performance data](https://github.com/Genivia/ugrep-benchmarks) with the community\n- add file indexing to speed up cold search performance, see [ugrep-indexer](https://github.com/Genivia/ugrep-indexer)\n\nOverview\n--------\n\nWhy use ugrep?\n\n- Compatible with the GNU grep command options and output, but faster and with a lot more features\n\n- Matches Unicode patterns by default and automatically searches UTF-8, UTF-16 and UTF-32 encoded files\n\n- Matches multiple lines with `\\n` or `\\R` in regex patterns, *no special options are required to do so!*\n\n- Built-in help: `ug --help`, where `ug --help WHAT` displays options related to `WHAT` you are looking for\n\n  💡 try `ug --help regex`, `ug --help globs`, `ug --help fuzzy`, `ug --help format`.\n\n- User-friendly with sensible defaults and customizable [configuration files](#config) used by the `ug` command intended for interactive use that loads a .ugrep configuration file with your preferences\n\n      ug PATTERN ...                         ugrep --config PATTERN ...\n\n  💡 `ug --save-config ...options-you-want-to-save...` saves a .ugrep config file in the working directory.\n\n- Interactive [query TUI](#query), press F1 or CTRL-Z for help and TAB/SHIFT-TAB to navigate to dirs and files\n\n      ug -Q                                  ug -Q -e PATTERN    \n\n  💡 `-Q` replaces `PATTERN` on the command line to let you enter patterns interactively.  Specify `-e PATTERN` to search and edit the `PATTERN` in the TUI.  Best is `-Qle PATTERN` to view a list of matching files.\n\n- Search with Google-like [Boolean query patterns](#bool) using `--bool` patterns with `AND` (or just space), `OR` (or a bar `|`), `NOT` (or a dash `-`), using quotes to match exactly, and grouping with `( )`; or with options `-e` (as an \"or\"), `--and`, `--andnot`, and `--not` regex patterns\n\n      ug --bool 'A B C' ...                  ug -e 'A' --and 'B' --and 'C' ...\n      ug --bool 'A|B C' ...                  ug -e 'A' -e 'B' --and 'C' ...\n      ug --bool 'A -B -C' ...                ug -e 'A' --andnot 'B' --andnot 'C' ...\n      ug --bool 'A -(B|C)'...                ug -e 'A' --andnot 'B' --andnot 'C' ...\n      ug --bool '\"abc\" \"def\"' ...            ug -e '\\Qabc\\E' --and '\\Qdef\\E' ...\n\n  where `A`, `B` and `C` are arbitrary regex patterns (use option `-F` to search strings)\n\n  💡 specify `--files --bool` to apply the Boolean query to files as a whole: a file matches if all Boolean conditions are satisfied by matching patterns file-wide.  Otherwise, Boolean conditions apply to single lines by default, since grep utilities are generally line-based pattern matchers.  Option `--stats` displays the query in human-readable form after the search completes.\n\n- Search the contents of [archives](#archives) (cpio, jar, tar, pax, zip) and [compressed files](#archives) (zip, gz, Z, bz, bz2, lzma, xz, lz4, zstd)\n\n      ug -z PATTERN ...                      ug -z --zmax=2 PATTERN ...\n\n  💡 specify `-z --zmax=2` to search compressed files and archives stored within archives.  The `--zmax` argument may range from 1 (default) to 99 for up to 99 decompression and de-archiving steps to search nested archives, far more than you will ever need!  Larger `--zmax` slows searching.\n\n- Search pdf, doc, docx, e-book, and more with `ug+` [using filters](#filter) associated with filename extensions:\n\n      ug+ PATTERN ...\n      ug --filter='pdf:pdftotext % -' PATTERN ...\n      ug --filter='doc:antiword %' PATTERN ...\n      ug --filter='odt,docx,epub,rtf:pandoc --wrap=preserve -t plain % -o -' PATTERN ...\n      ug --filter='odt,doc,docx,rtf,xls,xlsx,ppt,pptx:soffice --headless --cat %' PATTERN ...\n      ug --filter='pem:openssl x509 -text,cer,crt,der:openssl x509 -text -inform der' PATTERN ...\n      ug --filter='latin1:iconv -f LATIN1 -t UTF-8' PATTERN ...\n      ug --filter='7z:7z x -so -si' PATTERN ...\n\n  💡 the `ug+` command is the same as the `ug` command, but also uses filters to search PDFs, documents, and image metadata, when the [`pdftotext`](https://pypi.org/project/pdftotext), [`antiword`](https://github.com/rsdoiel/antiword), [`pandoc`](https://pandoc.org), and [`exiftool`](https://exiftool.sourceforge.net) are installed (optionally, not used when not installed).\n\n- Find approximate pattern matches with [fuzzy search](#fuzzy), within the specified Levenshtein distance\n\n      ug -Z PATTERN ...                      ug -Z3 PATTTERN ...\n\n  💡 `-Zn` matches up to `n` extra, missing or replaced characters, `-Z+n` matches up to `n` extra characters, `-Z-n` matches with up to `n` missing characters and `-Z~n` matches up to `n` replaced characters.  `-Z` defaults to `-Z1`.\n\n- Fzf-like search with regex (or fixed strings with `-F`), fuzzy matching with up to 4 extra characters with `-Z+4` and words only with `-w`, using `--files --bool` for file-wide Boolean searches\n\n      ug -Q1 --files --bool -l -w -Z+4 --sort=best\n\n  💡 `-l` lists the matching files in the TUI, press `TAB` then `ALT-y` to view a file, `SHIFT-TAB` and `Alt-l` to go back to view the list of matching files ordered by best match\n\n- Search [binary files](#binary) and display hexdumps with binary pattern matches (Unicode text or `-U` for byte patterns)\n\n      ug --hexdump -U BYTEPATTERN ...        ug --hexdump TEXTPATTERN ...\n      ug -X -U BYTEPATTERN ...               ug -X TEXTPATTERN ...\n      ug -W -U BYTEPATTERN ...               ug -W TEXTPATTERN ...\n\n  💡 `--hexdump=4chC1` displays `4` columns of hex without a character column `c`, no hex spacing `h`, and with one extra hex line `C1` before and after a match.  Option `-X` is the same as `--hexdump=2C` with `2` columns of hex and the whole matching line as `C` context in hex.\n\n- Include files to search by [file types or file \"magic bytes\"](#magic) or exclude them with `^`\n\n      ug -t TYPE PATTERN ...                 ug -t ^TYPE PATTERN ...\n      ug -M 'MAGIC' PATTERN ...              ug -M '^MAGIC' PATTERN ...\n\n- Include files and directories to search that match [gitignore-style globs](#globs) or exclude them with `^`\n\n      ug -g 'FILEGLOB' PATTERN ...           ug -g '^FILEGLOB' PATTERN ...\n      ug -g 'DIRGLOB/' PATTERN ...           ug -g '^DIRGLOB/' PATTERN ...\n      ug -g 'PATH/FILEGLOB' PATTERN ...      ug -g '^PATH/FILEGLOB' PATTERN ...\n      ug -g 'PATH/DIRGLOB/' PATTERN ...      ug -g '^PATH/DIRGLOB/' PATTERN ...\n\n- Include files to search by [filename extensions](#magic) (suffix) or exclude them with `^`, a shorthand for `-g\"*.EXT\"`\n\n      ug -O EXT PATTERN ...                  ug -O ^EXT PATTERN ...\n\n- Include [hidden files (dotfiles) and directories](#hidden) to search (omitted by default)\n\n      ug -. PATTERN ...                      ug -g'.*,.*/' PATTERN ...\n\n- Exclude files specified by [.gitignore](#ignore) etc.\n\n      ug --ignore-files PATTERN ...          ug --ignore-files=.ignore PATTERN ...\n\n- Search patterns excluding [negative patterns](#not) (\"match this but not that\")\n\n      ug -e PATTERN -N NOTPATTERN ...        ug -e '[0-9]+' -N 123 ...\n\n- Use [predefined regex patterns](#source) to search source code, javascript, XML, JSON, HTML, PHP, markdown, etc.\n\n      ug PATTERN -f c++/zap_comments -f c++/zap_strings ...\n      ug PATTERN -f php/zap_html ...\n      ug -f js/functions ... | ug PATTERN ...\n\n- Sort matching files by [name, best match, size, and time](#sort)\n\n      ug --sort PATTERN ...                  ug --sort=size PATTERN ...\n      ug --sort=changed PATTERN ...          ug --sort=created PATTERN ...\n      ug -Z --sort=best PATTERN ...\n\n- Output results in [CSV, JSON, XML](#json), and [user-specified formats](#format)\n\n      ug --csv PATTERN ...                   ug --json PATTERN ...\n      ug --xml PATTERN ...                   ug --format='file=%f line=%n match=%O%~' PATTERN ...\n\n  💡 `ug --help format` displays help on format `%` fields.\n\n- Search with PCRE's Perl-compatible regex patterns and display or replace [subpattern matches](#replace)\n\n      ug -P PATTERN ...                      ug -P --format='%1 and %2%~' 'PATTERN(SUB1)(SUB2)' ...\n\n- Replace patterns in the output with [-P and --replace](#replace) replacement text, optionally containing `%` [formatting fields](#format), using `-y` to pass the rest of the file through:\n\n      ug --replace='TEXT' PATTERN ...        ug -y --replace='TEXT' PATTERN ...\n      ug --replace='(%m:%o)' PATTERN ...     ug -y --replace='(%m:%o)' PATTERN ...\n      ug -P --replace='%1' PATTERN ...       ug -y -P --replace='%1' PATTERN ...\n\n  💡 `ug --help format` displays help on format `%` fields to optionally use with `--replace`.\n\n- Search files with a specific [encoding](#encoding) format such as ISO-8859-1 thru 16, CP 437, CP 850, MACROMAN, KOI8, etc.\n\n      ug --encoding=LATIN1 PATTERN ...\n\n<a name=\"toc\"/>\n\nTable of contents\n-----------------\n\n- [How to install](#install)\n- [Performance comparisons](#speed)\n- [Using ugrep within Vim](#vim)\n- [Using ugrep within Emacs](#emacs)\n- [Using ugrep to replace GNU/BSD grep](#grep)\n  - [Equivalence to GNU/BSD grep](#equivalence)\n  - [Short and quick command aliases](#aliases)\n  - [Notable improvements over grep](#improvements)\n- [Tutorial](#tutorial)\n  - [Examples](#examples)\n  - [Advanced examples](#advanced)\n  - [Displaying helpful info](#help)\n  - [Configuration files](#config)\n  - [Interactive search with -Q](#query)\n  - [Recursively list matching files with -l, -R, -r, --depth, -g, -O, and -t](#recursion)\n  - [Boolean query patterns with --bool (-%), --and, --not](#bool)\n  - [Search this but not that with -v, -e, -N, -f, -L, -w, -x](#not)\n  - [Search non-Unicode files with --encoding](#encoding)\n  - [Matching multiple lines of text](#multiline)\n  - [Displaying match context with -A, -B, -C, and -y](#context)\n  - [Searching source code using -f, -O, and -t](#source)\n  - [Searching compressed files and archives with -z](#archives)\n  - [Find files by file signature and shebang \"magic bytes\" with -M, -O and -t](#magic)\n  - [Fuzzy search with -Z](#fuzzy)\n  - [Search hidden files with -.](#hidden)\n  - [Using filter utilities to search documents with --filter](#filter)\n  - [Searching and displaying binary files with -U, -W, and -X](#binary)\n  - [Ignore binary files with -I](#nobinary)\n  - [Ignoring .gitignore-specified files with --ignore-files](#ignore)\n  - [Using gitignore-style globs to select directories and files to search](#globs)\n  - [Including or excluding mounted file systems from searches](#fs)\n  - [Counting the number of matches with -c and -co](#count)\n  - [Displaying file, line, column, and byte offset info with -H, -n, -k, -b, and -T](#fields)\n  - [Displaying colors with --color and paging the output with --pager](#color)\n  - [Output matches in JSON, XML, CSV, C++](#json)\n  - [Customize output with --format](#format)\n  - [Replacing matches with -P --replace and --format using backreferences](#replace)\n  - [Limiting the number of matches with -1,-2...-9, -K, -m, and --max-files](#max)\n  - [Matching empty patterns with -Y](#empty)\n  - [Case-insensitive matching with -i and -j](#case)\n  - [Sort files by name, best match, size, and time](#sort)\n  - [Tips for advanced users](#tips)\n  - [More examples](#more)\n- [Man page](#man)\n- [Regex patterns](#patterns)\n  - [POSIX regular expression syntax](#posix-syntax)\n  - [POSIX and Unicode character classes](#posix-classes)\n  - [POSIX and Unicode character categories](#posix-categories)\n  - [Perl regular expression syntax](#perl-syntax)\n- [Troubleshooting](#bugs)\n\n<a name=\"install\"/>\n\nHow to install\n--------------\n\n### Homebrew for MacOS (and Linux)\n\nInstall the latest ugrep commands with [Homebrew](https://brew.sh):\n\n    $ brew install ugrep\n\nThis installs the `ugrep` and `ug` commands, where `ug` is the same as `ugrep`\nbut also loads the configuration file .ugrep when present in the working\ndirectory or home directory.\n\n### Windows\n\nPractical hints on using `ugrep.exe` and `ug.exe` for interactive use on the\nWindows command line:\n- when quoting patterns and arguments on the command line, do not use single\n  `'` quotes but use `\"` instead; most Windows command utilities consider\n  the single `'` quotes part of the command-line argument!\n- file and directory globs specified with option `-g/GLOB` may behave more\n  intuitively than a `GLOB` command line argument, especially when directory\n  recursion is enabled;\n- when specifying an empty pattern `\"\"` to match all input, this may be ignored\n  by some Windows command interpreters such as Powershell, in that case use\n  option `--match` instead;\n- to match newlines in patterns, you may want to use `\\R` instead of `\\n` to\n  match any Unicode newlines, such as `\\r\\n` pairs and single `\\r` and `\\n`.\n\nInstall with [Chocolatey](https://community.chocolatey.org/packages/ugrep)\n`choco install ugrep`\n\nOr install with [Scoop](https://scoop.sh) `scoop install ugrep`\n\nOr download the full-featured `ugrep.exe` executable as release artifact from\n<https://github.com/Genivia/ugrep/releases>.  Then copy `ugrep.exe` to `ug.exe`\nif you also want the `ug` command intended for interactive use, which loads the\n.ugrep configuration file when present in the working directory or home\ndirectory.\n\nAdd `ugrep.exe` and `ug.exe` to your execution path: go to *Settings* and\nsearch for \"Path\" in *Find a Setting*.  Select *environment variables* ->\n*Path* -> *New* and add the directory where you placed the `ugrep.exe` and\n`ug.exe` executables.\n\n### Alpine Linux\n\n    $ apk add ugrep ugrep-doc\n\nCheck <https://pkgs.alpinelinux.org/packages?name=ugrep> for version info.\n\n### Arch Linux\n\n    $ pacman -S ugrep\n\nCheck <https://archlinux.org/packages/community/x86_64/ugrep> for version info.\n\n### CentOS\n\nFirst enable the [EPEL repository](https://docs.fedoraproject.org/en-US/epel/),\nthen you can install ugrep.\n\n    $ dnf install ugrep\n\nCheck <https://packages.fedoraproject.org/pkgs/ugrep/ugrep/> for version info.\n\n### Debian\n\n    $ apt-get install ugrep\n\nCheck <https://packages.debian.org/ugrep> for version info.  To build and try\n`ugrep` locally, see \"All platforms\" build steps further below.\n\n### Fedora\n\n    $ dnf install ugrep\n\nCheck <https://packages.fedoraproject.org/pkgs/ugrep/ugrep/> for version info.\n\n### FreeBSD\n\n    $ pkg install ugrep\n\nCheck <https://www.freshports.org/textproc/ugrep> for version info.\n\n### Haiku\n\n    $ pkgman install cmd:ugrep\n\nCheck <https://github.com/haikuports/haikuports/tree/master/app-text/ugrep> for\nversion info.  To build and try `ugrep` locally, see \"All platforms\" build\nsteps further below.\n\n### NetBSD\n\nYou can use the standard NetBSD package installer (pkgsrc):\n<http://cdn.netbsd.org/pub/pkgsrc/current/pkgsrc/textproc/ugrep/README.html>\n\n### RHEL\n\nFirst enable the [EPEL repository](https://docs.fedoraproject.org/en-US/epel/),\nthen you can install ugrep.\n\n    $ dnf install ugrep\n\nCheck <https://packages.fedoraproject.org/pkgs/ugrep/ugrep/> for version info.\n\n### Other platforms: step 1 download\n\nClone `ugrep` with\n\n    $ git clone https://github.com/Genivia/ugrep\n\nOr visit <https://github.com/Genivia/ugrep/releases> to download a specific\nrelease.\n\n### Other platforms: step 2 consider optional dependencies\n\nYou can always add these later, when you need these features:\n\n- Option `-P` (Perl regular expressions) requires either the PCRE2 library\n  (preferred) or the Boost.Regex library.  If PCRE2 is not installed,\n  install PCRE2 with e.g. `sudo apt-get install -y libpcre2-dev` or\n  [download PCRE2](https://www.pcre.org) and follow the installation\n  instructions.  Alternatively,\n  [download Boost.Regex](https://www.boost.org/users/download) and run\n  `./bootstrap.sh` and `sudo ./b2 --with-regex install`.  See\n  [Boost: getting started](https://www.boost.org/doc/libs/1_72_0/more/getting_started/unix-variants.html).\n\n- Option `-z` (compressed files and archives search) requires the\n  [zlib](https://www.zlib.net) library installed.  It is installed on most\n  systems.  If not, install it, e.g. with `sudo apt-get install -y libz-dev`.\n  To search `.bz` and `.bz2` files, install the\n  [bzip2](https://www.sourceware.org/bzip2) library, e.g. with\n  `sudo apt-get install -y libbz2-dev`.  To search `.lzma` and `.xz` files,\n  install the [lzma](https://tukaani.org/xz) library, e.g. with\n  `sudo apt-get install -y liblzma-dev`.  To search `.lz4` files, install the\n  [lz4](https://github.com/lz4/lz4) library, e.g. with\n  `sudo apt-get install -y liblz4-dev`.  To search `.zst` files, install the\n  [zstd](http://facebook.github.io/zstd) library, e.g. with\n  `sudo apt-get install -y libzstd-dev`\n\n**Note:** even if your system has command line utilities, such as `bzip2`, that\ndoes not necessarily mean that the development libraries such as `libbz2` are\ninstalled.  The *development libraries* should be installed.\n\nAfter installing one or more of these libraries, re-execute the commands to\nrebuild `ugrep`:\n\n    $ cd ugrep\n    $ ./build.sh\n\n**Note:** some Linux systems may not be configured to load dynamic libraries\nfrom `/usr/local/lib`, causing a library load error when running `ugrep`.  To\ncorrect this, add `export LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH:/usr/local/lib\"` to\nyour `~/.bashrc` file.  Or run `sudo ldconfig /usr/local/lib`.\n\n### Other platforms: step 3 build\n\nBuild `ugrep` on Unix-like systems with colors enabled by default:\n\n    $ cd ugrep\n    $ ./build.sh\n\nThis builds the `ugrep` executable in the `ugrep/src` directory with\n`./configure` and `make -j`, verified with `make test`.  When all tests pass,\nthe `ugrep` executable is copied to `ugrep/bin/ugrep` and the symlink\n`ugrep/bin/ug -> ugrep/bin/ugrep` is added for the `ug` command.\n\nNote that `ug` is the same as `ugrep` but also loads the configuration file\n.ugrep when present in the working directory or home directory.  This means\nthat you can define your default options for `ug` in .ugrep.\n\nTo build `ugrep` with specific hard defaults enabled, such as a pager:\n\n    $ cd ugrep\n    $ ./build.sh --enable-pager\n\nOptions to select defaults for builds include:\n\n- `--enable-hidden` always search hidden files and directories\n- `--enable-pager` always use a pager to display output on terminals\n- `--enable-pretty` colorize output to terminals and add filename headings\n- `--disable-auto-color` disable automatic colors, requires ugrep option `--color=auto` to show colors\n- `--disable-mmap` disable memory mapped files\n- `--disable-sse2` disable SSE2 and AVX optimizations\n- `--disable-avx` disable AVX optimizations, but compile with SSE2 when supported\n- `--disable-neon` disable ARM NEON/AArch64 optimizations\n- `--with-grep-path` the default `-f` path if `GREP_PATH` is not defined\n- `--with-grep-colors` the default colors if `GREP_COLORS` is not defined\n- `--help` display build options\n\nAfter the build completes, copy `ugrep/bin/ugrep` and `ugrep/bin/ug` to a\nconvenient location, for example in your `~/bin` directory. Or, if you may want\nto install the `ugrep` and `ug` commands and man pages:\n\n    $ sudo make install\n\nThis also installs the pattern files with predefined patterns for option `-f`\nat `/usr/local/share/ugrep/patterns/`.  Option `-f` first checks the working\ndirectory for the presence of pattern files, if not found checks environment\nvariable `GREP_PATH` to load the pattern files, and if not found reads the\ninstalled predefined pattern files.\n\n### Troubleshooting\n\n#### Git and timestamps\n\nUnfortunately, git clones do not preserve timestamps which means that you may\nrun into \"WARNING: 'aclocal-1.15' is missing on your system.\" or that\nautoheader was not found when running `make`.\n\nTo work around this problem, run:\n\n    $ autoreconf -fi\n    $ ./build.sh\n\n#### Compiler warnings\n\nGCC 8 and greater may produce warnings of the sort *\"note: parameter passing\nfor argument ... changed in GCC 7.1\"*.  These warnings should be ignored.\n\n### Dockerfile for developers\n\nA Dockerfile is included to build `ugrep` in a Ubuntu container.\n\nDevelopers may want to use sanitizers to verify the **ugrep** code when making\nsignificant changes, for example to detect data races with the\n[ThreadSanitizer](https://clang.llvm.org/docs/ThreadSanitizer.html):\n\n    $ ./build.sh CXXFLAGS='-fsanitize=thread -O1 -g'\n\nWe checked `ugrep` with the clang AddressSanitizer, MemorySanitizer,\nThreadSanitizer, and UndefinedBehaviorSanitizer.  These options incur\nsignificant runtime overhead and should not be used for the final build.\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"speed\"/>\n\nPerformance comparisons\n-----------------------\n\nFor an up-to-date comprehensive performance comparison, please see the\n[ugrep performance benchmarks](https://github.com/Genivia/ugrep-benchmarks).\n\nBelow is a two-year old performance comparison when ugrep was first released\nwith performance enhancements.  This old comparison is getting outdated.\n\nPerformance comparisons should represent what users can expect the performance\nto be in practice.  There should not be any shenanigans to trick the system to\nperform more optimally or to degrade an important aspect of the search to make\none grep tool look better than another.\n\n**ugrep** is a no-nonsense fast search tool that utilizes a worker pool of\nthreads with clever lock-free job queue stealing for optimized load balancing.\nA new hashing technique is used to identify possible matches to speed up\nmulti-pattern matches.  In addition, regex matching is optimized with AVX/SSE\nand ARM NEON/AArch64 instructions.  Compressed files are decompressed\nconcurrently while searching to further increase performance.  Asynchronous IO\nis implemented for efficient input and output.\n\n**ugrep** performs very well overall and particularly well when searching\ncompressed files and archives.  This means that at its core, the search\nengine's performance of ugrep excellent if not the best among grep tools\navailable.\n\n### Benchmarks\n\nThe following benchmark tests span a range of practical use cases:\n\nTest | Command                                                          | Description\n---- | ---------------------------------------------------------------- | -----------------------------------------------------\nT1   | `GREP -c quartz enwik8`                                          | count \"quartz\" in a 100MB file (word with low frequency letters)\nT2   | `GREP -c sternness enwik8`                                       | count \"sternness\" in a 100MB file (word with high frequency letters)\nT3   | `GREP -c 'Sherlock Holmes' en.txt`                               | count \"Sherlock Holmes\" in a huge [13GB decompressed file](http://opus.nlpl.eu/download.php?f=OpenSubtitles/v2018/mono/OpenSubtitles.raw.en.gz)\nT4   | `GREP -cw -e char -e int -e long -e size_t -e void big.cpp`      | count 5 short words in a 35MB C++ source code file\nT5   | `GREP -Eon 'serialize_[a-zA-Z0-9_]+Type' big.cpp`                | search and display C++ serialization functions in a 35MB source code file\nT6   | `GREP -Fon -f words1+1000 enwik8`                                | search 1000 words of length 1 or longer in a 100MB Wikipedia file\nT7   | `GREP -Fon -f words2+1000 enwik8`                                | search 1000 words of length 2 or longer in a 100MB Wikipedia file\nT8   | `GREP -Fon -f words4+1000 enwik8`                                | search 1000 words of length 4 or longer in a 100MB Wikipedia file\nT9   | `GREP -Fon -f words8+1000 enwik8`                                | search 1000 words of length 8 or longer in a 100MB Wikipedia file\nT10  | `GREP -ro '#[[:space:]]*include[[:space:]]+\"[^\"]+\"' -Oh,hpp,cpp` | multi-threaded recursive search of `#include \"...\"` in the directory tree from the Qt 5.9.2 root, restricted to `.h`, `.hpp`, and `.cpp` files\nT11  | `GREP -ro '#[[:space:]]*include[[:space:]]+\"[^\"]+\"' -Oh,hpp,cpp` | same as T10 but single-threaded\nT12  | `GREP -z -Fc word word*.gz`                                      | count `word` in 6 compressed files of 1MB to 3MB each\n\nNote: T10 and T11 use `ugrep` option `-Oh,hpp,cpp` to restrict the search to\nfiles with extensions `.h`, `.hpp`, and `.cpp`, which is formulated with\nGNU/BSD/PCRGE grep as `--include='*.h' --include='*.hpp' --include='*.cpp'`,\nwith silver searcher as `-G '.*\\.(h|hpp|cpp)'` requiring `--search-binary` to\nsearch compressed files (a bug), and with ripgrep as `--glob='*.h'\n--glob='*.hpp' --glob='*.cpp'`.\n\nThe corpora used in the tests are available for\n[download](https://www.genivia.com/files/corpora.zip).\n\n### Performance results\n\nThe following performance tests were conducted with a new and common MacBook\nPro using clang 12.0.0 -O2 on a 2.9 GHz Intel Core i7, 16 GB 2133 MHz LPDDR3\nMacOS 10.15.7 machine with the grep tools listed in the table installed (e.g.\nMacOS BSD grep 2.5.1).  The best times of 30 runs is shown under minimal\nmachine load.  When comparing tools, the same match counts were produced.\nThese results are reproducible on similar machines.\n\nResults are shown in real time (wall clock time) seconds elapsed.  Best times\nare shown in **boldface** and *n/a* means that the running time exceeded 1\nminute or the selected options are not supported (T12: option `-z`) or the\ninput file is too large (T3: 13GB file) resulting in an error.\n\nGREP            | T1       | T2       | T3       | T4       | T5       | T6       | T7       | T8       | T9       | T10      | T11      | T12      |\n--------------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- |\nugrep           | **0.02** | **0.03** | **6.05** | **0.06** | **0.02** | **0.92** | **0.86** | **0.74** | **0.23** | **0.10** | **0.19** | **0.02** |\nhyperscan grep  | 0.09     | 0.10     | **4.35** | 0.11     | 0.04     | 7.78     | 3.39     | 1.41     | 1.17     | *n/a*    | *n/a*    | *n/a*    |\nripgrep         | 0.06     | 0.10     | 7.50     | 0.19     | 0.06     | 2.20     | 2.07     | 2.01     | 2.14     | 0.12     | 0.36     | 0.03     |\nsilver searcher | 0.10     | 0.11     | *n/a*    | 0.16     | 0.21     | *n/a*    | *n/a*    | *n/a*    | *n/a*    | 0.45     | 0.32     | 0.09     |\nGNU grep 3.3    | 0.08     | 0.15     | 11.21    | 0.18     | 0.16     | 2.70     | 2.64     | 2.42     | 2.26     | *n/a*    | 0.26     | *n/a*    |\nPCREGREP 8.42   | 0.17     | 0.17     | *n/a*    | 0.26     | 0.08     | *n/a*    | *n/a*    | *n/a*    | *n/a*    | *n/a*    | 2.37     | *n/a*    |\nBSD grep 2.5.1  | 0.81     | 1.60     | *n/a*    | 1.85     | 0.83     | *n/a*    | *n/a*    | *n/a*    | *n/a*    | *n/a*    | 3.35     | 0.60     |\n\nNote T3: [Hyperscan simplegrep](https://github.com/intel/hyperscan/tree/master/examples)\nwas compiled with optimizations enabled.  Hyperscan results for T3 are somewhat\nbetter than ugrep as expected because hyperscan simplegrep has one advantage\nhere: it does not maintain line numbers and other line-related information.  By\ncontrast, line information should be tracked (as in ugrep) to determine if\nmatches are on the same line or not, as required by option `-c`.  Hyperscan\nsimplegrep returns more matches than other greps due to its \"all matches\nreported\" pattern matching behavior.\n\nNote T4-T9: Hyperscan simplegrep does not support command line options.  Option\n`-w` was emulated using the pattern `\\b(char|int|long|size_t|void)\\b`.  Option\n`-f` was emulated as follows:\n\n    paste -d'|' -s words1+1000 > pattern.txt\n    /usr/bin/time ./simplegrep `cat pattern.txt` enwik8 | ./null\n\nNote T10+T11: [silver searcher 2.2.0](https://github.com/ggreer/the_silver_searcher)\nruns slower with multiple threads (T10 0.45s) than single-threaded (T11 0.32s),\nwhich was reported as an issue to the maintainers.\n\nNote: ugrep option `-c` does not shortcut the search by skipping over the rest\nof the line after a first match, by contrast to other grep to speed up\nmatching.  The reason is that ugrep supports multi-line matches by default,\nwhich means that the remainder of the line should always be searched to produce\naccurate results.\n\nOutput is sent to a `null` utility to eliminate terminal display overhead\n(`> /dev/null` cannot be used as some greps detect it to remove all output).\nThe `null` utility source code:\n\n    #include <sys/types.h>\n    #include <sys/uio.h>\n    #include <unistd.h>\n    int main() { char buf[65536]; while (read(0, buf, 65536) > 0) continue; }\n\nPerformance results may depend on warm/cold runs, compilers, libraries,\nthe OS, the CPU type, and file system latencies.  However, comparable\ncompetitive results were obtained on many other types of machines.\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"vim\"/>\n\nUsing ugrep within Vim\n----------------------\n\nFirst, let's define the `:grep` command in Vim to search files recursively.  To\ndo so, add the following lines to your `.vimrc` located in the root directory:\n\n    if executable('ugrep')\n        set grepprg=ugrep\\ -RInk\\ -j\\ -u\\ --tabs=1\\ --ignore-files\n        set grepformat=%f:%l:%c:%m,%f+%l+%c+%m,%-G%f\\\\\\|%l\\\\\\|%c\\\\\\|%m\n    endif\n\nThis specifies `-j` [case insensitive searches](#case) with the Vim `:grep`\ncommand.  For case sensitive searches, remove `\\ -j` from `grepprg`.  Multiple\nmatches on the same line are listed in the quickfix window separately.  If this\nis not desired, remove `\\ -u` from `grepprg`.  With this change, only the first\nmatch on a line is shown.  Option `--ignore-files` skips files specified in\n`.gitignore` files, when present.  To limit the depth of recursive searches to\nthe current directory only, append `\\ -1` to `grepprg`.\n\nYou can now invoke the Vim `:grep` command in Vim to search files on a\nspecified `PATH` for `PATTERN` matches:\n\n    :grep PATTERN [PATH]\n\nIf you omit `PATH`, then the working directory is searched.  Use `%` as `PATH`\nto search only the currently opened file in Vim:\n\n    :grep PATTERN %\n\nThe `:grep` command shows the results in a\n[quickfix](http://vimdoc.sourceforge.net/htmldoc/quickfix.html#:grep) window\nthat allows you to quickly jump to the matches found.\n\nTo open a quickfix window with the latest list of matches:\n\n    :copen\n\nDouble-click on a line in this window (or select a line and press ENTER) to\njump to the file and location in the file of the match.  Enter commands `:cn`\nand `:cp` to jump to the next or previous match, respectively.  To update the\nsearch results in the quickfix window, just grep them.  For example, to\nrecursively search C++ source code marked `FIXME` in the working directory:\n\n    :grep -tc++ FIXME\n\nTo close the quickfix window:\n\n    :cclose\n\nYou can use **ugrep** options with the `:grep` command, for example to\nselect single- and multi-line comments in the current file:\n\n    :grep -f c++/comments %\n\nOnly the first line of a multi-line comment is shown in quickfix, to save\nspace.  To show all lines of a multi-line match, remove `%-G` from\n`grepformat`.\n\nA popular Vim tool is [ctrlp.vim](http://kien.github.io/ctrlp.vim), which is\ninstalled with:\n\n    $ cd ~/.vim\n    $ git clone https://github.com/kien/ctrlp.vim.git bundle/ctrlp.vim\n\nCtrlP uses **ugrep** by adding the following lines to your `.vimrc`:\n\n    if executable('ugrep')\n        set runtimepath^=~/.vim/bundle/ctrlp.vim\n        let g:ctrlp_match_window='bottom,order:ttb'\n        let g:ctrlp_user_command='ugrep \"\" %s -Rl -I --ignore-files -3'\n    endif\n\nwhere `-I` skips binary files, option `--ignore-files` skips files specified in\n`.gitignore` files, when present, and option `-3` restricts searching\ndirectories to three levels (the working directory and up to two levels below). \n\nStart Vim then enter the command:\n\n    :helptags ~/.vim/bundle/ctrlp.vim/doc\n\nTo view the CtrlP documentation in Vim, enter the command:\n\n    :help ctrlp.txt\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"emacs\"/>\n\nUsing ugrep within Emacs\n------------------------\n\nThanks to [Manuel Uberti](https://github.com/emacs-mirror/emacs/commits?author=manuel-uberti),\nyou can now use **ugrep** in Emacs.  To use **ugrep** instead of GNU grep\nwithin Emacs, add the following line to your `.emacs.d/init.el` file:\n\n    (setq-default xref-search-program ‘ugrep)\n\nThis means that Emacs commands such as `project-find-regexp` that rely on\n[Xref](https://www.gnu.org/software/emacs/manual/html_node/emacs/Xref.html) can\nnow leverage the power of **ugrep**.\n\nFurthermore, it is possible to use `grep` in the [Emacs grep\ncommands](https://www.gnu.org/software/emacs/manual/html_node/emacs/Grep-Searching.html).\nFor instance, you can run `lgrep` with `ugrep` by customizing `grep-template`\nto something like the following:\n\n    (setq-default grep-template \"ugrep --color=always -0Iinr -e <R>\")\n\nIf you do not have Emacs version 29 (or greater) you can download and build\nEmacs from the [Emacs master branch](https://github.com/emacs-mirror/emacs),\nor enable Xref integration with **ugrep** manually:\n\n    (with-eval-after-load 'xref\n     (push '(ugrep . \"xargs -0 ugrep <C> --null -ns -e <R>\")\n           xref-search-program-alist)\n     (setq-default xref-search-program 'ugrep))\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"grep\"/>\n\nUsing ugrep to replace GNU/BSD grep\n-----------------------------------\n\nOut-of-the-box **ugrep** supports all standard GNU/BSD grep command-line\noptions and improves many of them too.  For details see [notable improvements\nover grep](#improvements).\n\nIf you want to stick exactly to GNU/BSD grep ASCII/LATIN1 non-UTF Unicode\npatterns, use option `-U` to disable full Unicode pattern matching.\n\nIn fact, executing `ugrep` with options `-U`, `-Y`, `-.` and `--sort` makes it\nbehave exactly like `egrep`, matching only ASCII/LATIN1 non-UTF Unicode\npatterns, permitting empty patterns to match and search hidden files instead of\nignoring them, respectively.  See [grep equivalence](#equivalence).\n\n- You can create [convenient grep aliases](#aliases) with or without options\n  `-U`, `-Y`, `-.` and `--sort` or include other options as desired.\n\n- Or you can create `grep`, `egrep` and `fgrep` executables by copying `ugrep`\n  to those names.  When the `ugrep` (or `ugrep.exe`) executable is copied as\n  `grep` (`grep.exe`), `egrep` (`egrep.exe`), `fgrep` (`fgrep.exe`), then\n  option `-U`, `-Y` and `-.` are automatically enabled together with either\n  `-G` for `grep`, `-E` for `egrep` and `-F` for `fgrep`.  In addition, when\n  copied as `zgrep`, `zegrep` and `zfgrep`, option `-z` is enabled.  For\n  example, when `ugrep` is copied as `zegrep`, options `-z`, `-E`, `-Y`, `-.`\n  and `--sort` are enabled.\n\n- Likewise, symlinks and hard links to `ugrep` work fine too to create `grep`,\n  `egrep` and `fgrep` replacements.  For example, to create a symlink `egrep`:\n\n      sudo ln -s `which ugrep` /opt/local/bin/egrep\n\n  The `/opt/local/bin` is just an example and may or may not be in your `$path`\n  and may or may not be found when executing `egrep` depending on your `$path`.\n\n<a name=\"equivalence\"/>\n\n### Equivalence to GNU/BSD grep\n\n**ugrep** is equivalent to GNU/BSD grep when the following options are used:\n\n    grep   = ugrep -G -U -Y -. --sort -Dread -dread\n    egrep  = ugrep -E -U -Y -. --sort -Dread -dread\n    fgrep  = ugrep -F -U -Y -. --sort -Dread -dread\n\n    zgrep  = ugrep -z -G -U -Y -. --sort -Dread -dread\n    zegrep = ugrep -z -E -U -Y -. --sort -Dread -dread\n    zfgrep = ugrep -z -F -U -Y -. --sort -Dread -dread\n\nwhere:\n\n- `-U` disables Unicode wide-character pattern matching, so for example the\n  pattern `\\xa3` matches byte A3 instead of the Unicode code point U+00A3\n  represented by the UTF-8 sequence C2 A3.  By default in ugrep, `\\xa3` matches\n  U+00A3.  We do not recommend to use `-U` for text pattern searches, only for\n  binary searches or to search latin-1 (iso-8859-1) files without reporting\n  these files as binary (since ugrep v3.5.0).\n- `-Y` enables empty matches, so for example the pattern `a*` matches every\n  line instead of a sequence of `a`'s.  By default in ugrep, the pattern `a*`\n  matches a sequence of `a`'s.  Moreover, in ugrep the pattern `a*b*c*` matches\n  what it is supposed to match by default.  See [improvements](#improvements).\n- `-.` searches hidden files (dotfiles).  By default, hidden files are ignored,\n  like most Unix utilities.\n- `--sort` specifies output sorted by pathname, showing sorted matching files\n  first followed by sorted recursive matches in subdirectories.  Otherwise,\n  matching files are reported in no particular order to improve performance;\n- `-Dread` and `-dread` are the GNU/BSD grep defaults but are not recommended,\n  see [improvements](#improvements) for an explanation.\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"aliases\"/>\n\n### Short and quick command aliases\n\nCommonly-used aliases to add to `.bashrc` to increase productivity:\n\n    alias uq     = 'ug -Q'       # short & quick query TUI (interactive, uses .ugrep config)\n    alias ux     = 'ug -UX'      # short & quick binary pattern search (uses .ugrep config)\n    alias uz     = 'ug -z'       # short & quick compressed files and archives search (uses .ugrep config)\n\n    alias ugit   = 'ug -R --ignore-files' # works like git-grep & define your preferences in .ugrep config\n\n    alias grep   = 'ugrep -G'    # search with basic regular expressions (BRE)\n    alias egrep  = 'ugrep -E'    # search with extended regular expressions (ERE)\n    alias fgrep  = 'ugrep -F'    # find string(s)\n    alias pgrep  = 'ugrep -P'    # search with Perl regular expressions\n    alias xgrep  = 'ugrep -W'    # search (ERE) and output text or hex for binary\n\n    alias zgrep  = 'ugrep -zG'   # search compressed files and archives with BRE\n    alias zegrep = 'ugrep -zE'   # search compressed files and archives with ERE\n    alias zfgrep = 'ugrep -zF'   # find string(s) in compressed files and/or archives\n    alias zpgrep = 'ugrep -zP'   # search compressed files and archives with Perl regular expressions\n    alias zxgrep = 'ugrep -zW'   # search (ERE) compressed files/archives and output text or hex for binary\n\n    alias xdump  = 'ugrep -X \"\"' # hexdump files without searching\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"improvements\"/>\n\n### Notable improvements over grep\n\n- **ugrep** starts an interactive query TUI with option `-Q`.\n- **ugrep** matches patterns across multiple lines when patterns match `\\n`.\n- **ugrep** matches full Unicode by default (disabled with option `-U`).\n- **ugrep** supports Boolean patterns with AND, OR and NOT (option `--bool`).\n- **ugrep** supports gitignore with option `--ignore-files`.\n- **ugrep** supports fuzzy (approximate) matching with option `-Z`.\n- **ugrep** supports user-defined global and local configuration files.\n- **ugrep** searches compressed files and archives with option `-z`.\n- **ugrep** searches cpio, jar, pax, tar and zip archives with option `-z`.\n- **ugrep** searches cpio, jar, pax, tar and zip archives recursively stored\n  within archives with `-z` and `--zmax=NUM` for up to `NUM` levels deep.\n- **ugrep** searches pdf, doc, docx, xls, xlsx, epub, and more with `--filter`\n  using third-party format conversion utilities as plugins.\n- **ugrep** searches a directory when the FILE argument is a directory, like\n  most Unix/Linux utilities; use option `-r` to search directories recursively.\n- **ugrep** does not match hidden files by default like most Unix/Linux\n  utilities (hidden dotfile file matching is enabled with `-.`).\n- **ugrep** regular expression patterns are more expressive than GNU grep and\n  BSD grep POSIX ERE and support Unicode pattern matching.  Extended regular\n  expression (ERE) syntax is the default (i.e. option `-E` as egrep, whereas\n  `-G` enables BRE).\n- **ugrep** spawns threads to search files concurrently to improve search\n  speed (disabled with option `-J1`).\n- **ugrep** produces hexdumps with `-W` (output binary matches in hex with text\n  matches output as usual) and `-X` (output all matches in hex).\n- **ugrep** can output matches in JSON, XML, CSV and user-defined formats (with\n  option `--format`).\n- **ugrep** option `-f` uses `GREP_PATH` environment variable or the predefined\n  patterns installed in `/usr/local/share/ugrep/patterns`.  If `-f` is\n  specified and also one or more `-e` patterns are specified, then options\n  `-F`, `-x`, and `-w` do not apply to `-f` patterns.  This is to avoid\n  confusion when `-f` is used with predefined patterns that may no longer work\n  properly with these options.\n- **ugrep** options `-O`, `-M`, and `-t` specify file extensions, file\n  signature magic byte patterns, and predefined file types, respectively.  This\n  allows searching for certain types of files in directory trees, for example\n  with recursive search options `-R` and `-r`.  Options `-O`, `-M`, and `-t`\n  also applies to archived files in cpio, jar, pax, tar, and zip files.\n- **ugrep** option `-k`, `--column-number` to display the column number, taking\n  tab spacing into account by expanding tabs, as specified by option `--tabs`.\n- **ugrep** option `-P` (Perl regular expressions) supports backreferences\n  (with `--format`) and lookbehinds, which uses the PCRE2 or Boost.Regex\n  library for fast Perl regex matching with a PCRE-like syntax.\n- **ugrep** option `-b` with option `-o` or with option `-u`, ugrep displays\n  the exact byte offset of the pattern match instead of the byte offset of the\n  start of the matched line reported by GNU/BSD grep.\n- **ugrep** option `-u`, `--ungroup` to not group multiple matches per line.\n  This option displays a matched input line again for each additional pattern\n  match on the line.  This option is particularly useful with option `-c` to\n  report the total number of pattern matches per file instead of the number of\n  lines matched per file.\n- **ugrep** option `-Y` enables matching empty patterns.  Grepping with\n  empty-matching patterns is weird and gives different results with GNU grep\n  versus BSD grep.  Empty matches are not output by **ugrep** by default, which\n  avoids making mistakes that may produce \"random\" results.  For example, with\n  GNU/BSD grep, pattern `a*` matches every line in the input, and actually\n  matches `xyz` three times (the empty transitions before and between the `x`,\n  `y`, and `z`).  Allowing empty matches requires **ugrep** option `-Y`.\n  Patterns that start with `^` or end with `$`, such as `^\\h*$`, match empty.\n  These patterns automatically enable option `-Y`.\n- **ugrep** option `-D, --devices=ACTION` is `skip` by default, instead of\n  `read`.  This prevents unexpectedly hanging on named pipes in directories\n  that are recursively searched, as may happen with GNU/BSD grep that `read`\n  devices by default.\n- **ugrep** option `-d, --directories=ACTION` is `skip` by default, instead of\n  `read`.  By default, directories specified on the command line are searched,\n  but not recursively deeper into subdirectories.\n- **ugrep** offers *negative patterns* `-N PATTERN`, which are patterns of the\n  form `(?^X)` that skip all `X` input, thus removing `X` from the search.\n  For example, negative patterns can be used to skip strings and comments when\n  searching for identifiers in source code and find matches that aren't in\n  strings and comments.  Predefined `zap` patterns use negative patterns, for\n  example, use `-f cpp/zap_comments` to ignore pattern matches in C++ comments.\n- **ugrep** ignores the `GREP_OPTIONS` environment variable, because the\n  behavior of **ugrep** must be portable and predictable on every system.  Also\n  GNU grep abandoned `GREP_OPTIONS` for this reason.  Please use the `ug`\n  command that loads the .ugrep configuration file located in the working\n  directory or in the home directory when present, or use shell aliases to\n  create new commands with specific search options.\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"tutorial\"/>\n\nTutorial\n--------\n\n<a name=\"examples\"/>\n\n### Examples\n\nTo perform a search using a configuration file `.ugrep` placed in the working\ndirectory or home directory (note that `ug` is the same as `ugrep --config`):\n\n    ug PATTERN FILE...\n\nTo save a `.ugrep` configuration file to the working directory, then edit this\nfile in your home directory to customize your preferences for `ug` defaults:\n\n    ug --save-config\n\nTo search the working directory and recursively deeper for `main` (note that\n`-r` recurse symlinks is enabled by default if no file arguments are\nspecified):\n\n    ug main\n\nSame, but only search C++ source code files recursively, ignoring all other\nfiles:\n\n    ug -tc++ main\n\nSame, using the interactive query TUI, starting with the initial search pattern\n`main` (note that `-Q` with an initial pattern requires option `-e` because\npatterns are normally specified interactively and all command line arguments\nare considered files/directories):\n\n    ug -Q -tc++ -e main\n\nTo search for `#define` (and `# define` etc) using a regex pattern in C++ files\n(note that patterns should be quoted to prevent shell globbing of `*` and `?`):\n\n    ug -tc++ '#[\\t ]*define'\n\nTo search for `main` as a word (`-w`) recursively without following symlinks\n(`-r`) in directory `myproject`, showing the matching line (`-n`) and column\n(`-k`) numbers next to the lines matched:\n\n    ug -r -nkw main myproject\n\nSame, but only search `myproject` without recursing deeper (note that directory\narguments are searched at one level by default):\n\n    ug -nkw main myproject\n\nSame, but search `myproject` and one subdirectory level deeper (two levels)\nwith `-2`:\n\n    ug -2 -nkw main myproject\n\nSame, but only search C++ files in `myproject` and its subdirectories with\n`-tc++`:\n\n    ug -tc++ -2 -nkw main myproject\n\nSame, but also search inside archives (e.g. zip and tar files) and compressed\nfiles with `-z`:\n\n    ug -z -tc++ -2 -nkw main myproject\n\nSearch recursively the working directory for `main` while ignoring gitignored\nfiles (e.g.  assuming `.gitignore` is in the working directory or below):\n\n    ug --ignore-files -tc++ -nkw main\n\nTo list all files in the working directory and deeper that are not ignored by\n`.gitignore` file(s):\n\n    ug --ignore-files -l ''\n\nTo display the list of file name extensions and \"magic bytes\" (shebangs)\nthat are searched corresponding to `-t` arguments:\n\n    ug -tlist\n\nTo list all shell files recursively, based on extensions and shebangs with `-l`\n(note that `''` matches any non-empty file):\n\n    ug -l -tShell ''\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"advanced\"/>\n\n### Advanced examples\n\nTo search for `main` in source code while ignoring strings and comment blocks\nwe can use *negative patterns* with option `-N` to skip unwanted matches in\nC/C++ quoted strings and comment blocks:\n\n    ug -r -nkw -e 'main' -N '\"(\\\\.|\\\\\\r?\\n|[^\\\\\\n\"])*\"|//.*|/\\*([^*]|\\n|(\\*+([^*/]|\\n)))*\\*+\\/' myproject\n\nThis is a lot of work to type in correctly!  If you are like me, I don't want\nto spend time fiddling with regex patterns when I am working on something more\nimportant.  There is an easier way by using **ugrep**'s predefined patterns\n(`-f`) that are installed with the `ugrep` tool:\n\n    ug -r -nkw 'main' -f c/zap_strings -f c/zap_comments myproject\n\nThis query also searches through other files than C/C++ source code, like\nREADMEs, Makefiles, and so on.  We're also skipping symlinks with `-r`.  So\nlet's refine this query by selecting C/C++ files only using option `-tc,c++`\nand include symlinks to files and directories with `-R`:\n\n    ug -R -tc,c++ -nkw 'main' -f c/zap_strings -f c/zap_comments myproject\n\nWhat if we are only looking for the identifier `main` but not as a function\n`main(`?  We can use a negative pattern for this to skip unwanted `main\\h*(`\npattern matches:\n\n    ug -R -tc,c++ -nkw -e 'main' -N 'main\\h*\\(' -f c/zap_strings -f c/zap_comments myproject\n\nThis uses the `-e` and `-N` options to explicitly specify a pattern and a\nnegative pattern, respectively, which is essentially forming the pattern\n`main|(?^main\\h*\\()`, where `\\h` matches space and tab.  In general, negative\npatterns are useful to filter out pattern matches we are not interested in.\n\nAs another example, we may want to search for the word `FIXME` in C/C++ comment\nblocks.  To do so we can first select the comment blocks with **ugrep**'s\npredefined `c/comments` pattern AND THEN select lines with `FIXME` using a\npipe:\n\n    ug -R -tc,c++ -nk -f c/comments myproject | ug -w 'FIXME'\n\nFiltering results with pipes is generally easier than using AND-OR logic that\nsome search tools use.  This approach follows the Unix spirit to keep utilities\nsimple and use them in combination for more complex tasks.\n\nSay we want to produce a sorted list of all identifiers found in Java source\ncode while skipping strings and comments:\n\n    ug -R -tjava -f java/names myproject | sort -u\n\nThis matches Java Unicode identifiers using the regex\n`\\p{JavaIdentifierStart}\\p{JavaIdentifierPart}*` defined in\n`patterns/java/names`.\n\nWith traditional grep and grep-like tools it takes great effort to recursively\nsearch for the C/C++ source file that defines function `qsort`, requiring\nsomething like this:\n\n    ug -R --include='*.c' --include='*.cpp' '^([ \\t]*[[:word:]:*&]+)+[ \\t]+qsort[ \\t]*\\([^;\\n]+$' myproject\n\nFortunately, with **ugrep** we can simply select all function definitions in\nfiles with extension `.c` or `.cpp` by using option `-Oc,cpp` and by using a\npredefined pattern `functions` that is installed with the tool to produce\nall function definitions.  Then we select the one we want:\n\n    ug -R -Oc,cpp -nk -f c/functions | ug 'qsort'\n\nNote that we could have used `-tc,c++` to select C/C++ files, but this also\nincludes header files when we want to only search `.c` and `.cpp` files.\n\nWe can also skip files and directories from being searched that are defined in\n`.gitignore`.  To do so we use `--ignore-files` to exclude any files and\ndirectories from recursive searches that match the globs in `.gitignore`, when\none ore more`.gitignore` files are found:\n\n    ug -R -tc++ --ignore-files -f c++/defines\n\nThis searches C++ files (`-tc++`) in the working directory for `#define`\nlines (`-f c++/defines`), while skipping files and directories declared in\n`.gitignore`.  If you find this too long to type then define an alias to search\nGitHub directories:\n\n    alias ugit='ugrep -R --ignore-files'\n    ugit -tc++ -f c++/defines\n\nTo highlight matches when pushed through a chain of pipes we should use\n`--color=always`:\n\n    ugit --color=always -tc++ -f c++/defines | ugrep -w 'FOO.*'\n\nThis returns a color-highlighted list of all `#define FOO...` macros in C/C++\nsource code files, skipping files defined in `.gitignore`.\n\nNote that the complement of `--exclude` is not `--include`, because exclusions\nalways take precedence over inclusions, so we cannot reliably list the files\nthat are ignored with `--include-from='.gitignore'`.  Only files explicitly\nspecified with `--include` and directories explicitly specified with\n`--include-dir` are visited.  The `--include-from` from lists globs that are\nconsidered both files and directories to add to `--include` and\n`--include-dir`, respectively.  This means that when directory names and\ndirectory paths are not explicitly listed in this file then it will not be\nvisited using `--include-from`.\n\nBecause ugrep checks if the input is valid UTF-encoded Unicode (unless `-U` is\nused), it is possible to use it as a filter to ignore non-UTF output produced\nby a program:\n\n    program | ugrep -I ''\n\nIf the program produces valid output then the output is passed through,\notherwise the output is filtered out option `-I`.  If the output is initially\nvalid for a very large portion but is followed by invalid output, then ugrep\nmay initially show the output up to but excluding the invalid output after\nwhich further output is blocked.\n\nTo filter lines that are valid ASCII or UTF-encoded, while removing lines that\nare not:\n\n    program | ugrep '[\\p{Unicode}--[\\n]]+'\n\nNote that `\\p{Unicode}` matches `\\n` but we don't want to matche the whole\nfile!  Just lines with `[\\p{Unicode}--[\\n]]+`.\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"help\"/>\n\n### Displaying helpful info\n\nThe ugrep man page:\n\n    man ugrep\n\nTo show a help page:\n\n    ug --help\n\nTo show options that mention `WHAT`:\n\n    ug --help WHAT\n\nTo show a list of `-t TYPES` option values:\n\n    ug -tlist\n\nIn the interactive query TUI, press F1 or CTRL-Z for help and options:\n\n    ug -Q\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"config\"/>\n\n### Configuration files\n\n    --config[=FILE], ---[FILE]\n            Use configuration FILE.  The default FILE is `.ugrep'.  The working\n            directory is checked first for FILE, then the home directory.  The\n            options specified in the configuration FILE are parsed first,\n            followed by the remaining options specified on the command line.\n    --save-config[=FILE]\n            Save configuration FILE.  By default `.ugrep' is saved.  If FILE is\n            a `-', write the configuration to standard output.\n\n#### The ug command versus the ugrep command\n\nThe `ug` command is intended for context-dependent interactive searching and is\nequivalent to the `ugrep --config` command to load the configuration file\n`.ugrep` when present in the working directory or, when not found, in the home\ndirectory:\n\n    ug PATTERN ...\n    ugrep --config PATTERN ...\n\nThe `ug` command also sorts files by name per directory searched.  A\nconfiguration file contains `NAME=VALUE` pairs per line, where `NAME` is the\nname of a long option (without `--`) and `=VALUE` is an argument, which is\noptional and may be omitted depending on the option.  Empty lines and lines\nstarting with a `#` are ignored:\n\n    # Color scheme\n    colors=cx=hb:ms=hiy:mc=hic:fn=hi+y+K:ln=hg:cn=hg:bn=hg:se=\n    # Disable searching hidden files and directories\n    no-hidden\n    # ignore files specified in .ignore and .gitignore in recursive searches\n    ignore-files=.ignore\n    ignore-files=.gitignore\n\nCommand line options are parsed in the following order: first the (default or\nnamed) configuration file is loaded, then the remaining options and\narguments on the command line are parsed.\n\nOption `--stats` displays the configuration file used after searching.\n\n#### Named configuration files\n\nNamed configuration files are intended to streamline custom search tasks, by\nreducing the number of command line options to just one `---FILE` to use the\ncollection of options specified in `FILE`.  The `--config=FILE` option and its\nabbreviated form `---FILE` load the specified configuration file located in the\nworking directory or, when not found, located in the home directory:\n\n    ug ---FILE PATTERN ...\n    ugrep ---FILE PATTERN ...\n\nAn error is produced when `FILE` is not found or cannot be read.\n\nNamed configuration files can be used to define a collection of options that\nare specific to the requirements of a task in the development workflow of a\nproject.  For example to report unresolved issues by checking the source code\nand documentation for comments with FIXME and TODO items.  Such named\nconfiguration file can be localized to a project by placing it in the project\ndirectory, or it can be made global by placing it in the home directory.  For\nvisual feedback, a color scheme specific to this task can be specified with\noption `colors` in the configuration `FILE` to help identify the output\nproduced by a named configuration as opposed to the default configuration.\n\n#### Saving a configuration file\n\nThe `--save-config` option saves a `.ugrep` configuration file to the\nworking directory.  The file contains a strict subset of options that are\ndeemed reasonably safe with respect to the search results reported.\n\nThe `--save-config=FILE` option saves the configuration to the specified `FILE`.\nThe configuration is written to standard output when `FILE` is a `-`.\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"query\"/>\n\n### Interactive search with -Q\n\n    -Q[=DELAY], --query[=DELAY]\n            Query mode: user interface to perform interactive searches.  This\n            mode requires an ANSI capable terminal.  An optional DELAY argument\n            may be specified to reduce or increase the response time to execute\n            searches after the last key press, in increments of 100ms, where\n            the default is 5 (0.5s delay).  No whitespace may be given between\n            -Q and its argument DELAY.  Initial patterns may be specified with\n            -e PATTERN, i.e. a PATTERN argument requires option -e.  Press F1\n            or CTRL-Z to view the help screen.  Press F2 or CTRL-Y to invoke a\n            command to view or edit the file shown at the top of the screen.\n            The command can be specified with option --view, or defaults to\n            environment variable PAGER if defined, or EDITOR.  Press Tab and\n            Shift-Tab to navigate directories and to select a file to search.\n            Press Enter to select lines to output.  Press ALT-l for option -l\n            to list files, ALT-n for -n, etc.  Non-option commands include\n            ALT-] to increase fuzziness and ALT-} to increase context.  Enables\n            --heading.  See also options --confirm and --view.\n    --no-confirm\n            Do not confirm actions in -Q query mode.  The default is confirm.\n    --view[=COMMAND]\n            Use COMMAND to view/edit a file in query mode when pressing CTRL-Y.\n\nThis option starts a user interface to enter search patterns interactively:\n- Press F1 or CTRL-Z to view a help screen and to enable or disable options.\n- Press Alt with a key corresponding to a ugrep option letter or digit to\n  enable or disable the ugrep option.  For example, pressing Alt-c enables\n  option `-c` to count matches.  Pressing Alt-c again disables `-c`.  Options\n  can be toggled with the Alt key while searching or when viewing the help\n  screen.  If Alt/Meta keys are not supported (e.g. X11 xterm), then press\n  CTRL-O followed by the key corresponding to the option.\n- Press Alt-g to enter or edit option `-g` file and directory matching globs, a\n  comma-separated list of gitignore-style glob patterns.  Presssing ESC returns\n  control to the query pattern prompt (the globs are saved).  When a glob is\n  preceded by a `!` or a `^`, skips files whose name matches the glob When a\n  glob contains a `/`, full pathnames are matched.  Otherwise basenames are\n  matched.  When a glob ends with a `/`, directories are matched.\n- The query TUI prompt switches between `Q>` (normal), `F>` (fixed strings),\n  `G>` (basic regex), `P>` (Perl matching), and `Z>` (fuzzy matching).\n  When the `--glob=` prompt is shown, a comma-separated list of gitignore-style\n  glob patterns may be entered.  Presssing ESC returns control to the pattern\n  prompt.\n- Press Enter to switch to selection mode to select lines to output when ugrep\n  exits.  Normally, ugrep in query mode does not output any results unless\n  results are selected.  While in selection mode, select or deselect lines with\n  Enter or Del, or press A to select all results.\n- The file listed or shown at the top of the screen, or beneath the cursor in\n  selection mode, is edited by pressing F2 or CTRL-Y.  A file viewer or editor\n  may be specified with `--view=COMMAND`.  Otherwise, the `PAGER` or `EDITOR`\n  environment variables are used to invoke the command with CTRL-Y.  Filenames\n  must be enabled and visible in the output to use this feature.\n- Press TAB to chdir one level down into the directory of the file listed\n  or viewed at the top of the screen.  If no directory exists, the file itself\n  is selected to search.  Press Shift-TAB to go back up one level.\n- Press CTRL-T to toggle colors on and off.  Normally ugrep in query mode uses\n  colors and other markup to highlight results.  When colors are turned off,\n  selected results are also not colored in the output produced by ugrep when\n  ugrep exits.  When colors are turned on (the default), selected results are\n  colored depending on the `--color` option.\n- The query engine is optimized to limit system load by performing on-demand\n  searches to produce results only for the visible parts shown in the\n  interface.  That is, results are shown on demand, when scrolling down and\n  when exiting when all results are selected.  When the search pattern is\n  modified, the previous search query is cancelled when incomplete.  This\n  effectively limits the load on the system to maintain a high degree of\n  responsiveness of the query engine to user input.  Because the search results\n  are produced on demand, occasionally you may notice a flashing \"Searching...\"\n  message when searching files.\n- To display results faster, specify a low `DELAY` value such as 1.  However,\n  lower values may increase system load as a result of repeatedly initiating\n  and cancelling searches by each key pressed.\n- To avoid long pathnames to obscure the view, `--heading` is enabled by\n  default.  Press Alt-+ to switch headings off.\n\nQuery TUI key mapping:\n\nkey(s)                  | function\n----------------------- | -------------------------------------------------\n`Alt-key`               | toggle ugrep command-line option corresponding to `key`\n`Alt-/`xxxx`/`          | insert Unicode hex code point U+xxxx\n`Esc` `Ctrl-[` `Ctrl-C` | go back or exit\n`Ctrl-Q`                | quick exit and output the results selected in selection mode\n`Tab`                   | chdir to the directory of the file shown at the top of the screen or select file\n`Shift-Tab`             | chdir one level up or deselect file\n`Enter`                 | enter selection mode and toggle selected lines to output on exit\n`Up` `Ctrl-P`           | move up\n`Down` `Ctrl-N`         | move down\n`Left` `Ctrl-B`         | move left\n`Right` `Ctrl-F`        | move right\n`PgUp` `Ctrl-G`         | move display up by a page\n`PgDn` `Ctrl-D`         | move display down by a page\n`Alt-Up`                | move display up by 1/2 page (MacOS `Shift-Up`)\n`Alt-Down`              | move display down by 1/2 page (MacOS `Shift-Down`)\n`Alt-Left`              | move display left by 1/2 page (MacOS `Shift-Left`)\n`Alt-Right`             | move display right by 1/2 page (MacOS `Shift-Right`)\n`Home` `Ctrl-A`         | move cursor to the beginning of the line\n`End` `Ctrl-E`          | move cursor to the end of the line\n`Ctrl-K`                | delete after cursor\n`Ctrl-L`                | refresh screen\n`Ctrl-O`+`key`          | toggle ugrep command-line option corresponding to `key`, same as `Alt-key`\n`Ctrl-R` `F4`           | jump to bookmark\n`Ctrl-S`                | scroll to the next file\n`Ctrl-T`                | toggle colors on/off\n`Ctrl-U`                | delete before cursor\n`Ctrl-V`                | verbatim character\n`Ctrl-W`                | scroll back one file\n`Ctrl-X` `F3`           | set bookmark\n`Ctrl-Y` `F2`           | edit file shown at the top of the screen or under the cursor\n`Ctrl-Z` `F1`           | view help and options\n`Ctrl-^`                | chdir back to the starting working directory\n`Ctrl-\\`                | terminate process\n\nTo interactively search the files in the working directory and below:\n\n    ug -Q\n\nSame, but restricted to C++ files only and ignoring `.gitignore` files:\n\n    ug -Q -tc++ --ignore-files\n\nTo interactively search all makefiles in the working directory and below:\n\n    ug -Q -g 'Makefile*' -g 'makefile*'\n\nSame, but for up to 2 directory levels (working and one subdirectory level):\n\n    ug -Q -2 -g 'Makefile*' -g 'makefile*'\n\nTo interactively view the contents of `main.cpp` and search it, where `-y`\nshows any nonmatching lines as context:\n\n    ug -Q -y main.cpp\n\nTo interactively search `main.cpp`, starting with the search pattern `TODO` and\na match context of 5 lines (context can be interactively enabled and disabled,\nthis also overrides the default context size of 2 lines):\n\n    ug -Q -C5 -e TODO main.cpp\n\nTo view and search the contents of an archive (e.g. zip, tarball):\n\n    ug -Q -z archive.tar.gz\n\nTo interactively select files from `project.zip` to decompress with `unzip`,\nusing ugrep query selection mode (press Enter to select lines):\n\n    unzip project.zip `zipinfo -1 project.zip | ugrep -Q`\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"recursion\"/>\n\n### Recursively list matching files with -l, -R, -r, -S, --depth, -g, -O, and -t\n\n    -L, --files-without-match\n            Only the names of files not containing selected lines are written\n            to standard output.  Pathnames are listed once per file searched.\n            If the standard input is searched, the string ``(standard input)''\n            is written.  If --tree is specified, outputs directories in a\n            tree-like format.\n    -l, --files-with-matches\n            Only the names of files containing selected lines are written to\n            standard output.  ugrep will only search a file until a match has\n            been found, making searches potentially less expensive.  Pathnames\n            are listed once per file searched.  If the standard input is\n            searched, the string ``(standard input)'' is written.  If --tree is\n            specified, outputs directories in a tree-like format.\n    -R, --dereference-recursive\n            Recursively read all files under each directory.  Follow all\n            symbolic links to files and directories, unlike -r.\n    -r, --recursive\n            Recursively read all files under each directory, following symbolic\n            links only if they are on the command line.  Note that when no FILE\n            arguments are specified and input is read from a terminal,\n            recursive searches are performed as if -r is specified.\n    -S, --dereference-files\n            When -r is specified, symbolic links to files are followed, but not\n            to directories.  The default is not to follow symbolic links.\n    --depth=[MIN,][MAX], -1, -2, -3, ... -9, --10, --11, --12, ...\n            Restrict recursive searches from MIN to MAX directory levels deep,\n            where -1 (--depth=1) searches the specified path without recursing\n            into subdirectories.  Note that -3 -5, -3-5, and -35 search 3 to 5\n            levels deep.  Enables -r if -R or -r is not specified.\n    -g GLOBS, --glob=GLOBS\n            Search only files whose name matches the specified comma-separated\n            list of GLOBS, same as --include='glob' for each `glob' in GLOBS.\n            When a `glob' is preceded by a `!' or a `^', skip files whose name\n            matches `glob', same as --exclude='glob'.  When `glob' contains a\n            `/', full pathnames are matched.  Otherwise basenames are matched.\n            When `glob' ends with a `/', directories are matched, same as\n            --include-dir='glob' and --exclude-dir='glob'.  A leading `/'\n            matches the working directory.  This option may be repeated and may\n            be combined with options -M, -O and -t to expand searches.  See\n            `ugrep --help globs' and `man ugrep' section GLOBBING for details.\n    -O EXTENSIONS, --file-extension=EXTENSIONS\n            Search only files whose filename extensions match the specified\n            comma-separated list of EXTENSIONS, same as --include='*.ext' for\n            each `ext' in EXTENSIONS.  When `ext' is preceded by a `!' or a\n            `^', skip files whose filename extensions matches `ext', same as\n            --exclude='*.ext'.  This option may be repeated and may be combined\n            with options -g, -M and -t to expand the recursive search.\n    -t TYPES, --file-type=TYPES\n            Search only files associated with TYPES, a comma-separated list of\n            file types.  Each file type corresponds to a set of filename\n            extensions passed to option -O and filenames passed to option -g.\n            For capitalized file types, the search is expanded to include files\n            with matching file signature magic bytes, as if passed to option\n            -M.  When a type is preceded by a `!' or a `^', excludes files of\n            the specified type.  This option may be repeated.\n    --stats\n            Output statistics on the number of files and directories searched,\n            and the inclusion and exclusion constraints applied.\n\nIf no FILE arguments are specified and input is read from a terminal, recursive\nsearches are performed as if `-r` is specified.  To force reading from standard\ninput, specify `-` as the FILE argument.\n\nTo recursively list all non-empty files in the working directory:\n\n    ug -r -l ''\n\nTo list all non-empty files in the working directory but not deeper (since a\nFILE argument is given, in this case `.` for the working directory):\n\n    ug -l '' .\n\nTo list all non-empty files in directory `mydir` but not deeper (since a FILE\nargument is given):\n\n    ug -l '' mydir\n\nTo list all non-empty files in directory `mydir` and deeper while following\nsymlinks:\n\n    ug -R -l '' mydir\n\nTo recursively list all non-empty files on the path specified, while visiting\nsubdirectories only, i.e. directories `mydir/` and subdirectories at one\nlevel deeper `mydir/*/` are visited (note that `-2 -l` can be abbreviated to\n`-l2`):\n\n    ug -2 -l '' mydir\n\nTo recursively list all non-empty files in directory `mydir`, not following any\nsymbolic links (except when on the command line such as `mydir`):\n\n    ug -rl '' mydir\n\nTo recursively list all Makefiles matching the text `CPP`:\n\n    ug -l -tmake 'CPP'\n\nTo recursively list all `Makefile.*` matching `bin_PROGRAMS`:\n\n    ug -l -g'Makefile.*' 'bin_PROGRAMS'\n\nTo recursively list all non-empty files with extension .sh, with `-Osh`:\n\n    ug -l -Osh ''\n\nTo recursively list all shell scripts based on extensions and shebangs with\n`-tShell`:\n\n    ug -l -tShell ''\n\nTo recursively list all shell scripts based on extensions only with `-tshell`:\n\n    ug -l -tshell ''\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"bool\"/>\n\n### Boolean query patterns with --bool (-%), --and, --not\n\n    --bool, -%\n            Specifies Boolean query patterns.  A Boolean query pattern is\n            composed of `AND', `OR', `NOT' operators and grouping with `(' `)'.\n            Spacing between subpatterns is the same as `AND', `|' is the same\n            as `OR' and a `-' is the same as `NOT'.  The `OR' operator binds\n            more tightly than `AND'.  For example, --bool 'A|B C|D' matches\n            lines with (`A' or `B') and (`C' or `D'), --bool 'A -B' matches\n            lines with `A' and not `B'.  Operators `AND', `OR', `NOT' require\n            proper spacing.  For example, --bool 'A OR B AND C OR D' matches\n            lines with (`A' or `B') and (`C' or `D'), --bool 'A AND NOT B'\n            matches lines with `A' without `B'.  Quoted subpatterns are matched\n            literally as strings.  For example, --bool 'A \"AND\"|\"OR\"' matches\n            lines with `A' and also either `AND' or `OR'.  Parenthesis are used\n            for grouping.  For example, --bool '(A B)|C' matches lines with `A'\n            and `B', or lines with `C'.  Note that all subpatterns in a Boolean\n            query pattern are regular expressions, unless -F is specified.\n            Options -E, -F, -G, -P and -Z can be combined with --bool to match\n            subpatterns as strings or regular expressions (-E is the default.)\n            This option does not apply to -f FILE patterns.  Option --stats\n            displays the search patterns applied.  See also options --and,\n            --andnot, --not, --files and --lines.\n    --files\n            Apply Boolean queries to match files, the opposite of --lines.  A\n            file matches if all Boolean conditions are satisfied by the lines\n            matched in the file.  For example, --files -e A --and -e B -e C\n            --andnot -e D matches a file if some lines match `A' and some lines\n            match (`B' or `C') and no line in the file matches `D'.  May also\n            be specified as --files --bool 'A B|C -D'.  Option -v cannot be\n            specified with --files.  See also options --and, --andnot, --not,\n            --bool and --lines.\n    --lines\n            Apply Boolean queries to match lines, the opposite of --files.\n            This is the default Boolean query mode to match specific lines.\n    --and [[-e] PATTERN] ... -e PATTERN\n            Specify additional patterns to match.  Patterns must be specified\n            with -e.  Each -e PATTERN following this option is considered an\n            alternative pattern to match, i.e. each -e is interpreted as an OR\n            pattern.  For example, -e A -e B --and -e C -e D matches lines with\n            (`A' or `B') and (`C' or `D').  Note that multiple -e PATTERN are\n            alternations that bind more tightly together than --and.  Option\n            --stats displays the search patterns applied.  See also options\n            --not, --andnot, and --bool.\n    --andnot [[-e] PATTERN] ...\n            Combines --and --not.  See also options --and, --not, and --bool.\n    --not [-e] PATTERN\n            Specifies that PATTERN should not match.  Note that -e A --not -e B\n            matches lines with `A' or lines without a `B'.  To match lines with\n            `A' that have no `B', specify -e A --andnot -e B.  Option --stats\n            displays the search patterns applied.  See also options --and,\n            --andnot, and --bool.\n    --stats\n            Output statistics on the number of files and directories searched,\n            and the inclusion and exclusion constraints applied.\n\nNote that the `--and`, `--not`, and `--andnot` options require `-e PATTERN`.\n\nThe `--bool` option makes all patterns Boolean-based, supporting the following\nlogical operations listed from the highest level of precedence to the lowest:\n\noperator | alternative | result\n-------- | ----------- | -------\n`\"x\"`    |             | match `x` literally and exactly as specified (using the standard regex escapes `\\Q` and `\\E`)\n`( )`    |             | Boolean expression grouping\n`-x`     | `NOT x`     | inverted match, i.e. matches if `x` does not match\n`x\\|y`   | `x OR y`    | matches lines with `x` or `y`\n`x y`    | `x AND y`   | matches lines with both `x` and `y`\n\n- `x` and `y` are subpatterns that do not start with the special symbols `|`,\n  `-`, and `(` (use quotes or a `\\` escape to match these);\n\n- `-` and `NOT` are the same and take precedence over `OR`, which means that\n  `-x|y` == `(-x)|y` for example.\n\n- `|` and `OR` are the same and take precedence over `AND`, which means that\n  `x y|z` == `x (y|z)` for example;\n\nThe `--stats` option displays the Boolean queries in human-readable form\nconverted to CNF (Conjunctive Normal Form), after the search is completed.\nTo show the CNF without a search, read from standard input terminated by an\nEOF, like `echo | ugrep --bool '...' --stats`.\n\nSubpatterns are color-highlighted in the output, except those negated with\n`NOT` (a `NOT` subpattern may still show up in a matching line when using an\nOR-NOT pattern like `x|-y`).  Note that subpatterns may overlap.  In that\ncase only the first matching subpattern is color-highlighted.\n\nMultiple lines may be matched when subpatterns match newlines.  There is one\nexception however: subpatterns ending with `(?=X)` lookaheads may not match\nwhen `X` spans multiple lines.\n\nEmpty patterns match any line (grep standard).  Therefore, `--bool 'x|\"\"|y'`\nmatches everything and `x` and `y` are not color-highlighted.  Option `-y`\nshould be used to show every line as context, for example `-y 'x|y'`.\n\nFzf-like interactive querying (Boolean search with fixed strings with fuzzy\nmatching to allow e.g. up to 4 extra characters matched with `-Z+4` in words\nwith `-w`), press TAB and ALT-y to view a file with matches.  Press SHIFT-TAB\nand ALT-l to go back to the list of matching files:\n\n    ug -Q1 --bool -l -w -F -Z+4 --sort=best\n\nTo recursively find all files containing both `hot` and `dog` anywhere in the\nfile with option `--files`:\n\n    ug --files --bool 'hot dog'\n    ug --files -e hot --and dog\n\nTo find lines containing both `hot` and `dog` in `myfile.txt`:\n\n    ug --bool 'hot dog' myfile.txt\n    ug -e hot --and dog myfile.txt\n\nTo find lines containing `place` and then also `hotdog` or `taco` (or both) in\n`myfile.txt`:\n\n    ug --bool 'hotdog|taco place' myfile.txt\n    ug -e hotdog -e taco --and place myfile.txt\n\nSame, but exclude lines matching `diner`:\n\n    ug --bool 'hotdog|taco place -diner' myfile.txt\n    ug -e hotdog -e taco --and place --andnot diner myfile.txt\n\nTo find lines with `diner` or lines that match both `fast` and `food` but not `bad` in `myfile.txt`:\n\n    ug --bool 'diner|(fast food -bad)' myfile.txt\n\nTo find lines with `fast food` (exactly) or lines with `diner` but not `bad` or `old` in `myfile.txt`:\n\n    ug --bool '\"fast food\"|diner -bad -old' myfile.txt\n\nSame, but using a different Boolean expression that has the same meaning:\n\n    ug --bool '\"fast food\"|diner -(bad|old)' myfile.txt\n\nTo find lines with `diner` implying `good` in `myfile.txt` (that is, show lines\nwith `good` without `diner` and show lines with `diner` but only those with\n`good`, which is logically implied!):\n\n    ug --bool 'good|-diner' myfile.txt\n    ug -e good --not diner myfile.txt\n\nTo find lines with `foo` and `-bar` and `\"baz\"` in `myfile.txt` (not that `-`\nand `\"` should be matched using `\\` escapes and with `--and -e -bar`):\n\n    ug --bool 'foo \\-bar \\\"baz\\\"' myfile.txt\n    ug -e foo --and -e -bar --and '\"baz\"' myfile.txt\n\nTo search `myfile.cpp` for lines with `TODO` or `FIXME` but not both on the\nsame line, like XOR:\n\n    ug --bool 'TODO|FIXME -(TODO FIXME)' myfile.cpp\n    ug -e TODO -e FIXME --and --not TODO --not FIXME myfile.cpp\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"not\"/>\n\n### Search this but not that with -v, -e, -N, -f, -L, -w, -x\n\n    -e PATTERN, --regexp=PATTERN\n            Specify a PATTERN used during the search of the input: an input\n            line is selected if it matches any of the specified patterns.\n            Note that longer patterns take precedence over shorter patterns.\n            This option is most useful when multiple -e options are used to\n            specify multiple patterns, when a pattern begins with a dash (`-'),\n            to specify a pattern after option -f or after the FILE arguments.\n    -f FILE, --file=FILE\n            Read newline-separated patterns from FILE.  White space in patterns\n            is significant.  Empty lines in FILE are ignored.  If FILE does not\n            exist, the GREP_PATH environment variable is used as path to FILE.\n            If that fails, looks for FILE in /usr/local/share/ugrep/pattern.\n            When FILE is a `-', standard input is read.  This option may be\n            repeated.\n    -L, --files-without-match\n            Only the names of files not containing selected lines are written\n            to standard output.  Pathnames are listed once per file searched.\n            If the standard input is searched, the string ``(standard input)''\n            is written.\n    -N PATTERN, --neg-regexp=PATTERN\n            Specify a negative PATTERN used during the search of the input: an\n            input line is selected only if it matches the specified patterns\n            unless it matches the negative PATTERN.  Same as -e (?^PATTERN).\n            Negative pattern matches are essentially removed before any other\n            patterns are matched.  Note that longer patterns take precedence\n            over shorter patterns.  This option may be repeated.\n    -v, --invert-match\n            Selected lines are those not matching any of the specified\n            patterns.\n    -w, --word-regexp\n            The PATTERN is searched for as a word, such that the matching text\n            is preceded by a non-word character and is followed by a non-word\n            character.  Word characters are letters, digits, and the\n            underscore.  With option -P, word characters are Unicode letters,\n            digits, and underscore.  This option has no effect if -x is also\n            specified.  If a PATTERN is specified, or -e PATTERN or -N PATTERN,\n            then this option has no effect on -f FILE patterns to allow -f FILE\n            patterns to narrow or widen the scope of the PATTERN search.\n    -x, --line-regexp\n            Select only those matches that exactly match the whole line, as if\n            the patterns are surrounded by ^ and $.  If a PATTERN is specified,\n            or -e PATTERN or -N PATTERN, then this option does not apply to\n            -f FILE patterns to allow -f FILE patterns to narrow or widen the\n            scope of the PATTERN search.\n\nSee also [Boolean query patterns with --bool (-%), --and, --not](#bool) for\nmore powerful Boolean query options than the traditional GNU/BSD grep options.\n\nTo display lines in file `myfile.sh` but not lines matching `^[ \\t]*#`:\n\n    ug -v '^[ \\t]*#' myfile.sh\n\nTo search `myfile.cpp` for lines with `FIXME` and `urgent`, but not `Scotty`:\n\n    ugrep FIXME myfile.cpp | ugrep urgent | ugrep -v Scotty\n\nSame, but using `--bool` for Boolean queries:\n\n    ug --bool 'FIXME urgent -Scotty' myfile.cpp\n\nTo search for decimals using pattern `\\d+` that do not start with `0` using\nnegative pattern `0\\d+` and excluding `555`:\n\n    ug -e '\\d+' -N '0\\d+' -N 555 myfile.cpp\n\nTo search for words starting with `disp` without matching `display` in file\n`myfile.py` by using a \"negative pattern\" `-N '/<display\\>'` where `-N`\nspecifies an additional negative pattern to skip matches:\n\n    ug -e '\\<disp' -N '\\<display\\>' myfile.py\n\nTo search for lines with the word `display` in file `myfile.py` skipping this\nword in strings and comments, where `-f` specifies patterns in files which are\npredefined patterns in this case:\n\n    ug -n -w 'display' -f python/zap_strings -f python/zap_comments myfile.py\n\nTo display lines that are not blank lines:\n\n    ug -x -e '.*' -N '\\h*' myfile.py\n\nSame, but using `-v` and `-x` with `\\h*`, i.e. pattern `^\\h*$`:\n\n    ug -v -x '\\h*' myfile.py\n\nTo recursively list all Python files that do not contain the word `display`,\nallowing the word to occur in strings and comments:\n\n    ug -RL -tPython -w 'display' -f python/zap_strings -f python/zap_comments\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"encoding\"/>\n\n### Search non-Unicode files with --encoding\n\n    --encoding=ENCODING\n            The encoding format of the input.  The default ENCODING is binary\n            and UTF-8 which are the same.  Note that option -U specifies binary\n            PATTERN matching (text matching is the default.)\n\nBinary, ASCII and UTF-8 files do not require this option to search them.  Also\nUTF-16 and UTF-32 files do not require this option to search them, assuming\nthat UTF-16 and UTF-32 files start with a UTF BOM\n([byte order mark](https://en.wikipedia.org/wiki/Byte_order_mark)) as usual.\nOther file encodings require option `--encoding=ENCODING`:\n\nencoding               | parameter\n---------------------- | --------------\nASCII                  | *n/a*\nUTF-8                  | *n/a*\nUTF-16 with BOM        | *n/a*\nUTF-32 with BOM        | *n/a*\nUTF-16 BE w/o BOM      | `UTF-16` or `UTF-16BE`\nUTF-16 LE w/o BOM      | `UTF-16LE`\nUTF-32 w/o BOM         | `UTF-32` or `UTF-32BE`\nUTF-32 w/o BOM         | `UTF-32LE`\nLatin-1                | `LATIN1` or `ISO-8859-1`\nISO-8859-1             | `ISO-8859-1`\nISO-8859-2             | `ISO-8859-2`\nISO-8859-3             | `ISO-8859-3`\nISO-8859-4             | `ISO-8859-4`\nISO-8859-5             | `ISO-8859-5`\nISO-8859-6             | `ISO-8859-6`\nISO-8859-7             | `ISO-8859-7`\nISO-8859-8             | `ISO-8859-8`\nISO-8859-9             | `ISO-8859-9`\nISO-8859-10            | `ISO-8859-10`\nISO-8859-11            | `ISO-8859-11`\nISO-8859-13            | `ISO-8859-13`\nISO-8859-14            | `ISO-8859-14`\nISO-8859-15            | `ISO-8859-15`\nISO-8859-16            | `ISO-8859-16`\nMAC (CR=newline)       | `MAC`\nMacRoman (CR=newline)  | `MACROMAN`\nEBCDIC                 | `EBCDIC`\nDOS code page 437      | `CP437`\nDOS code page 850      | `CP850`\nDOS code page 858      | `CP858`\nWindows code page 1250 | `CP1250`\nWindows code page 1251 | `CP1251`\nWindows code page 1252 | `CP1252`\nWindows code page 1253 | `CP1253`\nWindows code page 1254 | `CP1254`\nWindows code page 1255 | `CP1255`\nWindows code page 1256 | `CP1256`\nWindows code page 1257 | `CP1257`\nWindows code page 1258 | `CP1258`\nKOI8-R                 | `KOI8-R`\nKOI8-U                 | `KOI8-U`\nKOI8-RU                | `KOI8-RU`\n\nNote that regex patterns are always specified in UTF-8 (includes ASCII).  To\nsearch binary files with binary patterns, see\n[searching and displaying binary files with -U, -W, and -X](#binary).\n\nTo recursively list all files that are ASCII (i.e. 7-bit):\n\n    ug -RL '[^[:ascii:]]'\n\nTo recursively list all files that are non-ASCII, i.e. UTF-8, UTF-16, and\nUTF-32 files with non-ASCII Unicode characters (U+0080 and up):\n\n    ug -Rl '[^[:ascii:]]'\n\nTo check if a file contains non-ASCII Unicode (U+0080 and up):\n\n    ug -q '[^[:ascii:]]' myfile && echo \"contains Unicode\"\n\nTo remove invalid Unicode characters from a file (note that `-o` does not work\nbecause binary data is detected and rejected and newlines are added, but\n`--format=\"%o%` does not check for binary and copies the match \"as is\"):\n\n    ug \"\\p{Unicode}\" --format=\"%o\" badfile.txt\n\nTo recursively list files with invalid UTF content (i.e. invalid UTF-8 byte\nsequences or files that contain any UTF-8/16/32 code points that are outside\nthe valid Unicode range) by matching any code point with `.` and by using a\nnegative pattern `-N '\\p{Unicode}'`:\n\n    ug -Rl -e '.' -N '\\p{Unicode}'\n\nTo display lines containing laughing face emojis:\n\n    ug '[😀-😏]' emojis.txt\n\nThe same results are obtained using `\\x{hhhh}` to select a Unicode character\nrange:\n\n    ug '[\\x{1F600}-\\x{1F60F}]' emojis.txt\n\nTo display lines containing the names Gödel (or Goedel), Escher, or Bach:\n\n    ug 'G(ö|oe)del|Escher|Bach' GEB.txt wiki.txt\n\nTo search for `lorem` in lower or upper case in a UTF-16 file that is marked\nwith a UTF-16 BOM:\n\n    ug -iw 'lorem' utf16lorem.txt\n\nTo search utf16lorem.txt when this file has no UTF-16 BOM, using `--encoding`:\n\n    ug --encoding=UTF-16 -iw 'lorem' utf16lorem.txt\n\nTo search file `spanish-iso.txt` encoded in ISO-8859-1:\n\n    ug --encoding=ISO-8859-1 -w 'año' spanish-iso.txt\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"multiline\"/>\n\n### Matching multiple lines of text\n\n    -o, --only-matching\n            Output only the matching part of lines.  Output additional matches\n            on the same line with `+' as the field separator.  When multiple\n            lines match a pattern, output the matching lines with `|' as the\n            field separator.  If -A, -B or -C is specified, fits the match and\n            its context on a line within the specified number of columns.\n\nMultiple lines may be matched by patterns that match newline characters.  Use\noption `-o` to output the match only, not the full lines(s) that match.\n\nTo match a `\\n` line break, include `\\n` in the pattern to match the LF\ncharacter.  If you want to match `\\r\\n` and `\\n` line breaks, use `\\r?\\n` or\nsimply use `\\R` to match any Unicode line break `\\r\\n`, `\\r`, `\\v`, `\\f`, `\\n`,\nU+0085, U+2028 and U+2029.\n\nTo match C/C++ `/*...*/` multi-line comments:\n\n    ug '/\\*([^*]|\\n|(\\*+([^*/]|\\n)))*\\*+\\/' myfile.cpp\n\nTo match C/C++ comments using the predefined `c/comments` patterns with\n`-f c/comments`, restricted to the matching part only with option `-o`:\n\n    ug -of c/comments myfile.cpp\n\nSame as `sed -n '/begin/,/end/p'`: to match all lines between a line containing\n`begin` and the first line after that containing `end`, using lazy repetition:\n\n    ug -o '.*begin(.|\\n)*?end.*' myfile.txt\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"context\"/>\n\n### Displaying match context with -A, -B, -C, -y, and --width\n\n    -A NUM, --after-context=NUM\n            Output NUM lines of trailing context after matching lines.  Places\n            a --group-separator between contiguous groups of matches.  If -o is\n            specified, output the match with context to fit NUM columns after\n            the match or shortens the match.  See also options -B, -C and -y.\n    -B NUM, --before-context=NUM\n            Output NUM lines of leading context before matching lines.  Places\n            a --group-separator between contiguous groups of matches.  If -o is\n            specified, output the match with context to fit NUM columns before\n            the match or shortens the match.  See also options -A, -C and -y.\n    -C NUM, --context=NUM\n            Output NUM lines of leading and trailing context surrounding each\n            matching line.  Places a --group-separator between contiguous\n            groups of matches.  If -o is specified, output the match with\n            context to fit NUM columns before and after the match or shortens\n            the match.  See also options -A, -B and -y.\n    -y, --any-line\n            Any line is output (passthru).  Non-matching lines are output as\n            context with a `-' separator.  See also options -A, -B, and -C.\n    --width[=NUM]\n            Truncate the output to NUM visible characters per line.  The width\n            of the terminal window is used if NUM is not specified.  Note that\n            double wide characters in the output may result in wider lines.\n    -o, --only-matching\n            Output only the matching part of lines.  Output additional matches\n            on the same line with `+' as the field separator.  When multiple\n            lines match a pattern, output the matching lines with `|' as the\n            field separator.  If -A, -B or -C is specified, fits the match and\n            its context on a line within the specified number of columns.\n\nTo display two lines of context before and after a matching line:\n\n    ug -C2 'FIXME' myfile.cpp\n\nTo show three lines of context after a matched line:\n\n    ug -A3 'FIXME.*' myfile.cpp:\n\nTo display one line of context before each matching line with a C function\ndefinition (C names are non-Unicode):\n\n    ug -B1 -f c/functions myfile.c\n\nTo display one line of context before each matching line with a C++ function\ndefinition (C++ names may be Unicode):\n\n    ug -B1 -f c++/functions myfile.cpp\n\nTo display any non-matching lines as context for matching lines with `-y`:\n\n    ug -y -f c++/functions myfile.cpp\n\nTo display a hexdump of a matching line with one line of hexdump context:\n\n    ug -C1 -UX '\\xaa\\xbb\\xcc' a.out\n\nContext within a line is displayed with option `-o` with a context option:\n\n    ug -o -C20 'pattern' myfile.cpp\n\nSame, but with pretty output with headings, line numbers and column numbers\n(`-k`) and showing context:\n\n    ug --pretty -oC20 'pattern' myfile.cpp\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"source\"/>\n\n### Searching source code using -f, -g, -O, and -t\n\n    -f FILE, --file=FILE\n            Read newline-separated patterns from FILE.  White space in patterns\n            is significant.  Empty lines in FILE are ignored.  If FILE does not\n            exist, the GREP_PATH environment variable is used as path to FILE.\n            If that fails, looks for FILE in /usr/local/share/ugrep/pattern.\n            When FILE is a `-', standard input is read.  This option may be\n            repeated.\n    --ignore-files[=FILE]\n            Ignore files and directories matching the globs in each FILE that\n            is encountered in recursive searches.  The default FILE is\n            `.gitignore'.  Matching files and directories located in the\n            directory of a FILE's location and in directories below are ignored\n            by temporarily extending the --exclude and --exclude-dir globs, as\n            if --exclude-from=FILE is locally enforced.  Globbing syntax is the\n            same as the --exclude-from=FILE gitignore syntax; directories are\n            excluded when the glob ends in a `/', same as git.  Files and\n            directories explicitly specified as command line arguments are\n            never ignored.  This option may be repeated with additional files.\n    -g GLOBS, --glob=GLOBS\n            Search only files whose name matches the specified comma-separated\n            list of GLOBS, same as --include='glob' for each `glob' in GLOBS.\n            When a `glob' is preceded by a `!' or a `^', skip files whose name\n            matches `glob', same as --exclude='glob'.  When `glob' contains a\n            `/', full pathnames are matched.  Otherwise basenames are matched.\n            When `glob' ends with a `/', directories are matched, same as\n            --include-dir='glob' and --exclude-dir='glob'.  A leading `/'\n            matches the working directory.  This option may be repeated and may\n            be combined with options -M, -O and -t to expand searches.  See\n            `ugrep --help globs' and `man ugrep' section GLOBBING for details.\n    -O EXTENSIONS, --file-extension=EXTENSIONS\n            Search only files whose filename extensions match the specified\n            comma-separated list of EXTENSIONS, same as --include='*.ext' for\n            each `ext' in EXTENSIONS.  When `ext' is preceded by a `!' or a\n            `^', skip files whose filename extensions matches `ext', same as\n            --exclude='*.ext'.  This option may be repeated and may be combined\n            with options -g, -M and -t to expand the recursive search.\n    -t TYPES, --file-type=TYPES\n            Search only files associated with TYPES, a comma-separated list of\n            file types.  Each file type corresponds to a set of filename\n            extensions passed to option -O and filenames passed to option -g.\n            For capitalized file types, the search is expanded to include files\n            with matching file signature magic bytes, as if passed to option\n            -M.  When a type is preceded by a `!' or a `^', excludes files of\n            the specified type.  This option may be repeated.\n    --stats\n            Output statistics on the number of files and directories searched,\n            and the inclusion and exclusion constraints applied.\n\nThe file types are listed with `ugrep -tlist`.  The list is based on\nestablished filename extensions and \"magic bytes\".  If you have a file type\nthat is not listed, use options `-O` and/or `-M`.  You may want to define an\nalias, e.g. `alias ugft='ugrep -Oft'` as a shorthand to search files with\nfilename suffix `.ft`.\n\nTo recursively display function definitions in C/C++ files (`.h`, `.hpp`, `.c`,\n`.cpp` etc.) with line numbers with `-tc++`, `-o`, `-n`, and `-f c++/functions`:\n\n    ug -on -tc++ -f c++/functions\n\nTo recursively display function definitions in `.c` and `.cpp` files with line\nnumbers with `-Oc,cpp`, `-o`, `-n`, and `-f c++/functions`:\n\n    ug -on -Oc,cpp -f c++/functions\n\nTo recursively list all shell files with `-tShell` to match filename extensions\nand files with shell shebangs, except files with suffix `.sh`:\n\n    ug -l -tShell -O^sh ''\n\nTo recursively list all non-shell files with `-t^Shell`:\n\n    ug -l -t^Shell ''\n\nTo recursively list all shell files with shell shebangs that have no shell\nfilename extensions:\n\n    ug -l -tShell -t^shell ''\n\nTo search for lines with `FIXME` in C/C++ comments, excluding `FIXME` in\nmulti-line strings:\n\n    ug -n 'FIXME' -f c++/zap_strings myfile.cpp\n\nTo read patterns `TODO` and `FIXME` from standard input to match lines in the\ninput, while excluding matches in C++ strings:\n\n    ug -on -f - -f c++/zap_strings myfile.cpp <<END\n    TODO\n    FIXME\n    END\n\nTo display XML element and attribute tags in an XML file, restricted to the\nmatching part with `-o`, excluding tags that are placed in (multi-line)\ncomments:\n\n    ug -o -f xml/tags -f xml/zap_comments myfile.xml\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"archives\"/>\n\n### Searching compressed files and archives with -z\n\n    -z, --decompress\n            Decompress files to search, when compressed.  Archives (.cpio,\n            .pax, .tar) and compressed archives (e.g. .zip, .taz, .tgz, .tpz,\n            .tbz, .tbz2, .tb2, .tz2, .tlz, .txz, .tzst) are searched and\n            matching pathnames of files in archives are output in braces.  When\n            used with option --zmax=NUM, searches the contents of compressed\n            files and archives stored within archives up to NUM levels.  If -g,\n            -O, -M, or -t is specified, searches files stored in archives whose\n            filenames match globs, match filename extensions, match file\n            signature magic bytes, or match file types, respectively.\n            Supported compression formats: gzip (.gz), compress (.Z), zip,\n            bzip2 (requires suffix .bz, .bz2, .bzip2, .tbz, .tbz2, .tb2, .tz2),\n            lzma and xz (requires suffix .lzma, .tlz, .xz, .txz),\n            lz4 (requires suffix .lz4),\n            zstd (requires suffix .zst, .zstd, .tzst).\n    --zmax=NUM\n            When used with option -z (--decompress), searches the contents of\n            compressed files and archives stored within archives by up to NUM\n            expansion levels deep.  The default --zmax=1 only permits searching\n            uncompressed files stored in cpio, pax, tar and zip archives;\n            compressed files and archives are detected as binary files and are\n            effectively ignored.  Specify --zmax=2 to search compressed files\n            and archives stored in cpio, pax, tar and zip archives.  NUM may\n            range from 1 to 99 for up to 99 decompression and de-archiving\n            steps.  Increasing NUM values gradually degrades performance.\n\nFiles compressed with gzip (`.gz`), compress (`.Z`), bzip2 (`.bz`, `.bz2`,\n`.bzip2`), lzma (`.lzma`), xz (`.xz`), lz4 (`.lz4`) and zstd (`.zst`, `.zstd`)\nare searched with option `-z`.  This option does not require files to be\ncompressed.  Uncompressed files are searched also.\n\nOther compression formats can be searched with **ugrep** [filters](#filter).\n\nArchives (cpio, jar, pax, tar, and zip) are searched with option `-z`.  Regular\nfiles in an archive that match are output with the archive pathnames enclosed\nin `{` and `}` braces.  Supported tar formats are v7, ustar, gnu, oldgnu, and\npax.  Supported cpio formats are odc, newc, and crc.  Not supported is the\nobsolete non-portable old binary cpio format.  Archive formats cpio, tar, and\npax are automatically recognized with option `-z` based on their content,\nindependent of their filename suffix.\n\nBy default, uncompressed archives stored within zip archives are also searched:\nall cpio, pax, and tar files in zip archives are automatically recognized and\nsearched.  However, by default compressed files stored within archives are not\nrecognized, e.g. zip files stored within tar files are not searched but rather\nall compressed files and archives are searched as if they are binary files\nwithout decompressing them.\n\nSpecify `--zmax=NUM` to search archives that contain compressed files and\narchives for up to `NUM` levels deep.  The value of `NUM` may range from 1 to\n99 for up to 99 decompression and de-archiving steps to expand up to 99 nested\narchives.  Larger `--zmax=NUM` values degrade performance.  It is unlikely you\nwill ever need 99 as `--zmax=2` suffices for most practical use cases, such as\nsearching zip files stored in tar files.\n\nWhen option `-z` is used with options `-g`, `-O`, `-M`, or `-t`, archives and\ncompressed and uncompressed files that match the filename selection criteria\n(glob, extension, magic bytes, or file type) are searched only.  For example,\n`ugrep -r -z -tc++` searches C++ files such as `main.cpp` and zip and tar\narchives that contain C++ files such as `main.cpp`.  Also included in the\nsearch are compressed C++ files such as `main.cpp.gz` and `main.cpp.xz` when\npresent.  Also any cpio, pax, tar, and zip archives when present are searched\nfor C++ files that they contain, such as `main.cpp`.  Use option `--stats` to\nsee a list of the glob patterns applied to filter file pathnames in the\nrecursive search and when searching archive contents.\n\nWhen option `-z` is used with options `-g`, `-O`, `-M`, or `-t` to search cpio,\njar, pax, tar, and zip archives, archived files that match the filename selection\ncriteria are searched only.\n\nThe gzip, compress, and zip formats are automatically detected, which is useful\nwhen reading gzip-compressed data from standard input, e.g. input redirected\nfrom a pipe.  Other compression formats require a filename suffix: `.bz`,\n`.bz2`, or `.bzip2` for bzip2, `.lzma` for lzma, `.xz` for xz, `.lz4` for lz4\nand `.zst` or `.zstd` for zstd.  Also the compressed tar archive shorthands\n`.taz`, `.tgz` and `.tpz` for gzip, `.tbz`, `.tbz2`, `.tb2`, and `.tz2` for\nbzip2, `.tlz` for lzma, `.txz` for xz, and `.tzst` for zstd are recognized.  To\nsearch these formats with ugrep from standard input, use option\n`--label='stdin.bz2'` for bzip2, `--label='stdin.lzma'` for lzma,\n`--label='stdin.xz'` for xz, `--label='stdin.lz4` for lz4 and\n`--label='stdin.zst` for zstd.  The name `stdin` is arbitrary and may be\nomitted:\n\nformat    | filename suffix         | tar/pax archive short suffix    | suffix required? | ugrep from stdin | lib required |\n--------- | ----------------------- | ------------------------------- | ---------------- | ---------------- | ------------ |\ngzip      | `.gz`                   | `.taz`, `.tgz`, `.tpz`          | no               | automatic        | libz         |\ncompress  | `.Z`                    | `.taZ`, `.tZ`                   | no               | automatic        | *built-in*   |\nzip       | `.zip`, `.zipx`, `.ZIP` |                                 | no               | automatic        | libz         |\nbzip2     | `.bz`, `.bz2`, `.bzip2` | `.tb2`, `.tbz`, `.tbz2`, `.tz2` | yes              | `--label=.bz2`   | libbz2       |\nlzma      | `.lzma`                 | `.tlz`                          | yes              | `--label=.lzma`  | liblzma      |\nxz        | `.xz`                   | `.txz`                          | yes              | `--label=.xz`    | liblzma      |\nlz4       | `.lz4`                  |                                 | yes              | `--label=.lz4`   | liblz4       |\nzstd      | `.zst`, `.zstd`         | `.tzst`                         | yes              | `--label=.zst`   | libzstd      |\n\nThe gzip, bzip2, xz, lz4 and zstd formats support concatenated compressed\nfiles.  Concatenated compressed files are searched as one file.\n\nSupported zip compression methods are stored (0), deflate (8), bzip2 (12), lzma\n(14), xz (95) and zstd (93).  The bzip2, lzma, xz and zstd methods require\nugrep to be compiled with the corresponding compression libraries.\n\nSearching encrypted zip archives is not supported (perhaps in future releases,\ndepending on requests for enhancements).\n\nOption `-z` uses threads for task parallelism to speed up searching larger\nfiles by running the decompressor concurrently with a search of the\ndecompressed stream.\n\nTo list all non-empty files stored in a `package.zip` archive, including the\ncontents of all cpio, pax, tar and zip files that are stored in it:\n\n    ug --zmax=2 -z -l '' package.zip\n\nSame, but only list the Python source code files, including scripts that invoke\nPython, with option `-tPython` (`ugrep -tlist` for details):\n\n    ug --zmax=2 -z -l -tPython '' package.zip\n\nTo search Python applications distributed as a tar file with their dependencies\nincludes as wheels (zip files with Python code), searching for the word\n`my_class` in `app.tgz`:\n\n    ug --zmax=2 -z -tPython -w my_class app.tgz\n\nTo recursively search C++ files including compressed files for the word\n`my_function`, while skipping C and C++ comments:\n\n    ug -z -r -tc++ -Fw my_function -f cpp/zap_comments\n\nTo search bzip2, lzma, xz, lz4 and zstd compressed data on standard input,\noption `--label` may be used to specify the extension corresponding to the\ncompression format to force decompression when the bzip2 extension is not\navailable to ugrep, for example:\n\n    cat myfile.bz2 | ugrep -z --label='stdin.bz2' 'xyz'\n\nTo search file `main.cpp` in `project.zip` for `TODO` and `FIXME` lines:\n\n    ug -z -g main.cpp -w -e 'TODO' -e 'FIXME' project.zip\n\nTo search tarball `project.tar.gz` for C++ files with `TODO` and `FIXME` lines:\n\n    ug -z -tc++ -w -e 'TODO' -e 'FIXME' project.tar.gz\n\nTo search files matching the glob `*.txt` in `project.zip` for the word\n`license` in any case (note that the `-g` glob argument must be quoted):\n\n    ug -z -g '*.txt' -w -i 'license' project.zip\n\nTo display and page through all C++ files in tarball `project.tgz`:\n\n    ug --pager -z -tc++ '' project.tgz\n\nTo list the files matching the gitignore-style glob `/**/projects/project1.*`\nin `projects.tgz`, by selecting files containing in the archive the text\n`December 12`:\n\n    ug -z -l -g '/**/projects/project1.*' -F 'December 12' projects.tgz\n\nTo view the META-INF/MANIFEST.MF data in a jar file with `-Ojar` and `-OMF` to\nselect the jar file and the MF file therein (`-Ojar` is required, otherwise the\njar file will be skipped though we could read it from standard input instead):\n\n    ug -z -h -OMF,jar '' my.jar\n\nTo extract C++ files that contain `FIXME` from `project.tgz`, we use `-m1`\nwith `--format=\"'%z '\"` to generate a space-separated list of pathnames of file\nlocated in the archive that match the word `FIXME`:\n\n    tar xzf project.tgz `ugrep -z -l -tc++ --format='%z ' -w FIXME project.tgz`\n\nTo perform a depth-first search with `find`, then use `cpio` and `ugrep` to\nsearch the files:\n\n    find . -depth -print | cpio -o | ugrep -z 'xyz'\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"magic\"/>\n\n### Find files by file signature and shebang \"magic bytes\" with -M, -O and -t\n\n    --ignore-files[=FILE]\n            Ignore files and directories matching the globs in each FILE that\n            is encountered in recursive searches.  The default FILE is\n            `.gitignore'.  Matching files and directories located in the\n            directory of a FILE's location and in directories below are ignored\n            by temporarily extending the --exclude and --exclude-dir globs, as\n            if --exclude-from=FILE is locally enforced.  Globbing syntax is the\n            same as the --exclude-from=FILE gitignore syntax; directories are\n            excluded when the glob ends in a `/', same as git.  Files and\n            directories explicitly specified as command line arguments are\n            never ignored.  This option may be repeated with additional files.\n    -M MAGIC, --file-magic=MAGIC\n            Only files matching the signature pattern MAGIC are searched.  The\n            signature \\\"magic bytes\\\" at the start of a file are compared to\n            the MAGIC regex pattern.  When matching, the file will be searched.\n            When MAGIC is preceded by a `!' or a `^', skip files with matching\n            MAGIC signatures.  This option may be repeated and may be combined\n            with options -O and -t to expand the search.  Every file on the\n            search path is read, making searches potentially more expensive.\n    -O EXTENSIONS, --file-extension=EXTENSIONS\n            Search only files whose filename extensions match the specified\n            comma-separated list of EXTENSIONS, same as --include='*.ext' for\n            each `ext' in EXTENSIONS.  When `ext' is preceded by a `!' or a\n            `^', skip files whose filename extensions matches `ext', same as\n            --exclude='*.ext'.  This option may be repeated and may be combined\n            with options -g, -M and -t to expand the recursive search.\n    -t TYPES, --file-type=TYPES\n            Search only files associated with TYPES, a comma-separated list of\n            file types.  Each file type corresponds to a set of filename\n            extensions passed to option -O and filenames passed to option -g.\n            For capitalized file types, the search is expanded to include files\n            with matching file signature magic bytes, as if passed to option\n            -M.  When a type is preceded by a `!' or a `^', excludes files of\n            the specified type.  This option may be repeated.\n    -g GLOBS, --glob=GLOBS\n            Search only files whose name matches the specified comma-separated\n            list of GLOBS, same as --include='glob' for each `glob' in GLOBS.\n            When a `glob' is preceded by a `!' or a `^', skip files whose name\n            matches `glob', same as --exclude='glob'.  When `glob' contains a\n            `/', full pathnames are matched.  Otherwise basenames are matched.\n            When `glob' ends with a `/', directories are matched, same as\n            --include-dir='glob' and --exclude-dir='glob'.  A leading `/'\n            matches the working directory.  This option may be repeated and may\n            be combined with options -M, -O and -t to expand searches.  See\n            `ugrep --help globs' and `man ugrep' section GLOBBING for details.\n    --stats\n            Output statistics on the number of files and directories searched,\n            and the inclusion and exclusion constraints applied.\n\nTo recursively list all files that start with `#!` shebangs:\n\n    ug -l -M'#!' ''\n\nTo recursively list all files that start with `#` but not with `#!` shebangs:\n\n    ug -l -M'#' -M'^#!' ''\n\nTo recursively list all Python files (extension `.py` or a shebang) with\n`-tPython`:\n\n    ug -l -tPython ''\n\nTo recursively list all non-shell files with `-t^Shell`:\n\n    ug -l -t^Shell ''\n\nTo recursively list Python files (extension `.py` or a shebang) that have\nimport statements, including hidden files with `-.`:\n\n    ug -l. -tPython -f python/imports\n \n🔝 [Back to table of contents](#toc)\n\n<a name=\"fuzzy\"/>\n\n### Fuzzy search with -Z\n\n    -Z[best][+-~][MAX], --fuzzy=[best][+-~][MAX]\n            Fuzzy mode: report approximate pattern matches within MAX errors.\n            The default is -Z1: one deletion, insertion or substitution is\n            allowed.  If `+`, `-' and/or `~' is specified, then `+' allows\n            insertions, `-' allows deletions and `~' allows substitutions.  For\n            example, -Z+~3 allows up to three insertions or substitutions, but\n            no deletions.  If `best' is specified, then only the best matching\n            lines are output with the lowest cost per file.  Option -Zbest\n            requires two passes over a file and cannot be used with standard\n            input or Boolean queries.  Option --sort=best orders matching files\n            by best match.  The first character of an approximate match always\n            matches a character at the beginning of the pattern.  To fuzzy\n            match the first character, replace it with a `.' or `.?'.  Option\n            -U applies fuzzy matching to ASCII and bytes instead of Unicode\n            text.  No whitespace may be given between -Z and its argument.\n\nThe beginning of a pattern always matches the first character of an approximate\nmatch as a practical strategy to prevent many false \"randomized\" matches for\nshort patterns.  This also greatly improves search speed.  Make the first\ncharacter optional to optionally match it, e.g. `p?attern` or use a dot as\nthe start of the pattern to match any wide character (but this is slow).\n\nLine feed (`\\n`) and NUL (`\\0`) characters are never deleted or substituted to\nensure that fuzzy matches do not extend the pattern match beyond the number of\nlines specified by the regex pattern.\n\nOption `-U` (`--ascii` or `--binary`) restricts fuzzy matches to ASCII and\nbinary only with edit distances measured in bytes.  Otherwise, fuzzy pattern\nmatching is performed with Unicode patterns and edit distances are measured in\nUnicode characters.\n\nOption `--sort=best` orders files by best match.  Files with at least one exact\nmatch anywhere in the file are shown first, followed by files with approximate\nmatches in increasing minimal edit distance order.  That is, ordered by the\nminimum error (edit distance) found among all approximate matches per file.\n\nTo recursively search for approximate matches of the word `foobar` with `-Z`,\ni.e.  approximate matching with one error, e.g. `Foobar`, `foo_bar`, `foo bar`,\n`fobar` and other forms with one missing, one extra or one deleted character:\n\n    ug -Z 'foobar'\n\nSame, but matching words only with `-w` and ignoring case with `-i`:\n\n    ug -Z -wi 'foobar'\n\nSame, but permit up to 2 insertions with `-Z+2`, no deletions/substitutions\n(matches up to 2 extra characters, such as `foos bar`), insertions-only offers\nthe fastest fuzzy matching method:\n\n    ug -Z+3 -wi 'foobar'\n\nSame, but sort matches from best (at least one exact match or fewest fuzzy\nmatch errors) to worst:\n\n    ug -Z+3 -wi --sort=best 'foobar'\n\n**Note:** because sorting by best match requires two passes over the input\nfiles, the efficiency of concurrent searching is significantly reduced.\n\nSame, but with customized formatting to show the edit distance \"cost\" of the\napproximate matches with format field `%Z` and `%F` to show the pathname:\n\n    ug -Z+3 -wi --format='%F%Z:%O%~' --sort=best 'foobar'\n\nSame, but this time count the matches with option `-c` and display them with a\ncustom format using `%m`, where `%Z` is the *average* cost per match:\n\n    ug -c -Z+3 -wi --format='%F%Z:%m%~' --sort=best 'foobar'\n\n**Note:** options `-c` and `-l` do not report a meaningful `%Z` value in the\n`--format` output, because `%Z` is the edit distance cost of a single match.\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"hidden\"/>\n\n### Search hidden files with -.\n\n    --hidden, -.\n            Search hidden files and directories.\n\nTo recursively search the working directory, including hidden files and\ndirectories, for the word `login` in shell scripts:\n\n    ug -. -tShell 'login'\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"filter\"/>\n\n### Using filter utilities to search documents with --filter\n\n    --filter=COMMANDS\n            Filter files through the specified COMMANDS first before searching.\n            COMMANDS is a comma-separated list of `exts:command [option ...]',\n            where `exts' is a comma-separated list of filename extensions and\n            `command' is a filter utility.  Files matching one of `exts' are\n            filtered.  When `exts' is a `*', all files are filtered.  One or\n            more `option' separated by spacing may be specified, which are\n            passed verbatim to the command.  A `%' as `option' expands into the\n            pathname to search.  For example, --filter='pdf:pdftotext % -'\n            searches PDF files.  The `%' expands into a `-' when searching\n            standard input.  When a `%' is not specified, a filter utility\n            should read from standard input and write to standard output.\n            Option --label=.ext may be used to specify extension `ext' when\n            searching standard input.  This option may be repeated.\n    --filter-magic-label=LABEL:MAGIC\n            Associate LABEL with files whose signature \"magic bytes\" match the\n            MAGIC regex pattern.  Only files that have no filename extension\n            are labeled, unless +LABEL is specified.  When LABEL matches an\n            extension specified in --filter=COMMANDS, the corresponding command\n            is invoked.  This option may be repeated.\n\nThe `--filter` option associates one or more filter utilities with specific\nfilename extensions.  A filter utility is selected based on the filename\nextension and executed by forking a process:  the utility's standard input\nreads the open input file and the utility's standard output is searched.  When\na `%` is specified as an option to the utility, the `%` is expanded to the\npathname of the file to open and read by the utility.\n\nWhen a specified utility is not found on the system, an error message is\ndisplayed.  When a utility fails to produce output, e.g. when the specified\noptions for the utility are invalid, the search is silently skipped.\n\nFiltering does not apply to files stored in archives and compressed files.  A\nfilter is usually applied to a file that is physically stored in the file\nsystem.  Archived files are not physically stored.\n\nCommon filter utilities are `cat` (concat, pass through), `head` (select first\nlines or bytes) `tr` (translate), `iconv` and `uconv` (convert), and more\nadvanced utilities, such as:\n\n- [`pdftotext`](https://pypi.org/project/pdftotext) to convert pdf to text\n- [`antiword`](https://github.com/rsdoiel/antiword) to convert doc to text\n- [`pandoc`](https://pandoc.org) to convert .docx, .epub, and other document\n  formats\n- [`exiftool`](https://exiftool.sourceforge.net) to read meta information\n  embedded in image and video media formats.\n- [`soffice`](https://www.libreoffice.org) to convert office documents\n- [`csvkit`](https://pypi.org/project/csvkit) to convert spreadsheets\n- [`openssl`](https://wiki.openssl.org/index.php/Command_Line_Utilities) to\n  convert certificates and key files to text and other formats\n\nThe `ugrep+` and `ug+` commands use the `pdftotext`, `antiword`, `pandoc` and\n`exiftool` filters, when installed, to search pdfs, documents, e-books, and\nimage metadata.\n\nAlso decompressors may be used as filter utilities, such as `unzip`, `gunzip`,\n`bunzip2`, `unlzma`, `unxz`, `lzop` and `7z` that decompress files to standard\noutput when option `--stdout` is specified.  For example:\n\n    ug --filter='lzo:lzop -d --stdout -' ...\n    ug --filter='gz:gunzip -d --stdout -' ...\n    ug --filter='7z:7z x -so %' ...\n\nThe `--filter='lzo:lzop -d --stdout -'` option decompresses files with\nextension `lzo` to standard output with `--stdout` with the compressed stream\nbeing read from standard input with `-`.  The `--filter='7z:7z x -so -si`\noption decompresses files with extension `7z` to standard output `-so` while\nreading standard input `-si` with the compressed file contents.\n\nNote that **ugrep** option `-z` is typically faster to search compressed files\ncompared to `--filter`.\n\nThe `--filter` option may also be used to run a user-defined shell script to\nfilter files.  For example, to invoke an action depending on the filename\nextension of the `%` argument.  Another use case is to pass a file to more than\none filter, which can be accomplished with a shell script containing the line\n`tool1 $1; tool2 $1`.  This filters the file argument `$1` with `tool1`\nfollowed by `tool2` to produce combined output to search for pattern matches.\nLikewise, we can use a script with the line `tool1 $1 | tool2` to stack two\nfilters `tool1` and `tool2`.\n\nThe `--filter` option may also be used as a predicate to skip certain files\nfrom the search.  As the most basic example, consider the `false` utility that\nexits with a nonzero exit code without reading input or producing output.\nTherefore, `--filter='swp: false'` skips all `.swp` files from recursive\nsearches.  The same can be done more efficiently with `-O^swp`.  However,\nthe `--filter` option could invoke a script that determines if the filename\npassed as a `%` argument meets certain constraints.  If the constraint is met\nthe script copies standard input to standard output with `cat`.  If not, the\nscript exits.\n\n**Warning:** option `--filter` should not be used with utilities that modify\nfiles.  Otherwise searches may be unpredicatable.  In the worst case files may\nbe lost, for example when the specified utility replaces or deletes the file\npassed to the command with `--filter` option `%`.\n\nTo recursively search files including PDF files in the working directory\nwithout recursing into subdirectories (with `-1`), for matches of `drink me`\nusing the `pdftotext` filter to convert PDF to text without preserving page\nbreaks:\n\n    ug -r -1 --filter='pdf:pdftotext -nopgbrk % -' 'drink me'\n\nTo recursively search text files for `eat me` while converting non-printable\ncharacters in .txt and .md files using the `cat -v` filter:\n\n    ug -r -ttext --filter='txt,md:cat -v' 'eat me'\n\nThe same, but specifying the .txt and .md filters separately:\n\n    ug -r -ttext --filter='txt:cat -v, md:cat -v' 'eat me'\n\nTo search the first 8K of a text file:\n\n    ug --filter='txt:head -c 8192' 'eat me' wonderland.txt\n\nTo recursively search and list the files that contain the word `Alice`,\nincluding .docx and .epub documents using the `pandoc` filter:\n\n    ug -rl -w --filter='docx,epub:pandoc --wrap=preserve -t plain % -o -' 'Alice'\n\n**Important:** the `pandoc` utility requires an input file and will not read\nstandard input.  Option `%` expands into the full pathname of the file to\nsearch.  The output format specified is `markdown`, which is close enough to\ntext to be searched.\n\nTo recursively search and list the files that contain the word `Alice`,\nincluding .odt, .doc, .docx, .rtf, .xls, .xlsx, .ppt, .pptx documents using the\n`soffice` filter:\n\n    ug -rl -w --filter='odt,doc,docx,rtf,xls,xlsx,ppt,pptx:soffice --headless --cat %' 'Alice'\n\n**Important:** the `soffice` utility will not output any text when one or more\nLibreOffice GUIs are open.  Make sure to quit all LibreOffice apps first.  This\nlooks like a bug, but the LibreOffice developers do not appear to fix this\nany time soon (unless perhaps more people complain?)\n\nTo recursively search and display rows of .csv, .xls, and .xlsx spreadsheets\nthat contain `10/6` using the `in2csv` filter of csvkit:\n\n    ug -r -Ocsv,xls,xlsx --filter='xls,xlsx:in2csv %' '10/6'\n\nTo search .docx, .xlsx, and .pptx files converted to XML for a match with\n`10/6` using `unzip` as a filter:\n\n    ug -lr -Odocx,xlsx,pptx --filter='docx,xlsx,pptx:unzip -p %' '10/6'\n\n**Important:** unzipping docx, xlxs, pptx files produces extensive XML output\ncontaining meta information and binary data such as images.  By contrast,\n**ugrep** option `-z` with `-Oxml` selects the XML components only:\n\n    ug -z -lr -Odocx,xlsx,pptx,xml '10/6'\n\n**Note:** docx, xlsx, and pptx are zip files containing multiple components.\nWhen selecting the XML components with option `-Oxml` in docx, xlsx, and pptx\ndocuments, we should also specify `-Odocx,xlsx,pptx` to search these type of\nfiles, otherwise these files will be ignored.\n\nTo recurssively search X509 certificate files for lines with `Not After` (e.g.\nto find expired certificates), using `openssl` as a filter:\n\n    ug -r 'Not After' -Ocer,der,pem --filter='pem:openssl x509 -text,cer,crt,der:openssl x509 -text -inform der'\n\nNote that `openssl` warning messages are displayed on standard error.  If\na file cannot be converted it is probably in a different format.  This can\nbe resolved by writing a shell script that executes `openssl` with options\nbased on the file content.  Then write a script with `ugrep --filter`.\n\nTo search PNG files by filename extension with `-tpng` using `exiftool`:\n\n    ug -r -i 'copyright' -tpng --filter='*:exiftool %'\n\nSame, but also include files matching PNG \"magic bytes\" with `-tPng` and\n`--filter-magic-label='+png:\\x89png\\x0d\\x0a\\x1a\\x0a'` to select the `png`\nfilter:\n\n    ug -r -i 'copyright' -tPng --filter='png:exiftool %' --filter-magic-label='+png:\\x89png\\x0d\\x0a\\x1a\\x0a'\n\nNote that `+png` overrides any filename extension match for `--filter`.\nOtherwise, without a `+`, the filename extension, when present, takes priority\nover labelled magic patterns to invoke the corresponding filter command.\nThe `LABEL` used with `--filter-magic-label` and `--filter` has no specific\nmeaning; any name or string that does not contain a `:` or `,` may be used.\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"binary\"/>\n\n### Searching and displaying binary files with -U, -W, and -X\n\n    -U, --ascii, --binary\n            Disables Unicode matching for binary file matching, forcing PATTERN\n            to match bytes, not Unicode characters.  For example, -U '\\xa3'\n            matches byte A3 (hex) instead of the Unicode code point U+00A3\n            represented by the UTF-8 sequence C2 A3.  See also --dotall.\n    -W, --with-hex\n            Output binary matches in hexadecimal, leaving text matches alone.\n            This option is equivalent to the --binary-files=with-hex option\n            with --hexdump=2C.  To omit the matching line from the hex output,\n            combine option --hexdump with option -W.  See also option -U.\n    -X, --hex\n            Output matches in hexadecimal.  This option is equivalent to the\n            --binary-files=hex option with --hexdump=2C.  To omit the matching\n            line from the hex output, use option --hexdump instead of -X.  See\n            also option -U.\n    --hexdump[=[1-8][a][bch][A[NUM]][B[NUM]][C[NUM]]]\n            Output matches in 1 to 8 columns of 8 hexadecimal octets.  The\n            default is 2 columns or 16 octets per line.  Option `a' outputs a\n            `*' for all hex lines that are identical to the previous hex line,\n            `b' removes all space breaks, `c' removes the character column, `h'\n            removes hex spacing, `A' includes up to NUM hex lines after the\n            match, `B' includes up to NUM hex lines before the match and `C'\n            includes up to NUM hex lines.  When NUM is omitted, the matching\n            line is included in the output.  See also options -U, -W and -X.\n    --dotall\n            Dot `.' in regular expressions matches anything, including newline.\n            Note that `.*' matches all input and should not be used.\n\nNote that `--hexdump` differs from `-X` by omitting the matching line from the\nhex output, showing only the matching pattern using a minimal number of hex\nlines.  Option `-X` is the same as `--hexdump=2C` to display the matching line\nas hex `C` context.\n\nTo search a file for ASCII words, displaying text lines as usual while binary\ncontent is shown in hex with `-U` and `-W`:\n\n    ug -UW '\\w+' myfile\n\nTo hexdump an entire file as a match with `-X`:\n\n    ug -X '' myfile\n\nTo hexdump an entire file with `-X`, displaying line numbers and byte offsets\nwith `-nb` (here with `-y` to display all line numbers):\n\n    ug -Xynb '' myfile\n\nTo hexdump lines containing one or more \\0 in a (binary) file using a\nnon-Unicode pattern with `-U` and `-X`:\n\n    ug -UX '\\x00+' myfile\n\nSame, but hexdump the entire file as context with `-y` (note that this\nline-based option does not permit matching patterns with newlines):\n\n    ug -UX -y '\\x00+' myfile\n\nSame, compacted to 32 bytes per line without the character column:\n\n    ug -UX -y '\\x00+' myfile\n\nTo match the binary pattern `A3..A3.` (hex) in a binary file without\nUnicode pattern matching (which would otherwise match `\\xaf` as a Unicode\ncharacter U+00A3 with UTF-8 byte sequence C2 A3) and display the results\nin compact hex with `--hexdump` with pager `less -R`:\n\n    ug --pager --hexdump -U '\\xa3[\\x00-\\xff]{2}\\xa3[\\x00-\\xff]' a.out\n\nSame, but using option `--dotall` to let `.` match any byte, including\nnewline that is not matched by dot (the default as required by grep):\n\n    ug --dotall --pager --hexdump -U '\\xa3.{2}\\xa3.' a.out\n\nTo list all files containing a RPM signature, located in the `rpm` directory and\nrecursively below (see for example\n[list of file signatures](https://en.wikipedia.org/wiki/List_of_file_signatures)):\n\n    ug -RlU '\\A\\xed\\xab\\xee\\xdb' rpm\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"nobinary\"/>\n\n### Ignore binary files with -I\n\n    -I      Ignore matches in binary files.  This option is equivalent to the\n            --binary-files=without-match option.\n\nTo recursively search without following symlinks and ignoring binary files:\n\n    ug -rl -I 'xyz'\n\nTo ignore specific binary files with extensions such as .exe, .bin, .out, .a,\nuse `--exclude` or `--exclude-from`:\n\n    ug -rl --exclude-from=ignore_binaries 'xyz'\n\nwhere `ignore_binaries` is a file containing a glob on each line to ignore\nmatching files, e.g.  `*.exe`, `*.bin`, `*.out`, `*.a`.  Because the command is\nquite long to type, an alias for this is recommended, for example `ugs` (ugrep\nsource):\n\n    alias ugs=\"ugrep --exclude-from=~/ignore_binaries\"\n    ugs -rl 'xyz'\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"ignore\"/>\n\n### Ignoring .gitignore-specified files with --ignore-files\n\n    --ignore-files[=FILE]\n            Ignore files and directories matching the globs in each FILE that\n            is encountered in recursive searches.  The default FILE is\n            `.gitignore'.  Matching files and directories located in the\n            directory of a FILE's location and in directories below are ignored\n            by temporarily extending the --exclude and --exclude-dir globs, as\n            if --exclude-from=FILE is locally enforced.  Globbing syntax is the\n            same as the --exclude-from=FILE gitignore syntax; directories are\n            excluded when the glob ends in a `/', same as git.  Files and\n            directories explicitly specified as command line arguments are\n            never ignored.  This option may be repeated with additional files.\n\nOption `--ignore-files` looks for `.gitignore`, or the specified `FILE`, in\nrecursive searches.  When `.gitignore`, or the specified `FILE`, is found while\ntraversing directory tree branches down, the `.gitignore` file is used to\ntemporarily extend the previous exclusions with the additional globs in\n`.gitignore` to apply the combined exclusions to the directory tree rooted at\nthe `.gitignore` location.  Use `--stats` to show the selection criteria\napplied to the search results and the locations of each `FILE` found.  To avoid\nconfusion, files and directories specified as command-line arguments to\n**ugrep** are never ignored.\n\nNote that exclude glob patterns take priority over include glob patterns when\nspecified with command line options.  By contrast, negated glob patterns\nspecified with `!` in `--ignore-files` files take priority.  This effectively\noverrides the exclusions and resolves conflicts in favor of listing matching\nfiles that are explicitly specified as exceptions and should be included in the\nsearch.\n\nSee also [Using gitignore-style globs to select directories and files to search](#globs).\n\nTo recursively search without following symlinks, while ignoring files and\ndirectories ignored by .gitignore (when present), use option `--ignore-files`.\nNote that `-r` is the default when no FILE arguments are specified, we use it\nhere to make the examples easier to follow.\n\n    ug -rl --ignore-files 'xyz'\n\nSame, but includes hidden files with `-.` rather than ignoring them:\n\n    ug -rl. --ignore-files 'xyz'\n\nTo recursively list all files that are not ignored by .gitignore (when present)\nwith `--ignore-files`:\n\n    ug -rl --ignore-files ''\n\nSame, but list shell scripts that are not ignored by .gitignore, when present:\n\n    ug -rl -tShell '' --ignore-files\n\nTo recursively list all files that are not ignored by .gitignore and are also\nnot excluded by `.git/info/exclude`:\n\n    ug -rl '' --ignore-files --exclude-from=.git/info/exclude\n\nSame, but by creating a symlink to `.git/info/exclude` to make the exclusions\nimplicit:\n\n    ln -s .git/info/exclude .ignore\n    ug -rl '' --ignore-files --ignore-files=.ignore\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"globs\"/>\n\n### Using gitignore-style globs to select directories and files to search\n\n    -g GLOBS, --glob=GLOBS\n            Search only files whose name matches the specified comma-separated\n            list of GLOBS, same as --include='glob' for each `glob' in GLOBS.\n            When a `glob' is preceded by a `!' or a `^', skip files whose name\n            matches `glob', same as --exclude='glob'.  When `glob' contains a\n            `/', full pathnames are matched.  Otherwise basenames are matched.\n            When `glob' ends with a `/', directories are matched, same as\n            --include-dir='glob' and --exclude-dir='glob'.  A leading `/'\n            matches the working directory.  This option may be repeated and may\n            be combined with options -M, -O and -t to expand searches.  See\n            `ugrep --help globs' and `man ugrep' section GLOBBING for details.\n    --exclude=GLOB\n            Skip files whose name matches GLOB using wildcard matching, same as\n            -g ^GLOB.  GLOB can use **, *, ?, and [...] as wildcards, and \\\\ to\n            quote a wildcard or backslash character literally.  When GLOB\n            contains a `/', full pathnames are matched.  Otherwise basenames\n            are matched.  When GLOB ends with a `/', directories are excluded\n            as if --exclude-dir is specified.  Otherwise files are excluded.\n            Note that --exclude patterns take priority over --include patterns.\n            GLOB should be quoted to prevent shell globbing.  This option may\n            be repeated.\n    --exclude-dir=GLOB\n            Exclude directories whose name matches GLOB from recursive\n            searches, same as -g ^GLOB/.  GLOB can use **, *, ?, and [...] as\n            wildcards, and \\\\ to quote a wildcard or backslash character\n            literally.  When GLOB contains a `/', full pathnames are matched.\n            Otherwise basenames are matched.  Note that --exclude-dir patterns\n            take priority over --include-dir patterns.  GLOB should be quoted\n            to prevent shell globbing.  This option may be repeated.\n    --exclude-from=FILE\n            Read the globs from FILE and skip files and directories whose name\n            matches one or more globs.  A glob can use **, *, ?, and [...] as\n            wildcards, and \\ to quote a wildcard or backslash character\n            literally.  When a glob contains a `/', full pathnames are matched.\n            Otherwise basenames are matched.  When a glob ends with a `/',\n            directories are excluded as if --exclude-dir is specified.\n            Otherwise files are excluded.  A glob starting with a `!' overrides\n            previously-specified exclusions by including matching files.  Lines\n            starting with a `#' and empty lines in FILE are ignored.  When FILE\n            is a `-', standard input is read.  This option may be repeated.\n    --ignore-files[=FILE]\n            Ignore files and directories matching the globs in each FILE that\n            is encountered in recursive searches.  The default FILE is\n            `.gitignore'.  Matching files and directories located in the\n            directory of a FILE's location and in directories below are ignored\n            by temporarily overriding the --exclude and --exclude-dir globs,\n            as if --exclude-from=FILE is locally enforced.  Globbing is the\n            same as --exclude-from=FILE and supports gitignore syntax, but\n            directories are not automatically excluded from searches (use a\n            glob ending with a `/' to identify directories to ignore, same as\n            git).  Files and directories explicitly specified as command line\n            arguments are never ignored.  This option may be repeated.\n    --include=GLOB\n            Search only files whose name matches GLOB using wildcard matching,\n            same as -g GLOB.  GLOB can use **, *, ?, and [...] as wildcards,\n            and \\\\ to quote a wildcard or backslash character literally.  When\n            GLOB contains a `/', full pathnames are matched.  Otherwise\n            basenames are matched.  When GLOB ends with a `/', directories are\n            included as if --include-dir is specified.  Otherwise files are\n            included.  Note that --exclude patterns take priority over\n            --include patterns.  GLOB should be quoted to prevent shell\n            globbing.  This option may be repeated.\n    --include-dir=GLOB\n            Only directories whose name matches GLOB are included in recursive\n            searches, same as -g GLOB/.  GLOB can use **, *, ?, and [...] as\n            wildcards, and \\\\ to quote a wildcard or backslash character\n            literally.  When GLOB contains a `/', full pathnames are matched.\n            Otherwise basenames are matched.  Note that --exclude-dir patterns\n            take priority over --include-dir patterns.  GLOB should be quoted\n            to prevent shell globbing.  This option may be repeated.\n    --include-from=FILE\n            Read the globs from FILE and search only files and directories\n            whose name matches one or more globs.  A glob can use **, *, ?, and\n            [...] as wildcards, and \\ to quote a wildcard or backslash\n            character literally.  When a glob contains a `/', full pathnames\n            are matched.  Otherwise basenames are matched.  When a glob ends\n            with a `/', directories are included as if --include-dir is\n            specified.  Otherwise files are included.  A glob starting with a\n            `!' overrides previously-specified inclusions by excluding matching\n            files.  Lines starting with a `#' and empty lines in FILE are\n            ignored.  When FILE is a `-', standard input is read.  This option\n            may be repeated.\n    -O EXTENSIONS, --file-extension=EXTENSIONS\n            Search only files whose filename extensions match the specified\n            comma-separated list of EXTENSIONS, same as --include='*.ext' for\n            each `ext' in EXTENSIONS.  When `ext' is preceded by a `!' or a\n            `^', skip files whose filename extensions matches `ext', same as\n            --exclude='*.ext'.  This option may be repeated and may be combined\n            with options -g, -M and -t to expand the recursive search.\n    --stats\n            Output statistics on the number of files and directories searched,\n            and the inclusion and exclusion constraints applied.\n\nSee also [Including or excluding mounted file systems from searches](#fs).\n\nGitignore-style glob syntax and conventions:\n\npattern    | matches\n---------- | ------------------------------------------------------------------\n`*`        | anything except `/`\n`?`        | any one character except `/`\n`[abc-e]`  | one character `a`,`b`,`c`,`d`,`e`\n`[^abc-e]` | one character not `a`,`b`,`c`,`d`,`e`,`/`\n`[!abc-e]` | one character not `a`,`b`,`c`,`d`,`e`,`/`\n`/`        | when used at the start of a glob, matches working directory\n`**/`      | zero or more directories\n`/**`      | when at the end of a glob, matches everything after the `/`\n`\\?`       | a `?` or any other character specified after the backslash\n\nWhen a glob pattern contains a path separator `/`, the full pathname is\nmatched.  Otherwise the basename of a file or directory is matched in recursive\nsearches.  For example, `*.h` matches `foo.h` and `bar/foo.h`. `bar/*.h`\nmatches `bar/foo.h` but not `foo.h` and not `bar/bar/foo.h`.\n\nWhen a glob pattern begins with a `/`, files and directories are matched at the\nworking directory, not recursively.  For example, use a leading `/` to force\n`/*.h` to match `foo.h` but not `bar/foo.h`.\n\nWhen a glob pattern ends with a `/`, directories are matched instead of files,\nsame as `--include-dir`.\n\nWhen a glob starts with a `!` as specified with `-g!GLOB`, or specified in a\n`FILE` with `--include-from=FILE` or `--exclude-from=FILE`, it is negated.\n\nTo view a list of inclusions and exclusions that were applied to a search, use\noption `--stats`.\n\nTo list only readable files with names starting with `foo` in the working\ndirectory, that contain `xyz`, without producing warning messages with `-s` and\n`-l`:\n\n    ug -sl 'xyz' foo*\n\nThe same, but using deep recursion with inclusion constraints (note that\n`-g'/foo*` is the same as `--include='/foo*'` and `-g'/foo*/'` is the same as\n`--include-dir='/foo*'`, i.e.  immediate subdirectories matching `/foo*` only):\n\n    ug -rl 'xyz' -g'/foo*' -g'/foo*/'\n\nNote that `-r` is the default, we use it here to make the examples easier to\nfollow.\n\nTo exclude directory `bak` located in the working directory:\n\n    ug -rl 'xyz' -g'^/bak/'\n\nTo exclude all directoies `bak` at any directory level deep:\n\n    ug -rl 'xyz' -g'^bak/'\n\nTo only list files in the working directory and its subdirectory `doc`,\nthat contain `xyz` (note that `-g'/doc/'` is the same as\n`--include-dir='/doc'`, i.e. immediate subdirectory `doc` only):\n\n    ug -rl 'xyz' -g'/doc/'\n\nTo only list files that are on a subdirectory path `doc` that includes\nsubdirectory `html` anywhere, that contain `xyz`:\n\n    ug -rl 'xyz' -g'doc/**/html/'\n\nTo only list files in the working directory and in the subdirectories `doc`\nand `doc/latest` but not below, that contain `xyz`:\n\n    ug -rl 'xyz' -g'/doc/' -g'/doc/latest/'\n\nTo recursively list .cpp files in the working directory and any subdirectory\nat any depth, that contain `xyz`:\n\n    ug -rl 'xyz' -g'*.cpp'\n\nThe same, but using a .gitignore-style glob that matches pathnames (globs with\n`/`) instead of matching basenames (globs without `/`) in the recursive search:\n\n    ug -rl 'xyz' -g'**/*.cpp'\n\nSame, but using option `-Ocpp` to match file name extensions:\n\n    ug -rl -Ocpp 'xyz'\n\nTo recursively list all files in the working directory and below that are not\nignored by a specific .gitignore file:\n\n    ug -rl '' --exclude-from=.gitignore\n\nTo recursively list all files in the working directory and below that are not\nignored by one or more .gitignore files, when any are present:\n\n    ug -rl '' --ignore-files\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"fs\"/>\n\n### Including or excluding mounted file systems from searches\n\n    --exclude-fs=MOUNTS\n            Exclude file systems specified by MOUNTS from recursive searches,\n            MOUNTS is a comma-separated list of mount points or pathnames of\n            directories on file systems.  Note that --exclude-fs mounts take\n            priority over --include-fs mounts.  This option may be repeated.\n    --include-fs=MOUNTS\n            Only file systems specified by MOUNTS are included in recursive\n            searches.  MOUNTS is a comma-separated list of mount points or\n            pathnames of directories on file systems.  --include-fs=. restricts\n            recursive searches to the file system of the working directory\n            only.  Note that --exclude-fs mounts take priority over\n            --include-fs mounts.  This option may be repeated.\n\nThese options control recursive searches across file systems by comparing\ndevice numbers.  Mounted devices and symbolic links to files and directories\nlocated on mounted file systems may be included or excluded from recursive\nsearches by specifying a mount point or a pathname of any directory on the file\nsystem to specify the applicable file system.\n\nNote that a list of mounted file systems is typically stored in `/etc/mtab`.\n\nTo restrict recursive searches to the file system of the working directory\nonly, without crossing into other file systems (similar to `find` option `-x`):\n\n    ug -rl --include-fs=. 'xyz' \n\nTo exclude the file systems mounted at `/dev` and `/proc` from recursive\nsearches:\n\n    ug -rl --exclude-fs=/dev,/proc 'xyz' \n\nTo only include the file system associated with drive `d:` in recursive\nsearches:\n\n    ug -rl --include-fs=d:/ 'xyz' \n\nTo exclude `fuse` and `tmpfs` type file systems from recursive searches:\n\n    exfs=`ugrep -w -e fuse -e tmpfs /etc/mtab | ugrep -P '^\\S+ (\\S+)' --format='%,%1'`\n    ug -rl --exclude-fs=\"$exfs\" 'xyz'\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"count\"/>\n\n### Counting the number of matches with -c and -co\n\n    -c, --count\n            Only a count of selected lines is written to standard output.  If\n            -o or -u is specified, counts the number of patterns matched.  If\n            -v is specified, counts the number of non-matching lines.  If\n            --tree is specified, outputs directories in a tree-like format.\n\nTo count the number of lines in a file:\n\n    ug -c '' myfile.txt\n\nTo count the number of lines with `TODO`:\n\n    ug -c -w 'TODO' myfile.cpp\n\nTo count the total number of `TODO` in a file, use `-c` and `-o`:\n\n    ug -co -w 'TODO' myfile.cpp\n\nTo count the number of ASCII words in a file:\n\n    ug -co '[[:word:]]+' myfile.txt\n\nTo count the number of ASCII and Unicode words in a file:\n\n    ug -co '\\w+' myfile.txt\n\nTo count the number of Unicode characters in a file:\n\n    ug -co '\\p{Unicode}' myfile.txt\n\nTo count the number of zero bytes in a file:\n\n    ug -UX -co '\\x00' image.jpg\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"fields\"/>\n\n### Displaying file, line, column, and byte offset info with -H, -n, -k, -b, and -T\n\n    -b, --byte-offset\n            The offset in bytes of a matched line is displayed in front of the\n            respective matched line.  When used with option -u, displays the\n            offset in bytes of each pattern matched.  Byte offsets are exact\n            for ASCII, UTF-8, and raw binary input.  Otherwise, the byte offset\n            in the UTF-8 converted input is displayed.\n    -H, --with-filename\n            Always print the filename with output lines.  This is the default\n            when there is more than one file to search.\n    -k, --column-number\n            The column number of a matched pattern is displayed in front of the\n            respective matched line, starting at column 1.  Tabs are expanded\n            when columns are counted, see option --tabs.\n    -n, --line-number\n            Each output line is preceded by its relative line number in the\n            file, starting at line 1.  The line number counter is reset for\n            each file processed.\n    -T, --initial-tab\n            Add a tab space to separate the file name, line number, column\n            number, and byte offset with the matched line.\n\nTo display the file name `-H`, line `-n`, and column `-k` numbers of matches in\n`myfile.cpp`, with spaces and tabs to space the columns apart with `-T`:\n\n    ug -THnk 'main' myfile.cpp\n\nTo display the line with `-n` of word `main` in `myfile.cpp`:\n\n    ug -nw 'main' myfile.cpp\n\nTo display the entire file `myfile.cpp` with line `-n` numbers:\n\n    ug -n '' myfile.cpp\n\nTo recursively search for C++ files with `main`, showing the line and column\nnumbers of matches with `-n` and `-k`:\n\n    ug -r -nk -tc++ 'main'\n\nTo display the byte offset of matches with `-b`:\n\n    ug -r -b -tc++ 'main'\n\nTo display the line and column numbers of matches in XML with `--xml`:\n\n    ug -r -nk --xml -tc++ 'main'\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"color\"/>\n\n### Displaying colors with --color and paging the output with --pager\n\n    --color[=WHEN], --colour[=WHEN]\n            Mark up the matching text with the expression stored in the\n            GREP_COLOR or GREP_COLORS environment variable.  The possible\n            values of WHEN can be `never', `always', or `auto', where `auto'\n            marks up matches only when output on a terminal.  The default is\n            `auto'.\n    --colors=COLORS, --colours=COLORS\n            Use COLORS to mark up text.  COLORS is a colon-separated list of\n            one or more parameters `sl=' (selected line), `cx=' (context line),\n            `mt=' (matched text), `ms=' (match selected), `mc=' (match\n            context), `fn=' (file name), `ln=' (line number), `cn=' (column\n            number), `bn=' (byte offset), `se=' (separator).  Parameter values\n            are ANSI SGR color codes or `k' (black), `r' (red), `g' (green),\n            `y' (yellow), `b' (blue), `m' (magenta), `c' (cyan), `w' (white).\n            Upper case specifies background colors.  A `+' qualifies a color as\n            bright.  A foreground and a background color may be combined with\n            font properties `n' (normal), `f' (faint), `h' (highlight), `i'\n            (invert), `u' (underline).  Parameter `hl' enables file name\n            hyperlinks.  Parameter `rv' reverses the `sl=' and `cx=' parameters\n            when option -v is specified.  Selectively overrides GREP_COLORS.\n    --tag[=TAG[,END]]\n            Disables colors to mark up matches with TAG.  END marks the end of\n            a match if specified, otherwise TAG.  The default is `___'.\n    --pager[=COMMAND]\n            When output is sent to the terminal, uses COMMAND to page through\n            the output.  The default COMMAND is `less -R'.  Enables --heading\n            and --line-buffered.\n    --pretty\n            When output is sent to a terminal, enables --color, --heading, -n,\n            --sort, --tree and -T when not explicitly disabled.\n\nTo change the color palette, set the `GREP_COLORS` environment variable or use\n`--colors=COLORS`.  The value is a colon-separated list of ANSI SGR parameters\nthat defaults to `cx=33:mt=1;31:fn=1;35:ln=1;32:cn=1;32:bn=1;32:se=36`:\n\nparam | result\n----- | ------------------------------------------------------------------------\n`sl=` | SGR substring for selected lines\n`cx=` | SGR substring for context lines\n`rv`  | Swaps the `sl=` and `cx=` capabilities when `-v` is specified\n`mt=` | SGR substring for matching text in any matching line\n`ms=` | SGR substring for matching text in a selected line.  The substring mt= by default\n`mc=` | SGR substring for matching text in a context line.  The substring mt= by default\n`fn=` | SGR substring for file names\n`ln=` | SGR substring for line numbers\n`cn=` | SGR substring for column numbers\n`bn=` | SGR substring for byte offsets\n`se=` | SGR substring for separators\n\nMultiple SGR codes may be specified for a single parameter when separated by a\nsemicolon, e.g. `mt=1;31` specifies bright red.  The following SGR codes are\navailable on most color terminals:\n\ncode | c | effect                     | code | c  | effect\n---- | - | -------------------------- | ---- | -- | ----------------------------\n0    | n | normal font and color      | 2    | f  | faint (not widely supported)\n1    | h | highlighted bold font      | 21   | H  | highlighted bold off\n4    | u | underline                  | 24   | U  | underline off\n7    | i | invert video               | 27   | I  | invert off\n30   | k | black text                 | 90   | +k | bright gray text\n31   | r | red text                   | 91   | +r | bright red text\n32   | g | green text                 | 92   | +g | bright green text\n33   | y | yellow text                | 93   | +y | bright yellow text\n34   | b | blue text                  | 94   | +b | bright blue text\n35   | m | magenta text               | 95   | +m | bright magenta text\n36   | c | cyan text                  | 96   | +c | bright cyan text\n37   | w | white text                 | 97   | +w | bright white text\n40   | K | black background           | 100  | +K | bright gray background\n41   | R | dark red background        | 101  | +R | bright red background\n42   | G | dark green background      | 102  | +G | bright green background\n43   | Y | dark yellow backgrounda    | 103  | +Y | bright yellow background\n44   | B | dark blue background       | 104  | +B | bright blue background\n45   | M | dark magenta background    | 105  | +M | bright magenta background\n46   | C | dark cyan background       | 106  | +C | bright cyan background\n47   | W | dark white background      | 107  | +W | bright white background\n\nSee Wikipedia [ANSI escape code - SGR parameters](https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_parameters)\n\nFor quick and easy color specification, the corresponding single-letter color\nnames may be used in place of numeric SGR codes.  Semicolons are not required\nto separate color names.  Color names and numeric codes may be mixed.\n\nFor example, to display matches in underlined bright green on bright selected\nlines, aiding in visualizing white space in matches and file names:\n\n    export GREP_COLORS='sl=1:cx=33:ms=1;4;32;100:mc=1;4;32:fn=1;32;100:ln=1;32:cn=1;32:bn=1;32:se=36'\n\nThe same, but with single-letter color names:\n\n    export GREP_COLORS='sl=h:cx=y:ms=hug+K:mc=hug:fn=hg+K:ln=hg:cn=hg:bn=hg:se=c'\n\nAnother color scheme that works well:\n\n    export GREP_COLORS='cx=hb:ms=hiy:mc=hic:fn=hi+y+K:ln=hg:cn=hg:bn=hg:se='\n\nModern Windows command interpreters support ANSI escape codes.  Named or\nnumeric colors can be set with `SET GREP_COLORS`, for example:\n\n    SET GREP_COLORS=sl=1;37:cx=33:mt=1;31:fn=1;35:ln=1;32:cn=1;32:bn=1;32:se=36\n\nTo disable colors on Windows:\n\n    SET GREP_COLORS=\"\"\n\nColor intensities may differ per platform and per terminal program used, which\naffects readability.\n\nOption `-y` outputs every line of input, including non-matching lines as\ncontext.  The use of color helps distinguish matches from non-matching context.\n\nTo copy silver searcher's color palette:\n\n    export GREP_COLORS='mt=30;43:fn=1;32:ln=1;33:cn=1;33:bn=1;33'\n\nTo produce color-highlighted results (`--color` is redundance since it is the\ndefault):\n\n    ug --color -r -n -k -tc++ 'FIXME.*'\n\nTo page through the results with pager (`less -R` by default):\n\n    ug --pager -r -n -k -tc++ 'FIXME'\n\nTo display a hexdump of a zip file itself (i.e. without decompressing), with\ncolor-highlighted matches of the zip magic bytes `PK\\x03\\x04` (`--color` is\nredundant since it is the default):\n\n    ug --color -y -UX 'PK\\x03\\x04' some.zip\n\nTo use predefined patterns to list all `#include` and `#define` in C++ files:\n\n    ug --pretty -r -n -tc++ -f c++/includes -f c++/defines\n\nSame, but overriding the color of matches as inverted yellow (reverse video)\nand headings with yellow on blue using `--pretty`:\n\n    ug --pretty --colors=\"ms=yi:fn=hyB\" -r -n -tc++ -f c++/includes -f c++/defines\n\nTo list all `#define FOO...` macros in C++ files, color-highlighted:\n\n    ug --color=always -r -n -tc++ -f c++/defines | ug 'FOO.*'\n\nSame, but restricted to `.cpp` files only:\n\n    ug --color=always -r -n -Ocpp -f c++/defines | ug 'FOO.*'\n\nTo search tarballs for matching names of PDF files (assuming bash is our shell):\n\n    for tb in *.tar *.tar.gz *.tgz; do echo \"$tb\"; tar tfz \"$tb\" | ugrep '.*\\.pdf$'; done\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"json\"/>\n\n### Output matches in JSON, XML, CSV, C++\n\n    --cpp   Output file matches in C++.  See also options --format and -u.\n    --csv   Output file matches in CSV.  If -H, -n, -k, or -b is specified,\n            additional values are output.  See also options --format and -u.\n    --json  Output file matches in JSON.  If -H, -n, -k, or -b is specified,\n            additional values are output.  See also options --format and -u.\n    --xml   Output file matches in XML.  If -H, -n, -k, or -b is specified,\n            additional values are output.  See also options --format and -u.\n\nTo recursively search for lines with `TODO` and display C++ file matches in\nJSON with line number properties:\n\n    ug -tc++ -n --json 'TODO'\n\nTo recursively search for lines with `TODO` and display C++ file matches in\nXML with line and column number attributes:\n\n    ug -tc++ -nk --xml 'TODO'\n\nTo recursively search for lines with `TODO` and display C++ file matches in CSV\nformat with file pathname, line number, and column number fields:\n\n    ug -tc++ --csv -Hnk 'TODO'\n\nTo extract a table from an HTML file and put it in C/C++ source code using\n`-o`:\n\n    ug -o --cpp '<tr>.*</tr>' index.html > table.cpp\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"format\"/>\n\n### Customized output with --format\n\n    --format=FORMAT\n            Output FORMAT-formatted matches.  For example --format='%f:%n:%O%~'\n            outputs matching lines `%O' with filename `%f` and line number `%n'\n            followed by a newline `%~'.  If -P is specified, FORMAT may include\n            `%1' to `%9', `%[NUM]#' and `%[NAME]#' to output group captures.  A\n            `%%' outputs `%'.  See `ugrep --help format' and `man ugrep'\n            section FORMAT for details.  When option -o is specified, option -u\n            is also enabled.  Context options -A, -B, -C and -y are ignored.\n    -P, --perl-regexp\n            Interpret PATTERN as a Perl regular expression.\n\nUse option `-P` to use group captures and backreferences.  Capturing groups in\nregex patterns are parenthesized expressions `(pattern)`.  The first group is\nreferenced in `FORMAT` by `%1`, the second by `%2` and so on.  Named captures\nare of the form `(?<NAME>pattern)` and are referenced in `FORMAT` by\n`%[NAME]#`.\n\nThe following output formatting options may be used.  The `FORMAT` string\n`%`-fields are listed in a table further below:\n\noption                  | result\n----------------------- | ------------------------------------------------------\n`--format-begin=FORMAT` | `FORMAT` beginning the search\n`--format-open=FORMAT`  | `FORMAT` opening a file and a match was found\n`--format=FORMAT`       | `FORMAT` for each match in a file\n`--format-close=FORMAT` | `FORMAT` closing a file and a match was found\n`--format-end=FORMAT`   | `FORMAT` ending the search\n\nThe following tables show the formatting options corresponding to `--csv`,\n`--json`, and `--xml`.\n\n#### `--csv`\n\noption           | format string (within quotes)\n---------------- | -----------------------------\n`--format-open`  | `'%+'`\n`--format`       | `'%[,]$%H%N%K%B%V%~%u'`\n\n#### `--json`\n\noption           | format string (within quotes)\n---------------- | -----------------------------\n`--format-begin` | `'['`\n`--format-open`  | `'%,%~  {%~    %[,%~    ]$%[\"file\": ]H\"matches\": ['`\n`--format`       | `'%,%~      { %[, ]$%[\"line\": ]N%[\"column\": ]K%[\"offset\": ]B\"match\": %J }%u'`\n`--format-close` | `'%~    ]%~  }'`\n`--format-end`   | `'%~]%~'`\n\n#### `--xml`\n\noption           | format string (within quotes)\n---------------- | -----------------------------\n`--format-begin` | `'<grep>%~'`\n`--format-open`  | `'  <file%[]$%[ name=]H>%~'`\n`--format`       | `'    <match%[\\\"]$%[ line=\\\"]N%[ column=\\\"]K%[ offset=\\\"]B>%X</match>%~%u'`\n`--format-close` | `'  </file>%~'`\n`--format-end`   | `'</grep>%~'`\n\n### `--only-line-number`\n\noption           | format string (within quotes)\n---------------- | -----------------------------\n`--format-open`  | `'%+'`\n`--format`       | `'%F%n%s%K%B%~%u'`\n\nThe following fields may be used in the `FORMAT` string:\n\nfield                   | output\n----------------------- | ------------------------------------------------------\n`%F`                    | if option `-H` is used: the file pathname and separator\n`%[ARG]F`               | if option `-H` is used: `ARG`, the file pathname and separator\n`%f`                    | the file pathname\n`%a`                    | the file basename without directory path\n`%p`                    | the directory path to the file\n`%z`                    | the pathname in a (compressed) archive, without `{` and `}`\n`%H`                    | if option `-H` is used: the quoted pathname and separator, `\\\"` and `\\\\` replace `\"` and `\\`\n`%[ARG]H`               | if option `-H` is used: `ARG`, the quoted pathname and separator, `\\\"` and `\\\\` replace `\"` and `\\`\n`%h`                    | the quoted file pathname, `\\\"` and `\\\\` replace `\"` and `\\`\n`%N`                    | if option `-n` is used: the line number and separator\n`%[ARG]N`               | if option `-n` is used: `ARG`, the line number and separator\n`%n`                    | the line number of the match\n`%K`                    | if option `-k` is used: the column number and separator\n`%[ARG]K`               | if option `-k` is used: `ARG`, the column number and separator\n`%k`                    | the column number of the match\n`%B`                    | if option `-b` is used: the byte offset and separator\n`%[ARG]B`               | if option `-b` is used: `ARG`, the byte offset and separator\n`%b`                    | the byte offset of the match\n`%T`                    | if option `-T` is used: `ARG` and a tab character\n`%[ARG]T`               | if option `-T` is used: `ARG` and a tab character\n`%t`                    | a tab character\n`%[SEP]$`               | set field separator to `SEP` for the rest of the format fields\n`%[ARG]<`               | if the first match: `ARG`\n`%[ARG]>`               | if not the first match: `ARG`\n`%,`                    | if not the first match: a comma, same as `%[,]>`\n`%:`                    | if not the first match: a colon, same as `%[:]>`\n`%;`                    | if not the first match: a semicolon, same as `%[;]>`\n`%│`                    | if not the first match: a vertical bar, same as `%[│]>`\n`%S`                    | if not the first match: separator, see also `%[SEP]$`\n`%[ARG]S`               | if not the first match: `ARG` and separator, see also `%[SEP]$`\n`%s`                    | the separator, see also `%[ARG]S` and `%[SEP]$`\n`%~`                    | a newline character\n`%+`                    | if option `--heading` is used: `%F` and a newline character, suppress all `%F` afterward\n`%m`                    | the number of matches, sequential (or number of matching files with `--format-end`)\n`%M`                    | the number of matching lines (or number of matching files with `--format-end`)\n`%O`                    | the matching line is output as is (a raw string of bytes)\n`%o`                    | the match is output as is (a raw string of bytes)\n`%Q`                    | the matching line as a quoted string, `\\\"` and `\\\\` replace `\"` and `\\`\n`%q`                    | the match as a quoted string, `\\\"` and `\\\\` replace `\"` and `\\`\n`%C`                    | the matching line formatted as a quoted C/C++ string\n`%c`                    | the match formatted as a quoted C/C++ string\n`%J`                    | the matching line formatted as a quoted JSON string\n`%j`                    | the match formatted as a quoted JSON string\n`%V`                    | the matching line formatted as a quoted CSV string\n`%v`                    | the match formatted as a quoted CSV string\n`%X`                    | the matching line formatted as XML character data\n`%x`                    | the match formatted as XML character data\n`%w`                    | the width of the match, counting (wide) characters\n`%d`                    | the size of the match, counting bytes\n`%e`                    | the ending byte offset of the match\n`%Z`                    | the edit distance cost of an approximate match with option `-Z`\n`%u`                    | select unique lines only unless option -u is used\n`%1` `%2` ... `%9`      | the first regex group capture of the match, and so on up to group `%9`, requires option `-P`\n`%[NUM]#`               | the regex group capture `NUM`; requires option `-P`\n`%[NUM]b`               | the byte offset of the group capture `NUM`; requires option `-P`\n`%[NUM]e`               | the ending byte offset of the group capture `NUM`; requires option `-P`\n`%[NUM]d`               | the byte length of the group capture `NUM`; requires option `-P`\n`%[NUM1\\|NUM2\\|...]#`   | the first group capture `NUM` that matched; requires option `-P`\n`%[NUM1\\|NUM2\\|...]b`   | the byte offset of the first group capture `NUM` that matched; requires option `-P`.\n`%[NUM1\\|NUM2\\|...]e`   | the ending byte offset of the first group capture `NUM` that matched; requires option `-P`.\n`%[NUM1\\|NUM2\\|...]d`   | the byte length of the first group capture `NUM` that matched; requires option `-P`.\n`%[NAME]#`              | the `NAME`d group capture; requires option `-P` and capturing pattern `(?<NAME>PATTERN)`\n`%[NAME]b`              | the byte offset of the `NAME`d group capture; requires option `-P` and capturing pattern `(?<NAME>PATTERN)`.\n`%[NAME]e`              | the ending byte offset of the `NAME`d group capture; requires option `-P` and capturing pattern `(?<NAME>PATTERN)`.\n`%[NAME]d`              | the byte length of the `NAME`d group capture; requires option `-P` and capturing pattern `(?<NAME>PATTERN)`.\n`%[NAME1\\|NAME2\\|...]#` | the first `NAME`d group capture that matched; requires option `-P` and capturing pattern `(?<NAME>PATTERN)`\n`%[NAME1\\|NAME2\\|...]b` | the byte offset of the first `NAME`d group capture that matched; requires option `-P` and capturing pattern `(?<NAME>PATTERN)`\n`%[NAME1\\|NAME2\\|...]e` | the ending byte offset of the first `NAME`d group capture that matched; requires option `-P` and capturing pattern `(?<NAME>PATTERN)`\n`%[NAME1\\|NAME2\\|...]d` | the byte length of the first `NAME`d group capture that matched; requires option `-P` and capturing pattern `(?<NAME>PATTERN)`\n`%G`                    | list of group capture indices/names of the match (see note)\n`%[TEXT1\\|TEXT2\\|...]G` | list of TEXT indexed by group capture indices that matched; requires option `-P`\n`%g`                    | the group capture index of the match or 1 (see note)\n`%[TEXT1\\|TEXT2\\|...]g` | the first TEXT indexed by the first group capture index that matched; requires option `-P`\n`%%`                    | the percentage sign\n\nNote:\n\n- Formatted output is written without a terminating newline, unless `%~` or `\\n`\n  is explicitly specified in the format string.\n- The `[ARG]` part of a field is optional and may be omitted.  When present,\n  the argument must be placed in `[]` brackets, for example `%[,]F` to output a\n  comma, the pathname, and a separator, when option `-H` is used.\n- Fields `%[SEP]$` and `%u` are switches and do not write anything to the\n  output.\n- The separator used by `%F`, `%H`, `%N`, `%K`, `%B`, `%S`, and `%G` may be\n  changed by preceding the field with a `%[SEP]$`.  When `[SEP]` is not\n  provided, reverts the separator to the default separator or the separator\n  specified by `--separator`.\n- Formatted output is written for each matching pattern, which means that a\n  line may be output multiple times when patterns match more than once on the\n  same line.  When field `%u` is found anywhere in the specified format string,\n  matching lines are output only once unless option `-u`, `--ungroup`\n  is used or when a newline is matched.\n- The group capture index value output by `%g` corresponds to the index of the\n  sub-pattern matched among the alternations in the pattern when option `-P` is\n  not used.  For example `foo|bar` matches `foo` with index 1 and `bar` with\n  index 2.  With option `-P`, the index corresponds to the number of the first\n  group captured in the specified pattern.\n- The strings specified in the list `%[TEXT1|TEXT2|...]G` and\n  `%[TEXT1|TEXT2|...]g` should correspond to the group capture index (see the\n  note above), i.e. `TEXT1` is output for index 1, `TEXT2` is output for index\n  2, and so on.  If the list is too short, the index value is output or the\n  name of a named group capture is output.\n- Option `-T` and `--pretty` add right-justifying spacing to fields `%N` and\n  `%K` if no leading `[ARG]` part is specified.\n- Field `%+` may be used in `--format-open` to output the pathname heading and\n   a newline break, respectively.  Field `%+` suppresses `%a`, `%F`, `%f`,\n   `%H`, `%h` and `%p` output.\n\nTo output matching lines faster by omitting the header output and binary match\nchecks, using `--format` with field `%O` (output matching line as is) and field\n`%~` (output newline):\n\n    ug --format='%O%~' 'href=' index.html\n\nSame, but also displaying the line and column numbers:\n\n    ug --format='%n%k: %O%~' 'href=' index.html\n\nSame, but display a line at most once when matching multiple patterns, unless\noption `-u` is used:\n\n    ug --format='%u%n%k: %O%~' 'href=' index.html\n\nTo string together a list of unique line numbers of matches, separated by\ncommas with field `%,`:\n\n    ug --format='%u%,%n' 'href=' index.html\n\nTo output the matching part of a line only with field `%o` (or option `-o` with\nfield `%O`):\n\n    ug --format='%o%~' \"href=[\\\"'][^\\\"'][\\\"']\" index.html\n\nTo string together the pattern matches as CSV-formatted strings with field `%v`\nseparated by commas with field `%,`:\n\n    ug --format='%,%v' \"href=[\\\"'][^\\\"'][\\\"']\" index.html\n\nTo output matches in CSV (comma-separated values), the same as option `--csv`\n(works with options `-H`, `-n`, `-k`, `-b` to add CSV values):\n\n    ug --format='\"%[,]$%H%N%K%B%V%~%u\"' 'href=' index.html\n\nTo output matches in AckMate format:\n\n    ug --format=\":%f%~%n;%k %w:%O%~\" 'href=' index.html\n\nTo output the sub-pattern indices 1, 2, and 3 on the left to the match for the\nthree patterns `foo`, `bar`, and `baz` in file `foobar.txt`:\n\n    ug --format='%g: %o%~' 'foo|bar|baz' foobar.txt\n\nSame, but using a file `foos` containing three lines with `foo`, `bar`, and\n`baz`, where option `-F` is used to match strings instead of regex:\n\n    ug -F -f foos --format='%g: %o%~' foobar.txt\n\nTo output `one`, `two`, and `a word` for the sub-patterns `[fF]oo`, `[bB]ar`,\nand any other word `\\w+`, respectively, using argument `[one|two|a word]` with\nfield `%g` indexed by sub-pattern (or group captures with option `-P`):\n\n    ug --format='%[one|two|a word]g%~' '([fF]oo)|([bB]ar)|(\\w+)' foobar.txt\n\nTo output a list of group capture indices with `%G` separated by the word `and`\ninstead of the default colons with `%[ and ]$`, followed by the matching line:\n\n    ug -P --format='%[ and ]$%G%$%s%O%~' '(foo)|(ba((r)|(z)))' foobar.txt\n\nSame, but showing names instead of numbers:\n\n    ug -P --format='%[ and ]$%[foo|ba|r|z]G%$%s%O%~' '(foo)|(ba(?:(r)|(z)))' foobar.txt\n\nNote that option `-P` is required for general use of group captures for\nsub-patterns.  Named sub-pattern matches may be used with PCRE2 and shown in\nthe output:\n\n    ug -P --format='%[ and ]$%G%$%s%O%~' '(?P<foo>foo)|(?P<ba>ba(?:(?P<r>r)|(?P<z>z)))' foobar.txt\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"replace\"/>\n\n### Replacing matches with -P --replace and --format using backreferences\n\n    --replace=FORMAT\n            Replace matching patterns in the output by the specified FORMAT\n            with `%' fields.  If -P is specified, FORMAT may include `%1' to\n            `%9', `%[NUM]#' and `%[NAME]#' to output group captures.  A `%%'\n            outputs `%' and `%~' outputs a newline.  See option --format,\n            `ugrep --help format' and `man ugrep' section FORMAT for details.\n    -y, --any-line\n            Any line is output (passthru).  Non-matching lines are output as\n            context with a `-' separator.  See also options -A, -B, and -C.\n    -P, --perl-regexp\n            Interpret PATTERN as a Perl regular expression.\n    --format=FORMAT\n            Output FORMAT-formatted matches.  For example --format='%f:%n:%O%~'\n            outputs matching lines `%O' with filename `%f` and line number `%n'\n            followed by a newline `%~'.  If -P is specified, FORMAT may include\n            `%1' to `%9', `%[NUM]#' and `%[NAME]#' to output group captures.  A\n            `%%' outputs `%'.  See `ugrep --help format' and `man ugrep'\n            section FORMAT for details.  When option -o is specified, option -u\n            is also enabled.  Context options -A, -B, -C and -y are ignored.\n\nSee [customized output with --format](#format) for details on the `FORMAT`\nfields.\n\nFor option `-o`, the replacement is not automatically followed by a newline to\nallow for more flexibility in replacements.  To output a newline, use `%~` in\nthe `FORMAT` string.\n\nUse option `-P` to use group captures and backreferences.  Capturing groups in\nregex patterns are parenthesized expressions `(pattern)` and the first is\nreferenced in `FORMAT` by `%1`, the second by `%2` and so on.  Named captures\nare of the form `(?<NAME>pattern)` and are referenced in `FORMAT` by\n`%[NAME]#`.\n\nTo display pattern matches with their sequential match number using\n`--replace='%m:%o'` where `%m` is the sequential match number and `%o` is the\npattern matched:\n\n    ug --replace='%m:%o' pattern myfile.txt\n\nSame, but passing the file through with option `-y`, while applying the\nreplacements to the output:\n\n    ug -y --replace='%m:%o' pattern myfile.txt\n\nTo extract table cells from an HTML file using Perl matching (`-P`) to support\ngroup captures with lazy quantifier `(.*?)`, and translate the matches to a\ncomma-separated list with format `%,%1` (conditional comma and group capture):\n\n    ug -P -o '<td>(.*?)</td>' --replace='%,%1' index.html\n\nSame, but using `--format='%,%1'` instead and we do not need `-o` (note that\n`--replace` color-highlights matches shown on a terminal but `--format` does\nnot):\n\n    ug -P '<td>(.*?)</td>' --format='%,%1' index.html\n\nSame, but displaying the formatted matches line-by-line, with `--replace` or\nwith `--format`:\n\n    ug -P -o '<td>(.*?)</td>' --replace='%,%1' index.html\n    ug -P '<td>(.*?)</td>' --format='%1%~' index.html\n\nTo collect all `href` URLs from all HTML and PHP files down the working\ndirectory, then sort them:\n\n    ug -r -thtml,php -P '<[^<>]+href\\h*=\\h*.([^\\x27\"]+).' --format='%1%~' | sort -u\n\nSame, but much easier by using the predefined `html/href` pattern:\n\n    ug -r -thtml,php -P -f html/href --format='%1%~' | sort -u\n\nSame, but in this case select `<script>` `src` URLs when referencing `http` and\n`https` sites:\n\n    ug -r -thtml,php -P '<script.*src\\h*=\\h*.(https?:[^\\x27\"]+).' --format='%1%~' | sort -u\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"max\"/>\n\n### Limiting the number of matches with -1,-2...-9, -K, -m, and --max-files\n\n    --depth=[MIN,][MAX], -1, -2, -3, ... -9, --10, --11, --12, ...\n            Restrict recursive searches from MIN to MAX directory levels deep,\n            where -1 (--depth=1) searches the specified path without recursing\n            into subdirectories.  Note that -3 -5, -3-5, and -35 search 3 to 5\n            levels deep.  Enables -r if -R or -r is not specified.\n    -K [MIN,][MAX], --range=[MIN,][MAX], --min-line=MIN, --max-line=MAX\n            Start searching at line MIN, stop at line MAX when specified.\n    -m [MIN,][MAX], --min-count=MIN, --max-count=MAX\n            Require MIN matches, stop after MAX matches when specified.  Output\n            MIN to MAX matches.  For example, -m1 outputs the first match and\n            -cm1, (with comma) counts non-zero matches.  See also option -K.\n    --max-files=NUM\n            Restrict the number of files matched to NUM.  Note that --sort or\n            -J1 may be specified to produce replicable results.  If --sort is\n            specified, the number of threads spawned is limited to NUM.\n    --sort[=KEY]\n            Displays matching files in the order specified by KEY in recursive\n            searches.  Normally the ug command sorts by name whereas the ugrep\n            batch command displays matches in no particular order to improve\n            performance.  The sort KEY can be `name' to sort by pathname\n            (default), `best' to sort by best match with option -Z (sort by\n            best match requires two passes over files, which is expensive),\n            `size' to sort by file size, `used' to sort by last access time,\n            `changed' to sort by last modification time and `created' to sort\n            by creation time.  Sorting is reversed with `rname', `rbest',\n            `rsize', `rused', `rchanged', or `rcreated'.  Archive contents are\n            not sorted.  Subdirectories are sorted and displayed after matching\n            files.  FILE arguments are searched in the same order as specified.\n\nTo show only the first 10 matches of `FIXME` in C++ files in the working\ndirectory and all subdirectories below:\n\n    ug -r -m10 -tc++ FIXME\n\nSame, but recursively search up to two directory levels, meaning that `./` and\n`./sub/` are visited but not deeper:\n\n    ug -2 -m10 -tc++ FIXME\n\nTo show only the first two files that have one or more matches of `FIXME` in\nthe list of files sorted by pathname, using `--max-files=2`:\n\n    ug --sort -r --max-files=2 -tc++ FIXME\n\nTo search file `install.sh` for the occurrences of the word `make` after the\nfirst line, we use `-K` with line number 2 to start searching, where `-n` shows\nthe line numbers in the output:\n\n    ug -n -K2 -w make install.sh\n\nSame, but restricting the search to lines 2 to 40 (inclusive):\n\n    ug -n -K2,40 -w make install.sh\n\nSame, but showing all lines 2 to 40 with `-y`:\n\n    ug -y -n -K2,40 -w make install.sh\n\nSame, but showing only the first four matching lines after line 2, with one\nline of context:\n\n    ug -n -C1 -K2 -m4 -w make install.sh\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"empty\"/>\n\n### Matching empty patterns with -Y\n\n    -Y, --empty\n            Permits empty matches.  By default, empty matches are disabled,\n            unless a pattern begins with `^' or ends with `$'.  Note that -Y\n            when specified with an empty-matching pattern, such as x? and x*,\n            match all input, not only lines containing the character `x'.\n\nOption `-Y` permits empty pattern matches, like GNU/BSD grep.  This option is\nintroduced by **ugrep** to prevent accidental matching with empty patterns:\nempty-matching patterns such as `x?` and `x*` match all input, not only lines\nwith `x`.  By default, without `-Y`, patterns match lines with at least one `x`\nas intended.\n\nThis option is automatically enabled when a pattern starts with `^` or ends\nwith `$` is specified.  For example, `^\\h*$` matches blank lines, including\nempty lines.\n\nTo recursively list files in the working directory with blank lines, i.e. lines\nwith white space only, including empty lines (note that option `-Y` is\nimplicitly enabled since the pattern starts with `^` and ends with `$`):\n\n    ug -l '^\\h*$'\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"case\"/>\n\n### Case-insentitive matching with -i and -j\n\n    -i, --ignore-case\n            Perform case insensitive matching.  By default, ugrep is case\n            sensitive.  By default, this option applies to ASCII letters only.\n            Use options -P and -i for Unicode case insensitive matching.\n    -j, --smart-case\n            Perform case insensitive matching like option -i, unless a pattern\n            is specified with a literal ASCII upper case letter.\n\nTo match `todo` in `myfile.cpp` regardless of case:\n\n     ug -i 'todo' myfile.txt\n\nTo match `todo XXX` with `todo` in any case but `XXX` as given, with pattern\n`(?i:todo)` to match `todo` ignoring case:\n\n     ug '(?i:todo) XXX' myfile.cpp\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"sort\"/>\n\n### Sort files by name, best match, size, and time\n\n    --sort[=KEY]\n            Displays matching files in the order specified by KEY in recursive\n            searches.  Normally the ug command sorts by name whereas the ugrep\n            batch command displays matches in no particular order to improve\n            performance.  The sort KEY can be `name' to sort by pathname\n            (default), `best' to sort by best match with option -Z (sort by\n            best match requires two passes over files, which is expensive),\n            `size' to sort by file size, `used' to sort by last access time,\n            `changed' to sort by last modification time and `created' to sort\n            by creation time.  Sorting is reversed with `rname', `rbest',\n            `rsize', `rused', `rchanged', or `rcreated'.  Archive contents are\n            not sorted.  Subdirectories are sorted and displayed after matching\n            files.  FILE arguments are searched in the same order as specified.\n\nMatching files are displayed in the order specified by `--sort` per directory\nsearched.  By default, the `ug` command sorts by name whereas the output of the\n`ugrep` command is not sorted to improve performance, unless option `-Q` is\nused which sorts files by name.  An optimized sorting method and strategy are\nimplemented in the asynchronous output class to keep the overhead of sorting\nvery low.  Directories are displayed after files are displayed first, when\nrecursing, which visually aids the user in finding the \"closest\" matching files\nfirst at the top of the displayed results.\n\nTo recursively search for C++ files that match `main` and sort them by date\ncreated:\n\n    ug --sort=created -tc++ 'main'\n\nSame, but sorted by time changed from most recent to oldest:\n\n    ug --sort=rchanged -tc++ 'main'\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"tips\"/>\n\n### Tips for advanced users\n\nWhen searching non-binary files only, the binary content check is disabled with\noption `-a` (`--text`) to speed up searching and displaying pattern matches.\nFor example, searching for lines with `int` in C++ source code:\n\n    ug -r -a -Ocpp -w 'int'\n\nIf a file has potentially many pattern matches, but each match is only one a\nsingle line, then option `-u` (`--ungroup`) can speed this up:\n\n    ug -r -a -u -Opython -w 'def'\n\nEven greater speeds can be achieved with `--format` when searching files with\nmany matches.  For example, `--format='%O%~'` displays matching lines for each\nmatch on that line, while `--format='%o%~'` displays the matching part only.\nNote that the `--format` option does not check for binary matches, so the\noutput is always \"as is\".  To match text and binary, you can use\n`--format='%C%~'` to display matches formatted as quoted C++ strings with\nescapes.  To display a line at most once (unless option `-u` is used), add the\n`%u` (unique) field to the format string, e.g. `--format='%u%O%~'`.\n\nFor example, to match all words recursively in the working directory with line\nand column numbers, where `%n` is the line number, `%k` is the column number,\n`%o` is the match (only matching), and `%~` is a newline:\n\n    ug -r --format='%n,%k:%o%~' '\\w+'\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"more\"/>\n\n### More examples\n\nTo search for pattern `-o` in `script.sh` using `-e` to explicitly specify a\npattern to prevent pattern `-o` from being interpreted as an option:\n\n    ug -n -e '-o' script.sh\n\nAlternatively, using `--` to end the list of command arguments:\n\n    ug -n -- '-o' script.sh\n\nTo recursively list all text files (.txt and .md) that do not properly end with\na `\\n` (`-o` is required to match `\\n` or `\\z`):\n\n    ug -L -o -Otext '\\n\\z'\n\nTo list all markdown sections in text files (.text, .txt, .TXT, and .md):\n\n    ug -o -ttext -e '^.*(?=\\r?\\n(===|---))' -e '^#{1,6}\\h+.*'\n\nTo display multi-line backtick and indented code blocks in markdown files with\ntheir line numbers, using a lazy quantifier `*?` to make the pattern compact:\n\n    ug -n -ttext -e '^```(.|\\n)*?\\n```' -e '^(\\t|[ ]{4}).*'\n\nTo find mismatched code (a backtick without matching backtick on the same line)\nin markdown:\n\n    ug -n -ttext -e '`[^`]+' -N '`[^`]*`'\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"man\"/>\n\n### Man page\n\n    UGREP(1)                          User Commands                         UGREP(1)\n\n\n\n    NAME\n           ugrep, ug -- file pattern searcher\n\n    SYNOPSIS\n           ugrep [OPTIONS] [-i] [-Q|PATTERN] [-e PATTERN] [-N PATTERN] [-f FILE]\n                 [-F|-G|-P|-Z] [-U] [-m [MIN,][MAX]] [--bool [--files|--lines]]\n                 [-r|-R|-1|...|-9|--10|...] [-t TYPES] [-g GLOBS] [--sort[=KEY]]\n                 [-l|-c] [-o] [-n] [-k] [-b] [-A NUM] [-B NUM] [-C NUM] [-y]\n                 [--color[=WHEN]|--colour[=WHEN]] [--pretty] [--pager[=COMMAND]]\n                 [--hexdump|--csv|--json|--xml] [-I] [-z] [--zmax=NUM] [FILE ...]\n\n    DESCRIPTION\n           The ugrep utility searches any given input files, selecting lines that\n           match one or more patterns.  By default, a pattern matches an input line\n           if the regular expression (RE) matches the input line.  A pattern matches\n           multiple input lines if the RE in the pattern matches one or more\n           newlines in the input.  An empty pattern matches every line.  Each input\n           line that matches at least one of the patterns is written to the standard\n           output.\n\n           The ug command is intended for interactive searching, using a .ugrep\n           configuration file located in the working directory or home directory,\n           see CONFIGURATION.  ug is equivalent to ugrep --config --pretty --sort to\n           load a .ugrep file, enhance the terminal output, and sort files by name.\n\n           The ugrep+ and ug+ commands are the same as the ugrep and ug commands,\n           but also use filters to search pdfs, documents, e-books, and image\n           metadata, when the corresponding filter tools are installed.\n\n           A list of matching files is produced with option -l (--files-with-\n           matches).  Option -c (--count) counts the number of matching lines.\n           Combine with option -o to count the total number of matches.  Combine\n           with option -m1, (--min-count=1) to omit zero matches.\n\n           The default pattern syntax is an extended form of the POSIX ERE syntax,\n           same as option -E (--extended-regexp).  Try ug --help regex for help with\n           pattern syntax and how to use logical connectives to specify Boolean\n           search queries with option -% (--bool).  Options -F (--fixed-strings), -G\n           (--basic-regexp) and -P (--perl-regexp) specify other pattern syntaxes.\n\n           Option -i (--ignore-case) ignores case in ASCII patterns.  Combine with\n           option -P for case-insensitive Unicode matching.  Option -j (--smart-\n           case) enables -i only if the search patterns are specified in lower case.\n\n           Fuzzy (approximate) search is specified with option -Z (--fuzzy) with an\n           optional argument to control character insertions, deletions, and/or\n           substitutions.  Try ug --help fuzzy for help with fuzzy search.\n\n           Note that pattern `.' matches any non-newline character.  Pattern `\\n'\n           matches a newline character.  Multiple lines may be matched with patterns\n           that match one or more newline characters.\n\n           Empty-matching patterns do not match all lines.  For example, the pattern\n           `a*' will match one or more a's.  The single exception to this rule is\n           the empty pattern \"\", which matches all lines.  Option -Y forces empty\n           matches for compatibility with other grep tools.\n\n           Option -f FILE matches patterns specified in FILE.\n\n           By default Unicode patterns are matched.  Option -U (--binary) disables\n           Unicode matching for ASCII and binary pattern matching.  Non-Unicode\n           matching is generally more efficient.\n\n           ugrep accepts input of various encoding formats and normalizes the output\n           to UTF-8.  When a UTF byte order mark is present in the input, the input\n           is automatically normalized.  An input encoding format may be specified\n           with option --encoding.\n\n           If no FILE arguments are specified and standard input is read from a\n           terminal, recursive searches are performed as if -r is specified.  To\n           force reading from standard input, specify `-' as a FILE argument.\n\n           Directories specified as FILE arguments are searched without recursing\n           deeper into subdirectories, unless -R, -r, or -2...-9 is specified to\n           search subdirectories recursively (up to the specified depth.)\n\n           Option -I (--ignore-binary) ignores binary files.  A binary file is a\n           file with non-text content.  A file with zero bytes or invalid UTF\n           formatting is considered binary.\n\n           Hidden files and directories are ignored in recursive searches.  Option\n           -. (--hidden) includes hidden files and directories in recursive\n           searches.\n\n           To match the names of files to search and the names of directories to\n           recurse, one or more of the following options may be specified.  Option\n           -O specifies one or more filename extensions to match.  Option -t\n           specifies one or more file types to search (-t list outputs a list of\n           types.)  Option -g specifies a gitignore-style glob pattern to match\n           filenames.  Option --ignore-files specifies a file with gitignore-style\n           globs to ignore directories and files.  Try ug --help globs for help with\n           filename and directory name matching.  See also section GLOBBING.\n\n           Compressed files and archives are searched with option -z (--decompress).\n           When used with option --zmax=NUM, searches the contents of compressed\n           files and archives stored within archives up to NUM levels.\n\n           A query terminal user interface (TUI) is opened with -Q (--query) to\n           interactively specify search patterns and view search results.  Note that\n           a PATTERN argument cannot be specified in this case.  To specify one or\n           more patterns with -Q to start searching, use -e PATTERN.\n\n           Output to a terminal for viewing is enhanced with --pretty, which is\n           enabled by default with the ug command.\n\n           A terminal output pager is enabled with --pager.\n\n           Customized output is produced with option --format or --replace.  Try ug\n           --help format for help with custom formatting of the output.  Predefined\n           formats include CSV with option --csv, JSON with option --json, and XML\n           with option --xml.  Hexdumps are output with option -X (--hex) or with\n           option --hexdump to customize hexdumps.  See also section FORMAT.\n\n           A `--' signals the end of options; the rest of the parameters are FILE\n           arguments, allowing filenames to begin with a `-' character.\n\n           Long options may start with `--no-' to disable, when applicable.\n\n           ug --help WHAT displays help on options related to WHAT.\n\n           The following options are available:\n\n           -A NUM, --after-context=NUM\n                  Output NUM lines of trailing context after matching lines.  Places\n                  a --group-separator between contiguous groups of matches.  If -o\n                  is specified, output the match with context to fit NUM columns\n                  after the match or shortens the match.  See also options -B, -C\n                  and -y.\n\n           -a, --text\n                  Process a binary file as if it were text.  This is equivalent to\n                  the --binary-files=text option.  This option might output binary\n                  garbage to the terminal, which can have problematic consequences\n                  if the terminal driver interprets some of it as commands.\n\n           --and [-e] PATTERN ... -e PATTERN\n                  Specify additional patterns to match.  Patterns must be specified\n                  with -e.  Each -e PATTERN following this option is considered an\n                  alternative pattern to match, i.e. each -e is interpreted as an OR\n                  pattern.  For example, -e A -e B --and -e C -e D matches lines\n                  with (`A' or `B') and (`C' or `D').  Note that multiple -e PATTERN\n                  are alternations that bind more tightly together than --and.\n                  Option --stats displays the search patterns applied.  See also\n                  options --not, --andnot, --bool, --files and --lines.\n\n           --andnot [-e] PATTERN\n                  Combines --and --not.  See also options --and, --not and --bool.\n\n           -B NUM, --before-context=NUM\n                  Output NUM lines of leading context before matching lines.  Places\n                  a --group-separator between contiguous groups of matches.  If -o\n                  is specified, output the match with context to fit NUM columns\n                  before the match or shortens the match.  See also options -A, -C\n                  and -y.\n\n           -b, --byte-offset\n                  The offset in bytes of a matched line is displayed in front of the\n                  respective matched line.  If -u is specified, displays the offset\n                  for each pattern matched on the same line.  Byte offsets are exact\n                  for ASCII, UTF-8 and raw binary input.  Otherwise, the byte offset\n                  in the UTF-8 normalized input is displayed.\n\n           --binary-files=TYPE\n                  Controls searching and reporting pattern matches in binary files.\n                  TYPE can be `binary', `without-match`, `text`, `hex` and\n                  `with-hex'.  The default is `binary' to search binary files and to\n                  report a match without displaying the match.  `without-match'\n                  ignores binary matches.  `text' treats all binary files as text,\n                  which might output binary garbage to the terminal, which can have\n                  problematic consequences if the terminal driver interprets some of\n                  it as commands.  `hex' reports all matches in hexadecimal.\n                  `with-hex' only reports binary matches in hexadecimal, leaving\n                  text matches alone.  A match is considered binary when matching a\n                  zero byte or invalid UTF.  Short options are -a, -I, -U, -W and\n                  -X.\n\n           --bool, -%\n                  Specifies Boolean query patterns.  A Boolean query pattern is\n                  composed of `AND', `OR', `NOT' operators and grouping with `('\n                  `)'.  Spacing between subpatterns is the same as `AND', `|' is the\n                  same as `OR' and a `-' is the same as `NOT'.  The `OR' operator\n                  binds more tightly than `AND'.  For example, --bool 'A|B C|D'\n                  matches lines with (`A' or `B') and (`C' or `D'), --bool 'A -B'\n                  matches lines with `A' and not `B'.  Operators `AND', `OR', `NOT'\n                  require proper spacing.  For example, --bool 'A OR B AND C OR D'\n                  matches lines with (`A' or `B') and (`C' or `D'), --bool 'A AND\n                  NOT B' matches lines with `A' without `B'.  Quoted subpatterns are\n                  matched literally as strings.  For example, --bool 'A \"AND\"|\"OR\"'\n                  matches lines with `A' and also either `AND' or `OR'.  Parenthesis\n                  are used for grouping.  For example, --bool '(A B)|C' matches\n                  lines with `A' and `B', or lines with `C'.  Note that all\n                  subpatterns in a Boolean query pattern are regular expressions,\n                  unless -F is specified.  Options -E, -F, -G, -P and -Z can be\n                  combined with --bool to match subpatterns as strings or regular\n                  expressions (-E is the default.)  This option does not apply to -f\n                  FILE patterns.  Option --stats displays the search patterns\n                  applied.  See also options --and, --andnot, --not, --files and\n                  --lines.\n\n           --break\n                  Adds a line break between results from different files.  This\n                  option is enabled by --pretty when the output is sent to a\n                  terminal.\n\n           -C NUM, --context=NUM\n                  Output NUM lines of leading and trailing context surrounding each\n                  matching line.  Places a --group-separator between contiguous\n                  groups of matches.  If -o is specified, output the match with\n                  context to fit NUM columns before and after the match or shortens\n                  the match.  See also options -A, -B and -y.\n\n           -c, --count\n                  Only a count of selected lines is written to standard output.  If\n                  -o or -u is specified, counts the number of patterns matched.  If\n                  -v is specified, counts the number of non-matching lines.  If\n                  --tree is specified, outputs directories in a tree-like format.\n\n           --color[=WHEN], --colour[=WHEN]\n                  Mark up the matching text with the expression stored in the\n                  GREP_COLOR or GREP_COLORS environment variable.  WHEN can be\n                  `never', `always', or `auto', where `auto' marks up matches only\n                  when output on a terminal.  The default is `auto'.\n\n           --colors=COLORS, --colours=COLORS\n                  Use COLORS to mark up text.  COLORS is a colon-separated list of\n                  one or more parameters `sl=' (selected line), `cx=' (context\n                  line), `mt=' (matched text), `ms=' (match selected), `mc=' (match\n                  context), `fn=' (file name), `ln=' (line number), `cn=' (column\n                  number), `bn=' (byte offset), `se=' (separator).  Parameter values\n                  are ANSI SGR color codes or `k' (black), `r' (red), `g' (green),\n                  `y' (yellow), `b' (blue), `m' (magenta), `c' (cyan), `w' (white).\n                  Upper case specifies background colors.  A `+' qualifies a color\n                  as bright.  A foreground and a background color may be combined\n                  with font properties `n' (normal), `f' (faint), `h' (highlight),\n                  `i' (invert), `u' (underline).  Parameter `hl' enables file name\n                  hyperlinks.  Parameter `rv' reverses the `sl=' and `cx='\n                  parameters when option -v is specified.  Selectively overrides\n                  GREP_COLORS.\n\n           --config[=FILE], ---[FILE]\n                  Use configuration FILE.  The default FILE is `.ugrep'.  The\n                  working directory is checked first for FILE, then the home\n                  directory.  The options specified in the configuration FILE are\n                  parsed first, followed by the remaining options specified on the\n                  command line.\n\n           --confirm\n                  Confirm actions in -Q query mode.  The default is confirm.\n\n           --cpp  Output file matches in C++.  See also options --format and -u.\n\n           --csv  Output file matches in CSV.  If -H, -n, -k, or -b is specified,\n                  additional values are output.  See also options --format and -u.\n\n           -D ACTION, --devices=ACTION\n                  If an input file is a device, FIFO or socket, use ACTION to\n                  process it.  By default, ACTION is `skip', which means that\n                  devices are silently skipped.  If ACTION is `read', devices read\n                  just as if they were ordinary files.\n\n           -d ACTION, --directories=ACTION\n                  If an input file is a directory, use ACTION to process it.  By\n                  default, ACTION is `skip', i.e., silently skip directories unless\n                  specified on the command line.  If ACTION is `read', warn when\n                  directories are read as input.  If ACTION is `recurse', read all\n                  files under each directory, recursively, following symbolic links\n                  only if they are on the command line.  This is equivalent to the\n                  -r option.  If ACTION is `dereference-recurse', read all files\n                  under each directory, recursively, following symbolic links.  This\n                  is equivalent to the -R option.\n\n           --depth=[MIN,][MAX], -1, -2, -3, ... -9, --10, --11, --12, ...\n                  Restrict recursive searches from MIN to MAX directory levels deep,\n                  where -1 (--depth=1) searches the specified path without recursing\n                  into subdirectories.  Note that -3 -5, -3-5, and -35 search 3 to 5\n                  levels deep.  Enables -r if -R or -r is not specified.\n\n           --dotall\n                  Dot `.' in regular expressions matches anything, including\n                  newline.  Note that `.*' matches all input and should not be used.\n\n           -E, --extended-regexp\n                  Interpret patterns as extended regular expressions (EREs). This is\n                  the default.\n\n           -e PATTERN, --regexp=PATTERN\n                  Specify a PATTERN used during the search of the input: an input\n                  line is selected if it matches any of the specified patterns.\n                  Note that longer patterns take precedence over shorter patterns.\n                  This option is most useful when multiple -e options are used to\n                  specify multiple patterns, when a pattern begins with a dash\n                  (`-'), to specify a pattern after option -f or after the FILE\n                  arguments.\n\n           --encoding=ENCODING\n                  The encoding format of the input.  The default ENCODING is binary\n                  and UTF-8 which are the same.  Note that option -U specifies\n                  binary PATTERN matching (text matching is the default.)  ENCODING\n                  can be: `binary', `ASCII', `UTF-8', `UTF-16', `UTF-16BE',\n                  `UTF-16LE', `UTF-32', `UTF-32BE', `UTF-32LE', `LATIN1',\n                  `ISO-8859-1', `ISO-8859-2', `ISO-8859-3', `ISO-8859-4',\n                  `ISO-8859-5', `ISO-8859-6', `ISO-8859-7', `ISO-8859-8',\n                  `ISO-8859-9', `ISO-8859-10', `ISO-8859-11', `ISO-8859-13',\n                  `ISO-8859-14', `ISO-8859-15', `ISO-8859-16', `MAC', `MACROMAN',\n                  `EBCDIC', `CP437', `CP850', `CP858', `CP1250', `CP1251', `CP1252',\n                  `CP1253', `CP1254', `CP1255', `CP1256', `CP1257', `CP1258',\n                  `KOI8-R', `KOI8-U', `KOI8-RU'.\n\n           --exclude=GLOB\n                  Skip files whose name matches GLOB using wildcard matching, same\n                  as -g ^GLOB.  GLOB can use **, *, ?, and [...] as wildcards and \\\n                  to quote a wildcard or backslash character literally.  When GLOB\n                  contains a `/', full pathnames are matched.  Otherwise basenames\n                  are matched.  When GLOB ends with a `/', directories are excluded\n                  as if --exclude-dir is specified.  Otherwise files are excluded.\n                  Note that --exclude patterns take priority over --include\n                  patterns.  GLOB should be quoted to prevent shell globbing.  This\n                  option may be repeated.\n\n           --exclude-dir=GLOB\n                  Exclude directories whose name matches GLOB from recursive\n                  searches, same as -g ^GLOB/.  GLOB can use **, *, ?, and [...] as\n                  wildcards and \\ to quote a wildcard or backslash character\n                  literally.  When GLOB contains a `/', full pathnames are matched.\n                  Otherwise basenames are matched.  Note that --exclude-dir patterns\n                  take priority over --include-dir patterns.  GLOB should be quoted\n                  to prevent shell globbing.  This option may be repeated.\n\n           --exclude-from=FILE\n                  Read the globs from FILE and skip files and directories whose name\n                  matches one or more globs.  A glob can use **, *, ?, and [...] as\n                  wildcards and \\ to quote a wildcard or backslash character\n                  literally.  When a glob contains a `/', full pathnames are\n                  matched.  Otherwise basenames are matched.  When a glob ends with\n                  a `/', directories are excluded as if --exclude-dir is specified.\n                  Otherwise files are excluded.  A glob starting with a `!'\n                  overrides previously-specified exclusions by including matching\n                  files.  Lines starting with a `#' and empty lines in FILE are\n                  ignored.  When FILE is a `-', standard input is read.  This option\n                  may be repeated.\n\n           --exclude-fs=MOUNTS\n                  Exclude file systems specified by MOUNTS from recursive searches,\n                  MOUNTS is a comma-separated list of mount points or pathnames of\n                  directories on file systems.  Note that --exclude-fs mounts take\n                  priority over --include-fs mounts.  This option may be repeated.\n\n           -F, --fixed-strings\n                  Interpret pattern as a set of fixed strings, separated by\n                  newlines, any of which is to be matched.  This makes ugrep behave\n                  as fgrep.  If a PATTERN is specified, or -e PATTERN or -N PATTERN,\n                  then this option has no effect on -f FILE patterns to allow -f\n                  FILE patterns to narrow or widen the scope of the PATTERN search.\n\n           -f FILE, --file=FILE\n                  Read newline-separated patterns from FILE.  White space in\n                  patterns is significant.  Empty lines in FILE are ignored.  If\n                  FILE does not exist, the GREP_PATH environment variable is used as\n                  path to FILE.  If that fails, looks for FILE in\n                  /usr/local/share/ugrep/patterns.  When FILE is a `-', standard\n                  input is read.  Empty files contain no patterns; thus nothing is\n                  matched.  This option may be repeated.\n\n           --filter=COMMANDS\n                  Filter files through the specified COMMANDS first before\n                  searching.  COMMANDS is a comma-separated list of `exts:command\n                  [option ...]', where `exts' is a comma-separated list of filename\n                  extensions and `command' is a filter utility.  Files matching one\n                  of `exts' are filtered.  When `exts' is a `*', all files are\n                  filtered.  One or more `option' separated by spacing may be\n                  specified, which are passed verbatim to the command.  A `%' as\n                  `option' expands into the pathname to search.  For example,\n                  --filter='pdf:pdftotext % -' searches PDF files.  The `%' expands\n                  into a `-' when searching standard input.  When a `%' is not\n                  specified, a filter utility should read from standard input and\n                  write to standard output.  Option --label=.ext may be used to\n                  specify extension `ext' when searching standard input.  This\n                  option may be repeated.\n\n           --filter-magic-label=[+]LABEL:MAGIC\n                  Associate LABEL with files whose signature \"magic bytes\" match the\n                  MAGIC regex pattern.  Only files that have no filename extension\n                  are labeled, unless +LABEL is specified.  When LABEL matches an\n                  extension specified in --filter=COMMANDS, the corresponding\n                  command is invoked.  This option may be repeated.\n\n           --format=FORMAT\n                  Output FORMAT-formatted matches.  For example\n                  --format='%f:%n:%O%~' outputs matching lines `%O' with filename\n                  `%f` and line number `%n' followed by a newline `%~'.  If -P is\n                  specified, FORMAT may include `%1' to `%9', `%[NUM]#' and\n                  `%[NAME]#' to output group captures.  A `%%' outputs `%'.  See\n                  `ugrep --help format' and `man ugrep' section FORMAT for details.\n                  When option -o is specified, option -u is also enabled.  Context\n                  options -A, -B, -C and -y are ignored.\n\n           --free-space\n                  Spacing (blanks and tabs) in regular expressions are ignored.\n\n           -G, --basic-regexp\n                  Interpret patterns as basic regular expressions (BREs), i.e. make\n                  ugrep behave as traditional grep.\n\n           -g GLOBS, --glob=GLOBS, --iglob=GLOBS\n                  Search only files whose name matches the specified comma-separated\n                  list of GLOBS, same as --include='glob' for each `glob' in GLOBS.\n                  When a `glob' is preceded by a `!' or a `^', skip files whose name\n                  matches `glob', same as --exclude='glob'.  When `glob' contains a\n                  `/', full pathnames are matched.  Otherwise basenames are matched.\n                  When `glob' ends with a `/', directories are matched, same as\n                  --include-dir='glob' and --exclude-dir='glob'.  A leading `/'\n                  matches the working directory.  Option --iglob performs\n                  case-insensitive name matching.  This option may be repeated and\n                  may be combined with options -M, -O and -t to expand searches.\n                  See `ugrep --help globs' and `man ugrep' section GLOBBING for\n                  details.\n\n           --glob-ignore-case\n                  Perform case-insensitive glob matching in general.\n\n           --group-separator[=SEP]\n                  Use SEP as a group separator for context options -A, -B and -C.\n                  The default is a double hyphen (`--').\n\n           -H, --with-filename\n                  Always print the filename with output lines.  This is the default\n                  when there is more than one file to search.\n\n           -h, --no-filename\n                  Never print filenames with output lines.  This is the default when\n                  there is only one file (or only standard input) to search.\n\n           --heading, -+\n                  Group matches per file.  Adds a heading and a line break between\n                  results from different files.  This option is enabled by --pretty\n                  when the output is sent to a terminal.\n\n           --help [WHAT], -? [WHAT]\n                  Display a help message on options related to WHAT when specified.\n                  In addition, `--help regex' displays an overview of regular\n                  expressions, `--help globs' displays an overview of glob syntax\n                  and conventions.  `--help fuzzy' displays details of fuzzy search\n                  with option -Z and `--help format' displays a list of --format\n                  fields.\n\n           --hexdump[=[1-8][a][bch][A[NUM]][B[NUM]][C[NUM]]]\n                  Output matches in 1 to 8 columns of 8 hexadecimal octets.  The\n                  default is 2 columns or 16 octets per line.  Option `a' outputs a\n                  `*' for all hex lines that are identical to the previous hex line,\n                  `b' removes all space breaks, `c' removes the character column,\n                  `h' removes hex spacing, `A' includes up to NUM hex lines after\n                  the match, `B' includes up to NUM hex lines before the match and\n                  `C' includes up to NUM hex lines.  When NUM is omitted, the\n                  matching line is included in the output.  See also options -U, -W\n                  and -X.\n\n           --hidden, -.\n                  Search hidden files and directories.\n\n           --hyperlink[=[PREFIX][+]]\n                  Hyperlinks are enabled for file names when colors are enabled.\n                  Same as --colors=hl.  When PREFIX is specified, replaces file://\n                  with PREFIX:// in the hyperlink.  A `+' includes the line number\n                  in the hyperlink and when option -k is specified, the column\n                  number.\n\n           -I, --ignore-binary\n                  Ignore matches in binary files.  This option is equivalent to the\n                  --binary-files=without-match option.\n\n           -i, --ignore-case\n                  Perform case insensitive matching.  By default, ugrep is case\n                  sensitive.  By default, this option applies to ASCII letters only.\n                  Use options -P and -i for Unicode case insensitive matching.\n\n           --ignore-files[=FILE]\n                  Ignore files and directories matching the globs in each FILE that\n                  is encountered in recursive searches.  The default FILE is\n                  `.gitignore'.  Matching files and directories located in the\n                  directory of a FILE's location and in directories below are\n                  ignored by temporarily extending the --exclude and --exclude-dir\n                  globs, as if --exclude-from=FILE is locally enforced.  Globbing\n                  syntax is the same as the --exclude-from=FILE gitignore syntax;\n                  directories are excluded when the glob ends in a `/', same as git.\n                  Files and directories explicitly specified as command line\n                  arguments are never ignored.  This option may be repeated with\n                  additional files.\n\n           --include=GLOB\n                  Search only files whose name matches GLOB using wildcard matching,\n                  same as -g GLOB.  GLOB can use **, *, ?, and [...] as wildcards\n                  and \\ to quote a wildcard or backslash character literally.  When\n                  GLOB contains a `/', full pathnames are matched.  Otherwise\n                  basenames are matched.  When GLOB ends with a `/', directories are\n                  included as if --include-dir is specified.  Otherwise files are\n                  included.  Note that --exclude patterns take priority over\n                  --include patterns.  GLOB should be quoted to prevent shell\n                  globbing.  This option may be repeated.\n\n           --include-dir=GLOB\n                  Only directories whose name matches GLOB are included in recursive\n                  searches, same as -g GLOB/.  GLOB can use **, *, ?, and [...] as\n                  wildcards and \\ to quote a wildcard or backslash character\n                  literally.  When GLOB contains a `/', full pathnames are matched.\n                  Otherwise basenames are matched.  Note that --exclude-dir patterns\n                  take priority over --include-dir patterns.  GLOB should be quoted\n                  to prevent shell globbing.  This option may be repeated.\n\n           --include-from=FILE\n                  Read the globs from FILE and search only files and directories\n                  whose name matches one or more globs.  A glob can use **, *, ?,\n                  and [...] as wildcards and \\ to quote a wildcard or backslash\n                  character literally.  When a glob contains a `/', full pathnames\n                  are matched.  Otherwise basenames are matched.  When a glob ends\n                  with a `/', directories are included as if --include-dir is\n                  specified.  Otherwise files are included.  A glob starting with a\n                  `!' overrides previously-specified inclusions by excluding\n                  matching files.  Lines starting with a `#' and empty lines in FILE\n                  are ignored.  When FILE is a `-', standard input is read.  This\n                  option may be repeated.\n\n           --include-fs=MOUNTS\n                  Only file systems specified by MOUNTS are included in recursive\n                  searches.  MOUNTS is a comma-separated list of mount points or\n                  pathnames of directories on file systems.  --include-fs=.\n                  restricts recursive searches to the file system of the working\n                  directory only.  Note that --exclude-fs mounts take priority over\n                  --include-fs mounts.  This option may be repeated.\n\n           --index\n                  Perform indexing-based search on files indexed with ugrep-indexer.\n                  Recursive searches are performed by skipping non-matching files.\n                  Binary files are skipped with option -I.  Note that the start-up\n                  time to search is increased, which may be significant when complex\n                  search patterns are specified that contain large Unicode character\n                  classes with `*' or `+' repeats, which should be avoided.  Option\n                  -U (--ascii) improves performance.  Option --stats=vm displays a\n                  detailed indexing-based search report.  This is a beta feature.\n\n           -J NUM, --jobs=NUM\n                  Specifies the number of threads spawned to search files.  By\n                  default an optimum number of threads is spawned to search files\n                  simultaneously.  -J1 disables threading: files are searched in the\n                  same order as specified.\n\n           -j, --smart-case\n                  Perform case insensitive matching like option -i, unless a pattern\n                  is specified with a literal ASCII upper case letter.\n\n           --json Output file matches in JSON.  If -H, -n, -k, or -b is specified,\n                  additional values are output.  See also options --format and -u.\n\n           -K [MIN,][MAX], --range=[MIN,][MAX], --min-line=MIN, --max-line=MAX\n                  Start searching at line MIN, stop at line MAX when specified.\n\n           -k, --column-number\n                  The column number of a matched pattern is displayed in front of\n                  the respective matched line, starting at column 1.  Tabs are\n                  expanded when columns are counted, see also option --tabs.\n\n           -L, --files-without-match\n                  Only the names of files not containing selected lines are written\n                  to standard output.  Pathnames are listed once per file searched.\n                  If the standard input is searched, the string ``(standard input)''\n                  is written.  If --tree is specified, outputs directories in a\n                  tree-like format.\n\n           -l, --files-with-matches\n                  Only the names of files containing selected lines are written to\n                  standard output.  ugrep will only search a file until a match has\n                  been found, making searches potentially less expensive.  Pathnames\n                  are listed once per file searched.  If the standard input is\n                  searched, the string ``(standard input)'' is written.  If --tree\n                  is specified, outputs directories in a tree-like format.\n\n           --label=LABEL\n                  Displays the LABEL value when input is read from standard input\n                  where a file name would normally be printed in the output.\n                  Associates a filename extension with standard input when LABEL has\n                  a suffix.  The default value is `(standard input)'.\n\n           --line-buffered\n                  Force output to be line buffered instead of block buffered.\n\n           --lines\n                  Apply Boolean queries to match lines, the opposite of --files.\n                  This is the default Boolean query mode to match specific lines.\n\n           -M MAGIC, --file-magic=MAGIC\n                  Only files matching the signature pattern MAGIC are searched.  The\n                  signature \"magic bytes\" at the start of a file are compared to the\n                  MAGIC regex pattern.  When matching, the file will be searched.\n                  When MAGIC is preceded by a `!' or a `^', skip files with matching\n                  MAGIC signatures.  This option may be repeated and may be combined\n                  with options -O and -t to expand the search.  Every file on the\n                  search path is read, making searches potentially more expensive.\n\n           -m [MIN,][MAX], --min-count=MIN, --max-count=MAX\n                  Require MIN matches, stop after MAX matches when specified.\n                  Output MIN to MAX matches.  For example, -m1 outputs the first\n                  match and -cm1, (with a comma) counts non-zero matches.  See also\n                  option -K.\n\n           --match\n                  Match all input.  Same as specifying an empty pattern to search.\n\n           --max-files=NUM\n                  Restrict the number of files matched to NUM.  Note that --sort or\n                  -J1 may be specified to produce replicable results.  If --sort is\n                  specified, the number of threads spawned is limited to NUM.\n\n           --mmap[=MAX]\n                  Use memory maps to search files.  By default, memory maps are used\n                  under certain conditions to improve performance.  When MAX is\n                  specified, use up to MAX mmap memory per thread.\n\n           -N PATTERN, --neg-regexp=PATTERN\n                  Specify a negative PATTERN used during the search of the input: an\n                  input line is selected only if it matches the specified patterns\n                  unless it matches the negative PATTERN.  Same as -e (?^PATTERN).\n                  Negative pattern matches are essentially removed before any other\n                  patterns are matched.  Note that longer patterns take precedence\n                  over shorter patterns.  This option may be repeated.\n\n           -n, --line-number\n                  Each output line is preceded by its relative line number in the\n                  file, starting at line 1.  The line number counter is reset for\n                  each file processed.\n\n           --no-group-separator\n                  Removes the group separator line from the output for context\n                  options -A, -B and -C.\n\n           --not [-e] PATTERN\n                  Specifies that PATTERN should not match.  Note that -e A --not -e\n                  B matches lines with `A' or lines without a `B'.  To match lines\n                  with `A' that have no `B', specify -e A --andnot -e B.  Option\n                  --stats displays the search patterns applied.  See also options\n                  --and, --andnot, --bool, --files and --lines.\n\n           -O EXTENSIONS, --file-extension=EXTENSIONS\n                  Search only files whose filename extensions match the specified\n                  comma-separated list of EXTENSIONS, same as --include='*.ext' for\n                  each `ext' in EXTENSIONS.  When an `ext' is preceded by a `!' or a\n                  `^', skip files whose filename extensions matches `ext', same as\n                  --exclude='*.ext'.  This option may be repeated and may be\n                  combined with options -g, -M and -t to expand the recursive\n                  search.\n\n           -o, --only-matching\n                  Output only the matching part of lines.  Output additional matches\n                  on the same line with `+' as the field separator.  When multiple\n                  lines match a pattern, output the matching lines with `|' as the\n                  field separator.  If -A, -B or -C is specified, fits the match and\n                  its context on a line within the specified number of columns.\n\n           --only-line-number\n                  The line number of the matching line in the file is output without\n                  displaying the match.  The line number counter is reset for each\n                  file processed.\n\n           --files\n                  Apply Boolean queries to match files, the opposite of --lines.  A\n                  file matches if all Boolean conditions are satisfied by the lines\n                  matched in the file.  For example, --files -e A --and -e B -e C\n                  --andnot -e D matches a file if some lines match `A' and some\n                  lines match (`B' or `C') and no line in the file matches `D'.  May\n                  also be specified as --files --bool 'A B|C -D'.  Option -v cannot\n                  be specified with --files.  See also options --and, --andnot,\n                  --not, --bool and --lines.\n\n           -P, --perl-regexp\n                  Interpret PATTERN as a Perl regular expression using PCRE2.  Note\n                  that Perl pattern matching differs from the default grep POSIX\n                  pattern matching.\n\n           -p, --no-dereference\n                  If -R or -r is specified, do not follow symbolic links, even when\n                  symbolic links are specified on the command line.\n\n           --pager[=COMMAND]\n                  When output is sent to the terminal, uses COMMAND to page through\n                  the output.  The default COMMAND is `less -R'.  Enables --heading\n                  and --line-buffered.\n\n           --pretty\n                  When output is sent to a terminal, enables --color, --heading, -n,\n                  --sort, --tree and -T when not explicitly disabled.\n\n           -Q[=DELAY], --query[=DELAY]\n                  Query mode: user interface to perform interactive searches.  This\n                  mode requires an ANSI capable terminal.  An optional DELAY\n                  argument may be specified to reduce or increase the response time\n                  to execute searches after the last key press, in increments of\n                  100ms, where the default is 5 (0.5s delay).  No whitespace may be\n                  given between -Q and its argument DELAY.  Initial patterns may be\n                  specified with -e PATTERN, i.e. a PATTERN argument requires option\n                  -e.  Press F1 or CTRL-Z to view the help screen.  Press F2 or\n                  CTRL-Y to invoke a command to view or edit the file shown at the\n                  top of the screen.  The command can be specified with option\n                  --view, or defaults to environment variable PAGER if defined, or\n                  EDITOR.  Press Tab and Shift-Tab to navigate directories and to\n                  select a file to search.  Press Enter to select lines to output.\n                  Press ALT-l for option -l to list files, ALT-n for -n, etc.\n                  Non-option commands include ALT-] to increase fuzziness and ALT-}\n                  to increase context.  Enables --heading.  See also options\n                  --confirm and --view.\n\n           -q, --quiet, --silent\n                  Quiet mode: suppress all output.  Only search a file until a match\n                  has been found.\n\n           -R, --dereference-recursive\n                  Recursively read all files under each directory.  Follow symbolic\n                  links to files and directories, unlike -r.\n\n           -r, --recursive\n                  Recursively read all files under each directory, following\n                  symbolic links only if they are on the command line.  Note that\n                  when no FILE arguments are specified and input is read from a\n                  terminal, recursive searches are performed as if -r is specified.\n\n           --replace=FORMAT\n                  Replace matching patterns in the output by the specified FORMAT\n                  with `%' fields.  If -P is specified, FORMAT may include `%1' to\n                  `%9', `%[NUM]#' and `%[NAME]#' to output group captures.  A `%%'\n                  outputs `%' and `%~' outputs a newline.  See option --format,\n                  `ugrep --help format' and `man ugrep' section FORMAT for details.\n\n           -S, --dereference-files\n                  When -r is specified, follow symbolic links to files, but not to\n                  directories.  The default is not to follow symbolic links.\n\n           -s, --no-messages\n                  Silent mode: nonexistent and unreadable files are ignored, i.e.\n                  their error messages and warnings are suppressed.\n\n           --save-config[=FILE]\n                  Save configuration FILE.  By default `.ugrep' is saved.  If FILE\n                  is a `-', write the configuration to standard output.\n\n           --separator[=SEP]\n                  Use SEP as field separator between file name, line number, column\n                  number, byte offset and the matched line.  The default is a colon\n                  (`:'), a plus (`+') for additional matches on the same line, and a\n                  bar (`|') for multi-line pattern matches.\n\n           --sort[=KEY]\n                  Displays matching files in the order specified by KEY in recursive\n                  searches.  Normally the ug command sorts by name whereas the ugrep\n                  batch command displays matches in no particular order to improve\n                  performance.  The sort KEY can be `name' to sort by pathname\n                  (default), `best' to sort by best match with option -Z (sort by\n                  best match requires two passes over files, which is expensive),\n                  `size' to sort by file size, `used' to sort by last access time,\n                  `changed' to sort by last modification time and `created' to sort\n                  by creation time.  Sorting is reversed with `rname', `rbest',\n                  `rsize', `rused', `rchanged', or `rcreated'.  Archive contents are\n                  not sorted.  Subdirectories are sorted and displayed after\n                  matching files.  FILE arguments are searched in the same order as\n                  specified.\n\n           --stats\n                  Output statistics on the number of files and directories searched\n                  and the inclusion and exclusion constraints applied.\n\n           -T, --initial-tab\n                  Add a tab space to separate the file name, line number, column\n                  number and byte offset with the matched line.\n\n           -t TYPES, --file-type=TYPES\n                  Search only files associated with TYPES, a comma-separated list of\n                  file types.  Each file type corresponds to a set of filename\n                  extensions passed to option -O and filenames passed to option -g.\n                  For capitalized file types, the search is expanded to include\n                  files with matching file signature magic bytes, as if passed to\n                  option -M.  When a type is preceded by a `!' or a `^', excludes\n                  files of the specified type.  This option may be repeated.  The\n                  possible file types can be (where -tlist displays a detailed\n                  list): `actionscript', `ada', `asm', `asp', `aspx', `autoconf',\n                  `automake', `awk', `Awk', `basic', `batch', `bison', `c', `c++',\n                  `clojure', `cpp', `csharp', `css', `csv', `dart', `Dart',\n                  `delphi', `elisp', `elixir', `erlang', `fortran', `gif', `Gif',\n                  `go', `groovy', `gsp', `haskell', `html', `jade', `java', `jpeg',\n                  `Jpeg', `js', `json', `jsp', `julia', `kotlin', `less', `lex',\n                  `lisp', `lua', `m4', `make', `markdown', `matlab', `node', `Node',\n                  `objc', `objc++', `ocaml', `parrot', `pascal', `pdf', `Pdf',\n                  `perl', `Perl', `php', `Php', `png', `Png', `prolog', `python',\n                  `Python', `r', `rpm', `Rpm', `rst', `rtf', `Rtf', `ruby', `Ruby',\n                  `rust', `scala', `scheme', `shell', `Shell', `smalltalk', `sql',\n                  `svg', `swift', `tcl', `tex', `text', `tiff', `Tiff', `tt',\n                  `typescript', `verilog', `vhdl', `vim', `xml', `Xml', `yacc',\n                  `yaml'.\n\n           --tabs[=NUM]\n                  Set the tab size to NUM to expand tabs for option -k.  The value\n                  of NUM may be 1, 2, 4, or 8.  The default tab size is 8.\n\n           --tag[=TAG[,END]]\n                  Disables colors to mark up matches with TAG.  END marks the end of\n                  a match if specified, otherwise TAG.  The default is `___'.\n\n           --tree, -^\n                  Output directories with matching files in a tree-like format when\n                  options -c, -l or -L are used.  This option is enabled by --pretty\n                  when the output is sent to a terminal.\n\n           -U, --ascii, --binary\n                  Disables Unicode matching for ASCII and binary matching.  PATTERN\n                  matches bytes, not Unicode characters.  For example, -U '\\xa3'\n                  matches byte A3 (hex) instead of the Unicode code point U+00A3\n                  represented by the UTF-8 sequence C2 A3.  See also option\n                  --dotall.\n\n           -u, --ungroup\n                  Do not group multiple pattern matches on the same matched line.\n                  Output the matched line again for each additional pattern match,\n                  using `+' as a separator.\n\n           -V, --version\n                  Display version with linked libraries and exit.\n\n           -v, --invert-match\n                  Selected lines are those not matching any of the specified\n                  patterns.\n\n           --view[=COMMAND]\n                  Use COMMAND to view/edit a file in query mode when pressing\n                  CTRL-Y.\n\n           -W, --with-hex\n                  Output binary matches in hexadecimal, leaving text matches alone.\n                  This option is equivalent to the --binary-files=with-hex option\n                  with --hexdump=2C.  To omit the matching line from the hex output,\n                  combine option --hexdump with option -W.  See also option -U.\n\n           -w, --word-regexp\n                  The PATTERN is searched for as a word, such that the matching text\n                  is preceded by a non-word character and is followed by a non-word\n                  character.  Word characters are letters, digits and the\n                  underscore.  With option -P, word characters are Unicode letters,\n                  digits and underscore.  This option has no effect if -x is also\n                  specified.  If a PATTERN is specified, or -e PATTERN or -N\n                  PATTERN, then this option has no effect on -f FILE patterns to\n                  allow -f FILE patterns to narrow or widen the scope of the PATTERN\n                  search.\n\n           --width[=NUM]\n                  Truncate the output to NUM visible characters per line.  The width\n                  of the terminal window is used if NUM is not specified.  Note that\n                  double wide characters in the output may result in wider lines.\n\n           -X, --hex\n                  Output matches in hexadecimal.  This option is equivalent to the\n                  --binary-files=hex option with --hexdump=2C.  To omit the matching\n                  line from the hex output, use option --hexdump instead of -X.  See\n                  also option -U.\n\n           -x, --line-regexp\n                  Select only those matches that exactly match the whole line, as if\n                  the patterns are surrounded by ^ and $.  If a PATTERN is\n                  specified, or -e PATTERN or -N PATTERN, then this option has no\n                  effect on -f FILE patterns to allow -f FILE patterns to narrow or\n                  widen the scope of the PATTERN search.\n\n           --xml  Output file matches in XML.  If -H, -n, -k, or -b is specified,\n                  additional values are output.  See also options --format and -u.\n\n           -Y, --empty\n                  Permits empty matches.  By default, empty matches are disabled,\n                  unless a pattern begins with `^' or ends with `$'.  With this\n                  option, empty-matching patterns such as x? and x*, match all\n                  input, not only lines containing the character `x'.\n\n           -y, --any-line, --passthru\n                  Any line is output (passthru).  Non-matching lines are output as\n                  context with a `-' separator.  See also options -A, -B and -C.\n\n           -Z[best][+-~][MAX], --fuzzy=[best][+-~][MAX]\n                  Fuzzy mode: report approximate pattern matches within MAX errors.\n                  The default is -Z1: one deletion, insertion or substitution is\n                  allowed.  If `+`, `-' and/or `~' is specified, then `+' allows\n                  insertions, `-' allows deletions and `~' allows substitutions.\n                  For example, -Z+~3 allows up to three insertions or substitutions,\n                  but no deletions.  If `best' is specified, then only the best\n                  matching lines are output with the lowest cost per file.  Option\n                  -Zbest requires two passes over a file and cannot be used with\n                  standard input or Boolean queries.  Option --sort=best orders\n                  matching files by best match.  The first character of an\n                  approximate match always matches a character at the beginning of\n                  the pattern.  To fuzzy match the first character, replace it with\n                  a `.' or `.?'.  Option -U applies fuzzy matching to ASCII and\n                  bytes instead of Unicode text.  No whitespace may be given between\n                  -Z and its argument.\n\n           -z, --decompress\n                  Decompress files to search, when compressed.  Archives (.cpio,\n                  .pax, .tar) and compressed archives (e.g. .zip, .taz, .tgz, .tpz,\n                  .tbz, .tbz2, .tb2, .tz2, .tlz, .txz, .tzst) are searched and\n                  matching pathnames of files in archives are output in braces.\n                  When used with option --zmax=NUM, searches the contents of\n                  compressed files and archives stored within archives up to NUM\n                  levels.  If -g, -O, -M, or -t is specified, searches files stored\n                  in archives whose filenames match globs, match filename\n                  extensions, match file signature magic bytes, or match file types,\n                  respectively.  Supported compression formats: gzip (.gz), compress\n                  (.Z), zip, bzip2 (requires suffix .bz, .bz2, .bzip2, .tbz, .tbz2,\n                  .tb2, .tz2), lzma and xz (requires suffix .lzma, .tlz, .xz, .txz),\n                  lz4 (requires suffix .lz4), zstd (requires suffix .zst, .zstd,\n                  .tzst).\n\n           --zmax=NUM\n                  When used with option -z (--decompress), searches the contents of\n                  compressed files and archives stored within archives by up to NUM\n                  expansion levels deep.  The default --zmax=1 only permits\n                  searching uncompressed files stored in cpio, pax, tar and zip\n                  archives; compressed files and archives are detected as binary\n                  files and are effectively ignored.  Specify --zmax=2 to search\n                  compressed files and archives stored in cpio, pax, tar and zip\n                  archives.  NUM may range from 1 to 99 for up to 99 decompression\n                  and de-archiving steps.  Increasing NUM values gradually degrades\n                  performance.\n\n           -0, --null\n                  Output a zero-byte (NUL) after the file name.  This option can be\n                  used with commands such as `find -print0' and `xargs -0' to\n                  process arbitrary file names.\n\n    EXIT STATUS\n           The ugrep utility exits with one of the following values:\n\n           0      One or more lines were selected.\n\n           1      No lines were selected.\n\n           >1     An error occurred.\n\n           If -q or --quiet or --silent is used and a line is selected, the exit\n           status is 0 even if an error occurred.\n\n    CONFIGURATION\n           The ug command is intended for context-dependent interactive searching\n           and is equivalent to the ugrep --config --pretty --sort command to load\n           the default configuration file `.ugrep' when present in the working\n           directory or in the home directory.\n\n           A configuration file contains `NAME=VALUE' pairs per line, where `NAME`\n           is the name of a long option (without `--') and `=VALUE' is an argument,\n           which is optional and may be omitted depending on the option.  Empty\n           lines and lines starting with a `#' are ignored.\n\n           The --config=FILE option and its abbreviated form ---FILE load the\n           specified configuration file located in the working directory or, when\n           not found, located in the home directory.  An error is produced when FILE\n           is not found or cannot be read.\n\n           Command line options are parsed in the following order: the configuration\n           file is loaded first, followed by the remaining options and arguments on\n           the command line.\n\n           The --save-config option saves a `.ugrep' configuration file to the\n           working directory with a subset of the current options.  The --save-\n           config=FILE option saves the configuration to FILE.  The configuration is\n           written to standard output when FILE is a `-'.\n\n    GLOBBING\n           Globbing is used by options -g, --include, --include-dir, --include-from,\n           --exclude, --exclude-dir, --exclude-from and --ignore-files to match\n           pathnames and basenames in recursive searches.  Glob arguments for these\n           options should be quoted to prevent shell globbing.\n\n           Globbing supports gitignore syntax and the corresponding matching rules,\n           except that a glob normally matches files but not directories.  If a glob\n           ends in a path separator `/', then it matches directories but not files,\n           as if --include-dir or --exclude-dir is specified.  When a glob contains\n           a path separator `/', the full pathname is matched.  Otherwise the\n           basename of a file or directory is matched.  For example, *.h matches\n           foo.h and bar/foo.h.  bar/*.h matches bar/foo.h but not foo.h and not\n           bar/bar/foo.h.  Use a leading `/' to force /*.h to match foo.h but not\n           bar/foo.h.\n\n           When a glob starts with a `^' or a `!' as in -g^GLOB, the match is\n           negated.  Likewise, a `!' (but not a `^') may be used with globs in the\n           files specified --include-from, --exclude-from, and --ignore-files to\n           negate the glob match.  Empty lines or lines starting with a `#' are\n           ignored.\n\n           Glob Syntax and Conventions\n\n           *      Matches anything except /.\n\n           ?      Matches any one character except /.\n\n           [abc-e]\n                  Matches one character a,b,c,d,e.\n\n           [^abc-e]\n                  Matches one character not a,b,c,d,e,/.\n\n           [!abc-e]\n                  Matches one character not a,b,c,d,e,/.\n\n           /      When used at the start of a glob, matches if pathname has no /.\n                  When used at the end of a glob, matches directories only.\n\n           **/    Matches zero or more directories.\n\n           /**    When used at the end of a glob, matches everything after the /.\n\n           \\?     Matches a ? or any other character specified after the backslash.\n\n           Glob Matching Examples\n\n           *      Matches a, b, x/a, x/y/b\n\n           a      Matches a, x/a, x/y/a,       but not b, x/b, a/a/b\n\n           /*     Matches a, b,                but not x/a, x/b, x/y/a\n\n           /a     Matches a,                   but not x/a, x/y/a\n\n           a?b    Matches axb, ayb,            but not a, b, ab, a/b\n\n           a[xy]b Matches axb, ayb             but not a, b, azb\n\n           a[a-z]b\n                  Matches aab, abb, acb, azb,  but not a, b, a3b, aAb, aZb\n\n           a[^xy]b\n                  Matches aab, abb, acb, azb,  but not a, b, axb, ayb\n\n           a[^a-z]b\n                  Matches a3b, aAb, aZb        but not a, b, aab, abb, acb, azb\n\n           a/*/b  Matches a/x/b, a/y/b,        but not a/b, a/x/y/b\n\n           **/a   Matches a, x/a, x/y/a,       but not b, x/b.\n\n           a/**/b Matches a/b, a/x/b, a/x/y/b, but not x/a/b, a/b/x\n\n           a/**   Matches a/x, a/y, a/x/y,     but not a, b/x\n\n           a\\?b   Matches a?b,                 but not a, b, ab, axb, a/b\n\n           Note that exclude glob patterns take priority over include glob patterns\n           when specified with options -g, --exclude, --exclude-dir, --include and\n           include-dir.\n\n           Glob patterns specified with prefix `!' in any of the files associated\n           with --include-from, --exclude-from and --ignore-files will negate a\n           previous glob match.  That is, any matching file or directory excluded by\n           a previous glob pattern specified in the files associated with --exclude-\n           from or --ignore-file will become included again.  Likewise, any matching\n           file or directory included by a previous glob pattern specified in the\n           files associated with --include-from will become excluded again.\n\n    ENVIRONMENT\n           GREP_PATH\n                  May be used to specify a file path to pattern files.  The file\n                  path is used by option -f to open a pattern file, when the pattern\n                  file does not exist.\n\n           GREP_COLOR\n                  May be used to specify ANSI SGR parameters to highlight matches\n                  when option --color is used, e.g. 1;35;40 shows pattern matches in\n                  bold magenta text on a black background.  Deprecated in favor of\n                  GREP_COLORS, but still supported.\n\n           GREP_COLORS\n                  May be used to specify ANSI SGR parameters to highlight matches\n                  and other attributes when option --color is used.  Its value is a\n                  colon-separated list of ANSI SGR parameters that defaults to\n                  cx=33:mt=1;31:fn=1;35:ln=1;32:cn=1;32:bn=1;32:se=36.  The mt=,\n                  ms=, and mc= capabilities of GREP_COLORS take priority over\n                  GREP_COLOR.  Option --colors takes priority over GREP_COLORS.\n\n    GREP_COLORS\n           Colors are specified as string of colon-separated ANSI SGR parameters of\n           the form `what=substring', where `substring' is a semicolon-separated\n           list of ANSI SGR codes or `k' (black), `r' (red), `g' (green), `y'\n           (yellow), `b' (blue), `m' (magenta), `c' (cyan), `w' (white).  Upper case\n           specifies background colors.  A `+' qualifies a color as bright.  A\n           foreground and a background color may be combined with one or more font\n           properties `n' (normal), `f' (faint), `h' (highlight), `i' (invert), `u'\n           (underline).  Substrings may be specified for:\n\n           sl=    SGR substring for selected lines.\n\n           cx=    SGR substring for context lines.\n\n           rv     Swaps the sl= and cx= capabilities when -v is specified.\n\n           mt=    SGR substring for matching text in any matching line.\n\n           ms=    SGR substring for matching text in a selected line.  The substring\n                  mt= by default.\n\n           mc=    SGR substring for matching text in a context line.  The substring\n                  mt= by default.\n\n           fn=    SGR substring for filenames.\n\n           ln=    SGR substring for line numbers.\n\n           cn=    SGR substring for column numbers.\n\n           bn=    SGR substring for byte offsets.\n\n           se=    SGR substring for separators.\n\n           rv     a Boolean parameter, switches sl= and cx= with option -v.\n\n           hl     a Boolean parameter, enables filename hyperlinks (\\33]8;;link).\n\n           ne     a Boolean parameter, disables ``erase in line'' \\33[K.\n\n    FORMAT\n           Option --format=FORMAT specifies an output format for file matches.\n           Fields may be used in FORMAT, which expand into the following values:\n\n           %[ARG]F\n                  if option -H is used: ARG, the file pathname and separator.\n\n           %f     the file pathname.\n\n           %a     the file basename without directory path.\n\n           %p     the directory path to the file.\n\n           %z     the file pathname in a (compressed) archive.\n\n           %[ARG]H\n                  if option -H is used: ARG, the quoted pathname and separator, \\\"\n                  and \\\\ replace \" and \\.\n\n           %h     the quoted file pathname, \\\" and \\\\ replace \" and \\.\n\n           %[ARG]N\n                  if option -n is used: ARG, the line number and separator.\n\n           %n     the line number of the match.\n\n           %[ARG]K\n                  if option -k is used: ARG, the column number and separator.\n\n           %k     the column number of the match.\n\n           %[ARG]B\n                  if option -b is used: ARG, the byte offset and separator.\n\n           %b     the byte offset of the match.\n\n           %[ARG]T\n                  if option -T is used: ARG and a tab character.\n\n           %t     a tab character.\n\n           %[SEP]$\n                  set field separator to SEP for the rest of the format fields.\n\n           %[ARG]<\n                  if the first match: ARG.\n\n           %[ARG]>\n                  if not the first match: ARG.\n\n           %,     if not the first match: a comma, same as %[,]>.\n\n           %:     if not the first match: a colon, same as %[:]>.\n\n           %;     if not the first match: a semicolon, same as %[;]>.\n\n           %|     if not the first match: a vertical bar, same as %[|]>.\n\n           %[ARG]S\n                  if not the first match: ARG and separator, see also %[SEP]$.\n\n           %s     the separator, see also %[ARG]S and %[SEP]$.\n\n           %~     a newline character.\n\n           %M     the number of matching lines\n\n           %m     the number of matches\n\n           %O     the matching line is output as a raw string of bytes.\n\n           %o     the match is output as a raw string of bytes.\n\n           %Q     the matching line as a quoted string, \\\" and \\\\ replace \" and \\.\n\n           %q     the match as a quoted string, \\\" and \\\\ replace \" and \\.\n\n           %C     the matching line formatted as a quoted C/C++ string.\n\n           %c     the match formatted as a quoted C/C++ string.\n\n           %J     the matching line formatted as a quoted JSON string.\n\n           %j     the match formatted as a quoted JSON string.\n\n           %V     the matching line formatted as a quoted CSV string.\n\n           %v     the match formatted as a quoted CSV string.\n\n           %X     the matching line formatted as XML character data.\n\n           %x     the match formatted as XML character data.\n\n           %w     the width of the match, counting wide characters.\n\n           %d     the size of the match, counting bytes.\n\n           %e     the ending byte offset of the match.\n\n           %Z     the edit distance cost of an approximate match with option -Z\n\n           %u     select unique lines only, unless option -u is used.\n\n           %1     the first regex group capture of the match, and so on up to group\n                  %9, same as %[1]#; requires option -P.\n\n           %[NUM]#\n                  the regex group capture NUM; requires option -P.\n\n           %[NUM]b\n                  the byte offset of the group capture NUM; requires option -P.  Use\n                  e for the ending byte offset and d for the byte length.\n\n           %[NUM1|NUM2|...]#\n                  the first group capture NUM that matched; requires option -P.\n\n           %[NUM1|NUM2|...]b\n                  the byte offset of the first group capture NUM that matched;\n                  requires option -P.  Use e for the ending byte offset and d for\n                  the byte length.\n\n           %[NAME]#\n                  the NAMEd group capture; requires option -P and capturing pattern\n                  `(?<NAME>PATTERN)', see also %G.\n\n           %[NAME]b\n                  the byte offset of the NAMEd group capture; requires option -P and\n                  capturing pattern `(?<NAME>PATTERN)'.  Use e for the ending byte\n                  offset and d for the byte length.\n\n           %[NAME1|NAME2|...]#\n                  the first NAMEd group capture that matched; requires option -P and\n                  capturing pattern `(?<NAME>PATTERN)', see also %G.\n\n           %[NAME1|NAME2|...]b\n                  the byte offset of the first NAMEd group capture that matched;\n                  requires option -P and capturing pattern `(?<NAME>PATTERN)'.  Use\n                  e for the ending byte offset and d for the byte length.\n\n           %G     list of group capture indices/names that matched; requires option\n                  -P.\n\n           %[TEXT1|TEXT2|...]G\n                  list of TEXT indexed by group capture indices that matched;\n                  requires option -P.\n\n           %g     the group capture index/name matched or 1; requires option -P.\n\n           %[TEXT1|TEXT2|...]g\n                  the first TEXT indexed by the first group capture index that\n                  matched; requires option -P.\n\n           %%     the percentage sign.\n\n           Formatted output is written without a terminating newline, unless %~ or\n           `\\n' is explicitly specified in the format string.\n\n           The [ARG] part of a field is optional and may be omitted.  When present,\n           the argument must be placed in [] brackets, for example %[,]F to output a\n           comma, the pathname, and a separator.\n\n           %[SEP]$ and %u are switches and do not send anything to the output.\n\n           The separator used by the %F, %H, %N, %K, %B, %S and %G fields may be\n           changed by preceding the field by %[SEP]$.  When [SEP] is not provided,\n           this reverts the separator to the default separator or the separator\n           specified with --separator.\n\n           Formatted output is written for each matching pattern, which means that a\n           line may be output multiple times when patterns match more than once on\n           the same line.  If field %u is specified anywhere in a format string,\n           matching lines are output only once, unless option -u, --ungroup is\n           specified or when more than one line of input matched the search pattern.\n\n           Additional formatting options:\n\n           --format-begin=FORMAT\n                  the FORMAT when beginning the search.\n\n           --format-open=FORMAT\n                  the FORMAT when opening a file and a match was found.\n\n           --format-close=FORMAT\n                  the FORMAT when closing a file and a match was found.\n\n           --format-end=FORMAT\n                  the FORMAT when ending the search.\n\n           The context options -A, -B, -C, -y, and display options --break,\n           --heading, --color, -T, and --null have no effect on formatted output.\n\n    EXAMPLES\n           Display lines containing the word `patricia' in `myfile.txt':\n\n                  $ ugrep -w patricia myfile.txt\n\n           Display lines containing the word `patricia', ignoring case:\n\n                  $ ugrep -wi patricia myfile.txt\n\n           Display lines approximately matching the word `patricia', ignoring case\n           and allowing up to 2 spelling errors using fuzzy search:\n\n                  $ ugrep -Z2 -wi patricia myfile.txt\n\n           Count the number of lines containing `patricia', ignoring case:\n\n                  $ ugrep -cwi patricia myfile.txt\n\n           Count the number of words `patricia', ignoring case:\n\n                  $ ugrep -cowi patricia myfile.txt\n\n           List lines with `amount' and a decimal, ignoring case (space is AND):\n\n                  $ ugrep -i --bool 'amount +(.+)?' myfile.txt\n\n           Alternative query:\n\n                  $ ugrep -wi -e amount --and '+(.+)?' myfile.txt\n\n           List all Unicode words in a file:\n\n                  $ ugrep -o '\\w+' myfile.txt\n\n           List all ASCII words in a file:\n\n                  $ ugrep -o '[[:word:]]+' myfile.txt\n\n           List the laughing face emojis (Unicode code points U+1F600 to U+1F60F):\n\n                  $ ugrep -o '[\\x{1F600}-\\x{1F60F}]' myfile.txt\n\n           Check if a file contains any non-ASCII (i.e. Unicode) characters:\n\n                  $ ugrep -q '[^[:ascii:]]' myfile.txt && echo \"contains Unicode\"\n\n           Display the line and column number of `FIXME' in C++ files using\n           recursive search, with one line of context before and after a matched\n           line:\n\n                  $ ugrep -C1 -R -n -k -tc++ FIXME\n\n           Display the line and column number of `FIXME' in long Javascript files\n           using recursive search, showing only matches with up to 10 characters of\n           context before and after:\n\n                  $ ugrep -o -C20 -R -n -k -tjs FIXME\n\n           List the C/C++ comments in a file with line numbers:\n\n                  $ ugrep -n -e '//.*' -e '/\\*([^*]|(\\*+[^*/]))*\\*+\\/' myfile.cpp\n\n           The same, but using predefined pattern c++/comments:\n\n                  $ ugrep -n -f c++/comments myfile.cpp\n\n           List the lines that need fixing in a C/C++ source file by looking for the\n           word `FIXME' while skipping any `FIXME' in quoted strings:\n\n                  $ ugrep -e FIXME -N '\"(\\\\.|\\\\\\r?\\n|[^\\\\\\n\"])*\"' myfile.cpp\n\n           The same, but using predefined pattern cpp/zap_strings:\n\n                  $ ugrep -e FIXME -f cpp/zap_strings myfile.cpp\n\n           Find lines with `FIXME' or `TODO', showing line numberes:\n\n                  $ ugrep -n -e FIXME -e TODO myfile.cpp\n\n           Find lines with `FIXME' that also contain `urgent':\n\n                  $ ugrep -n -e FIXME --and urgent myfile.cpp\n\n           The same, but with a Boolean query pattern (a space is AND):\n\n                  $ ugrep -n --bool 'FIXME urgent' myfile.cpp\n\n           Find lines with `FIXME' that do not also contain `later':\n\n                  $ ugrep -n -e FIXME --andnot later myfile.cpp\n\n           The same, but with a Boolean query pattern (a space is AND, - is NOT):\n\n                  $ ugrep -n --bool 'FIXME -later' myfile.cpp\n\n           Output a list of line numbers of lines with `FIXME' but not `later':\n\n                  $ ugrep -e FIXME --andnot later --format='%,%n' myfile.cpp\n\n           Recursively list all files with both `FIXME' and `LICENSE' anywhere in\n           the file, not necessarily on the same line:\n\n                  $ ugrep -l --files --bool 'FIXME LICENSE'\n\n           Find lines with `FIXME' in the C/C++ files stored in a tarball:\n\n                  $ ugrep -z -tc++ -n FIXME project.tgz\n\n           Recursively find lines with `FIXME' in C/C++ files, but do not search any\n           `bak' and `old' directories:\n\n                  $ ugrep -n FIXME -tc++ -g^bak/,^old/\n\n           Recursively search for the word `copyright' in cpio/jar/pax/tar/zip\n           archives, compressed and regular files, and in PDFs using a PDF filter:\n\n                  $ ugrep -z -w --filter='pdf:pdftotext % -' copyright\n\n           Match the binary pattern `A3hhhhA3' (hex) in a binary file without\n           Unicode pattern matching -U (which would otherwise match `\\xaf' as a\n           Unicode character U+00A3 with UTF-8 byte sequence C2 A3) and display the\n           results in hex with --hexdump with C1 to output one hex line before and\n           after each match:\n\n                  $ ugrep -U --hexdump=C1 '\\xa3[\\x00-\\xff]{2}\\xa3' a.out\n\n           Hexdump an entire file using a pager for viewing:\n\n                  $ ugrep -X --pager '' a.out\n\n           List all files that are not ignored by one or more `.gitignore':\n\n                  $ ugrep -l '' --ignore-files\n\n           List all files containing a RPM signature, located in the `rpm' directory\n           and recursively below up to two levels deeper (3 levels total):\n\n                  $ ugrep -3 -l -tRpm '' rpm/\n\n           Monitor the system log for bug reports and ungroup multiple matches on a\n           line:\n\n                  $ tail -f /var/log/system.log | ugrep -u -i -w bug\n\n           Interactive fuzzy search with Boolean search queries:\n\n                  $ ugrep -Q -l --bool -Z3 --sort=best\n\n           Display all words in a MacRoman-encoded file that has CR newlines:\n\n                  $ ugrep --encoding=MACROMAN '\\w+' mac.txt\n\n           Display options related to \"fuzzy\" searching:\n\n                  $ ugrep --help fuzzy\n\n    BUGS\n           Report bugs at:\n\n                  https://github.com/Genivia/ugrep/issues\n\n    LICENSE\n           ugrep is released under the BSD-3 license.  All parts of the software\n           have reasonable copyright terms permitting free redistribution.  This\n           includes the ability to reuse all or parts of the ugrep source tree.\n\n    SEE ALSO\n           grep(1).\n\n\n\n    ugrep 4.0.0                      August 18, 2023                        UGREP(1)\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"patterns\"/>\n\nRegex patterns\n--------------\n\nFor PCRE regex patterns with option `-P`, please see the PCRE documentation\n<https://www.pcre.org/original/doc/html/pcrepattern.html>.  The pattern syntax\nhas more features than the pattern syntax described below.  For the patterns in\ncommon the syntax and meaning are the same.\n\nNote that `\\s` and inverted bracket lists `[^...]` are modified in **ugrep** to\nprevent matching newlines `\\n`.  This modification is done to replicate the\nbehavior of grep.\n\n<a name=\"posix-syntax\"/>\n\n### POSIX regular expression syntax\n\nAn empty pattern is a special case that matches everything except empty files,\ni.e. does not match zero-length files, as per POSIX.1 grep standard.\n\nA regex pattern is an extended set of regular expressions (ERE), with nested\nsub-expression patterns `φ` and `ψ`:\n\n  Pattern   | Matches\n  --------- | -----------------------------------------------------------------\n  `x`       | matches the character `x`, where `x` is not a special character\n  `.`       | matches any single character except newline (unless in dotall mode)\n  `\\.`      | matches `.` (dot), special characters are escaped with a backslash\n  `\\n`      | matches a newline, others are `\\a` (BEL), `\\b` (BS), `\\t` (HT), `\\v` (VT), `\\f` (FF), and `\\r` (CR)\n  `\\0`      | matches the NUL character\n  `\\cX`     | matches the control character `X` mod 32 (e.g. `\\cA` is `\\x01`)\n  `\\0141`   | matches an 8-bit character with octal value `141`, i.e. `a`\n  `\\x7f`    | matches an 8-bit character with hexadecimal value `7f`\n  `\\x{3B1}` | matches Unicode character U+03B1, i.e. `α`\n  `\\u{3B1}` | matches Unicode character U+03B1, i.e. `α`\n  `\\o{141}` | matches Unicode character U+0061, i.e. `a`, in octal\n  `\\p{C}`   | matches a character in Unicode category C\n  `\\Q...\\E` | matches the quoted content between `\\Q` and `\\E` literally\n  `[abc]`   | matches one of `a`, `b`, or `c`\n  `[0-9]`   | matches a digit `0` to `9`\n  `[^0-9]`  | matches any character except a digit and excluding newline `\\n`\n  `φ?`      | matches `φ` zero or one time (optional)\n  `φ*`      | matches `φ` zero or more times (repetition)\n  `φ+`      | matches `φ` one or more times (repetition)\n  `φ{2,5}`  | matches `φ` two to five times (repetition)\n  `φ{2,}`   | matches `φ` at least two times (repetition)\n  `φ{2}`    | matches `φ` exactly two times (repetition)\n  `φ??`     | matches `φ` zero or once as needed (lazy optional)\n  `φ*?`     | matches `φ` a minimum number of times as needed (lazy repetition)\n  `φ+?`     | matches `φ` a minimum number of times at least once as needed (lazy repetition)\n  `φ{2,5}?` | matches `φ` two to five times as needed (lazy repetition)\n  `φ{2,}?`  | matches `φ` at least two times or more as needed (lazy repetition)\n  `φψ`      | matches `φ` then matches `ψ` (concatenation)\n  `φ⎮ψ`     | matches `φ` or matches `ψ` (alternation)\n  `(φ)`     | matches `φ` as a group\n  `(?:φ)`   | matches `φ` as a group without capture\n  `(?=φ)`   | matches `φ` without consuming it, i.e. lookahead (without option `-P`: nothing may occur after `(?=φ)`)\n  `(?^φ)`   | matches `φ` and ignores it, marking everything in the pattern as a non-match\n  `^φ`      | matches `φ` at the start of input or start of a line (nothing may occur before `^`)\n  `φ$`      | matches `φ` at the end of input or end of a line (nothing may occur after `$`)\n  `\\Aφ`     | matches `φ` at the start of input (nothing may occur before `\\A`)\n  `φ\\z`     | matches `φ` at the end of input (nothing may occur after `\\z`)\n  `\\bφ`     | matches `φ` starting at a word boundary (without option `-P`: nothing may occur before `\\b`)\n  `φ\\b`     | matches `φ` ending at a word boundary (without option `-P`: nothing may occur after `\\b`)\n  `\\Bφ`     | matches `φ` starting at a non-word boundary (without option `-P`: nothing may occur before `\\B`)\n  `φ\\B`     | matches `φ` ending at a non-word boundary (without option `-P`: nothing may occur after `\\B`)\n  `\\<φ`     | matches `φ` that starts a word (without option `-P`: nothing may occur before `\\<`)\n  `\\>φ`     | matches `φ` that starts a non-word (without option `-P`: nothing may occur before `\\>`)\n  `φ\\<`     | matches `φ` that ends a non-word (without option `-P`: nothing may occur after `\\<`)\n  `φ\\>`     | matches `φ` that ends a word (without option `-P`: nothing may occur after `\\>`)\n  `(?i:φ)`  | matches `φ` ignoring case\n  `(?s:φ)`  | `.` (dot) in `φ` matches newline\n  `(?x:φ)`  | ignore all whitespace and comments in `φ`\n  `(?#:X)`  | all of `X` is skipped as a comment\n\nThe order of precedence for composing larger patterns from sub-patterns is as\nfollows, from high to low precedence:\n\n  1. Characters, character classes (bracket expressions), escapes, quotation\n  2. Grouping `(φ)`, `(?:φ)`, `(?=φ)`, and inline modifiers `(?imsux:φ)`\n  3. Quantifiers `?`, `*`, `+`, `{n,m}`\n  4. Concatenation `φψ`\n  5. Anchoring `^`, `$`, `\\<`, `\\>`, `\\b`, `\\B`, `\\A`, `\\z` \n  6. Alternation `φ|ψ`\n  7. Global modifiers `(?imsux)φ`\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"posix-classes\"/>\n\n### POSIX and Unicode character classes\n\nCharacter classes in bracket lists represent sets of characters.  Sets can be\nnegated (inverted), subtracted, intersected, and merged (not supported by PCRE2\nwith option `-P`):\n\n  Pattern           | Matches\n  ----------------- | ---------------------------------------------------------\n  `[a-zA-Z]`        | matches a letter\n  `[^a-zA-Z]`       | matches a non-letter (character class negation), newlines are not matched\n  `[a-z−−[aeiou]]`  | matches a consonant (character class subtraction)\n  `[a-z&&[^aeiou]]` | matches a consonant (character class intersection)\n  `[a-z⎮⎮[A-Z]]`    | matches a letter (character class union)\n\nBracket lists cannot be empty, so `[]` and `[^]` are invalid.  In fact, the\nfirst character after the bracket is always part of the list.  So `[][]` is a\nlist that matches a `]` and a `[`, `[^][]` is a list that matches anything but\n`]` and `[`, and `[-^]` is a list that matches a `-` and a `^`.\n\nNegated character classes such as `[^a-z]` do not match newlines for\ncompatibility with traditional grep pattern matching.\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"posix-categories\"/>\n\n### POSIX and Unicode character categories\n\nThe POSIX form can only be used in bracket lists, for example\n`[[:lower:][:digit:]]` matches an ASCII lower case letter or a digit.  \n\nYou can also use the `\\p{C}` form for class `C` and upper case `\\P{C}` form\nthat has the same meaning as `\\p{^C}`, which matches any character except\ncharacters in the class `C`.  For example, `\\P{ASCII}` is the same as\n`\\p{^ASCII}` which is the same as `[[:^ascii]]`.\n\n  POSIX form   | POSIX category    | Matches\n  ------------ | ----------------- | ---------------------------------------------\n  `[:ascii:]`  | `\\p{ASCII}`       | matches an ASCII character U+0000 to U+007F\n  `[:space:]`  |                   | matches a white space character `[ \\t\\n\\v\\f\\r]` or `\\p{Space}` with `-P`\n  `[:xdigit:]` | `\\p{Xdigit}`      | matches a hex digit `[0-9A-Fa-f]`\n  `[:cntrl:]`  | `\\p{Cntrl}`       | matches a control character `[\\x00-\\0x1f\\x7f]`\n  `[:print:]`  | `\\p{Print}`       | matches a printable character `[\\x20-\\x7e]`\n  `[:alnum:]`  | `\\p{Alnum}`       | matches a alphanumeric character `[0-9A-Za-z]` or `[\\p{L}\\p{N}]` with `-P`\n  `[:alpha:]`  | `\\p{Alpha}`       | matches a letter `[A-Za-z]` or `\\p{L}` with `-P`\n  `[:blank:]`  | `\\p{Blank}`, `\\h` | matches a blank `[ \\t]` or horizontal space with `-P`\n  `[:digit:]`  | `\\p{Digit}`       | matches a digit `[0-9]` or `\\p{Nd}` with `-P`\n  `[:graph:]`  | `\\p{Graph}`       | matches a visible character `[\\x21-\\x7e]`\n  `[:lower:]`  |                   | matches a lower case letter `[a-z]` or `\\p{Ll}` with `-P`\n  `[:punct:]`  | `\\p{Punct}`       | matches a punctuation character `[\\x21-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7e]`\n  `[:upper:]`  |                   | matches an upper case letter `[A-Z]` or `\\p{Lu}` with `-P`\n  `[:word:]`   |                   | matches a word character `[0-9A-Za-z_]` or `[\\p{L}\\p{N}_]` with `-P`\n  `[:^blank:]` | `\\P{Blank}`, `\\H` | matches a non-blank character including newline `\\n`\n  `[:^digit:]` | `\\P{Digit}`       | matches a non-digit including newline `\\n`\n\nPOSIX character categories only cover ASCII, `[[:^ascii]]` is empty and\ntherefore invalid to use.  By contrast, `[^[:ascii]]` is a Unicode character\nclass that excludes the ASCII character category.\n\nNote that the patterns `[[:ascii:]]`, `[[:ctnrl:]]` and `[[:space:]]` and most\nof the negated classes such as `[[:^blank:]]` and `[[:digit:]]` match newlines,\nwhich is the official definition of these POSIX categories.  By contrast,\nGNU/BSD grep never match newlines.  As a consequence, more patterns may match.\n\nNegated character classes of the form `[^...]` match any Unicode character\nexcept the given characters and does not match newlines either.  For example\n`[^[:digit:]]` matches non-digits (including Unicode) and does not match\nnewlines.  By contrast, `[[:^digit:]]` matches ASCII non-digits, including\nnewlines.\n\nOption `-U` disables Unicode wide-character matching, i.e. ASCII matching.\n\n  Unicode category                       | Matches\n  -------------------------------------- | ------------------------------------\n  `.`                                    | matches any single Unicode character except newline `\\n` unless with `--dotall`\n  `\\a`                                   | matches BEL U+0007\n  `\\d`                                   | matches a digit `[0-9]` or `\\p{Nd}`\n  `\\D`                                   | matches a non-digit including `\\n`\n  `\\e`                                   | matches ESC U+001b\n  `\\f`                                   | matches FF U+000c\n  `\\l`                                   | matches a lower case letter `\\p{Ll}`\n  `\\n`                                   | matches LF U+000a\n  `\\N`                                   | matches a non-LF character\n  `\\r`                                   | matches CR U+000d\n  `\\R`                                   | matches a Unicode line break (`\\r\\n`, `\\r`, `\\v`, `\\f`, `\\n`, U+0085, U+2028 and U+2029)\n  `\\s`                                   | matches a white space character `[ \\t\\v\\f\\r\\x85\\p{Z}]` excluding `\\n`\n  `\\S`                                   | matches a non-white space character\n  `\\t`                                   | matches TAB U+0009\n  `\\u`                                   | matches an upper case letter `\\p{Lu}`\n  `\\v`                                   | matches VT U+000b or vertical space character with option `-P`\n  `\\w`                                   | matches a word character `[0-9A-Za-z_]` or `[\\p{L}\\p{Nd}\\p{Pc}]`\n  `\\W`                                   | matches a non-Unicode word character\n  `\\X`                                   | matches any ISO-8859-1 or Unicode character\n  `\\p{Space}`                            | matches a white space character `[ \\t\\n\\v\\f\\r\\x85\\p{Z}]` including `\\n`\n  `\\p{Unicode}`                          | matches any Unicode character U+0000 to U+10FFFF minus U+D800 to U+DFFF\n  `\\p{ASCII}`                            | matches an ASCII character U+0000 to U+007F\n  `\\p{Non_ASCII_Unicode}`                | matches a non-ASCII character U+0080 to U+10FFFF minus U+D800 to U+DFFF\n  `\\p{L&}`                               | matches a character with Unicode property L& (i.e. property Ll, Lu, or Lt)\n  `\\p{Letter}`,`\\p{L}`                   | matches a character with Unicode property Letter\n  `\\p{Mark}`,`\\p{M}`                     | matches a character with Unicode property Mark\n  `\\p{Separator}`,`\\p{Z}`                | matches a character with Unicode property Separator\n  `\\p{Symbol}`,`\\p{S}`                   | matches a character with Unicode property Symbol\n  `\\p{Number}`,`\\p{N}`                   | matches a character with Unicode property Number\n  `\\p{Punctuation}`,`\\p{P}`              | matches a character with Unicode property Punctuation\n  `\\p{Other}`,`\\p{C}`                    | matches a character with Unicode property Other\n  `\\p{Lowercase_Letter}`, `\\p{Ll}`       | matches a character with Unicode sub-property Ll\n  `\\p{Uppercase_Letter}`, `\\p{Lu}`       | matches a character with Unicode sub-property Lu\n  `\\p{Titlecase_Letter}`, `\\p{Lt}`       | matches a character with Unicode sub-property Lt\n  `\\p{Modifier_Letter}`, `\\p{Lm}`        | matches a character with Unicode sub-property Lm\n  `\\p{Other_Letter}`, `\\p{Lo}`           | matches a character with Unicode sub-property Lo\n  `\\p{Non_Spacing_Mark}`, `\\p{Mn}`       | matches a character with Unicode sub-property Mn\n  `\\p{Spacing_Combining_Mark}`, `\\p{Mc}` | matches a character with Unicode sub-property Mc\n  `\\p{Enclosing_Mark}`, `\\p{Me}`         | matches a character with Unicode sub-property Me\n  `\\p{Space_Separator}`, `\\p{Zs}`        | matches a character with Unicode sub-property Zs\n  `\\p{Line_Separator}`, `\\p{Zl}`         | matches a character with Unicode sub-property Zl\n  `\\p{Paragraph_Separator}`, `\\p{Zp}`    | matches a character with Unicode sub-property Zp\n  `\\p{Math_Symbol}`, `\\p{Sm}`            | matches a character with Unicode sub-property Sm\n  `\\p{Currency_Symbol}`, `\\p{Sc}`        | matches a character with Unicode sub-property Sc\n  `\\p{Modifier_Symbol}`, `\\p{Sk}`        | matches a character with Unicode sub-property Sk\n  `\\p{Other_Symbol}`, `\\p{So}`           | matches a character with Unicode sub-property So\n  `\\p{Decimal_Digit_Number}`, `\\p{Nd}`   | matches a character with Unicode sub-property Nd\n  `\\p{Letter_Number}`, `\\p{Nl}`          | matches a character with Unicode sub-property Nl\n  `\\p{Other_Number}`, `\\p{No}`           | matches a character with Unicode sub-property No\n  `\\p{Dash_Punctuation}`, `\\p{Pd}`       | matches a character with Unicode sub-property Pd\n  `\\p{Open_Punctuation}`, `\\p{Ps}`       | matches a character with Unicode sub-property Ps\n  `\\p{Close_Punctuation}`, `\\p{Pe}`      | matches a character with Unicode sub-property Pe\n  `\\p{Initial_Punctuation}`, `\\p{Pi}`    | matches a character with Unicode sub-property Pi\n  `\\p{Final_Punctuation}`, `\\p{Pf}`      | matches a character with Unicode sub-property Pf\n  `\\p{Connector_Punctuation}`, `\\p{Pc}`  | matches a character with Unicode sub-property Pc\n  `\\p{Other_Punctuation}`, `\\p{Po}`      | matches a character with Unicode sub-property Po\n  `\\p{Control}`, `\\p{Cc}`                | matches a character with Unicode sub-property Cc\n  `\\p{Format}`, `\\p{Cf}`                 | matches a character with Unicode sub-property Cf\n  `\\p{UnicodeIdentifierStart}`           | matches a character in the Unicode IdentifierStart class\n  `\\p{UnicodeIdentifierPart}`            | matches a character in the Unicode IdentifierPart class\n  `\\p{IdentifierIgnorable}`              | matches a character in the IdentifierIgnorable class\n  `\\p{JavaIdentifierStart}`              | matches a character in the Java IdentifierStart class\n  `\\p{JavaIdentifierPart}`               | matches a character in the Java IdentifierPart class\n  `\\p{CsIdentifierStart}`                | matches a character in the C# IdentifierStart class\n  `\\p{CsIdentifierPart}`                 | matches a character in the C# IdentifierPart class\n  `\\p{PythonIdentifierStart}`            | matches a character in the Python IdentifierStart class\n  `\\p{PythonIdentifierPart}`             | matches a character in the Python IdentifierPart class\n\nTo specify a Unicode block as a category use `\\p{IsBlockName}` with a Unicode\n`BlockName`.\n\nTo specify a Unicode language script, use `\\p{Language}` with a Unicode\n`Language`.\n\nUnicode language script character classes differ from the Unicode blocks that\nhave a similar name.  For example, the `\\p{Greek}` class represents Greek and\nCoptic letters and differs from the Unicode block `\\p{IsGreek}` that spans a\nspecific Unicode block of Greek and Coptic characters only, which also includes\nunassigned characters.\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"perl-syntax\"/>\n\n### Perl regular expression syntax\n\nFor the pattern syntax of **ugrep** option `-P` (Perl regular expressions), see\nfor example [Perl regular expression syntax](https://www.boost.org/doc/libs/1_70_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html).\nHowever, **ugrep** enhances the Perl regular expression syntax with all of the\nfeatures listed in [POSIX regular expression syntax](#posix-syntax).\n\n🔝 [Back to table of contents](#toc)\n\n<a name=\"bugs\"/>\n\nTroubleshooting\n---------------\n\nIf something is not working, then please check the [tutorial](#tutorial) and\nthe [man page](#man).  If you can't find it there and it looks like a bug, then\n[report an issue](https://github.com/Genivia/ugrep/issues) on GitHub.  Bug\nreports are quickly addressed.\n\n[ci-image]: https://github.com/Genivia/ugrep/actions/workflows/c-cpp.yml/badge.svg\n[ci-url]: https://github.com/Genivia/ugrep/actions/workflows/c-cpp.yml\n[bsd-3-image]: https://img.shields.io/badge/license-BSD%203--Clause-blue.svg\n[bsd-3-url]: https://opensource.org/licenses/BSD-3-Clause"
}
