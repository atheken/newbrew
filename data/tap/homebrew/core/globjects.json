{
  "name": "globjects",
  "full_name": "globjects",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "C++ library strictly wrapping OpenGL objects",
  "license": "MIT",
  "homepage": "https://github.com/cginternals/globjects",
  "versions": {
    "stable": "1.1.0",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/cginternals/globjects/archive/v1.1.0.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "68fa218c1478c09b555e44f2209a066b28be025312e0bab6e3a0b142a01ebbc6"
    },
    "head": {
      "url": "https://github.com/cginternals/globjects.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/globjects/blobs/sha256:9f4e78cc1d1161dc273cd1a3bb0b920d11b1c249893bd39a69178d64704e2e0d",
          "sha256": "9f4e78cc1d1161dc273cd1a3bb0b920d11b1c249893bd39a69178d64704e2e0d"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/globjects/blobs/sha256:f268fe12c238a3714fd1bec33a818b7c372fb53e26f019596146538b2f2f7868",
          "sha256": "f268fe12c238a3714fd1bec33a818b7c372fb53e26f019596146538b2f2f7868"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/globjects/blobs/sha256:97b76d2b662c4f123604d312b442d2b59d606a3cc1e3e4f10cbe2dd3cc8b6f62",
          "sha256": "97b76d2b662c4f123604d312b442d2b59d606a3cc1e3e4f10cbe2dd3cc8b6f62"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/globjects/blobs/sha256:c1531e62e47c2e3119d37d2647f3937f602387ca7c60bc41071177361dd23ab3",
          "sha256": "c1531e62e47c2e3119d37d2647f3937f602387ca7c60bc41071177361dd23ab3"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/globjects/blobs/sha256:4b2845c9354d14fd119544b28536d6fcfddd8f6c9d5eee2a5e01ff77c8b38f03",
          "sha256": "4b2845c9354d14fd119544b28536d6fcfddd8f6c9d5eee2a5e01ff77c8b38f03"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/globjects/blobs/sha256:7a47a09787bf617fa6616f2cd88567b12b5d5c5d0a29225688908ed8c8b2c88d",
          "sha256": "7a47a09787bf617fa6616f2cd88567b12b5d5c5d0a29225688908ed8c8b2c88d"
        },
        "catalina": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/globjects/blobs/sha256:8093cb17f6c1ba5ce345d3a89f0a2330cbdbb88100ad241be0dd8611a6ad52d9",
          "sha256": "8093cb17f6c1ba5ce345d3a89f0a2330cbdbb88100ad241be0dd8611a6ad52d9"
        },
        "mojave": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/globjects/blobs/sha256:9bbf36b86602a7b0c7bf66bb911e200e4f7b94f05c304afb261781edebf119ce",
          "sha256": "9bbf36b86602a7b0c7bf66bb911e200e4f7b94f05c304afb261781edebf119ce"
        },
        "high_sierra": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/globjects/blobs/sha256:baae740c033bc384454f81c0abba246f935765ec7decf408777d318d60cbe565",
          "sha256": "baae740c033bc384454f81c0abba246f935765ec7decf408777d318d60cbe565"
        },
        "sierra": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/globjects/blobs/sha256:dacabb07360fa768e54e9436f071a6ac2a56d0fc9da0d72b491fb8a645f48c33",
          "sha256": "dacabb07360fa768e54e9436f071a6ac2a56d0fc9da0d72b491fb8a645f48c33"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/globjects/blobs/sha256:6fe2640f8e2a366ca0d65e9afde39a1c60583af73fce21d22dadae53807c2b5a",
          "sha256": "6fe2640f8e2a366ca0d65e9afde39a1c60583af73fce21d22dadae53807c2b5a"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake"
  ],
  "dependencies": [
    "glbinding",
    "glm"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/globjects.rb",
  "ruby_source_checksum": {
    "sha256": "e969154435d449489472a36263fb52e5aed760d3b93c78a219c62e3566382340"
  },
  "date_added": "2017-02-15T16:41:38+00:00",
  "readme": "[//]: # (Comment)\n\n<br><a href=\"https://github.com/cginternals/globjects/\"><img src=\"https://raw.githubusercontent.com/cginternals/globjects/master/globjects-logo.svg?sanitize=true\" width=\"50%\"></a>\n\n*globjects* is a cross-platform C++ wrapper for [OpenGL API](http://www.opengl.org) objects.\n\n![GitHub release](https://img.shields.io/github/release/cginternals/globjects.svg)\n[![Travis](https://img.shields.io/travis/cginternals/globjects/master.svg?style=flat&logo=travis)](https://travis-ci.org/cginternals/globjects)\n[![Appveyor](https://img.shields.io/appveyor/ci/scheibel/globjects/master.svg?style=flat&logo=appveyor)](https://ci.appveyor.com/project/scheibel/globjects/branch/master)\n[![Coverity](https://img.shields.io/coverity/scan/6828.svg?style=flat&logo=coverity)](https://scan.coverity.com/projects/6828)\n[![Coveralls](https://img.shields.io/badge/coveralls-ToDo-lightgrey.svg?)](https://coveralls.io/github/cginternals/globjects)\n[![Tokei](https://tokei.rs/b1/github/cginternals/globjects)](https://github.com/Aaronepower/tokei)\n[![Tokei](https://tokei.rs/b1/github/cginternals/globjects?category=comments)](https://github.com/Aaronepower/tokei)\n\n[![Documentation](https://img.shields.io/badge/documentation-online-blue.svg?style=flat&logo=data%3Aimage%2Fsvg%2Bxml%3Bbase64%2CPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMC41IDEzLjciPjxwYXRoIGQ9Ik0xMS41IDYuOGwtMy43IDYuNEwuNS41aDE0LjdsLTEuMyAyLjFINC4yTDcuOCA5bDIuNS00LjN6bTcuMyA0LjNsMS4yIDIuMWgtOS43TDE3LjYuNWwxLjIgMi4xLTQuOSA4LjV6IiBmaWxsPSIjZmZmIi8%2BPC9zdmc%2B)](https://www.globjects.org/docs.html)\n[![Examples](https://img.shields.io/badge/examples-examples-blue.svg?style=flat&logo=data%3Aimage%2Fsvg%2Bxml%3Bbase64%2CPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMC41IDEzLjciPjxwYXRoIGQ9Ik0xMS41IDYuOGwtMy43IDYuNEwuNS41aDE0LjdsLTEuMyAyLjFINC4yTDcuOCA5bDIuNS00LjN6bTcuMyA0LjNsMS4yIDIuMWgtOS43TDE3LjYuNWwxLjIgMi4xLTQuOSA4LjV6IiBmaWxsPSIjZmZmIi8%2BPC9zdmc%2B)](https://github.com/cginternals/globjects/wiki/Examples)\n\n\n[//]: # (HEADER_END)\n\n*globjects* provides object-oriented interfaces to the OpenGL API (3.0 and higher).\nIt reduces the amount of OpenGL code required for rendering and facilitates coherent OpenGL use by means of an additional abstraction layer to [glbinding](https://github.com/cginternals/glbinding) and [GLM](https://github.com/g-truc/glm). Common rendering tasks and processes are automated and missing features of specific OpenGL drivers are partially simulated or even emulated at run-time.\n\n![what-is-globjects](https://raw.githubusercontent.com/cginternals/globjects/master/docs/what-is-globjects.png)\n\nThe following code snippet shows an exemplary use of the OpenGL API:\n\n```cpp\n// OpenGL API\n\nauto program = glCreateProgram();\nauto vertexShader = glCreateShader(GL_VERTEX_SHADER);\nauto fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);\n\nglShaderSource(vertexShader, 1, &vertexShaderSource, nullptr);\nglShaderSource(fragmentShader, 1, &fragmentShaderSource, nullptr);\n\nglCompileShader(vertexShader);\nglCompileShader(fragmentShader);\n\nglAttachShader(program, vertexShader);\nglAttachShader(program, fragmentShader);\n\nglLinkProgram(program);\n\nglUseProgram(program);\nglUniform2f(glGetUniformLocation(program, \"extent\"), 1.0f, 0.5f);\n```\n\nUsing *globjects*, this can be reduced to the following code:\n\n```cpp\n// globjects API\n\nauto program = new Program();\n\nprogram->attach(\n  Shader::fromString(GL_VERTEX_SHADER, vertexShaderSource), \n  Shader::fromString(GL_FRAGMENT_SHADER, fragmentShaderSource)\n);\n\nprogram->setUniform(\"extent\", glm::vec2(1.0f, 0.5f)));\n```\nIf enabled, this code checks (1) for GL errors (```glGetError```) after each call, (2) shaders for compilation errors, and (3) the program for linker errors.\n\n# Resources\n\n* [Examples](https://github.com/cginternals/globjects/wiki/examples)\n* [Doxygen Documentations](https://globjects.org/docs.html) ([stable](https://globjects.org/docs/v1.1/index.html), [master](https://globjects.org/docs/master/index.html))\n\n###### Installation and Development\n\n* [Install Instructions](#install-instructions)\n* [Build form Source](#build-instructions)\n* [Tips for Linking](#tips-for-linking)\n\n###### Context Management\n\n* [Initializing Contexts](#initialize-contexts)\n\n###### Wrapped OpenGL Objects and Code Snippets\n\n* [Global Functions](#global-functions)\n* [Buffer](#buffer)\n* [Texture](#texture)\n* [State](#state)\n* [Error](#error)\n* [Debug Message](#debug-message)\n* [Framebuffer](#framebuffer)\n* [Named String](#named-string)\n* [Program](#program)\n* [Program Pipeline](#program-pipeline)\n* [Query](#query)\n* [Renderbuffer](#renderbuffer)\n* [Sampler](#sampler)\n* [Shader](#shader)\n* [Sync](#sync)\n* [Transform Feedback](#transform-feedback)\n* [Uniform](#uniform)\n* [Uniform Block](#uniform-block)\n* [Vertex Array](#vertex-array)\n* [Vertex Attribute Binding](#vertex-attribute-binding)\n\n###### Additional Feature Documentation and Code Snippets\n\n* [Reference pointer as memory model](#reference-pointers)\n* [Shader templates](#shader-templates)\n* [Manual strategy override](#strategy-override)\n* [iostream Integration](#logging)\n\n\n# Install Instructions\n\n*globjects* is available for different platforms using different distribution channels. \nYou can either download the source and manually [compile](#build-instructions) it or use one of the [pre-compiled releases](https://github.com/cginternals/globjects/releases) of this repository.\nFor systems providing package managers, we generally strive for packages in these package managers.\n\n#### Windows\n\nThe various globjects packages can be installed either by downloading an installer, e.g., the [latest x64 installer](https://github.com/cginternals/globjects/releases/download/v1.0.0/globjects-1.0.0-msvc2015-x64-installer.exe) for Microsoft Visual Studio 2015, or downloading and extracting one of the precompiled archives, e.g. [runtime](https://github.com/cginternals/globjects/releases/download/v1.0.0/globjects-1.0.0-msvc2015-x64-runtime.zip),\n[examples](https://github.com/cginternals/globjects/releases/download/v1.0.0/globjects-1.0.0-msvc2015-x64-examples.zip), and\n[dev](https://github.com/cginternals/globjects/releases/download/v1.0.0/globjects-1.0.0-msvc2015-x64-dev.zip).\nAlternatively, download the source code and commence [building from source](#build-instructions).\n\n#### Ubuntu\n\n*globjects* is provided on Ubuntu using PPAs.\nFor Ubuntu 16.04 (xenial), 15.10 (wily), and 15.04 (vivid) use the [current PPA](https://launchpad.net/~cginternals/+archive/ubuntu/ppa), for Ubuntu 14.04 (trusty) use the [backports PPA](https://launchpad.net/~cginternals/+archive/ubuntu/backports-ppa).\nUsing the current PPA as example, the following lines install *globjects* including the GLFW examples:\n\n```shell\n> sudo apt-add-repository ppa:cginternals/ppa\n> sudo apt-get update\n> sudo apt-get install libglobjects-examples-glfw\n> # start example\n> /usr/share/globjects/computeshader\n```\n\nTo use globjects as dependency, install the development package:\n\n```shell\n> sudo apt-get install libglobjects-dev libglobjects-dbg\n```\n\nAlternatively, download the source code and commence [building from source](#build-instructions).\n\n#### OS X\n\nThe package manager on OS X we depend on is homebrew. The package there is called [globjects](http://brewformulas.org/Globjects).\nTo install *globjects* using homebrew, execute the following line:\n\n```shell\n> brew install globjects\n```\n\nAlternatively, download the source code and commence [building from source](#build-instructions).\n\n#### Debian-based Systems\n\nThere is currently no precompiled package maintained. Please download the source code and commence [building from source](#build-instructions).\n\n\n# Build Instructions\n\n#### Prerequisites and Dependencies\n\nThe only mandatory run-time dependencies of globjects are the STL of the used compiler, glbinding, and an OpenGL driver library, dynamically linked with your application. However, compiling *globjects* requires the following required and optional dependencies:\n* [CMake](https://cmake.org/) 3.0 or higher for building globjects from source (mandatory for any build from source)\n* [git](https://git-scm.com/) for version control and script supporting tasks\n* [glbinding](https://github.com/cginternals/glbinding) as OpenGL API binding\n* [GLM](https://github.com/g-truc/glm) for OpenGL math and data structures (0.9.7 or above)\n* [Eigen3](https://eigen.tuxfamily.org/) as alternative to pass vector data to OpenGL (3.3 or above)\n* [GLFW](http://www.glfw.org/) 3.0 or higher for examples\n* [cpplocate](https://github.com/cginternals/cpplocate) for the examples\n* [Qt5](http://www.qt.io/developers/) 5.0 or higher for the qt-based example\n* [Doxygen](http://www.stack.nl/~dimitri/doxygen/) 1.8 or higher for generating the documentation on your system\n  * [graphviz](http://www.graphviz.org/) for generating diagrams (optional)\n\n#### Compile Instructions\n\nFor compilation, a C++11 compliant compiler, e.g., GCC 4.8, Clang 3.3, MSVC 2013 **Update 3**, is required.\n\nFirst, download the source code [as archive](https://github.com/cginternals/globjects/releases) or via git:\n\n```shell\n> git clone https://github.com/cginternals/globjects.git\n> cd globjects\n```\n\nThen, depending on the version of globjects you want to build, choose the appropriate tag or branch, e.g., for the 1.0.0 release:\n\n```shell\n> git fetch --tags\n> git checkout v1.0.0\n```\n\nThe actual compilation can be done using CMake and your favorite compiler and IDE.\n\nFor building *globjects* CMake via command line can be used (should work on all systems):\n\nFirst create a build directory (we do not recommend in-source builds):\n\n```shell\n> mkdir build\n> cd build\n```\n\nConfigure *globjects* with your prefered or default generator, e.g., for Visual Studio 2015 in x64 use\n(note: some IDEs have integrated support for CMake projects, e.g., Qt Creator, and allow you to skip the manual project configuration):\n\n```shell\n> cmake .. -G \"Visual Studio 14 2015 Win64\"\n```\n\nSeveral options are available :\n\n```\n# Project options\noption(BUILD_SHARED_LIBS          \"Build shared instead of static libraries.\"                    ON)\noption(OPTION_SELF_CONTAINED      \"Create a self-contained install with all dependencies.\"       OFF)\noption(OPTION_BUILD_DOCS          \"Build documentation.\"                                         OFF)\noption(OPTION_BUILD_EXAMPLES      \"Build examples.\"                                              OFF)\noption(OPTION_ERRORS_AS_EXCEPTION \"Throw exceptions instead of printing OpenGL run-time errors.\" OFF)\noption(OPTION_USE_EIGEN           \"Add Eigen types as basic vector type for uniforms.\"           OFF)\n```\n\nThese option are activated with CMake invocation, for instance\n```shell \n> cmake .. -DOPTION_USE_EIGEN=ON\n```\n\n\nIn order to compile the project, either use you favorite Editor/IDE with the created project or use CMake as follows:\n\n```shell\n> cmake --build .\n```\n\n\n# Tips for Linking\n\nWe suggest using the build system of globjects for a smooth integration: [CMake](https://cmake.org/)\n\nFor it, *globjects* provides a find configuration script that should be installed into your system or at least accessible by CMake. \nIn the projects CMakeLists.txt, add one of the following lines:\n\n```\nfind_package(globjects QUIET) # if you want to check for existence\nfind_package(globjects REQUIRED) # if it is really required in your project\n```\n\nFinally, just link globjects to your own library or executable:\n\n```\ntarget_link_libraries(${target} ... PUBLIC globjects::globjects)\n```\n\n# Initialize Contexts\n\nglobjects can handle multiple OpenGL contexts. For each context, you have to initialize the globjects state.\nFurther, you have to tell globjects which context is active on a per-thread basis.\n\n```cpp\n#include <globjects/globjects.h>\n\n// manage contexts\ninit();\n\n// set explicit context active\nsetContext(contextID);\n\n// set current context active\nsetCurrentContext();\n```\n\nYou can also use glbinding to automatically sync OpenGL active contexts and their glbinding and globjects counterparts:\n\n```cpp\nglbinding::Binding::addContextSwitchCallback([](glbinding::ContextHandle handle) {\n    setContext(handle);\n}\n```\n\nThe only additional thing to do is telling glbinding when a context is switched (per thread).\n\n```cpp\nglbinding::Binding::useContext(handle);\n```\n\n# Wrapped OpenGL Objects\n\n#### Global Functions\n\nSome often used functions are wrapped to ease the interface as proposed by the OpenGL API.\n\n```cpp\n// somehow similar to glbinding\n\nstd::string extensions = getString(GL_EXTENSIONS);\nint numExtensions = getInteger(GL_NUM_EXTENSIONS);\n\nif (isCoreProfile())\n{\n    return renderer(); // returns the GL_RENDERER string\n}\n```\n\n#### Buffer\n\nA buffer in means of OpenGL can be used for vertex attributes, indices, uniform data, atomic counters, texture data, and shader storage data.\n\n```cpp\nauto buffer = new Buffer();\n\n// Using buffer data\nbuffer->setData({{ 0, 1, 2, 3, 4}}, GL_STATIC_DRAW);\n\n// Using buffer storage\nbuffer->setStorage({{ 0, 1, 2, 3, 4}}, GL_MAP_READ_BIT | GL_MAP_PERSISTENT_BIT);\n\nbuffer->setSubData({{ 4, 3, 2 }}, 0);\nbuffer->bindBase(GL_SHADER_STORAGE_BUFFER, 0);\n```\n\n#### Texture\n\nTexture supports both traditional interfaces and bindless support.\n\n```cpp\nauto texture1 = new Texture(GL_TEXTURE_2D); // type has to be fix during lifetime\ntexture1->setParameter(GL_TEXTURE_MIN_FILTER, GL_LINEAR);\ntexture1->setParameter(GL_TEXTURE_MAG_FILTER, GL_LINEAR);\ntexture1->setParameter(GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\ntexture1->setParameter(GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\ntexture1->image2D(0, GL_RGBA8, glm::ivec2(512), 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);\ntexture1->clearImage(0, GL_RGBA, GL_UNSIGNED_BYTE, glm::ivec4(255, 255, 255, 255));\ntexture1->generateMipMap();\n\nauto texture2 = Texture::createDefault(); // creates a default-configured 2D texture\n\nauto handle = texture2->textureHandle(); // for bindless texturing\ntexture2->bindActive(0); // For traditional texturing\n```\n\n#### State\n\nOpenGL state is wrapped as States, StateSettings and Capabilities, where the latter two are mainly used internally.\n\n```cpp\nauto currentState = State::currentState(); // full current state; usable for resetting\n\nauto state1 = new State(State::ImmediateMode); // all changes are applied immediately\nstate1->enable(GL_RASTERIZER_DISCARD); // Configuring a Capability\nstate1->primitiveRestartIndex(static_cast<GLuint>(-1)); // Configuring a StateSetting\n\nauto state2 = new State(State::DeferredMode); // changes has to be applied explicitly\nstate2->pointSize(10.0f);\nstate2->apply();\n\ncurrentState->apply(); // Reset manipulated state\n```\n\n#### Error\n\n```cpp\nauto error = Error::get();\n\nif (error)\n{\n    std::cout << \"Error \" << std::hex << error.code() << \": \" << error.name() << std::endl;\n}\n```\n\n#### Debug Message\n\nEnable DebugMessages to get performance hints, warnings and errors from your OpenGL driver.\n\n```cpp\nDebugMessage::enable(); // enable automatic messages if KHR_debug is available\n\nDebugMessage::setCallback([](const DebugMessage & message) {\n    std::cout << message.message() << std::endl;\n}); // if you want to handle messages by yourself\n```\n\n#### Framebuffer\n\nWraps a canvas with multiple render targets to render on.\n\n```cpp\nauto fbo = new Framebuffer();\nfbo->attachTexture(GL_COLOR_ATTACHMENT0, texture1);\nfbo->attachTexture(GL_COLOR_ATTACHMENT1, texture2);\nfbo->attachRenderbuffer(GL_DEPTH_ATTACHMENT, depthRenderbuffer);\nfbo->setDrawBuffers({ GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_NONE });\nfbo->printStatus(true); // Print errors if fbo is not complete\n\nfbo->clear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\nfbo->clearBuffer(GL_COLOR, 0, glm::vec4(1.0f, 1.0f, 1.0f, 0.0f));\n\nfbo->blit(GL_COLOR_ATTACHMENT0, {{ 0, 0, width, height }}, Framebuffer::defaultFBO(),\n    GL_BACK_LEFT, {{ 0, 0, width, height }}, GL_COLOR_BUFFER_BIT, GL_NEAREST);\n```\n\n#### Named String\n\nRegister compile-time shader replacements for shader includes.\n\n```cpp\n// typically the only function call you'll need\nauto namedString1 = new NamedString(\"/upNormal.glsl\", \"const vec3 up = vec3(0.0, 1.0, 0.0);\");\n\n// or reference an actual source file\nauto namedString2 = new NamedString(\"/phong.glsl\", new File(\"data/shaders/phong.glsl\"));\n```\n\n#### Program\n\nThe Program object can represent both render programs and compute programs. Prior usage it automatically relinks upon shader changes.\n\n```cpp\nauto renderProgram = new Program();\nrenderProgram->attach(vertexShader, fragmentShader);\nrenderProgram->addUniform(\"viewProjection\", glm::mat4(1.0));\n\nrenderProgram->use(); // compiles shaders, links and uses program\n\nauto computeProgram = new Program();\ncomputeProgram->attach(computeShader);\n\ncomputeProgram->dispatchCompute(128, 1, 1);\n```\n\n#### Program Pipeline\n\n```cpp\nauto pipeline = new ProgramPipeline();\npipeline->useStages(vertexProgram, gl::GL_VERTEX_SHADER_BIT);\npipeline->useStages(fragmentProgram, gl::GL_FRAGMENT_SHADER_BIT);\npipeline->use(); // as Program interface\n```\n\n#### Query\n\nQuery and measure time and perform conditional rendering with passed samples.\n\n```cpp\nauto query = new Query();\nquery->begin(GL_TIME_ELAPSED);\n// calls\nquery->end(GL_TIME_ELAPSED);\n\nif (!query->resultsAvailable())\n{\n    query->wait();\n}\n\nauto elapsed = query->get(GL_QUERY_RESULT);\n```\n\n#### Renderbuffer\n\n```cpp\nauto renderBuffer = new Renderbuffer();\nrenderBuffer->storage(GL_RGBA32F, 512, 512);\n```\n\n#### Sampler\n\nFor temporary overrides of texture parameters. Note: a newly created sampler is not configured by default, and thus invalid.\n\n```cpp\nauto sampler = new Sampler();\nsampler->setParameter(GL_TEXTURE_MIN_FILTER, GL_LINEAR);\nsampler->setParameter(GL_TEXTURE_MAG_FILTER, GL_LINEAR);\nsampler->setParameter(GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\nsampler->setParameter(GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\nsampler->bind(0); // override sampler state for texture at binding point 0\n```\n\n#### Shader\n\n```cpp\nauto shader1 = new Shader::fromFile(GL_VERTEX_SHADER, filename);\nauto shader2 = new Shader::fromString(GL_FRAGMENT_SHADER, shaderSource);\n\nShader::globalReplace(\"#version 140\", \"#version 150\"); // e.g., useful for OS X\n\nshader1->setIncludePaths({ std::string(\"/data\") });\n\nshader2->compile();\nstd::cout << shader2->infoLog() << std::endl; // acess compile info log, although it's done automatically if there is a compile error\n```\n\n#### Sync\n\n```cpp\nauto sync = Sync::fence(GL_SYNC_GPU_COMMANDS_COMPLETE);\n\nsync->clientWait(GL_SYNC_FLUSH_COMMANDS_BIT, 2000000000); // wait on GPU; 2 secs\nsync->waitSync(1000000); // wait on CPU; 1 millisecond\n```\n\n#### Transform Feedback\n\nConnect shader outputs to buffers and restart drawing.\n\n```cpp\nauto tf = new TransformFeedback();\ntf->setVaryings(program, { { \"next_position\" } }, GL_INTERLEAVED_ATTRIBS);\n\ntf->bind();\nglEnable(GL_RASTERIZER_DISCARD);\nprogram->use();\ntf->begin(GL_TRIANGLES);\nvao->drawArrays(GL_TRIANGLES, 0, 3);\ntf->end();\nglDisable(GL_RASTERIZER_DISCARD);\ntf->draw(GL_TRIANGLE_STRIP);\n```\n\n#### Uniform\n\nUniforms attached to Programs are updated automatically, even after relinking.\n\n```cpp\nauto uniform1 = new Uniform<glm::vec3>(\"lightPos\", glm::vec3(10.0f, 5.0f, 0.0f)); // name-based uniform binding\nauto uniform2 = new Uniform<glm::mat4>(0, glm::mat4(1.0f)); // location-based uniform binding\n\nprogram->addUniform(uniform1);\nprogram->addUniform(uniform2);\n\nprogram->use(); // uniform values are updated if required\n```\n\n#### Uniform Block\n\nUse uniform blocks for large, often switched chunks of uniforms.\n\n```cpp\nauto block = program->uniformBlock(\"uniforms\");\nblock->setBinding(0);\nbuffer->bindBase(GL_UNIFORM_BUFFER, 0);\n```\n\n#### Vertex Array\n\nUse to configure vertex shader inputs and trigger render pipeline processes.\n\n```cpp\nauto vao = new VertexArray();\n// configure bindings (see next section)\n\nvao->enable(0);\nvao->enable(1);\n\nvao->drawArrays(GL_POINTS, 0, 10);\n```\n\n#### Vertex Attribute Binding\n\n```cpp\n// For attribute pointers\nauto binding1 = vao->binding(0);\nbinding1->setBuffer(vertexBuffer, 0, sizeof(glm::vec3));\nbinding1->setFormat(3, GL_FLOAT, GL_FALSE, 0);\n\n// For static attributes for each vertex\nauto binding2 = vao->binding(0);\nbinding2->setValue<float>(1.0f);\n```\n\n# Additional Features\n\n#### Reference Pointers\n\nglobjects uses the RAII (resource allocation is initialization) principle, meaning that created objects are also created on the GPU.\nTo effectively manage the dual-allocated memory, we use reference pointers.\nWe advise that every globjects ```Object``` pointer is stored in a ```ref_ptr```.\n\n```cpp\n{\n    ref_ptr<Query> query = new Query(); // allocate on CPU and GPU\n    \n    // query is destructed and freed on GPU at the end of the block.\n}\n```\n\nAs the objects in globjects uses ```ref_ptr``` to store references, not using reference counting can lead to *accidentally* freed objects.\nIf you don't want to use smart pointers, you have to use the manual reference counting interface:\n\n```cpp\nprogram->ref(); // increase reference count\nprogram->unref(); // decreare reference count; potentially free program pointer and GPU program\n```\n\n#### Shader Templates\n\nThe sources of Shaders (```ShaderSource```) can be configured and templated.\n\n```cpp\nauto template = new StringTemplate(new File(\"fragmentShader.frag\"));\ntemplate->replace(\"REPLACE\", \"WITH THIS\");\n\nauto shader = new Shader(template);\n```\n\n#### Strategy Override\n\nAlthough globjects tries to use most current OpenGL APIs, you can override this automatic process.\n\n```cpp\n// Enable CPU shader includes (although supported, some drivers have problems, so disable it)\nglobjects::init(Shader::IncludeImplementation::Fallback);\n\n// Update strategy at run-time\nBuffer::hintBindlessImplementation(Buffer::BindlessImplementation::Legacy);\n```\n\n#### Logging\n\nglobjects provides logging interfaces to its objects as well as glm objects.\n\n```cpp\nstd::cout << Framebuffer::defaultFBO();\nstd::cout << glm::vec4(1.0, 0.0, 0.0, 1.0);\nwarning() << shader;\n```"
}
