{
  "name": "erigon",
  "full_name": "erigon",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Implementation of Ethereum (execution client), on the efficiency frontier",
  "license": "GPL-3.0-or-later and LGPL-3.0-or-later",
  "homepage": "https://github.com/ledgerwatch/erigon",
  "versions": {
    "stable": "2.48.1",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/ledgerwatch/erigon/archive/refs/tags/v2.48.1.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "8b6502a394752156d74d334b0c893beb45cea59baad8113ed9a2106de13582cc"
    },
    "head": {
      "url": "https://github.com/ledgerwatch/erigon.git",
      "branch": "devel"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/erigon/blobs/sha256:af177de64b630ec20db621eb1f1132ac4ad6eca1d0f44dca00cf648c8aa2298d",
          "sha256": "af177de64b630ec20db621eb1f1132ac4ad6eca1d0f44dca00cf648c8aa2298d"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/erigon/blobs/sha256:0122e639d980cf4b2aea8c4a8efab6016774b1f562934a7b2b6915e9ec30375e",
          "sha256": "0122e639d980cf4b2aea8c4a8efab6016774b1f562934a7b2b6915e9ec30375e"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/erigon/blobs/sha256:5c4c97b1ca99226a1f75b64ca8561d33a40832e81fcb19c3fafae8d59354db6f",
          "sha256": "5c4c97b1ca99226a1f75b64ca8561d33a40832e81fcb19c3fafae8d59354db6f"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/erigon/blobs/sha256:cb6b6894fed8d3af8571959a20d1da965ec9a225dc7174f4255d8e2567972f9a",
          "sha256": "cb6b6894fed8d3af8571959a20d1da965ec9a225dc7174f4255d8e2567972f9a"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/erigon/blobs/sha256:fe52f7af468baa32a38e2f4964de05f7c877dc6afe56fc5d3117c74712dc6127",
          "sha256": "fe52f7af468baa32a38e2f4964de05f7c877dc6afe56fc5d3117c74712dc6127"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/erigon/blobs/sha256:97b2e849f77626ee7fb0a8cef5a03ffa7aeb866d8d8e3349e1dd714ab8c91b8e",
          "sha256": "97b2e849f77626ee7fb0a8cef5a03ffa7aeb866d8d8e3349e1dd714ab8c91b8e"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/erigon/blobs/sha256:daf702c28fc1138ee1399f7e3f57346e1728a3979957364a4ed7091b4be11988",
          "sha256": "daf702c28fc1138ee1399f7e3f57346e1728a3979957364a4ed7091b4be11988"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "gcc",
    "go"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [
    "ethereum"
  ],
  "conflicts_with_reasons": [
    "both install `evm` binaries"
  ],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/erigon.rb",
  "ruby_source_checksum": {
    "sha256": "da56572e766a615d5a38d10475fbebc791c4d9088bf5f991b38ab5d38489cbea"
  },
  "date_added": "2022-12-11T18:12:02+00:00",
  "readme": "# Erigon\n\nErigon is an implementation of Ethereum (execution layer with embeddable consensus layer), on the efficiency\nfrontier. [Archive Node](https://ethereum.org/en/developers/docs/nodes-and-clients/archive-nodes/#what-is-an-archive-node)\nby default.\n\n![Build status](https://github.com/ledgerwatch/erigon/actions/workflows/ci.yml/badge.svg)\n\n![Coverage](https://gist.githubusercontent.com/revitteth/ee38e9beb22353eef6b88f2ad6ed7aa9/raw/badge.svg)\n\n<!--ts-->\n\n- [System Requirements](#system-requirements)\n- [Usage](#usage)\n    + [Getting Started](#getting-started)\n    + [Logging](#logging)\n    + [Testnets](#testnets)\n    + [Block Production](#block-production-pow-miner-or-pos-validator)\n    + [Windows](#windows)\n    + [GoDoc](https://godoc.org/github.com/ledgerwatch/erigon)\n    + [Beacon Chain](#beacon-chain-consensus-layer)\n    + [Dev Chain](#dev-chain)\n\n- [Key features](#key-features)\n    + [More Efficient State Storage](#more-efficient-state-storage)\n    + [Faster Initial Sync](#faster-initial-sync)\n    + [JSON-RPC daemon](#json-rpc-daemon)\n    + [Run all components by docker-compose](#run-all-components-by-docker-compose)\n    + [Grafana dashboard](#grafana-dashboard)\n- [Documentation](#documentation)\n- [FAQ](#faq)\n- [Getting in touch](#getting-in-touch)\n    + [Erigon Discord Server](#erigon-discord-server)\n    + [Reporting security issues/concerns](#reporting-security-issues/concerns)\n    + [Team](#team)\n- [Known issues](#known-issues)\n    + [`htop` shows incorrect memory usage](#htop-shows-incorrect-memory-usage)\n\n<!--te-->\n\n**Disclaimer**: this software is currently a tech preview. We will do our best to keep it stable and make no breaking\nchanges but we don't guarantee anything. Things can and will break.\n\n**Important defaults**: Erigon is an Archive Node by default (to remove history see: `--prune` flags\nin `erigon --help`). We don't allow change this flag after first start.\n\n<code>In-depth links are marked by the microscope sign (ðŸ”¬) </code>\n\nSystem Requirements\n===================\n\n* For an Archive node of Ethereum Mainnet we recommend >=3TB storage space: 1.8TB state (as of March 2022),\n  200GB temp files (can symlink or mount folder `<datadir>/temp` to another disk). Ethereum Mainnet Full node (\n  see `--prune*` flags): 400Gb (April 2022).\n\n* Goerli Full node (see `--prune*` flags): 189GB on Beta, 114GB on Alpha (April 2022).\n\n* Gnosis Chain Archive: 370GB (January 2023).\n\n* Polygon Mainnet Archive: 5TB. Polygon Mumbai Archive: 1TB. (April 2022).\n\nSSD or NVMe. Do not recommend HDD - on HDD Erigon will always stay N blocks behind chain tip, but not fall behind.\nBear in mind that SSD performance deteriorates when close to capacity.\n\nRAM: >=16GB, 64-bit architecture.\n\n[Golang version >= 1.19](https://golang.org/doc/install); GCC 10+ or Clang; On Linux: kernel > v4\n\n<code>ðŸ”¬ more details on disk storage [here](https://erigon.substack.com/p/disk-footprint-changes-in-new-erigon?s=r)\nand [here](https://ledgerwatch.github.io/turbo_geth_release.html#Disk-space).</code>\n\nUsage\n=====\n\n### Getting Started\n\nFor building the latest stable release (this will be suitable for most users just wanting to run a node):\n\n```sh\ngit clone --branch stable --single-branch https://github.com/ledgerwatch/erigon.git\ncd erigon\nmake erigon\n./build/bin/erigon\n```\n\nYou can check [the list of releases](https://github.com/ledgerwatch/erigon/releases) for release notes.\n\nFor building the bleeding edge development branch:\n\n```sh\ngit clone --recurse-submodules https://github.com/ledgerwatch/erigon.git\ncd erigon\ngit checkout devel\nmake erigon\n./build/bin/erigon\n```\n\nDefault `--snapshots` for `mainnet`, `goerli`, `gnosis`, `chiado`. Other networks now have default `--snapshots=false`.\nIncrease\ndownload speed by flag `--torrent.download.rate=20mb`. <code>ðŸ”¬ See [Downloader docs](./cmd/downloader/readme.md)</code>\n\nUse `--datadir` to choose where to store data.\n\nUse `--chain=gnosis` for [Gnosis Chain](https://www.gnosis.io/), `--chain=bor-mainnet` for Polygon Mainnet,\nand `--chain=mumbai` for Polygon Mumbai.\nFor Gnosis Chain you need a [Consensus Layer](#beacon-chain-consensus-layer) client alongside\nErigon (https://docs.gnosischain.com/node/guide/beacon).\n\nRunning `make help` will list and describe the convenience commands available in the [Makefile](./Makefile).\n\n### Datadir structure\n\n- chaindata: recent blocks, state, recent state history. low-latency disk recommended.\n- snapshots: old blocks, old state history. can symlink/mount it to cheaper disk. mostly immutable. must have ~100gb free space (for merge recent files to bigger one).\n- temp: can grow to ~100gb, but usually empty. can symlink/mount it to cheaper disk.\n- txpool: pending transactions. safe to remove.\n- nodes:  p2p peers. safe to remove.\n\n### Logging\n\n_Flags:_\n\n- `verbosity`\n- `log.console.verbosity` (overriding alias for `verbosity`)\n- `log.json`\n- `log.console.json` (alias for `log.json`)\n- `log.dir.path`\n- `log.dir.prefix`\n- `log.dir.verbosity`\n- `log.dir.json`\n\nIn order to log only to the stdout/stderr the `--verbosity` (or `log.console.verbosity`) flag can be used to supply an\nint value specifying the highest output log level:\n\n```\n  LvlCrit = 0\n  LvlError = 1\n  LvlWarn = 2\n  LvlInfo = 3\n  LvlDebug = 4\n  LvlTrace = 5\n```\n\nTo set an output dir for logs to be collected on disk, please set `--log.dir.path` If you want to change the filename prodiced from `erigon` you should also set the `--log.dir.prefix` flag to an alternate name. The flag `--log.dir.verbosity` is\nalso available to control the verbosity of this logging, with the same int value as above, or the string value e.g. '\ndebug' or 'info'. Default verbosity is 'debug' (4), for disk logging.\n\nLog format can be set to json by the use of the boolean flags `log.json` or `log.console.json`, or for the disk\noutput `--log.dir.json`.\n\n### Modularity\n\nErigon by default is \"all in one binary\" solution, but it's possible start TxPool as separated processes.\nSame true about: JSON RPC layer (RPCDaemon), p2p layer (Sentry), history download layer (Downloader), consensus.\nDon't start services as separated processes unless you have clear reason for it: resource limiting, scale, replace by\nyour own implementation, security.\nHow to start Erigon's services as separated processes, see in [docker-compose.yml](./docker-compose.yml).\n\n### Embedded Consensus Layer\n\nOn Ethereum Mainnet, GÃ¶rli, and Sepolia, the Engine API can be disabled in favour of the Erigon native Embedded\nConsensus Layer.\nIf you want to use the internal Consensus Layer, run Erigon with flag `--internalcl`.\n_Warning:_ Staking (block production) is not possible with the embedded CL.\n\n### Testnets\n\nIf you would like to give Erigon a try, but do not have spare 2TB on your drive, a good option is to start syncing one\nof the public testnets, GÃ¶rli. It syncs much quicker, and does not take so much disk space:\n\n```sh\ngit clone --recurse-submodules -j8 https://github.com/ledgerwatch/erigon.git\ncd erigon\nmake erigon\n./build/bin/erigon --datadir=<your_datadir> --chain=goerli\n```\n\nPlease note the `--datadir` option that allows you to store Erigon files in a non-default location, in this example,\nin `goerli` subdirectory of the current directory. Name of the directory `--datadir` does not have to match the name of\nthe chain in `--chain`.\n\n### Block Production (PoW Miner or PoS Validator)\n\n**Disclaimer: Not supported/tested for Gnosis Chain and Polygon Network (In Progress)**\n\nSupport only remote-miners.\n\n* To enable, add `--mine --miner.etherbase=...` or `--mine --miner.miner.sigkey=...` flags.\n* Other supported options: `--miner.extradata`, `--miner.notify`, `--miner.gaslimit`, `--miner.gasprice`\n  , `--miner.gastarget`\n* JSON-RPC supports methods: eth_coinbase , eth_hashrate, eth_mining, eth_getWork, eth_submitWork, eth_submitHashrate\n* JSON-RPC supports websocket methods: newPendingTransaction\n* TODO:\n    + we don't broadcast mined blocks to p2p-network\n      yet, [but it's easy to accomplish](https://github.com/ledgerwatch/erigon/blob/9b8cdc0f2289a7cef78218a15043de5bdff4465e/eth/downloader/downloader.go#L673)\n    + eth_newPendingTransactionFilter\n    + eth_newBlockFilter\n    + eth_newFilter\n    + websocket Logs\n\n<code> ðŸ”¬ Detailed explanation is [here](/docs/mining.md).</code>\n\n### Windows\n\nWindows users may run erigon in 3 possible ways:\n\n* Build executable binaries natively for Windows using provided `wmake.ps1` PowerShell script. Usage syntax is the same\n  as `make` command so you have to run `.\\wmake.ps1 [-target] <targetname>`. Example: `.\\wmake.ps1 erigon` builds erigon\n  executable. All binaries are placed in `.\\build\\bin\\` subfolder. There are some requirements for a successful native\n  build on windows :\n    * [Git](https://git-scm.com/downloads) for Windows must be installed. If you're cloning this repository is very\n      likely you already have it\n    * [GO Programming Language](https://golang.org/dl/) must be installed. Minimum required version is 1.19\n    * GNU CC Compiler at least version 10 (is highly suggested that you install `chocolatey` package manager - see\n      following point)\n    * If you need to build MDBX tools (i.e. `.\\wmake.ps1 db-tools`)\n      then [Chocolatey package manager](https://chocolatey.org/) for Windows must be installed. By Chocolatey you need\n      to install the following components : `cmake`, `make`, `mingw` by `choco install cmake make mingw`. Make sure\n      Windows System \"Path\" variable has:\n      C:\\ProgramData\\chocolatey\\lib\\mingw\\tools\\install\\mingw64\\bin\n\n  **Important note about Anti-Viruses**\n  During MinGW's compiler detection phase some temporary executables are generated to test compiler capabilities. It's\n  been reported some anti-virus programs detect those files as possibly infected by `Win64/Kryptic.CIS` trojan horse (or\n  a variant of it). Although those are false positives we have no control over 100+ vendors of security products for\n  Windows and their respective detection algorithms and we understand this might make your experience with Windows\n  builds uncomfortable. To workaround the issue you might either set exclusions for your antivirus specifically\n  for `build\\bin\\mdbx\\CMakeFiles` sub-folder of the cloned repo or you can run erigon using the following other two\n  options\n\n* Use Docker :  see [docker-compose.yml](./docker-compose.yml)\n\n* Use WSL (Windows Subsystem for Linux) **strictly on version 2**. Under this option you can build Erigon just as you\n  would on a regular Linux distribution. You can point your data also to any of the mounted Windows partitions (\n  eg. `/mnt/c/[...]`, `/mnt/d/[...]` etc) but in such case be advised performance is impacted: this is due to the fact\n  those mount points use `DrvFS` which is a [network file system](#blocks-execution-is-slow-on-cloud-network-drives)\n  and, additionally, MDBX locks the db for exclusive access which implies only one process at a time can access data.\n  This has consequences on the running of `rpcdaemon` which has to be configured as [Remote DB](#for-remote-db) even if\n  it is executed on the very same computer. If instead your data is hosted on the native Linux filesystem non\n  limitations apply.\n  **Please also note the default WSL2 environment has its own IP address which does not match the one of the network\n  interface of Windows host: take this into account when configuring NAT for port 30303 on your router.**\n\n### Using TOML or YAML Config Files\n\nYou can set Erigon flags through a YAML or TOML configuration file with the flag `--config`. The flags set in the\nconfiguration\nfile can be overwritten by writing the flags directly on Erigon command line\n\n### Example\n\n`./build/bin/erigon --config ./config.yaml --chain=goerli`\n\nAssuming we have `chain : \"mainnet\"` in our configuration file, by adding `--chain=goerli` allows the overwrite of the\nflag inside\nof the yaml configuration file and sets the chain to goerli\n\n### TOML\n\nExample of setting up TOML config file\n\n```\n`datadir = 'your datadir'\nport = 1111\nchain = \"mainnet\"\nhttp = true\n\"private.api.addr\"=\"localhost:9090\"\n\n\"http.api\" = [\"eth\",\"debug\",\"net\"]\n```\n\n### YAML\n\nExample of setting up a YAML config file\n\n```\ndatadir : 'your datadir'\nport : 1111\nchain : \"mainnet\"\nhttp : true\nprivate.api.addr : \"localhost:9090\"\n\nhttp.api : [\"eth\",\"debug\",\"net\"]\n```\n\n### Beacon Chain (Consensus Layer)\n\nErigon can be used as an Execution Layer (EL) for Consensus Layer clients (CL). Default configuration is OK.\n\nIf your CL client is on a different device, add `--authrpc.addr 0.0.0.0` ([Engine API] listens on localhost by default)\nas well as `--authrpc.vhosts <CL host>` where `<CL host>` is your source host or `any`.\n\n[Engine API]: https://github.com/ethereum/execution-apis/blob/main/src/engine\n\nIn order to establish a secure connection between the Consensus Layer and the Execution Layer, a JWT secret key is\nautomatically generated.\n\nThe JWT secret key will be present in the datadir by default under the name of `jwt.hex` and its path can be specified\nwith the flag `--authrpc.jwtsecret`.\n\nThis piece of info needs to be specified in the Consensus Layer as well in order to establish connection successfully.\nMore information can be found [here](https://github.com/ethereum/execution-apis/blob/main/src/engine/authentication.md).\n\nOnce Erigon is running, you need to point your CL client to `<erigon address>:8551`,\nwhere `<erigon address>` is either `localhost` or the IP address of the device running Erigon, and also point to the JWT\nsecret path created by Erigon.\n\n### Multiple Instances / One Machine\n\nDefine 6 flags to avoid conflicts: `--datadir --port --http.port --authrpc.port --torrent.port --private.api.addr`.\nExample of multiple chains on the same machine:\n\n```\n# mainnet\n./build/bin/erigon --datadir=\"<your_mainnet_data_path>\" --chain=mainnet --port=30303 --http.port=8545 --authrpc.port=8551 --torrent.port=42069 --private.api.addr=127.0.0.1:9090 --http --ws --http.api=eth,debug,net,trace,web3,erigon\n\n\n# sepolia\n./build/bin/erigon --datadir=\"<your_sepolia_data_path>\" --chain=sepolia --port=30304 --http.port=8546 --authrpc.port=8552 --torrent.port=42068 --private.api.addr=127.0.0.1:9091 --http --ws --http.api=eth,debug,net,trace,web3,erigon\n```\n\nQuote your path if it has spaces.\n\n### Dev Chain\n\n<code> ðŸ”¬ Detailed explanation is [DEV_CHAIN](/DEV_CHAIN.md).</code>\n\nKey features\n============\n\n<code>ðŸ”¬ See more\ndetailed [overview of functionality and current limitations](https://ledgerwatch.github.io/turbo_geth_release.html). It\nis being updated on recurring basis.</code>\n\n### More Efficient State Storage\n\n**Flat KV storage.** Erigon uses a key-value database and storing accounts and storage in a simple way.\n\n<code> ðŸ”¬ See our detailed DB walkthrough [here](./docs/programmers_guide/db_walkthrough.MD).</code>\n\n**Preprocessing**. For some operations, Erigon uses temporary files to preprocess data before inserting it into the main\nDB. That reduces write amplification and DB inserts are orders of magnitude quicker.\n\n<code> ðŸ”¬ See our detailed ETL explanation [here](https://github.com/ledgerwatch/erigon-lib/blob/main/etl/README.md).</code>\n\n**Plain state**.\n\n**Single accounts/state trie**. Erigon uses a single Merkle trie for both accounts and the storage.\n\n### Faster Initial Sync\n\nErigon uses a rearchitected full sync algorithm from\n[Go-Ethereum](https://github.com/ethereum/go-ethereum) that is split into\n\"stages\".\n\n<code>ðŸ”¬ See more detailed explanation in the [Staged Sync Readme](/eth/stagedsync/README.md)</code>\n\nIt uses the same network primitives and is compatible with regular go-ethereum nodes that are using full sync, you do\nnot need any special sync capabilities for Erigon to sync.\n\nWhen reimagining the full sync, with focus on batching data together and minimize DB overwrites. That makes it possible\nto sync Ethereum mainnet in under 2 days if you have a fast enough network connection and an SSD drive.\n\nExamples of stages are:\n\n* Downloading headers;\n\n* Downloading block bodies;\n\n* Recovering senders' addresses;\n\n* Executing blocks;\n\n* Validating root hashes and building intermediate hashes for the state Merkle trie;\n\n* [...]\n\n### JSON-RPC daemon\n\nMost of Erigon's components (txpool, rpcdaemon, snapshots downloader, sentry, ...) can work inside Erigon and as\nindependent process.\n\nTo enable built-in RPC server: `--http` and `--ws` (sharing same port with http)\n\nRun RPCDaemon as separated process: this daemon can use local DB (with running Erigon or on snapshot of a database) or\nremote DB (run on another server). <code>ðŸ”¬ See [RPC-Daemon docs](./cmd/rpcdaemon/README.md)</code>\n\n#### **For remote DB**\n\nThis works regardless of whether RPC daemon is on the same computer with Erigon, or on a different one. They use TPC\nsocket connection to pass data between them. To use this mode, run Erigon in one terminal window\n\n```sh\nmake erigon\n./build/bin/erigon --private.api.addr=localhost:9090 --http=false\nmake rpcdaemon\n./build/bin/rpcdaemon --private.api.addr=localhost:9090 --http.api=eth,erigon,web3,net,debug,trace,txpool\n```\n\n#### **gRPC ports**\n\n`9090` erigon, `9091` sentry, `9092` consensus engine, `9093` torrent downloader, `9094` transactions pool\n\nSupported JSON-RPC calls ([eth](./cmd/rpcdaemon/commands/eth_api.go), [debug](./cmd/rpcdaemon/commands/debug_api.go)\n, [net](./cmd/rpcdaemon/commands/net_api.go), [web3](./cmd/rpcdaemon/commands/web3_api.go)):\n\nFor a details on the implementation status of each\ncommand, [see this table](./cmd/rpcdaemon/README.md#rpc-implementation-status).\n\n### Run all components by docker-compose\n\nDocker allows for building and running Erigon via containers. This alleviates the need for installing build dependencies\nonto the host OS.\n\n#### Optional: Setup dedicated user\n\nUser UID/GID need to be synchronized between the host OS and container so files are written with correct permission.\n\nYou may wish to setup a dedicated user/group on the host OS, in which case the following `make` targets are available.\n\n```sh\n# create \"erigon\" user\nmake user_linux\n# or\nmake user_macos\n```\n\n#### Environment Variables\n\nThere is a `.env.example` file in the root of the repo.\n\n* `DOCKER_UID` - The UID of the docker user\n* `DOCKER_GID` - The GID of the docker user\n* `XDG_DATA_HOME` - The data directory which will be mounted to the docker containers\n\nIf not specified, the UID/GID will use the current user.\n\nA good choice for `XDG_DATA_HOME` is to use the `~erigon/.ethereum` directory created by helper\ntargets `make user_linux` or `make user_macos`.\n\n#### Check: Permissions\n\nIn all cases, `XDG_DATA_HOME` (specified or default) must be writeable by the user UID/GID in docker, which will be\ndetermined by the `DOCKER_UID` and `DOCKER_GID` at build time.\n\nIf a build or service startup is failing due to permissions, check that all the directories, UID, and GID controlled by\nthese environment variables are correct.\n\n#### Run\n\nNext command starts: Erigon on port 30303, rpcdaemon on port 8545, prometheus on port 9090, and grafana on port 3000.\n\n```sh\n#\n# Will mount ~/.local/share/erigon to /home/erigon/.local/share/erigon inside container\n#\nmake docker-compose\n\n#\n# or\n#\n# if you want to use a custom data directory\n# or, if you want to use different uid/gid for a dedicated user\n#\n# To solve this, pass in the uid/gid parameters into the container.\n#\n# DOCKER_UID: the user id\n# DOCKER_GID: the group id\n# XDG_DATA_HOME: the data directory (default: ~/.local/share)\n#\n# Note: /preferred/data/folder must be read/writeable on host OS by user with UID/GID given\n#       if you followed above instructions\n#\n# Note: uid/gid syntax below will automatically use uid/gid of running user so this syntax\n#       is intended to be run via the dedicated user setup earlier\n#\nDOCKER_UID=$(id -u) DOCKER_GID=$(id -g) XDG_DATA_HOME=/preferred/data/folder DOCKER_BUILDKIT=1 COMPOSE_DOCKER_CLI_BUILD=1 make docker-compose\n\n#\n# if you want to run the docker, but you are not logged in as the $ERIGON_USER\n# then you'll need to adjust the syntax above to grab the correct uid/gid\n#\n# To run the command via another user, use\n#\nERIGON_USER=erigon\nsudo -u ${ERIGON_USER} DOCKER_UID=$(id -u ${ERIGON_USER}) DOCKER_GID=$(id -g ${ERIGON_USER}) XDG_DATA_HOME=~${ERIGON_USER}/.ethereum DOCKER_BUILDKIT=1 COMPOSE_DOCKER_CLI_BUILD=1 make docker-compose\n```\n\nMakefile creates the initial directories for erigon, prometheus and grafana. The PID namespace is shared between erigon\nand rpcdaemon which is required to open Erigon's DB from another process (RPCDaemon local-mode).\nSee: https://github.com/ledgerwatch/erigon/pull/2392/files\n\nIf your docker installation requires the docker daemon to run as root (which is by default), you will need to prefix\nthe command above with `sudo`. However, it is sometimes recommended running docker (and therefore its containers) as a\nnon-root user for security reasons. For more information about how to do this, refer to\n[this article](https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user).\n\nWindows support for docker-compose is not ready yet. Please help us with .ps1 port.\n\n### Grafana dashboard\n\n`docker compose up prometheus grafana`, [detailed docs](./cmd/prometheus/Readme.md).\n\n###       \n\nold data\n\nDisabled by default. To enable see `./build/bin/erigon --help` for flags `--prune`\n\nDocumentation\n==============\n\nThe `./docs` directory includes a lot of useful but outdated documentation. For code located\nin the `./cmd` directory, their respective documentation can be found in `./cmd/*/README.md`.\nA more recent collation of developments and happenings in Erigon can be found in the\n[Erigon Blog](https://erigon.substack.com/).\n\n\n\nFAQ\n================\n\n### How much RAM do I need\n\n- Baseline (ext4 SSD): 16Gb RAM sync takes 6 days, 32Gb - 5 days, 64Gb - 4 days\n- +1 day on \"zfs compression=off\". +2 days on \"zfs compression=on\" (2x compression ratio). +3 days on btrfs.\n- -1 day on NVMe\n\nDetailed explanation: [./docs/programmers_guide/db_faq.md](./docs/programmers_guide/db_faq.md)\n\n### Default Ports and Firewalls\n\n#### `erigon` ports\n\n| Port  | Protocol  |        Purpose         | Expose  |\n|:-----:|:---------:|:----------------------:|:-------:|\n| 30303 | TCP & UDP |     eth/66 peering     | Public  |\n| 30304 | TCP & UDP |     eth/67 peering     | Public  |\n| 9090  |    TCP    |    gRPC Connections    | Private |\n| 42069 | TCP & UDP | Snap sync (Bittorrent) | Public  |\n| 6060  |    TCP    |    Metrics or Pprof    | Private |\n| 8551  |    TCP    | Engine API (JWT auth)  | Private |\n\nTypically, 30303 and 30304 are exposed to the internet to allow incoming peering connections. 9090 is exposed only\ninternally for rpcdaemon or other connections, (e.g. rpcdaemon -> erigon).\nPort 8551 (JWT authenticated) is exposed only internally for [Engine API] JSON-RPC queries from the Consensus Layer\nnode.\n\n#### `RPC` ports\n\n| Port | Protocol |           Purpose           | Expose  |\n|:----:|:--------:|:---------------------------:|:-------:|\n| 8545 |   TCP    | HTTP & WebSockets & GraphQL | Private |\n\nTypically, 8545 is exposed only internally for JSON-RPC queries. Both HTTP and WebSocket and GraphQL are on the same\nport.\n\n#### `sentry` ports\n\n| Port  | Protocol  |     Purpose      | Expose  |\n|:-----:|:---------:|:----------------:|:-------:|\n| 30303 | TCP & UDP |     Peering      | Public  |\n| 9091  |    TCP    | gRPC Connections | Private |\n\nTypically, a sentry process will run one eth/xx protocol (e.g. eth/66) and will be exposed to the internet on 30303.\nPort\n9091 is for internal gRCP connections (e.g erigon -> sentry).\n\n#### `sentinel` ports\n\n| Port | Protocol |     Purpose      | Expose  |\n|:----:|:--------:|:----------------:|:-------:|\n| 4000 |   UDP    |     Peering      | Public  |\n| 4001 |   TCP    |     Peering      | Public  |\n| 7777 |   TCP    | gRPC Connections | Private |\n\n#### Other ports\n\n| Port | Protocol | Purpose | Expose  |\n|:----:|:--------:|:-------:|:-------:|\n| 6060 |   TCP    |  pprof  | Private |\n| 6060 |   TCP    | metrics | Private |\n\nOptional flags can be enabled that enable pprof or metrics (or both) - however, they both run on 6060 by default, so\nyou'll have to change one if you want to run both at the same time. use `--help` with the binary for more info.\n\nReserved for future use: **gRPC ports**: `9092` consensus engine, `9093` snapshot downloader, `9094` TxPool\n\n#### Hetzner expecting strict firewall rules\n\n```\n0.0.0.0/8             \"This\" Network             RFC 1122, Section 3.2.1.3\n10.0.0.0/8            Private-Use Networks       RFC 1918\n100.64.0.0/10         Carrier-Grade NAT (CGN)    RFC 6598, Section 7\n127.16.0.0/12         Private-Use Networks       RFC 1918 \n169.254.0.0/16        Link Local                 RFC 3927\n172.16.0.0/12         Private-Use Networks       RFC 1918\n192.0.0.0/24          IETF Protocol Assignments  RFC 5736\n192.0.2.0/24          TEST-NET-1                 RFC 5737\n192.88.99.0/24        6to4 Relay Anycast         RFC 3068\n192.168.0.0/16        Private-Use Networks       RFC 1918\n198.18.0.0/15         Network Interconnect\n                      Device Benchmark Testing   RFC 2544\n198.51.100.0/24       TEST-NET-2                 RFC 5737\n203.0.113.0/24        TEST-NET-3                 RFC 5737\n224.0.0.0/4           Multicast                  RFC 3171\n240.0.0.0/4           Reserved for Future Use    RFC 1112, Section 4\n255.255.255.255/32    Limited Broadcast          RFC 919, Section 7\n                                                 RFC 922, Section 7\n```\n\nSame in [IpTables syntax](https://ethereum.stackexchange.com/questions/6386/how-to-prevent-being-blacklisted-for-running-an-ethereum-client/13068#13068)\n\n### How to get diagnostic for bug report?\n\n- Get stack trace: `kill -SIGUSR1 <pid>`, get trace and stop: `kill -6 <pid>`\n- Get CPU profiling: add `--pprof flag`\n  run `go tool pprof -png  http://127.0.0.1:6060/debug/pprof/profile\\?seconds\\=20 > cpu.png`\n- Get RAM profiling: add `--pprof flag`\n  run `go tool pprof -inuse_space -png  http://127.0.0.1:6060/debug/pprof/heap > mem.png`\n\n### How to run local devnet?\n\n<code> ðŸ”¬ Detailed explanation is [here](/DEV_CHAIN.md).</code>\n\n### Docker permissions error\n\nDocker uses user erigon with UID/GID 1000 (for security reasons). You can see this user being created in the Dockerfile.\nCan fix by giving a host's user ownership of the folder, where the host's user UID/GID is the same as the docker's user\nUID/GID (1000).\nMore details\nin [post](https://www.fullstaq.com/knowledge-hub/blogs/docker-and-the-host-filesystem-owner-matching-problem)\n\n### Run RaspberyPI\n\nhttps://github.com/mathMakesArt/Erigon-on-RPi-4\n\nGetting in touch\n================\n\n### Erigon Discord Server\n\nThe main discussions are happening on our Discord server. To get an invite, send an email to `bloxster [at] proton.me` with\nyour name, occupation, a brief explanation of why you want to join the Discord, and how you heard about Erigon.\n\n### Reporting security issues/concerns\n\nSend an email to `security [at] torquem.ch`.\n\nKnown issues\n============\n\n### `htop` shows incorrect memory usage\n\nErigon's internal DB (MDBX) using `MemoryMap` - when OS does manage all `read, write, cache` operations instead of\nApplication\n([linux](https://linux-kernel-labs.github.io/refs/heads/master/labs/memory_mapping.html)\n, [windows](https://docs.microsoft.com/en-us/windows/win32/memory/file-mapping))\n\n`htop` on column `res` shows memory of \"App + OS used to hold page cache for given App\", but it's not informative,\nbecause if `htop` says that app using 90% of memory you still can run 3 more instances of app on the same machine -\nbecause most of that `90%` is \"OS pages cache\".\nOS automatically frees this cache any time it needs memory. Smaller \"page cache size\" may not impact performance of\nErigon at all.\n\nNext tools show correct memory usage of Erigon:\n\n- `vmmap -summary PID | grep -i \"Physical footprint\"`. Without `grep` you can see details\n    - `section MALLOC ZONE column Resident Size` shows App memory usage, `section REGION TYPE column Resident Size`\n      shows OS pages cache size.\n- `Prometheus` dashboard shows memory of Go app without OS pages cache (`make prometheus`, open in\n  browser `localhost:3000`, credentials `admin/admin`)\n- `cat /proc/<PID>/smaps`\n\nErigon uses ~4Gb of RAM during genesis sync and ~1Gb during normal work. OS pages cache can utilize unlimited amount of\nmemory.\n\n**Warning:** Multiple instances of Erigon on same machine will touch Disk concurrently, it impacts performance - one of\nmain Erigon optimisations: \"reduce Disk random access\".\n\"Blocks Execution stage\" still does many random reads - this is reason why it's slowest stage. We do not recommend\nrunning\nmultiple genesis syncs on same Disk. If genesis sync passed, then it's fine to run multiple Erigon instances on same\nDisk.\n\n### Blocks Execution is slow on cloud-network-drives\n\nPlease read https://github.com/ledgerwatch/erigon/issues/1516#issuecomment-811958891\nIn short: network-disks are bad for blocks execution - because blocks execution reading data from db non-parallel\nnon-batched way.\n\n### Filesystem's background features are expensive\n\nFor example: btrfs's autodefrag option - may increase write IO 100x times\n\n### Gnome Tracker can kill Erigon\n\n[Gnome Tracker](https://wiki.gnome.org/Projects/Tracker) - detecting miners and kill them.\n\n### the --mount option requires BuildKit error\n\nFor anyone else that was getting the BuildKit error when trying to start Erigon the old way you can use the below...\n\n```\nXDG_DATA_HOME=/preferred/data/folder DOCKER_BUILDKIT=1 COMPOSE_DOCKER_CLI_BUILD=1 make docker-compose\n```"
}
