{
  "name": "go-jira",
  "full_name": "go-jira",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Simple jira command-line client in Go",
  "license": "Apache-2.0",
  "homepage": "https://github.com/go-jira/jira",
  "versions": {
    "stable": "1.0.27",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/go-jira/jira/archive/v1.0.27.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "c5bcf7b61300b67a8f4e42ab60e462204130c352050e8551b1c23ab2ecafefc7"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-jira/blobs/sha256:1f733c561a610de82fdabf831fa5dccd2d94cbdd128338d83afbe46ff432e2fe",
          "sha256": "1f733c561a610de82fdabf831fa5dccd2d94cbdd128338d83afbe46ff432e2fe"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-jira/blobs/sha256:e59a1ae3dc441cf2216b2aab847239884fadaa77b78c56b2d005ef2dd37a7519",
          "sha256": "e59a1ae3dc441cf2216b2aab847239884fadaa77b78c56b2d005ef2dd37a7519"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-jira/blobs/sha256:b1352079509d72281e76344ebe41a0704b97a0c116151fb7536a2bb6b26d2bf1",
          "sha256": "b1352079509d72281e76344ebe41a0704b97a0c116151fb7536a2bb6b26d2bf1"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-jira/blobs/sha256:6abb3ebbda9a8a58d0cd89d9bdacf4e35bc0086acc951568454ca63ad5ff0c02",
          "sha256": "6abb3ebbda9a8a58d0cd89d9bdacf4e35bc0086acc951568454ca63ad5ff0c02"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-jira/blobs/sha256:7e5fd3b74f5866d42899c6fb895c95b72465db1eb6a41be127e644c12cdf0f53",
          "sha256": "7e5fd3b74f5866d42899c6fb895c95b72465db1eb6a41be127e644c12cdf0f53"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-jira/blobs/sha256:40fd5a4ecfcb1f7a296651f59f28829e760a1ef69f884766b5262abf972663d6",
          "sha256": "40fd5a4ecfcb1f7a296651f59f28829e760a1ef69f884766b5262abf972663d6"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-jira/blobs/sha256:82a05966c4af4b6200507909bc37eaef905f96d69d1c790ae655e35741ca058c",
          "sha256": "82a05966c4af4b6200507909bc37eaef905f96d69d1c790ae655e35741ca058c"
        },
        "mojave": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-jira/blobs/sha256:32dbd901f35e80fce61a466811dfa5261e543bdb15da855973506e1964c21497",
          "sha256": "32dbd901f35e80fce61a466811dfa5261e543bdb15da855973506e1964c21497"
        },
        "high_sierra": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-jira/blobs/sha256:94372ad76c9857929142891482451672c615a03a32ea310ffcc993b89ad889ff",
          "sha256": "94372ad76c9857929142891482451672c615a03a32ea310ffcc993b89ad889ff"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-jira/blobs/sha256:6892ea2385e3c1eb948612c8a9c98a14442ccbdb046779fb0948db892112dc74",
          "sha256": "6892ea2385e3c1eb948612c8a9c98a14442ccbdb046779fb0948db892112dc74"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "go"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/go-jira.rb",
  "ruby_source_checksum": {
    "sha256": "f44f79298664dd6eb81412e200367067c133db3e0862032415c7e2c8ca1e2748"
  },
  "date_added": "2017-11-02T13:42:25-04:00",
  "readme": "[![Build Status](https://travis-ci.org/go-jira/jira.svg?branch=master)](https://travis-ci.org/go-jira/jira)\n[![GoDoc](https://godoc.org/github.com/go-jira/jira?status.svg)](https://godoc.org/github.com/go-jira/jira)\n[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)\n\n# go-jira\n\nSimple command line client for Atlassian's Jira service written in Go.\n\n## GDPR USERNAME DISCLAIMER\n\nWhen this tool was initial written the \"username\" parameter was widely used in the Atlassian API.\nDue to GDPR restrictions this parameter was been almost completely phased out other then V1 login.\nThe \"--user\" field is still provided as a default global, however moving forward any usage of this field should be phased out in favor of the \"--login\" option. \n\nCommands which previously took a username will now expect an email address such as watch, create, assign, etc...\n\n## Install\n\n### Download\n\nYou can download one of the pre-built binaries for **go-jira** [here](https://github.com/go-jira/jira/releases).\n\n### Build\n\nYou can build and install the official repository with [Go](https://golang.org/dl/) (before running the below command, ensure you have `GO111MODULE=on` set in your environment):\n\n\tgo get github.com/go-jira/jira/cmd/jira\n\nThis will checkout this repository into `$GOPATH/src/github.com/go-jira/jira/`, build, and install it.\n\nIt should then be available in $GOPATH/bin/jira.\n\n## Usage\n\n\n#### Setting up TAB completion\n\nSince go-jira is built with the \"kingpin\" golang command line library we support bash/zsh shell completion automatically:\n\n * <https://github.com/alecthomas/kingpin/tree/v2.2.5#bashzsh-shell-completion>\n\nFor example, in bash, adding something along the lines of:\n\n  `eval \"$(jira --completion-script-bash)\"`\n\nto your bashrc, or .profile (assuming go-jira binary is already in your path) will cause jira to offer tab completion behavior.\n\n## Configuration\n\n**go-jira** uses a configuration hierarchy.  When loading the configuration from disk it will recursively look through all parent directories in your current path looking for a **.jira.d** directory.  If your current directory is not a child directory of your homedir, then your homedir will also be inspected for a **.jira.d** directory.  From all of **.jira.d** directories discovered **go-jira** will load a **&lt;command&gt;.yml** file (ie for `jira list` it will load `.jira.d/list.yml`) then it will merge in any properties from the **config.yml** if found.  The configuration properties found in a file closest to your current working directory will have precedence.  Properties overridden with command line options will have final precedence.\n\nThe complicated configuration hierarchy is used because **go-jira** attempts to be context aware.  For example, if you are working on a \"foo\" project and you `cd` into your project workspace, wouldn't it be nice if `jira ls` automatically knew to list only issues related to the \"foo\" project?  Likewise when you `cd` to the \"bar\" project then `jira ls` should only list issues related to \"bar\" project.  You can do this with by creating a configuration under your project workspace at **./.jira.d/config.yml** that looks like:\n\n```yaml\nproject: foo\n```\n\nYou will need to specify your local jira endpoint first, typically in your homedir like:\n\n```bash\nmkdir ~/.jira.d\n\ncat <<EOM >~/.jira.d/config.yml\nendpoint: https://jira.mycompany.com\nEOM\n```\n\nThen use `jira login` to authenticate yourself as $USER. To change your username, use the `-u` CLI flag or set `user:` in your config.yml\n\n### Dynamic Configuration\n\nIf the **.jira.d/config.yml** file is executable, then **go-jira** will attempt to execute the file and use the stdout for configuration.  You can use this to customize templates or other overrides depending on what type of operation you are running.  For example if you would like to use the \"table\" template when ever you run `jira ls`, then you can create a template like this:\n\n```sh\n#!/bin/sh\n\necho \"endpoint: https://jira.mycompany.com\"\necho \"editor: emacs -nw\"\n\ncase $JIRA_OPERATION in\n    list)\n      echo \"template: table\";;\nesac\n```\n\nOr if you always set the same overrides when you create an issue for your project you can do something like this:\n\n```sh\n#!/bin/sh\necho \"project: GOJIRA\"\n\ncase $JIRA_OPERATION in\n    create)\n        echo \"assignee: $USER\"\n        echo \"watchers: mothra\"\n        ;;\nesac\n```\n\n### Custom Commands\nYou can now create custom commands for `jira` just by editing your `.jira.d/config.yml` config file.  These commands are effectively shell-scripts that can have documented options and arguments. The basic format is like:\n```yaml\ncustom-commands:\n  - command1\n  - command2\n```\n##### Commands\nWhere the individual commands are maps with these keys:\n* `name: string` [**required**] This is the command name, so for `jira foobar` you would have `name: foobar`\n* `help: string` This is help message displayed in the usage for the command\n* `hidden: bool` This command will be hidden from users, but still executable.  Sometimes useful for constructing complex commands where one custom command might call another.\n* `default: bool` Use this for compound command groups.  If you wanted to have `jira foo bar` and `jira foo baz` you would have two commands with `name: foo bar` and `name: foo baz`.  Then if you wanted `jira foo baz` to be called by default when you type `jira foo` you would set `default: true` for that custom command.\n* `options: list`  This is the list of possible option flags that the command will accept\n* `args: list` This is the list of command arguments (like the ISSUE) that the command will accept.\n* `aliases: string list`: This is a list of alternate names that the user can provide on the command line to run the same command.  Typically used to shorten the command name or provide alternatives that users might expect.\n* `script: string` [**required**] This is the script that will be executed as the action for this command. The value will be treated as a template and substitutions for options and arguments will be made before executing.\n\n##### Options\nThese are possible keys under the command `options` property:\n* `name: string` [**required**] Name of the option, so `name: foobar` will result in `--foobar` option.\n* `help: string` The help message displayed in usage for the option.\n* `type: string`:  The type of the option, can be one of these values: `BOOL`, `COUNTER`, `ENUM`, `FLOAT32`, `FLOAT64`, `INT8`, `INT16`, `INT32`, `INT64`, `INT`, `STRING`, `STRINGMAP`, `UINT8`, `UINT16`, `UINT32`,  `UINT64` and `UINT`.  Most of these are primitive data types an should be self-explanatory.  The default type is `STRING`. There are some special types:\n  * `COUNTER` will be an integer type that increments each time the option is used.  So something like `--count --count` will results in `{{options.count}}` of `2`.\n  * `ENUM` type is used with the `enum` property.  The raw type is a string and **must** be one of the values listed in the `enum` property.\n  * `STRINGMAP` is a `string => string` map with the format of `KEY=VALUE`.  So `--override foo=bar --override bin=baz` will allow for `{{options.override.foo}}` to be `bar` and `{{options.override.bin}}` to be `baz`.\n* `short: char` The single character option to be used so `short: c` will allow for `-c`.\n* `required: bool` Indicate that this option must be provided on the command line.  Conflicts with the `default` property.\n* `default: any` Specify the default value for the option.  Conflicts with the `required` property.\n* `hidden: bool` Hide the option from the usage help message, but otherwise works fine.  Sometimes useful for developer options that user should not play with.\n* `repeat: bool` Indicate that this option can be repeated.  Not applicable for `COUNTER` and `STRINGMAP` types.  This will turn the option value into an array that you can iterate over.  So `--day Monday --day Thursday` can be used like `{{range options.day}}Day: {{.}}{{end}}`\n* `enum: string list` Used with the `type: ENUM` property, it is a list of strings values that represent the set of possible values the option accepts.\n\n##### Arguments\nThese are possible keys under the command `args` property:\n* `name: string` [**required**] Name of the option, so `name: ISSUE` will show in the usage as `jira <command> ISSUE`.  This also represents the name of the argument to be used in the script template, so `{{args.ISSUE}}`.\n* `help: string` The help message displayed in usage for the argument.\n* `type: string`:  The type of the argument, can be one of these values: `BOOL`, `COUNTER`, `ENUM`, `FLOAT32`, `FLOAT64`, `INT8`, `INT16`, `INT32`, `INT64`, `INT`, `STRING`, `STRINGMAP`, `UINT8`, `UINT16`, `UINT32`,  `UINT64` and `UINT`.  Most of these are primitive data types an should be self-explanatory.  The default type is `STRING`.  There are some special types:\n  * `COUNTER` will be an integer type that increments each the argument is provided  So something like `jira <command> ISSUE-12 ISSUE-23` will results in `{{args.ISSUE}}` of `2`.\n  * `ENUM` type is used with the `enum` property.  The raw type is a string and **must** be one of the values listed in the `enum` property.\n  * `STRINGMAP` is a `string => string` map with the format of `KEY=VALUE`.  So `jira <command> foo=bar bin=baz` along with a `name: OVERRIDE` property will allow for `{{args.OVERRIDE.foo}}` to be `bar` and `{{args.OVERRIDE.bin}}` to be `baz`.\n* `required: bool` Indicate that this argument must be provided on the command line.  Conflicts with the `default` property.\n* `default: any` Specify the default value for the argument.  Conflicts with the `required` property.\n* `repeat: bool` Indicate that this argument can be repeated.  Not applicable for `COUNTER` and `STRINGMAP` types.  This will turn the template value into an array that you can iterate over.  So `jira <command> ISSUE-12 ISSUE-23` can be used like `{{range args.ISSUE}}Issue: {{.}}{{end}}`\n* `enum: string list` Used with the `type: ENUM` property, it is a list of strings values that represent the set of possible values for the argument.\n\n##### Script Template\nThe `script` property is a template that would produce `/bin/sh` compatible syntax after the template has been processed.  There are 2 key template functions `{{args}}` and `{{options}}` that return the parsed arguments and option flags as a map.\n\nTo demonstrate how you might use args and options here is a `custom-test` command:\n```yaml\ncustom-commands:\n  - name: custom-test\n    help: Testing the custom commands\n    options:\n      - name: abc\n        short: a\n        default: default\n      - name: day\n        type: ENUM\n        enum:\n          - Monday\n          - Tuesday\n          - Wednesday\n          - Thursday\n          - Friday\n        required: true\n    args:\n      - name: ARG\n        required: true\n      - name: MORE\n        repeat: true\n    script: |\n      echo COMMAND {{args.ARG}} --abc {{options.abc}} --day {{options.day}} {{range $more := args.MORE}}{{$more}} {{end}}\n```\n\nThen to run it:\n```\n$ jira custom-test\nERROR Invalid Usage: required flag --day not provided\n\n$ jira custom-test --day Sunday\nERROR Invalid Usage: enum value must be one of Monday,Tuesday,Wednesday,Thursday,Friday, got 'Sunday'\n\n$ jira custom-test --day Tuesday\nERROR Invalid Usage: required argument 'ARG' not provided\n\n$ jira custom-test --day Tuesday arg1\nCOMMAND arg1 --abc default --day Tuesday\n\n$ jira custom-test --day Tuesday arg1 more1 more2 more3\nCOMMAND arg1 --abc default --day Tuesday more1 more2 more3\n\n$ jira custom-test --day Tuesday arg1 more1 more2 more3 --abc non-default\nCOMMAND arg1 --abc non-default --day Tuesday more1 more2 more3\n\n$ jira custom-test --day Tuesday arg1 more1 more2 more3 -a short-non-default\nCOMMAND arg1 --abc short-non-default --day Tuesday more1 more2 more3\n```\n\nThe script has access to all the environment variables that are in your current environment plus those that `jira` will set.  `jira` sets environment variables for each config property it has parsed from `.jira.d/config.yml` or the command configs at `.jira.d/<command>.yml`.  It might be useful to see all environment variables that `jira` is producing, so here is a simple custom command to list them:\n```yaml\ncustom-commands:\n  - name: env\n    help: print the JIRA environment variables available to custom commands\n    script: |\n      env | grep JIRA\n ```\n\nYou could use the environment variables automatically, so if your `.jira.d/config.yml` looks something like this:\n```yaml\nproject: PROJECT\ncustom-commands:\n  - name: print-project\n    help: print the name of the configured project\n    script: \"echo $JIRA_PROJECT\"\n```\n\n##### Examples\n\n* `jira mine` for listing issues assigned to you\n```yaml\ncustom-commands:\n  - name: mine\n    help: display issues assigned to me\n    script: |-\n      if [ -n \"$JIRA_PROJECT\" ]; then\n          # if `project: ...` configured just list the issues for current project\n          {{jira}} list --template table --query \"resolution = unresolved and assignee=currentuser() and project = $JIRA_PROJECT ORDER BY priority asc, created\"\n      else\n          # otherwise list issues for all project\n          {{jira}} list --template table --query \"resolution = unresolved and assignee=currentuser() ORDER BY priority asc, created\"\n      fi\n```\n* `jira sprint` for listing issues in your current sprint\n```yaml\ncustom-commands:\n  - name: sprint\n    help: display issues for active sprint\n    script: |-\n      if [ -n \"$JIRA_PROJECT\" ]; then\n          # if `project: ...` configured just list the issues for current project\n          {{jira}} list --template table --query \"sprint in openSprints() and type != epic and resolution = unresolved and project=$JIRA_PROJECT ORDER BY rank asc, created\"\n      else\n          # otherwise list issues for all project\n          {{jira}} list --template table --query \"sprint in openSprints() and type != epic and resolution = unresolved ORDER BY rank asc, created\"\n      fi\n```\n\n### Editing\n\nWhen you run command like `jira edit` it will open up your favorite editor with the templatized output so you can quickly edit.  When the editor\ncloses **go-jira** will submit the completed form.  The order which **go-jira** attempts to determine your preferred editor is:\n\n* **editor** property in any config.yml file\n* **JIRA_EDITOR** environment variable\n* **EDITOR** environment variable\n* vim\n\n### Templates\n\n**go-jira** has the ability to customize most output (and editor input) via templates.  There are default templates available for all operations,\nwhich may or may not work for your actual jira implementation.  Jira is endlessly customizable, so it is hard to provide default templates\nthat will work for all issue types.\n\nWhen running a command like `jira edit` it will look through the current directory hierarchy trying to find a file that matches **.jira.d/templates/edit**,\nif found it will use that file as the template, otherwise it will use the default **edit** template hard-coded into **go-jira**.  You can export the default\nhard-coded templates with `jira export-templates` which will write them to **~/.jira.d/templates/**.\n\n#### Writing/Editing Templates\n\nFirst the basic templating functionality is defined by the Go language 'text/template' library.  The library reference documentation can be found [here](https://golang.org/pkg/text/template/), and there is a good primer document [here](https://gohugo.io/templates/go-templates/).  `go-jira` also provides a few extra helper functions to make it a bit easier to format the data, those functions are defined [here](https://github.com/go-jira/jira/blob/master/jiracli/templates.go#L64).\n\nKnowing what data and fields are available to any given template is not obvious. The easiest approach to determine what is available is to use the `debug` template on any given operation.  For example to find out what is available to the \"view\" templates, you can use:\n```\njira view GOJIRA-321 -t debug\n```\n\nThis will print out the data in JSON format that is available to the template.  You can do this for any other operation, like \"list\":\n```\njira list -t debug\n```\n\n### Authentication\n\n#### Atlassian Cloud\n\nFor Atlassian Cloud hosted Jira [API Tokens are now required](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-basic-auth-and-cookie-based-auth/).  You will automatically be prompted for an API Token if your jira endpoint ends in `.atlassian.net`.\n\n##### Quickstart API Token and Keychain\n\n1. Edit your config or execute the snippit (make sure to replace `<SUBDOMAIN>` and `<EMAIL>`)\n```\nexport SUBDOMAIN=\"https://<SUBDOMAIN>.atlassian.net\"\nexport EMAIL=\"<EMAIL>\"\nmkdir -p ~/.jira.d\nprintf \"endpoint: $SUBDOMAIN\\nuser: $EMAIL\\npassword-source: keyring\" > ~/.jira.d/config.yml\n```\n2. Create a new API Token at [id.atlassian.com](https://id.atlassian.com/manage-profile/security)\n3. Execute `jira session` and enter your API Token. `jira` will add your session to the keyring.\n\n#### Private Jira Service\nIf you are using a private Jira service, you can force `jira` to use an api-token by setting the `authentication-method: api-token` property in your `$HOME/.jira.d/config.yml` file.  The API Token needs to be presented to the Jira service on every request, so it is recommended to store this API Token security within your OS's keyring, or using the `pass`/`gopass` service as documented below so that it can be programmatically accessed via `jira` and not prompt you every time.  For a less-secure option you can also provide the API token via a `JIRA_API_TOKEN` environment variable.  If you are unable to use an api-token for an Atlassian Cloud hosted Jira then you can still force `jira` to use the old session based authentication (until it the hosted system stops accepting it) by setting `authentication-method: session`.\n\nThe API Token authentication requires both the token and the email of the user. The email mut be set in the  `user:` in your config.yml. Failure to provide the `user` will result in a 401 error.\n\nIf your Jira service still allows you to use the Session based authentication method then `jira` will prompt for a password automatically when get a response header from the Jira service that indicates you do not have an active session (ie the `X-Ausername` header is set to `anonymous`).  Then after authentication we cache the `cloud.session.token` cookie returned by the service [session login api](https://docs.atlassian.com/jira/REST/cloud/#auth/1/session-login) and reuse that on subsequent requests.  Typically this cookie will be valid for several hours (depending on the service configuration).  To automatically securely store your password for easy reuse by jira You can enable a `password-source` via `.jira.d/config.yml` with possible values of `keyring`, `pass` or `gopass`.\n\nDepending on how your private Jira service is configured, API tokens may require the \"[Bearer][]\" authentication scheme instead of the traditional \"[Basic][]\" [authentication scheme][scheme]. In this case, set the `authentication-method: bearer-token` property in your `$HOME/.jira.d/config.yml` file.\n\n[scheme]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#authentication_schemes\n[Bearer]: https://datatracker.ietf.org/doc/html/rfc6750\n[Basic]: https://tools.ietf.org/html/rfc7617\n\n| **API token [scheme][]** | `authentication-method` | **Example HTTP request header**                 |\n|:------------------------:|-------------------------|-------------------------------------------------|\n|        [Basic][]         | `api-token`             | `Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQK` |\n|        [Bearer][]        | `bearer-token`          | `Authorization: Bearer MY_TOKEN`                |\n\n#### User vs Login\nThe Jira service has sometimes differing opinions about how a user is identified.  In other words the ID you login with might not be ID that the jira system recognized you as.  This matters when trying to identify a user via various Jira REST APIs (like issue assignment).  This is especially relevant when trying to authenticate with an API Token where the authentication user is usually an email address, but within the Jira system the user is identified by a user name.  To accommodate this `jira` now supports two different properties in the config file.  So when authentication using the API Tokens you will likely want something like this in your `$HOME/.jira.d/config.yml` file:\n```yaml\nuser: person\nlogin: person@example.com\n```\n\nYou can also override these values on the command line with `jira --user person --login person@example.com`.  The `login` value will be used only for authentication purposes, the `user` value will be used when a user name is required for any Jira service API calls.\n\n#### `keyring` password source\nOn OSX and Linux there are a few keyring providers that `go-jira` can use (via this [golang module](https://github.com/tmc/keyring)).  To integrate `go-jira` with a supported keyring just add this configuration to `$HOME/.jira.d/config.yml`:\n```yaml\npassword-source: keyring\n```\nAfter setting this and issuing a `jira login`, your credentials will be stored in your platform's backend (e.g. Keychain for Mac OS X) automatically. Subsequent operations, like a `jira ls`, should automatically login.\n\n#### `pass` password source\nAn alternative to the keyring password source is the `pass` tool (documentation [here](https://www.passwordstore.org/)).  This uses gpg to encrypt/decrypt passwords on demand and by using `gpg-agent` you can cache the gpg credentials for a period of time so you will not be prompted repeatedly for decrypting the passwords.  The advantage over the keyring integration is that `pass` can be used on more platforms than OSX and Linux, although it does require more setup.  To use `pass` for password storage and retrieval via `go-jira` just add this configuration to `$HOME/.jira.d/config.yml`:\n```yaml\npassword-source: pass\npassword-name: jira.example.com/myuser\n```\n\nThis assumes you have already setup `pass` correctly on your system.  Specifically you will need to have created a gpg key like this:\n\n```\n$ gpg --gen-key\n```\n\nThen you will need the GPG Key ID you want associated with `pass`.  First list the available keys:\n```\n$ gpg --list-keys\n/home/gojira/.gnupg/pubring.gpg\n-------------------------------------------------\npub   2048R/A307D709 2016-12-18\nuid                  Go Jira <gojira@example.com>\nsub   2048R/F9A047B8 2016-12-18\n```\n\nThen initialize the `pass` tool to use the correct key:\n```\n$ pass init \"Go Jira <gojira@example.com>\"\n```\n\nNow insert your password with the name you configured.\n\n```\n$ pass insert jira.example.com/myuser\n```\n\nYou probably want to setup gpg-agent so that you don't have to type in your gpg passphrase all the time.  You can get `gpg-agent` to automatically start by adding something like this to your `$HOME/.bashrc`\n```bash\nif [ -f $HOME/.gpg-agent-info ]; then\n    . $HOME/.gpg-agent-info\n    export GPG_AGENT_INFO\nfi\n\nif [ ! -f $HOME/.gpg-agent.conf ]; then\n  cat <<EOM >$HOME/.gpg-agent.conf\ndefault-cache-ttl 604800\nmax-cache-ttl 604800\ndefault-cache-ttl-ssh 604800\nmax-cache-ttl-ssh 604800\nEOM\nfi\n\nif [ -n \"${GPG_AGENT_INFO}\" ]; then\n    nc  -U \"${GPG_AGENT_INFO%%:*}\" >/dev/null </dev/null\n    if [ ! -S \"${GPG_AGENT_INFO%%:*}\" -o $? != 0 ]; then\n        # set passphrase cache so I only have to type my passphrase once a day\n        eval $(gpg-agent --options $HOME/.gpg-agent.conf --daemon --write-env-file $HOME/.gpg-agent-info --use-standard-socket --log-file $HOME/tmp/gpg-agent.log --verbose)\n    fi\nfi\nexport GPG_TTY=$(tty)\n```\n\n#### `gopass` password source\nThere is also the possibility to use [gopass](https://www.gopass.pw/) as a password source. `gopass` (like `pass`) uses gpg to encrypt/decrypt passwords. To use `gopass` for password storagte and retrieval via `go-jira` just add this configuration to `$HOME/.jira.d/config.yml`:\n```yaml\npassword-source: gopass\npassword-name: jira.example.com/myuser\n```\n\nFor this to work, you need a working `gopass` installation. \n\nTo configure your `gpg-agent` to cache your gpg passphrase take a look at the `pass` section of the readme. \n\n#### `stdin` password source\n\nWhen `password-source` is set to `stdin`, the `jira login` command will read from stdin until EOF, and the bytes read will be the used as the password. This is useful if you have some other programmatic method for fetching passwords. For example, if `password-generator` creates a one-time password and prints it to stdout, you could use it like this.\n\n```bash\n$ ./password-generator | jira login --endpoint=https://my.jira.endpoint.com --user=USERNAME\n```\n\n#### Switch path  used for password source\nFor `gopass` and `pass` it is possible to specify the full path for the `password-source` tool  used for retrieval of the password. This can be accomplised\nby setting the `password-source-path` option in the configuration file. \n\nE.g.\n```yaml\npassword-source: gopass\npassword-name: jira.example.com/myuser\npassword-source-path: /path/to/my-special-gopass\n```\n\nThis will cause go-jira to use the `gopass` style cli interaction with the `my-special-gopass` binary.\n\nIf you ommit the `password-source-path` option, either `gopass` (for `gopass`) or `pass` (for `pass`) \nwill be used."
}
