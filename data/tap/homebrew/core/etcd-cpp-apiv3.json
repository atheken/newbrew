{
  "name": "etcd-cpp-apiv3",
  "full_name": "etcd-cpp-apiv3",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "C++ implementation for etcd's v3 client API, i.e., ETCDCTL_API=3",
  "license": "BSD-3-Clause",
  "homepage": "https://github.com/etcd-cpp-apiv3/etcd-cpp-apiv3",
  "versions": {
    "stable": "0.15.3",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/etcd-cpp-apiv3/etcd-cpp-apiv3/archive/refs/tags/v0.15.3.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "1a6f4ed634f3c75cbfaa2768917e280c6df77cac2af5d945ad67ef20d53d8b60"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/etcd-cpp-apiv3/blobs/sha256:9e6bcc365b9e839fe7f1107e813f9ff1fb5105800783ed0154cdb51a2b2cb2fe",
          "sha256": "9e6bcc365b9e839fe7f1107e813f9ff1fb5105800783ed0154cdb51a2b2cb2fe"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/etcd-cpp-apiv3/blobs/sha256:88e27d9f0791238266ed5cc3d81a5f88edce3d0ecf54df6136b942f85d4343dd",
          "sha256": "88e27d9f0791238266ed5cc3d81a5f88edce3d0ecf54df6136b942f85d4343dd"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/etcd-cpp-apiv3/blobs/sha256:a8aa4b03f58419883f1f1b182d3f128f1a78b62e3dd8fd2ce04e3319c9121294",
          "sha256": "a8aa4b03f58419883f1f1b182d3f128f1a78b62e3dd8fd2ce04e3319c9121294"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/etcd-cpp-apiv3/blobs/sha256:f76c3bee74a2bec3013bbc432600959a69c9c1093f032007685cbd39d31defcb",
          "sha256": "f76c3bee74a2bec3013bbc432600959a69c9c1093f032007685cbd39d31defcb"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/etcd-cpp-apiv3/blobs/sha256:a7bb00ff67bd68a6c757372707a08493b7b4117e225d231610320cb06e975a55",
          "sha256": "a7bb00ff67bd68a6c757372707a08493b7b4117e225d231610320cb06e975a55"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/etcd-cpp-apiv3/blobs/sha256:37f33202aa68c49b581a98f000664da4f6670e57052e7ebbc1be91e88272c5a9",
          "sha256": "37f33202aa68c49b581a98f000664da4f6670e57052e7ebbc1be91e88272c5a9"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/etcd-cpp-apiv3/blobs/sha256:1089119445965fc006756f16f9b8233c5bce1c8fc8e9dcde78e9b0860c5a51ad",
          "sha256": "1089119445965fc006756f16f9b8233c5bce1c8fc8e9dcde78e9b0860c5a51ad"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake"
  ],
  "dependencies": [
    "boost",
    "cpprestsdk",
    "grpc",
    "openssl@3",
    "protobuf"
  ],
  "test_dependencies": [
    "etcd"
  ],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/etcd-cpp-apiv3.rb",
  "ruby_source_checksum": {
    "sha256": "4db4494a9a97aa4cfb0f7704c44b63d3ff032debd5dd2019079e868e6f41610c"
  },
  "date_added": "2021-12-22T13:45:32+00:00",
  "readme": "etcd-cpp-apiv3\n==============\n\nThe _etcd-cpp-apiv3_ is a C++ API for [etcd](https://etcd.io/)'s v3 client API,\ni.e., `ETCDCTL_API=3`.\n\n[![Build and Test](https://github.com/etcd-cpp-apiv3/etcd-cpp-apiv3/workflows/Build%20and%20Test/badge.svg)](https://github.com/etcd-cpp-apiv3/etcd-cpp-apiv3/actions?workflow=Build+and+Test)\n\n### Supported OS environments\n\n+ **Linux**\n  - Ubuntu 18.04, requires upgrade gRPC libraries (tested with 1.27.x).\n  - Ubuntu 20.04\n  - CentOS 8 (tested with 1.27.x)\n\n+ **MacOS**\n  - MacOS 10.15\n  - MacOS 11.0\n\n+ **Windows**\n  - Windows 10, with [vcpkg](https://github.com/microsoft/vcpkg/tree/master/ports/etcd-cpp-apiv3)\n\n### Supported etcd versions:\n\n+ etcd 3.2, tested with [v3.2.26](https://github.com/etcd-io/etcd/releases/v3.2.26)\n+ etcd 3.3, tested with [v3.3.11](https://github.com/etcd-io/etcd/releases/v3.3.11)\n+ etcd 3.4, tested with [v3.4.13](https://github.com/etcd-io/etcd/releases/v3.4.13)\n\n## Requirements\n\n1. boost and openssl (**Note that boost is only required if you need the asynchronous runtime**)\n\n   + On Ubuntu, above requirement could be installed as:\n\n         apt-get install libboost-all-dev libssl-dev\n\n   + On MacOS, above requirement could be installed as:\n\n         brew install boost openssl\n\n2. protobuf & gRPC\n\n   + On Ubuntu, above requirements related to protobuf and gRPC can be installed as:\n\n         apt-get install libgrpc-dev \\\n                 libgrpc++-dev \\\n                 libprotobuf-dev \\\n                 protobuf-compiler-grpc\n\n   + On MacOS, above requirements related to protobuf and gRPC can be installed as:\n\n         brew install grpc protobuf\n\n   + When building grpc from source code (e.g., on [Ubuntu 18.04](https://github.com/etcd-cpp-apiv3/etcd-cpp-apiv3/blob/master/.github/workflows/build-test.yml#L73)\n     and on [CentOS](https://github.com/etcd-cpp-apiv3/etcd-cpp-apiv3/blob/master/.github/workflows/centos-latest.yml#L44-L67)),\n     if the system-installed openssl is preferred, you need to add `-DgRPC_SSL_PROVIDER=package`\n     when building gRPC with CMake.\n\n3. [cpprestsdk](https://github.com/microsoft/cpprestsdk), the latest version of master branch\n   on github should work, you can build and install this dependency using cmake with:\n\n        git clone https://github.com/microsoft/cpprestsdk.git\n        cd cpprestsdk\n        mkdir build && cd build\n        cmake .. -DCPPREST_EXCLUDE_WEBSOCKETS=ON\n        make -j$(nproc) && make install\n\n## API documentation\n\nThe _etcd-cpp-apiv3_ doesn't maintain a website for documentation, for detail usage of the\netcd APIs, please refer to [the \"etcd operations\" section](https://github.com/etcd-cpp-apiv3/etcd-cpp-apiv3#etcd-operations)\nin README, and see the detail C++ interfaces in [Client.hpp](https://github.com/etcd-cpp-apiv3/etcd-cpp-apiv3/blob/master/etcd/Client.hpp)\nand [SyncClient.hpp](https://github.com/etcd-cpp-apiv3/etcd-cpp-apiv3/blob/master/etcd/SyncClient.hpp).\n\n## Build and install\n\nThe _etcd-cpp-apiv3_ library could be easily built and installed using cmake, after all above\ndependencies have been successfully installed:\n\n    git clone https://github.com/etcd-cpp-apiv3/etcd-cpp-apiv3.git\n    cd etcd-cpp-apiv3\n    mkdir build && cd build\n    cmake ..\n    make -j$(nproc) && make install\n\n## Using this package in your CMake project\n\nTo use this package in your CMake project, you can either\n\n- install, then find the library using `find_package()`:\n\n  ```cmake\n  find_package(etcd-cpp-apiv3 REQUIRED)\n  target_link_libraries(your_target PRIVATE etcd-cpp-api)\n  ```\n\n- or, add this repository as a subdirectory in your project, and link the library directly:\n\n  ```cmake\n  add_subdirectory(thirdparty/etcd-cpp-apiv3)\n  target_link_libraries(your_target PRIVATE etcd-cpp-api)\n  ```\n\n- or, use [FetchContent](https://cmake.org/cmake/help/latest/module/FetchContent.html):\n\n  ```cmake\n  include(FetchContent)\n  FetchContent_Declare(\n    etcd-cpp-apiv3\n    https://github.com/etcd-cpp-apiv3/etcd-cpp-apiv3.git\n  )\n  FetchContent_MakeAvailable(etcd-cpp-apiv3)\n  target_link_libraries(your_target PRIVATE etcd-cpp-api)\n  ```\n\n## Compatible etcd version\n\nThe _etcd-cpp-apiv3_ should work well with etcd > 3.0. Feel free to issue an issue to us on\nGithub when you encounter problems when working with etcd 3.x releases.\n\n## Sync vs. Async runtime\n\nThere are various discussion about whether to support a user-transparent multi-thread executor in\nthe background, or, leaving the burden of thread management to the user (e.g., see\n[issue#100](https://github.com/etcd-cpp-apiv3/etcd-cpp-apiv3/issues/100) and\n[issue#207](https://github.com/etcd-cpp-apiv3/etcd-cpp-apiv3/issues/207) for more discussion about\nthe implementation of underlying thread model).\n\nThe _etcd-cpp-apiv3_ library supports both synchronous and asynchronous runtime, controlled by the\ncmake option `BUILD_ETCD_CORE_ONLY=ON/OFF` (defaults to `OFF`).\n\n- When it is set as `OFF`: the library artifact name will be `libetcd-cpp-api.{a,so,dylib,lib,dll}` and a\n  cmake target `etcd-cpp-api` is exported and pointed to it. The library provides both synchronous runtime\n  (`etcd/SyncClient.hpp`) and asynchronous runtime (`etcd/Client.hpp`), and the `cpprestsdk` is a\n  required dependency.\n- When it is set as `ON`: the library artifact name will be `libetcd-cpp-api-core.{a,so,dylib,lib,dll}`\n  and a cmake target `etcd-cpp-api` is exported and pointed to it. The library provides only the\n  synchronous runtime (`etcd/SyncClient.hpp`), and the `cpprestsdk` won't be required.\n\nWe encourage the users to use the asynchronous runtime by default, as it provides more flexibility\nand convenient APIs and less possibilities for errors that block the main thread. Note that the\nasynchronous runtime requires `cpprestsdk` and will setup a thread pool in the background.\n\n**Warning: users cannot link both `libetcd-cpp-api.{a,so,dylib,lib,dll}` and `libetcd-cpp-api-core.{a,so,dylib,lib,dll}`\nto same program.**\n\n## Usage\n\n```c++\n  etcd::Client etcd(\"http://127.0.0.1:2379\");\n  etcd::Response response = etcd.get(\"/test/key1\").get();\n  std::cout << response.value().as_string();\n```\n\nMethods of the etcd client object are sending the corresponding gRPC requests and are returning\nimmediately with a `pplx::task` object. The task object is responsible for handling the\nreception of the HTTP response as well as parsing the gRPC of the response. All of this is done\nasynchronously in a background thread so you can continue your code to do other operations while the\ncurrent etcd operation is executing in the background or you can wait for the response with the\n`wait()` or `get()` methods if a synchronous behavior is enough for your needs. These methods\nare blocking until the HTTP response arrives or some error situation happens. `get()` method\nalso returns the `etcd::Response` object.\n\n```c++\n  etcd::Client etcd(\"http://127.0.0.1:2379\");\n  pplx::task<etcd::Response> response_task = etcd.get(\"/test/key1\");\n  // ... do something else\n  etcd::Response response = response_task.get();\n  std::cout << response.value().as_string();\n```\n\nThe pplx library allows to do even more. You can attach continuation objects to the task if you do\nnot care about when the response is coming you only want to specify what to do then. This\ncan be achieved by calling the `then` method of the task, giving a function object parameter to\nit that can be used as a callback when the response is arrived and processed. The parameter of this\ncallback should be either a `etcd::Response` or a `pplx::task<etcd:Response>`. You should\nprobably use a C++ lambda function here as a callback.\n\n```c++\n  etcd::Client etcd(\"http://127.0.0.1:2379\");\n  etcd.get(\"/test/key1\").then([](etcd::Response response)\n  {\n    std::cout << response.value().as_string();\n  });\n\n  // ... your code can continue here without any delay\n```\n\nYour lambda function should have a parameter of type `etcd::Response` or\n`pplx::task<etcd::Response>`. In the latter case you can get the actual `etcd::Response`\nobject with the `get()` function of the task. Calling get can raise exceptions so this is the way\nhow you can catch the errors generated by the REST interface. The `get()` call will not block in\nthis case since the response has been already arrived (we are inside the callback).\n\n```c++\n  etcd::Client etcd(\"http://127.0.0.1:2379\");\n  etcd.get(\"/test/key1\").then([](pplx::task<etcd::Response> response_task)\n  {\n    try\n    {\n      etcd::Response response = response_task.get(); // can throw\n      std::cout << response.value().as_string();\n    }\n    catch (std::exception const & ex)\n    {\n      std::cerr << ex.what();\n    }\n  });\n\n  // ... your code can continue here without any delay\n```\n\n### Multiple endpoints\n\nConnecting to multiple endpoints is supported:\n\n```c++\n  // multiple endpoints are separated by comma\n  etcd::Client etcd(\"http://a.com:2379,http://b.com:2379,http://c.com:2379\");\n\n  // or, separated semicolon\n  etcd::Client etcd(\"http://a.com:2379;http://b.com:2379;http://c.com:2379\");\n```\n\nBehind the screen, gRPC's load balancer is used and the round-robin strategy will\nbe used by default.\n\n### Etcd authentication\n\n#### v3 authentication\n\nEtcd [v3 authentication](https://etcd.io/docs/v3.4.0/learning/design-auth-v3/) has been\nsupported. The `Client::Client` could accept a `username` and `password` as arguments and handle\nthe authentication properly.\n\n```c++\n  etcd::Client etcd(\"http://127.0.0.1:2379\", \"root\", \"root\");\n```\n\nOr the etcd client can be constructed explicitly:\n\n```c++\n  etcd::Client *etcd = etcd::Client::WithUser(\n                    \"http://127.0.0.1:2379\", \"root\", \"root\");\n```\n\nThe default authentication token will be expired every 5 minutes (300 seconds), which is controlled by\nthe `--auth-token-ttl` flag of etcd. When constructing a etcd client, a customized TTL value is allow:\n\n```c++\n  etcd::Client etcd(\"http://127.0.0.1:2379\", \"root\", \"root\", 300);\n```\n\nEnabling v3 authentication requires a bit more work for older versions etcd (etcd 3.2.x and etcd 3.3.x).\nFirst you need to set the `ETCDCTL_API=3`, then\n\n+ add a user, and type the password:\n\n```bash\nprintf 'root\\nroot\\n' | /usr/local/bin/etcdctl user add root\n```\n\n+ enabling authentication:\n\n```bash\n/usr/local/bin/etcdctl auth enable\n```\n\n+ disable authentication:\n\n```bash\n/usr/local/bin/etcdctl --user=\"root:root\" auth disable\n```\n\n#### transport security\n\nEtcd [transport security](https://etcd.io/docs/v3.4.0/op-guide/security/) and certificate based\nauthentication have been supported as well. The `Client::Client` could accept arguments `ca` ,\n`cert` and `privkey` for CA cert, cert and private key files for the SSL/TLS transport and authentication.\nNote that the later arguments `cert` and `privkey` could be empty strings or omitted if you just need\nsecure transport and don't enable certificate-based client authentication (using the `--client-cert-auth`\narguments when launching etcd server).\n\n```c++\n  etcd::Client etcd(\"https://127.0.0.1:2379\",\n                    \"example.rootca.cert\", \"example.cert\", \"example.key\",\n                    \"round_robin\");\n```\n\nOr the etcd client can be constructed explicitly:\n\n```c++\n  etcd::Client *etcd = etcd::Client::WithSSL(\n                    \"https://127.0.0.1:2379\",\n                    \"example.rootca.cert\", \"example.cert\", \"example.key\");\n```\n\nUsing secure transport but not certificated-based client authentication:\n\n```c++\n  etcd::Client *etcd = etcd::Client::WithSSL(\n                    \"https://127.0.0.1:2379\", \"example.rootca.cert\");\n```\n\nFor more details about setup about security communication between etcd server and client, please\nrefer to [transport security](https://etcd.io/docs/v3.4.0/op-guide/security/) in etcd documentation\nand [an example](https://github.com/kelseyhightower/etcd-production-setup) about setup etcd with\ntransport security using openssl.\n\nWe also provide a tool [`setup-ca.sh`](./security-config/setup-ca.sh) as a helper for development and testing.\n\n#### transport security & multiple endpoints\n\nIf you want to use multiple `https://` endpoints, and you are working with self-signed certificates, you\nmay encountered errors like\n\n```\nerror: 14: connections to all backends failing\n```\n\nThat means your DNS have some problems with your DNS resolver and SSL authority, you could put a domain\nname (a host name) to the `SANS` field when self-signing your certificate, e.g,\n\n```\n\"sans\": [\n  \"etcd\",\n  \"127.0.0.1\",\n  \"127.0.0.2\",\n  \"127.0.0.3\"\n],\n```\n\nAnd pass a `target_name_override` arguments to `WithSSL`,\n\n```cpp\n  etcd::Client *etcd = etcd::Client::WithSSL(\n                    \"https://127.0.0.1:2379,https://127.0.0.2:2479\",\n                    \"example.rootca.cert\", \"example.cert\", \"example.key\", \"etcd\");\n```\n\nFor more discussion about this feature, see also [#87](https://github.com/etcd-cpp-apiv3/etcd-cpp-apiv3/issues/87),\n[grpc#20186](https://github.com/grpc/grpc/issues/20186) and [grpc#22119](https://github.com/grpc/grpc/issues/22119).\n\n### Fine-grained gRPC channel arguments\n\nBy default the etcd-cpp-apiv3 library will set the following arguments for transport layer\n\n+ `GRPC_ARG_MAX_SEND_MESSAGE_LENGTH` to `INT_MAX`\n+ `GRPC_ARG_MAX_RECEIVE_MESSAGE_LENGTH` to `INT_MAX`\n\nIf _load balancer strategy_ is specified, the following argument will be set\n\n+ `GRPC_ARG_LB_POLICY_NAME`\n\nWhen transport security is enabled and `target_name_override` is specified when working with SSL, the\nfollowing argument will be set\n\n+ `GRPC_SSL_TARGET_NAME_OVERRIDE_ARG`\n\nFurther, all variants of constructors for `etcd::Client` accepts an extra `grpc::ChannelArguments` argument\nwhich can be used for fine-grained control the gRPC settings, e.g.,\n\n```cpp\n  grpc::ChannelArguments grpc_args;\n  grpc_args.SetInt(GRPC_ARG_KEEPALIVE_TIME_MS, 2000);\n  grpc_args.SetInt(GRPC_ARG_KEEPALIVE_TIMEOUT_MS, 6000);\n  grpc_args.SetInt(GRPC_ARG_KEEPALIVE_PERMIT_WITHOUT_CALLS, 1);\n\n  etcd::Client etcd(\"http://127.0.0.1:2379\", grpc_args);\n```\n\nFor more motivation and discussion about the above design, please refer to [issue-103](https://github.com/etcd-cpp-apiv3/etcd-cpp-apiv3/issues/103).\n\n### gRPC timeout when waiting for responses\n\ngRPC Timeout is long-standing missing pieces in the etcd-cpp-apiv3 library. The timeout has been\nsupported via a `set_grpc_timeout` interfaces on the client,\n\n```cpp\n  template <typename Rep = std::micro>\n  void set_grpc_timeout(std::chrono::duration<Rep> const &timeout)\n```\n\nAny `std::chrono::duration` value can be used to set the grpc timeout, e.g.,\n\n```cpp\n  etcd.set_grpc_timeout(std::chrono::seconds(5));\n```\n\nNote that the timeout value is the \"timeout\" when waiting for responses upon the gRPC channel, i.e., `CompletionQueue::AsyncNext`.\nIt doesn't means the timeout between issuing a `.set()` method getting the `etcd::Response`, as in the async mode the such a time\nduration is unpredictable and the gRPC timeout should be enough to avoid deadly waiting (e.g., waiting for a `lock()`).\n\n### Error code in responses\n\nThe `class etcd::Response` may yield an error code and error message when error occurs,\n\n```cpp\n  int error_code() const;\n  std::string const & error_message() const;\n\n  bool is_ok() const;\n```\n\nThe error code would be `0` when succeed, otherwise the error code might be\n\n```cpp\n  extern const int ERROR_GRPC_OK;\n  extern const int ERROR_GRPC_CANCELLED;\n  extern const int ERROR_GRPC_UNKNOWN;\n  extern const int ERROR_GRPC_INVALID_ARGUMENT;\n  extern const int ERROR_GRPC_DEADLINE_EXCEEDED;\n  extern const int ERROR_GRPC_NOT_FOUND;\n  extern const int ERROR_GRPC_ALREADY_EXISTS;\n  extern const int ERROR_GRPC_PERMISSION_DENIED;\n  extern const int ERROR_GRPC_UNAUTHENTICATED;\n  extern const int ERROR_GRPC_RESOURCE_EXHAUSTED;\n  extern const int ERROR_GRPC_FAILED_PRECONDITION;\n  extern const int ERROR_GRPC_ABORTED;\n  extern const int ERROR_GRPC_OUT_OF_RANGE;\n  extern const int ERROR_GRPC_UNIMPLEMENTED;\n  extern const int ERROR_GRPC_INTERNAL;\n  extern const int ERROR_GRPC_UNAVAILABLE;\n  extern const int ERROR_GRPC_DATA_LOSS;\n\n  extern const int ERROR_KEY_NOT_FOUND;\n  extern const int ERROR_COMPARE_FAILED;\n  extern const int ERROR_KEY_ALREADY_EXISTS;\n  extern const int ERROR_ACTION_CANCELLED;\n```\n\n## Etcd operations\n\n### Reading a value\n\nYou can read a value with the `get()` method of the client instance. The only parameter is the\nkey to be read. If the read operation is successful then the value of the key can be acquired with\nthe `value()` method of the response. Success of the operation can be checked with the\n`is_ok()` method of the response. In case of an error, the `error_code()` and\n`error_message()` methods can be called for some further detail.\n\nPlease note that there can be two kind of error situations. There can be some problem with the\ncommunication between the client and the etcd server. In this case the `get()``` method of the\nresponse task will throw an exception as shown above. If the communication is ok but there is some\nproblem with the content of the actual operation, like attempting to read a non-existing key then the\nresponse object will give you all the details. Let's see this in an example.\n\nThe Value object of the response also holds some extra information besides the string value of the\nkey. You can also get the index number of the creation and the last modification of this key with\nthe `created_index()` and the `modified_index()` methods.\n\n```c++\n  etcd::Client etcd(\"http://127.0.0.1:2379\");\n  pplx::task<etcd::Response> response_task = etcd.get(\"/test/key1\");\n\n  try\n  {\n    etcd::Response response = response_task.get(); // can throw\n    if (response.is_ok())\n      std::cout << \"successful read, value=\" << response.value().as_string();\n    else\n      std::cout << \"operation failed, details: \" << response.error_message();\n  }\n  catch (std::exception const & ex)\n  {\n    std::cerr << \"communication problem, details: \" << ex.what();\n  }\n```\n\n### Put a value\n\nYou can put a key-value pair to etcd with the the `put()` method of the client instance. The only\nparameter is the key and value to be put\n\n```c++\n  etcd::Client etcd(\"http://127.0.0.1:2379\");\n  pplx::task<etcd::Response> response_task = etcd.put(\"foo\", \"bar\");\n```\n\n### Modifying a value\n\nSetting the value of a key can be done with the `set()` method of the client. You simply pass\nthe key and the value as string parameters and you are done. The newly set value object can be asked\nfrom the response object exactly the same way as in case of the reading (with the `value()`\nmethod). This way you can check for example the index value of your modification. You can also check\nwhat was the previous value that this operation was overwritten. You can do that with the\n`prev_value()` method of the response object.\n\n```c++\n  etcd::Client etcd(\"http://127.0.0.1:2379\");\n  pplx::task<etcd::Response> response_task = etcd.set(\"/test/key1\", \"42\");\n\n  try\n  {\n    etcd::Response response = response_task.get();\n    if (response.is_ok())\n      std::cout << \"The new value is successfully set, previous value was \"\n                << response.prev_value().as_string();\n    else\n      std::cout << \"operation failed, details: \" << response.error_message();\n  }\n  catch (std::exception const & ex)\n  {\n    std::cerr << \"communication problem, details: \" << ex.what();\n  }\n```\n\nThe set method creates a new leaf node if it weren't exists already or modifies an existing one.\nThere are a couple of other modification methods that are executing the write operation only upon\nsome specific conditions.\n\n* `add(key, value)` creates a new value if it's key does not exists and returns a \"Key\n  already exists\" error otherwise (error code `ERROR_KEY_ALREADY_EXISTS`)\n* `modify(key, value)` modifies an already existing value or returns a \"etcd-cpp-apiv3: key not found\" error\n  otherwise (error code `KEY_NOT_FOUND`)\n* `modify_if(key, value, old_value)` modifies an already existing value but only if the previous\n  value equals with old_value. If the values does not match returns with \"Compare failed\" error\n  (code `ERROR_COMPARE_FAILED`)\n* `modify_if(key, value, old_index)` modifies an already existing value but only if the index of\n  the previous value equals with old_index. If the indices does not match returns with \"Compare\n  failed\" error (code `ERROR_COMPARE_FAILED`)\n\n### Deleting a value\n\nValues can be deleted with the `rm` method passing the key to be deleted as a parameter. The key\nshould point to an existing value. There are conditional variations for deletion too.\n\n* `rm(std::string const& key)` unconditionally deletes the given key\n* `rm_if(key, value, old_value)` deletes an already existing value but only if the previous\n  value equals with old_value. If the values does not match returns with \"Compare failed\" error\n  (code `ERROR_COMPARE_FAILED`)\n* `rm_if(key, value, old_index)` deletes an already existing value but only if the index of\n  the previous value equals with old_index. If the indices does not match returns with \"Compare\n  failed\" error (code `ERROR_COMPARE_FAILED`)\n\n### Handling directory nodes\n\nDirectory nodes are not supported anymore in etcdv3. However, ls and rmdir will list/delete\nkeys defined by the prefix. mkdir method is removed since etcdv3 treats everything as keys.\n\n1. Creating a directory:\n\n   Creating a directory is not supported anymore in etcdv3 cpp client. Users should remove the\n   API from their code.\n\n2. Listing a directory:\n\n   Listing directory in etcd3 cpp client will return all keys that matched the given prefix\n   recursively.\n\n   ```c++\n     etcd.set(\"/test/key1\", \"value1\").wait();\n     etcd.set(\"/test/key2\", \"value2\").wait();\n     etcd.set(\"/test/key3\", \"value3\").wait();\n     etcd.set(\"/test/subdir/foo\", \"foo\").wait();\n\n     etcd::Response resp = etcd.ls(\"/test\").get();\n   ```\n\n   `resp.key()` will have the following values:\n\n   ```\n   /test/key1s\n   /test/key2\n   /test/key3\n   /test/subdir/foo\n   ```\n\n   Note: Regarding the returned keys when listing a directory:\n\n   + In etcdv3 cpp client, resp.key(0) will return \"/test/new_dir/key1\" since everything is\n     treated as keys in etcdv3.\n   + While in etcdv2 cpp client it will return \"key1\" and \"/test/new_dir\" directory should\n     be created first before you can set \"key1\".\n\n   When you list a directory the response object's `keys()` and `values()` methods gives\n   you a vector of key names and values. The `value()` method with an integer parameter also\n   returns with the i-th element of the values vector, so `response.values()[i] == response.value(i)`.\n\n   ```c++\n     etcd::Client etcd(\"http://127.0.0.1:2379\");\n     etcd::Response resp = etcd.ls(\"/test/new_dir\").get();\n     for (int i = 0; i < resp.keys().size(); ++i)\n     {\n       std::cout << resp.keys(i);\n       std::cout << \" = \" << resp.value(i).as_string() << std::endl;\n     }\n   ```\n\n   etcd-cpp-apiv3 supports lists keys only without fetching values from etcd server:\n\n   ```c++\n     etcd::Client etcd(\"http://127.0.0.1:2379\");\n     etcd::Response resp = etcd.keys(\"/test/new_dir\").get();\n     for (int i = 0; i < resp.keys().size(); ++i)\n     {\n       std::cout << resp.keys(i);\n     }\n   ```\n\n3. Removing directory:\n\n   If you want the delete recursively then you have to pass a second `true` parameter\n   to rmdir and supply a key. This key will be treated as a prefix. All keys that match the\n   prefix will be deleted. All deleted keys will be placed in `response.values()` and\n   `response.keys()`. This parameter defaults to `false`.\n\n   ```c++\n     etcd::Client etcd(\"http://127.0.0.1:2379\");\n     etcd.set(\"/test/key1\", \"foo\");\n     etcd.set(\"/test/key2\", \"bar\");\n     etcd.set(\"/test/key3\", \"foo_bar\");\n     etcd::Response resp = etcd.rmdir(\"/test\", true).get();\n     for (int i = 0; i < resp.keys().size(); ++i)\n     {\n       std::cout << resp.keys(i);\n       std::cout << \" = \" << resp.value(i).as_string() << std::endl;\n     }\n   ```\n\n   However, if recursive parameter is false, functionality will be the same as just deleting a key.\n   The key supplied will NOT be treated as a prefix and will be treated as a normal key name.\n\n### Using binary data as key and value\n\nEtcd itself support using arbitrary binary data as the key and value, i.e., the key and value\ncan contain `\\NUL` (`\\0`) and not necessary NUL-terminated strings. `std::string` in C++ supports\nembed `\\0` as well, but please note that when constructing `std::string` from a C-style string\nthe string will be terminated by the first `\\0` character. Rather, you need to use the constructor\nwith the `count` parameter explicitly. When unpack a `std::string` that contains `\\0`, you need\n`.data()`,\n\n```c++\n  std::string key = \"key-foo\\0bar\";\n  std::string value = \"value-foo\\0bar\";\n  etcd.put(key, value).wait();\n```\n\n### Lock\n\nEtcd lock has been supported as follows:\n\n```c++\n  etcd::Client etcd(\"http://127.0.0.1:2379\");\n  etcd.lock(\"/test/lock\");\n```\n\nIt will create a lease and a keep-alive job behind the screen, the lease will be revoked until\nthe lock is unlocked.\n\nUsers can also feed their own lease directory for lock:\n\n```c++\n  etcd::Client etcd(\"http://127.0.0.1:2379\");\n  etcd.lock_with_lease(\"/test/lock\", lease_id);\n```\n\nNote that the arguments for `unlock()` is the the same key that used for `lock()`, but the\n`response.lock_key()` that return by `lock()`:\n\n```c++\n  etcd::Client etcd(\"http://127.0.0.1:2379\");\n\n  // lock\n  auto response = etcd.lock(\"/test/lock\").get();\n\n  // unlock\n  auto _ = etcd.unlock(response.lock_key()).get();\n```\n\n### Watching for changes\n\nWatching for a change is possible with the `watch()` operation of the client. The watch method\nsimply does not deliver a response object until the watched value changes in any way (modified or\ndeleted). When a change happens the returned result object will be the same as the result object of\nthe modification operation. So if the change is triggered by a value change, then\n`response.action()` will return \"set\", `response.value()` will hold the new\nvalue and `response.prev_value()` will contain the previous value. In case of a delete\n`response.action()` will return \"delete\", `response.value()` will be empty and should not be\ncalled at all and `response.prev_value()` will contain the deleted value.\n\nAs mentioned in the section \"handling directory nodes\", directory nodes are not supported anymore\nin etcdv3.\n\nHowever it is still possible to watch a whole \"directory subtree\", or more specifically a set of\nkeys that match the prefix, for changes with passing `true` to the second `recursive`\nparameter of `watch` (this parameter defaults to `false` if omitted). In this case the\nmodified value object's `key()` method can be handy to determine what key is actually changed.\nSince this can be a long lasting operation you have to be prepared that is terminated by an\nexception and you have to restart the watch operation.\n\nThe watch also accepts an index parameter that specifies what is the first change we are interested\nabout. Since etcd stores the last couple of modifications with this feature you can ensure that your\nclient does not miss a single change.\n\nHere is an example how you can watch continuously for changes of one specific key.\n\n```c++\nvoid watch_for_changes()\n{\n  etcd.watch(\"/nodes\", index + 1, true).then([this](pplx::task<etcd::Response> resp_task)\n  {\n    try\n    {\n      etcd::Response resp = resp_task.get();\n      index = resp.index();\n      std::cout << resp.action() << \" \" << resp.value().as_string() << std::endl;\n    }\n    catch(...) {}\n    watch_for_changes();\n  });\n}\n```\n\nAt first glance it seems that `watch_for_changes()` calls itself on every value change but in\nfact it just sends the asynchronous request, sets up a callback for the response and then returns. The\ncallback is executed by some thread from the pplx library's thread pool and the callback (in this\ncase a small lambda function actually) will call `watch_for_changes()` again from there.\n\n#### Watcher Class\n\nUsers can watch a key indefinitely or until user cancels the watch. This can be done by\ninstantiating a Watcher class. The supplied callback function in Watcher class will be\ncalled every time there is an event for the specified key. Watch stream will be cancelled\neither by user implicitly calling `Cancel()` or when watcher class is destroyed.\n\n```c++\n  etcd::Watcher watcher(\"http://127.0.0.1:2379\", \"/test\", printResponse);\n  etcd.set(\"/test/key\", \"42\"); /* print response will be called */\n  etcd.set(\"/test/key\", \"43\"); /* print response will be called */\n  watcher.Cancel();\n  etcd.set(\"/test/key\", \"43\"); /* print response will NOT be called,\n                                  since watch is already cancelled */\n```\n\n#### Watcher re-connection\n\nA watcher will be disconnected from etcd server in some cases, for some examples, the etcd\nserver is restarted, or the network is temporarily unavailable. It is users' responsibility\nto decide if a watcher should re-connect to the etcd server.\n\nHere is an example how users can make a watcher re-connect to server after disconnected.\n\n```c++\n// wait the client ready\nvoid wait_for_connection(etcd::Client &client) {\n  // wait until the client connects to etcd server\n  while (!client.head().get().is_ok()) {\n    sleep(1);\n  }\n}\n\n// a loop for initialized a watcher with auto-restart capability\nvoid initialize_watcher(const std::string& endpoints,\n                        const std::string& prefix,\n                        std::function<void(etcd::Response)> callback,\n                        std::shared_ptr<etcd::Watcher>& watcher) {\n  etcd::Client client(endpoints);\n  wait_for_connection(client);\n\n  // Check if the failed one has been cancelled first\n  if (watcher && watcher->Cancelled()) {\n    std::cout << \"watcher's reconnect loop been cancelled\" << std::endl;\n    return;\n  }\n  watcher.reset(new etcd::Watcher(client, prefix, callback, true));\n\n  // Note that lambda requires `mutable`qualifier.\n  watcher->Wait([endpoints, prefix, callback,\n    /* By reference for renewing */ &watcher](bool cancelled) mutable {\n    if (cancelled) {\n      std::cout << \"watcher's reconnect loop stopped as been cancelled\" << std::endl;\n      return;\n    }\n    initialize_watcher(endpoints, prefix, callback, watcher);\n  });\n}\n```\n\nThe functionalities can be used as\n\n```c++\nstd::string endpoints = \"http://127.0.0.1:2379\";\nstd::function<void(Response)> callback = printResponse;\nconst std::string prefix = \"/test/key\";\n\n// the watcher initialized in this way will auto re-connect to etcd\nstd::shared_ptr<etcd::Watcher> watcher;\ninitialize_watcher(endpoints, prefix, callback, watcher);\n```\n\nFor a complete runnable example, see also [./tst/RewatchTest.cpp](./tst/RewatchTest.cpp). Note\nthat you shouldn't use the watcher itself inside the `Wait()` callback as the callback will be\ninvoked in a separate **detached** thread where the watcher may have been destroyed.\n\n### Requesting for lease\n\nUsers can request for lease which is governed by a time-to-live(TTL) value given by the user.\nMoreover, user can attached the lease to a key(s) by indicating the lease id in `add()`,\n`set()`, `modify()` and `modify_if()`. Also the ttl will that was granted by etcd\nserver will be indicated in `ttl()`.\n\n```c++\n  etcd::Client etcd(\"http://127.0.0.1:2379\");\n  etcd::Response resp = etcd.leasegrant(60).get();\n  etcd.set(\"/test/key2\", \"bar\", resp.value().lease());\n  std::cout << \"ttl\" << resp.value().ttl();\n```\n\nThe lease can be revoked by\n\n```c++\n  etcd.leaserevoke(resp.value().lease());\n```\n\nA lease can also be attached with a `KeepAlive` object at the creation time,\n\n```c++\n  std::shared_ptr<etcd::KeepAlive> keepalive = etcd.leasekeepalive(60).get();\n  std::cout << \"lease id: \" << keepalive->Lease();\n```\n\nThe remaining time-to-live of a lease can be inspected by\n\n```c++\n  etcd::Response resp2 = etcd.leasetimetolive(resp.value().lease()).get();\n  std::cout << \"ttl\" << resp.value().ttl();\n```\n\n#### Keep alive\n\nKeep alive for leases is implemented using a separate class `KeepAlive`, which can be used as:\n\n```c++\n  etcd::KeepAlive keepalive(etcd, ttl, lease_id);\n```\n\nIt will perform a period keep-alive action before it is cancelled explicitly, or destructed implicitly.\n\n`KeepAlive` may fails (e.g., when the etcd server stopped unexpectedly), the constructor of `KeepAlive`\ncould accept a handler of type `std::function<std::exception_ptr>` and the handler will be invoked\nwhen exception occurs during keeping it alive.\n\nNote that the handler will invoked in a separated thread, not the thread where the `KeepAlive` object\nis constructed.\n\n```c++\n  std::function<void (std::exception_ptr)> handler = [](std::exception_ptr eptr) {\n    try {\n        if (eptr) {\n            std::rethrow_exception(eptr);\n        }\n    } catch(const std::runtime_error& e) {\n        std::cerr << \"Connection failure \\\"\" << e.what() << \"\\\"\\n\";\n    } catch(const std::out_of_range& e) {\n        std::cerr << \"Lease expiry \\\"\" << e.what() << \"\\\"\\n\";\n    }\n  };\n  etcd::KeepAlive keepalive(etcd, handler, ttl, lease_id);\n```\n\nWithout handler, the internal state can be checked via `KeepAlive::Check()` and it will rethrow\nthe async exception when there are errors during keeping the lease alive.\n\nNote that even with `handler`, the `KeepAlive::Check()` still rethrow if there's an async exception.\n\n### Etcd transactions\n\nEtcd v3's [Transaction APIs](https://etcd.io/docs/v3.4/learning/api/#transaction) is supported via the\n`etcdv3::Transaction` interfaces. A set of convenient APIs are use to add operations to a transaction, e.g.,\n\n```cpp\n  etcdv3::Transaction txn;\n  txn.setup_put(\"/test/x1\", \"1\");\n  txn.setup_put(\"/test/x2\", \"2\");\n  txn.setup_put(\"/test/x3\", \"3\");\n  etcd::Response resp = etcd.txn(txn).get();\n```\n\nTransactions in etcd supports set a set of comparison targets to specify the condition of transaction, e.g.,\n\n```cpp\n  etcdv3::Transaction txn;\n\n  // setup the conditions\n  txn.add_compare_value(\"/test/x1\", \"1\");\n  txn.add_compare_value(\"/test/x2\", \"2\");\n\n  // or, compare the last modified revision\n  txn.add_compare_mod(\"/test/x3\", 0);  // not exists\n  txn.add_compare_mod(\"/test/x4\", etcdv3::CompareResult::GREATER, 1234);  // the modified revision is greater than 1234\n```\n\nHigh-level APIs (e.g., `compare_and_create`, `compare_and_swap`) are also provided, e.g.,\n`fetch-and-add` operation can be implemented as\n\n```cpp\n  auto fetch_and_add = [](etcd::Client& client,\n                          std::string const& key) -> void {\n    auto value = stoi(client.get(key).get().value().as_string());\n    while (true) {\n      auto txn = etcdv3::Transaction();\n      txn.setup_compare_and_swap(key, std::to_string(value),\n                                 std::to_string(value + 1));\n      etcd::Response resp = client.txn(txn).get();\n      if (resp.is_ok()) {\n        break;\n      }\n      value = stoi(resp.value().as_string());\n    }\n  };\n```\n\nSee full example of the usages of transaction APIs, please refer to [./tst/TransactionTest.cpp](./tst/TransactionTest.cpp),\nfor full list of the transaction operation APIs, see [./etcd/v3/Transaction.hpp](./etcd/v3/Transaction.hpp).\n\n### Election API\n\nEtcd v3's [election APIs](https://github.com/etcd-io/etcd/blob/main/server/etcdserver/api/v3election/v3electionpb/v3election.proto)\nare supported via the following interfaces,\n\n```c++\npplx::task<Response> campaign(std::string const &name, int64_t lease_id,\n                              std::string const &value);\n\npplx::task<Response> proclaim(std::string const &name, int64_t lease_id,\n                              std::string const &key, int64_t revision,\n                              std::string const &value);\n\npplx::task<Response> leader(std::string const &name);\n\nstd::unique_ptr<SyncClient::Observer> observe(std::string const &name);\n\npplx::task<Response> resign(std::string const &name, int64_t lease_id,\n                            std::string const &key, int64_t revision);\n```\n\nNote that if grpc timeout is set, `campaign()` will return an timeout error response if it\ncannot acquire the election ownership within the timeout period. Otherwise will block until\nbecome the leader.\n\nThe `Observer` returned by `observe()` can be use to monitor the changes of election ownership.\nThe observer stream will be canceled when been destructed.\n\n```c++\n  std::unique_ptr<etcd::SyncClient::Observer> observer = etcd.observe(\"test\");\n\n  // wait one change event, blocked execution\n  etcd::Response resp = observer->WaitOnce();\n\n  // wait many change events, blocked execution\n  for (size_t i = 0; i < ...; ++i) {\n    etcd::Response resp = observer->WaitOnce();\n    ...\n  }\n\n  // cancel the observer\n  observer.reset(nullptr);\n```\n\nfor more details, please refer to [etcd/Client.hpp](./etcd/Client.hpp) and [tst/ElectionTest.cpp](./tst/ElectionTest.cpp).\n\n### TODO\n\n1. Cancellation of asynchronous calls(except for watch)\n\n## License\n\nThis project is licensed under the BSD-3-Clause license - see the [LICENSE](https://github.com/etcd-cpp-apiv3/etcd-cpp-apiv3/blob/master/LICENSE.txt)."
}
