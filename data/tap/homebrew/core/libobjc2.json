{
  "name": "libobjc2",
  "full_name": "libobjc2",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Objective-C runtime library intended for use with Clang",
  "license": "MIT",
  "homepage": "https://github.com/gnustep/libobjc2",
  "versions": {
    "stable": "2.1",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/gnustep/libobjc2/archive/refs/tags/v2.1.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "78fc3711db14bf863040ae98f7bdca08f41623ebeaf7efaea7dd49a38b5f054c"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/libobjc2/blobs/sha256:ba344263f90c949f7be3cf48ac100e83eb0fe062f5b770cd688b2b84b6f3ece4",
          "sha256": "ba344263f90c949f7be3cf48ac100e83eb0fe062f5b770cd688b2b84b6f3ece4"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake"
  ],
  "dependencies": [],
  "test_dependencies": [
    "pkg-config"
  ],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [
    {
      "llvm": [
        "build",
        "test"
      ]
    }
  ],
  "uses_from_macos_bounds": [
    {}
  ],
  "requirements": [
    {
      "name": "linux",
      "cask": null,
      "download": null,
      "version": null,
      "contexts": [],
      "specs": [
        "stable"
      ]
    }
  ],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/libobjc2.rb",
  "ruby_source_checksum": {
    "sha256": "3b11bd2023365c9f9234107b2a6e5524fff864fc6a8b543b9f17c889ecf03574"
  },
  "date_added": "2022-07-02T02:27:20+00:00",
  "readme": "GNUstep Objective-C Runtime\n===========================\n\nLinux and Windows CI: [![Libobjc2 CI](https://github.com/gnustep/libobjc2/actions/workflows/main.yml/badge.svg)](https://github.com/gnustep/libobjc2/actions/workflows/main.yml)\n\nFreeBSD CI: [![Build Status](https://api.cirrus-ci.com/github/gnustep/libobjc2.svg)](https://cirrus-ci.com/github/gnustep/libobjc2)\n\nThe GNUstep Objective-C runtime was designed as a drop-in replacement for the\nGCC runtime.  It supports three ABIs:\n\n- The old GCC ABI, which provides support for Objective-C 1.0 features.  This\n  can be selected via the `-fobjc-runtime=gcc` flag in Clang or by compiling\n  with GCC.\n- The initial GNUstep non-fragile ABI, which was intended to be compatible with\n  the GCC ABI, but provide support for modern Objective-C features.  This can be\n  selected with the `-fobjc-runtime=gnustep-1.9` flag in Clang.\n- The modern (v2) ABI, which provides richer reflection metadata, smaller\n  binaries and reduced memory usage.  This is selected with the\n  `-fobjc-runtime=gnustep-2.0` flag in Clang 7.0 or later.\n\nThe runtime can be built without support for older ABIs by setting the\n`OLDABI_COMPAT` flag to `OFF` in CMake configuration.  This will result in a\nsmaller binary, which will not link against code using the older ABIs.\n\nAll ABIs support the following feature above and beyond the GCC runtime:\n\n- The modern Objective-C runtime APIs, initially introduced with OS X 10.5.\n- Blocks (closures).\n- Synthesised property accessors.\n- Efficient support for @synchronized()\n- Type-dependent dispatch, eliminating stack corruption from mismatched\n  selectors.\n- Support for the associated reference APIs introduced with Mac OS X 10.6.\n- Support for the automatic reference counting APIs introduced with Mac OS X\n  10.7\n\nHistory\n-------\n\nEarly work on the GNUstep runtime combined code from the GCC Objective-C\nruntime, the Étoilé Objective-C runtime, Remy Demarest's blocks runtime for OS\nX 10.5, and the Étoilé Objective-C 2 API compatibility framework.  All of these\naside from the GCC runtime were MIT licensed, although the GPL'd code present\nin the GCC runtime meant that the combined work had to remain under the GPL.\n\nSince then, all of the GCC code has been removed, leaving the remaining files\nall MIT licensed, and allowing the entire work to be MIT licensed.  \n\nThe exception handling code uses a header file implementing the generic parts\nof the Itanium EH ABI.  This file comes from PathScale's libcxxrt.  PathScale\nkindly allowed it to be MIT licensed for inclusion here.\n\nVarious parts of Windows support were contributed by the WinObjC team at\nMicrosoft.\n\nType-Dependent Dispatch\n-----------------------\n\nTraditionally, Objective-C method lookup is done entirely on the name of the\nmethod.  This is problematic when the sender and receiver of the method\ndisagree on the types of a method.  \n\nFor example, consider a trivial case where you have two methods with the same\nname, one taking an integer, the other taking a floating point value.  Both\nwill pass their argument in a register on most platforms, but not the same\nregister.  If the sender thinks it is calling one, but is really calling the\nother, then the receiver will look in the wrong register and use a nonsense\nvalue.  The compiler will often not warn about this.\n\nThis is a relatively benign example, but if the mismatch is between methods\ntaking or returning a structure and those only using scalar arguments and\nreturn then the call frame layout will be so different that the result will be\nstack corruption, possibly leading to security holes.\n\nIf you compile the GNUstep runtime with type-dependent dispatch enabled, then\nsending a message with a typed selector will only ever invoke a method with the\nsame types.  Sending a message with an untyped selector will invoke any method\nwith a matching name, although the slot returned from the lookup function will\ncontain the types, allowing the caller to check them and construct a valid call\nframe, if required.\n\nIf a lookup with a typed selector matches a method with the wrong types, the\nruntime will call a handler.  This handler, by default, prints a helpful\nmessage and exits.  LanguageKit provides an alternative version which\ndynamically generates a new method performing the required boxing and calling\nthe original."
}
