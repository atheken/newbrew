{
  "name": "libnfs",
  "full_name": "libnfs",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "C client library for NFS",
  "license": "LGPL-2.1-or-later",
  "homepage": "https://github.com/sahlberg/libnfs",
  "versions": {
    "stable": "5.0.2",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/sahlberg/libnfs/archive/libnfs-5.0.2.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "637e56643b19da9fba98f06847788c4dad308b723156a64748041035dcdf9bd3"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libnfs/blobs/sha256:a1a8014854317d7d2cb77e7bdef425ea9ca5555dd0f1ada88326afe6dda189fb",
          "sha256": "a1a8014854317d7d2cb77e7bdef425ea9ca5555dd0f1ada88326afe6dda189fb"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libnfs/blobs/sha256:b8df8747861411e30845ca1a6ab42877c74d8ca3e65c838b5ad498faa6609481",
          "sha256": "b8df8747861411e30845ca1a6ab42877c74d8ca3e65c838b5ad498faa6609481"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libnfs/blobs/sha256:df45a5d53a8ddd243d7702fbbd834607db180679dd694eb9ef91bf14f1a399f2",
          "sha256": "df45a5d53a8ddd243d7702fbbd834607db180679dd694eb9ef91bf14f1a399f2"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libnfs/blobs/sha256:586c605f631aefc3ebfaca7f45dace462b7fbcf813a0e9e16992727b4d996f5e",
          "sha256": "586c605f631aefc3ebfaca7f45dace462b7fbcf813a0e9e16992727b4d996f5e"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libnfs/blobs/sha256:af2b41b3437f4e5e5ead13ff3f3c4fb8cea0aa69813a56199e4d7b0547b6a7bd",
          "sha256": "af2b41b3437f4e5e5ead13ff3f3c4fb8cea0aa69813a56199e4d7b0547b6a7bd"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libnfs/blobs/sha256:c4fd271ca3189c9fe0509bd7637f6d8c4b9974f47db586de2deb0893bbb4cf68",
          "sha256": "c4fd271ca3189c9fe0509bd7637f6d8c4b9974f47db586de2deb0893bbb4cf68"
        },
        "catalina": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libnfs/blobs/sha256:e188d926e1a762f20c892a5b9202de9c42e2221bc35899a22f5c6a064dac1dd1",
          "sha256": "e188d926e1a762f20c892a5b9202de9c42e2221bc35899a22f5c6a064dac1dd1"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/libnfs/blobs/sha256:e778214a1e42d82af233ca4ff61fb2cfec684bd9e610c26fc6152e600efd6830",
          "sha256": "e778214a1e42d82af233ca4ff61fb2cfec684bd9e610c26fc6152e600efd6830"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "autoconf",
    "automake",
    "libtool"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/libnfs.rb",
  "ruby_source_checksum": {
    "sha256": "c245dbbb7c4e0e5cd44a4350ff8a388f1e52c9ce70d47d0a50ed8074c48adb59"
  },
  "date_added": "2015-05-28T21:12:18+01:00",
  "readme": "NOTE\nThe master branch is currently in maintenance only.\nNew developments are now happening in the libnfs-next-gen branch.\nThat branch now supports zero-copy reads which will greatly improve\nperformance on read-intensive workloads as it eliminates the memcpy()\n\nThose changes required a change to the API and since changing the read\nAPI will basically break the API for virtually all applications I\ndecided to proceed to do all other API breaking changes that libnfs needed\nas well.\nIncluding changing the function signature for all raw RPC function which now\nallows applications to cancel commands that are in flight.\n\nPlease consider using libnfs-next-gen for new projects going forward.\nThis branch may be merged back into libnfs in a new major version of the\nlibrary or it may become a separate project.\n=======\n\n\nLIBNFS is a client library for accessing NFS shares over a network.\n\nLIBNFS offers three different APIs, for different use :\n1, RAW : A fully async low level RPC library for NFS protocols\nThis API is described in include/libnfs-raw.h\nit offers a fully async interface to raw XDR encoded blobs.\nThis API provides very flexible and precise control of the RPC issued.\n\nexamples/nfsclient-raw.c provides examples on how to use the raw API\n\n2, NFS ASYNC : A fully asynchronous library for high level vfs functions\nThis API is described by the *_async() functions in include/libnfs.h.\nThis API provides a fully async access to posix vfs like functions such as\nstat(), read(), ...\n\nexamples/nfsclient-async.c provides examples on how to use this API\n\n\n3, NFS SYNC : A synchronous library for high level vfs functions\nThis API is described by the *_sync() functions in include/libnfs.h.\nThis API provides access to posix vfs like functions such as\nstat(), read(), ...\n\nexamples/nfsclient-sync.c provides examples on how to use this API\n\nNFSv4:\n======\nNFSv3 is the default but NFSv4 can be selected either by using the URL argument\nversion=4 or programatically calling nfs_set_version(nfs, NFS_V4) before\nconnecting to the server/share.\n\nSERVER SUPPORT:\n===============\nLibnfs supports building RPC servers.\nExamples/portmapper-server.c is a small \"portmapper\" example written using\nlibnfs.\n\nURL-FORMAT:\n===========\nLibnfs uses RFC2224 style URLs extended with some minor libnfs extensions.\nThe basic syntax of these URLs is :\n\nnfs://<server|ipv4|ipv6>[:<port>]/path[?arg=val[&arg=val]*]\n\nSpecial characters in 'path' are escaped using %-hex-hex syntax.\n\nFor example '?' must be escaped if it occurs in a path as '?' is also used to\nseparate the path from the optional list of url arguments.\n\nExample:\nnfs://127.0.0.1/my?path/?version=4\nmust be escaped as\nnfs://127.0.0.1/my%3Fpath/?version=4\n\nArguments supported by libnfs are :\n tcp-syncnt=<int>  : Number of SYNs to send during the session establish\n                     before failing setting up the tcp connection to the\n                     server.\n uid=<int>         : UID value to use when talking to the server.\n                     default it 65534 on Windows and getuid() on unixen.\n gid=<int>         : GID value to use when talking to the server.\n                     default it 65534 on Windows and getgid() on unixen.\n readahead=<int>   : Enable readahead for files and set the maximum amount\n                     of readahead to <int> bytes.\n auto-traverse-mounts=<0|1>\n                   : Should libnfs try to traverse across nested mounts\n                     automatically or not. Default is 1 == enabled.\n dircache=<0|1>    : Disable/enable directory caching. Enabled by default.\n autoreconnect=<-1|0|>=1>\n                   : Control the auto-reconnect behaviour to the NFS session.\n                    -1 : Try to reconnect forever on session failures.\n                         Just like normal NFS clients do.\n                     0 : Disable auto-reconnect completely and immediately\n                         return a failure to the application.\n                   >=1 : Retry to connect back to the server this many\n                         times before failing and returing an error back\n                         to the application.\n if=<interface>    : Interface name (e.g., eth1) to bind; requires `root`\n version=<3|4>     : NFS Version. Default is 3.\n nfsport=<port>    : Use this port for NFS instead of using the portmapper.\n mountport=<port>  : Use this port for the MOUNT protocol instead of\n                     using portmapper. This argument is ignored for NFSv4\n                     as it does not use the MOUNT protocol.\n readdir-buffer=<count> | readdir-buffer=<dircount>,<maxcount>\n                   : Set the buffer size for READDIRPLUS, where dircount is\n                     the maximum amount of bytes the server should use to\n                     retrieve the entry names and maxcount is the maximum\n                     size of the response buffer (including attributes).\n                     If only one <count> is given it will be used for both.\n                     Default is 8192 for both.\n\nAuto_traverse_mounts\n====================\nNormally in NFSv3 if a server has nested exports, for example if it would\nexport both /data and /data/tmp then a client would need to mount\nboth these exports as well.\nThe reason is because the NFSv3 protocol does not allow a client request\nto return data for an object in a different filesystem/mount.\n(legacy, but it is what it is. One reason for this restriction is to\nguarantee that inodes are unique across the mounted system.)\n\nThis option, when enabled, will make libnfs perform all these mounts\ninternally for you. This means that one libnfs mount may now have files\nwith duplicate inode values so if you cache files based on inode\nmake sure you cache files based on BOTH st.st_ino and st.st_dev.\n\n\nROOT vs NON-ROOT\n================\nWhen running as root, libnfs tries to allocate a system port for its connection\nto the NFS server. When running as non-root it will use a normal\nephemeral port.\nMany NFS servers default to a mode where they do not allow non-system\nports from connecting.\nThese servers require you use the \"insecure\" export option in /etc/exports\nin order to allow libnfs clients to be able to connect.\n\nOn Linux we can get around this restriction by setting the NET_BIND_SERVICE\ncapability for the application binary.\n\nThis is set up by running\n    sudo setcap 'cap_net_bind_service=+ep' /path/to/executable\nThis capability allows the binary to use systems ports like this even when\nnot running as root. Thus if you set this capability for your application\nyou no longer need to edit the export on the NFS server to set \"insecure\".\n\n\nI do not know what equivalent \"capability\" support is available on other\nplatforms. Please drop me an email if your os of choice has something similar\nand I can add it to the README.\n\n\nDOCUMENTATION\n=============\nlibnfs sources ship with prebuilt manpage(s) in the doc directory.\nIf you change the manpage sources you need to manually regenerate the new\nmanpages by running\n  cd doc\n  make doc\n\n\nPLATFORM support\n=================\nThis is a truly multiplatform library.\n\nLinux:  - tested with Ubuntu 10.04 - should work with others as well\nCygwin: - tested under 64bit win2k8.\nMacOSX: - tested with SDK 10.4 (under Snow Leopard) - should also work with later SDKs and 64Bit\niOS:    - tested with iOS SDK 4.2 - running on iOS 4.3.x\nFreeBSD:- tested with 8.2\nSolaris\nWindows:- tested on Windows 7 64 and Windows XP 32 using Visual Studio 10 (see README.win32.txt for build instructions)\n        - tested on Windows 7 64 using MingW on Linux to cross-compile (Debian and Ubuntu tested)\nAndroid:- tested with NDK r10e - running on Android 4.4 (should work starting from 2.3.3)\nAROS: - Build with 'make -f aros/Makefile.AROS'\nPlaystation 2: - Build and install with 'cd ps2ee; make -f Makefile.PS2_EE install'\nPlayStation 3: - Build and install the library with 'make -f ps3_ppu/Makefile.PS3_PPU install'\n\n\nLD_PRELOAD\n==========\nexamples/ld_nfs.c contains a LD_PRELOADable module that can be used to make\nseveral standard utilities nfs aware.\nIt is still very incomplete but can be used for basic things such as cat and cp.\nPatches to add more coverage is welcome.\n\nCompile with :\ngcc -fPIC -shared -o ld_nfs.so examples/ld_nfs.c -ldl -lnfs\n\nThen try things like\nLD_NFS_DEBUG=9 LD_PRELOAD=./ld_nfs.so cat nfs://127.0.0.1//data/tmp/foo123\n\nLD_NFS_DEBUG=9 LD_PRELOAD=./ld_nfs.so cp nfs://127.0.0.1//data/tmp/foo123 nfs://127.0.0.1//data/tmp/foo123.copy\n\nLD_NFS_UID and LD_NFS_GID can be used to fake the uid and the gid in the nfs context.\nThis can be useful on \"insecure\" enabled NFS share to make the server trust you as a root.\nYou can try to run as a normal user things like :\nLD_NFS_DEBUG=9 LD_NFS_UID=0 LD_NFS_GID=0 LD_PRELOAD=./ld_nfs.so chown root:root nfs://127.0.0.1//data/tmp/foo123\n\nThis is just a toy preload module. Don't open bugs if it does not work. Send\npatches to make it better instead.\n\n\nRELEASE TARBALLS\n================\nRelease tarballs are available at\nhttps://sites.google.com/site/libnfstarballs/li\n\n\n\nMAILING LIST\n============\nA libnfs mailing list is available at http://groups.google.com/group/libnfs\nAnnouncements of new versions of libnfs will be posted to this list."
}
