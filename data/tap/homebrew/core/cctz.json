{
  "name": "cctz",
  "full_name": "cctz",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "C++ library for translating between absolute and civil times",
  "license": "Apache-2.0",
  "homepage": "https://github.com/google/cctz",
  "versions": {
    "stable": "2.3",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/google/cctz/archive/v2.3.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "8615b20d4e33e02a271c3b93a3b208e3d7d5d66880f5f6208b03426e448f32db"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/cctz/blobs/sha256:72f87dc452212bdf12aefe25c5ae745d15a6df0b5161919c3c01bcac29a39477",
          "sha256": "72f87dc452212bdf12aefe25c5ae745d15a6df0b5161919c3c01bcac29a39477"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/cctz/blobs/sha256:756dc7625a50e7e2e607a45c75fa7f2002fc7e8bcec504ddcb06eab20766948d",
          "sha256": "756dc7625a50e7e2e607a45c75fa7f2002fc7e8bcec504ddcb06eab20766948d"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/cctz/blobs/sha256:4895638a03396673d972613bed298d7288d369fe91aca165ddcf9b0357aade18",
          "sha256": "4895638a03396673d972613bed298d7288d369fe91aca165ddcf9b0357aade18"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/cctz/blobs/sha256:347a197be8fddb79983086f3a54fc3f7adda08b00cf926bb7596b1f71f898ea2",
          "sha256": "347a197be8fddb79983086f3a54fc3f7adda08b00cf926bb7596b1f71f898ea2"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/cctz/blobs/sha256:ee512d1b222211307cfc2f3e5e6c4ce33085ec79bb0a25aec62ce16cca13fd7f",
          "sha256": "ee512d1b222211307cfc2f3e5e6c4ce33085ec79bb0a25aec62ce16cca13fd7f"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/cctz/blobs/sha256:b0796719cf068ae526435e86922477820dedd3afd5a9044fd099fe3ff6c90765",
          "sha256": "b0796719cf068ae526435e86922477820dedd3afd5a9044fd099fe3ff6c90765"
        },
        "catalina": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/cctz/blobs/sha256:3a73ab9d2f67020d95657e8c5b32a26d7eb81987cee2eace2b9d26eab2621bbb",
          "sha256": "3a73ab9d2f67020d95657e8c5b32a26d7eb81987cee2eace2b9d26eab2621bbb"
        },
        "mojave": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/cctz/blobs/sha256:439ce8e6d464aa64aadd117e3effba68379883c3013de4944dda1def4127ff7d",
          "sha256": "439ce8e6d464aa64aadd117e3effba68379883c3013de4944dda1def4127ff7d"
        },
        "high_sierra": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/cctz/blobs/sha256:2d61f3555630f98a572971867d5da46212712eb30a18bb6545f9067369865c33",
          "sha256": "2d61f3555630f98a572971867d5da46212712eb30a18bb6545f9067369865c33"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/cctz/blobs/sha256:59dffb99b033ab3a17ae375e4b2e66cf3bd9e403b88b58611cbe994155d33c44",
          "sha256": "59dffb99b033ab3a17ae375e4b2e66cf3bd9e403b88b58611cbe994155d33c44"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/cctz.rb",
  "ruby_source_checksum": {
    "sha256": "a511e62a812d749cfba599f0a0eec9a8e76ec7df6c672fc58ddc227d6b445a0d"
  },
  "date_added": "2020-02-06T08:38:36-05:00",
  "readme": "This is not an official Google product.\n\n# Overview\n\nCCTZ contains two libraries that cooperate with `<chrono>` to give C++\nprogrammers all the necessary tools for computing with dates, times, and time\nzones in a simple and correct manner. The libraries in CCTZ are:\n\n*   **The Civil-Time Library** &mdash; This is a header-only library that\n    supports computing with human-scale time, such as dates (which are\n    represented by the `cctz::civil_day` class). This library is declared in\n    [`include/cctz/civil_time.h`](https://github.com/google/cctz/blob/master/include/cctz/civil_time.h).\n*   **The Time-Zone Library** &mdash; This library uses the IANA time zone\n    database that is installed on the system to convert between *absolute time*\n    and *civil time*. This library is declared in\n    [`include/cctz/time_zone.h`](https://github.com/google/cctz/blob/master/include/cctz/time_zone.h).\n\nThese libraries are currently known to work on **Linux**, **Mac OS X**, and\n**Android**.\n\nThey will also work on **Windows** if you install the zoneinfo files. We are\ninterested, though, in an implementation of the cctz::TimeZoneIf interface that\ncalls the Windows time APIs instead. Please contact us if you're interested in\ncontributing.\n\n# Getting Started\n\nCCTZ is best built and tested using the [Bazel](https://bazel.io) build system\nand the [Google Test](https://github.com/google/googletest) framework. (There is\nalso a simple [`Makefile`](https://github.com/google/cctz/blob/master/Makefile)\nand a\n[`CMakeLists.txt`](https://github.com/google/cctz/blob/master/CMakeLists.txt)\nthat should work if you're unable to use Bazel.)\n\n1.  Download/install\n    [Bazel](https://docs.bazel.build/versions/master/install.html)\n2.  Get the cctz source: `git clone https://github.com/google/cctz.git` then `cd\n    cctz`\n3.  Build cctz and run the tests: `bazel test :all`\n\nWith CMake:\n\n1.  Make sure you have CMake >= 2.8.12 installed.\n2.  Get the cctz source: `git clone https://github.com/google/cctz.git` then `cd\n    cctz`.\n3.  Build cctz so that is can be used by shared libraries and run the tests (use\n    `-DBUILD_TESTING=OFF` to skip the tests):\n\n        mkdir mybuild\n        cd mybuild\n        cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_POSITION_INDEPENDENT_CODE=ON ..\n        cmake --build . --config Release\n        ctest\n        cmake --build . --config Release --target install\n\n4.  Use in your CMake-based project with:\n\n    ```cmake\n    find_package(cctz REQUIRED)\n    add_executable(mytarget file.cc)\n    target_link_libraries(mytarget cctz::cctz)\n    ```\n\nNote: When using CCTZ in your own project, you might find it easiest to compile\nthe sources using your existing build system.\n\nNext Steps:\n\n1.  See the documentation for the libraries in CCTZ:\n    *   Civil Time:\n        [`include/cctz/civil_time.h`](https://github.com/google/cctz/blob/master/include/cctz/civil_time.h)\n    *   Time Zone:\n        [`include/cctz/time_zone.h`](https://github.com/google/cctz/blob/master/include/cctz/time_zone.h)\n2.  Look at the examples in https://github.com/google/cctz/tree/master/examples\n3.  Join our mailing list to ask questions and keep informed of changes:\n    *   https://groups.google.com/forum/#!forum/cctz\n\n# Fundamental Concepts\n\n*[The concepts presented here describe general truths about the problem domain\nand are library and language agnostic. An understanding of these concepts helps\nthe programmer correctly reason about even the most-complicated time-programming\nchallenges and produce the simplest possible solutions.]*\n\nThere are two main ways to think about time in a computer program: as *absolute\ntime*, and as *civil time*. Both have their uses and it is important to\nunderstand when each is appropriate. Absolute and civil times may be converted\nback and forth using a *time zone* &mdash; this is the only way to correctly\nconvert between them. Let us now look more deeply at the three main concepts of\ntime programming: Absolute Time, Civil Time, and Time Zone.\n\n*Absolute time* uniquely and universally represents a specific instant in time.\nIt has no notion of calendars, or dates, or times of day. Instead, it is a\nmeasure of the passage of real time, typically as a simple count of ticks since\nsome epoch. Absolute times are independent of all time zones and do not suffer\nfrom human-imposed complexities such as daylight-saving time (DST). Many C++\ntypes exist to represent absolute times, classically `time_t` and more recently\n`std::chrono::time_point`.\n\n*Civil time* is the legally recognized representation of time for ordinary\naffairs (cf. https://www.merriam-webster.com/dictionary/civil). It is a\nhuman-scale representation of time that consists of the six fields &mdash; year,\nmonth, day, hour, minute, and second (sometimes shortened to \"YMDHMS\") &mdash;\nand it follows the rules of the Proleptic Gregorian Calendar, with 24-hour days\ndivided into 60-minute hours and 60-second minutes. Like absolute times, civil\ntimes are also independent of all time zones and their related complexities\n(e.g., DST). While `std::tm` contains the six civil-time fields (YMDHMS), plus a\nfew more, it does not have behavior to enforce the rules of civil time.\n\n*Time zones* are geo-political regions within which human-defined rules are\nshared to convert between the absolute-time and civil-time domains. A time\nzone's rules include things like the region's offset from the UTC time standard,\ndaylight-saving adjustments, and short abbreviation strings. Time zones often\nhave a history of disparate rules that apply only for certain periods, because\nthe rules may change at the whim of a region's local government. For this\nreason, time-zone rules are usually compiled into data snapshots that are used\nat runtime to perform conversions between absolute and civil times. There is\ncurrently no C++ standard library supporting arbitrary time zones.\n\nIn order for programmers to reason about and program applications that correctly\ndeal with these concepts, they must have a library that correctly implements the\nabove concepts. CCTZ adds to the existing C++11 `<chrono>` library to fully\nimplement the above concepts.\n\n*   Absolute time &mdash; This is implemented by the existing C++11\n    [`<chrono>`](https://en.cppreference.com/w/cpp/chrono) library without\n    modification. For example, an absolute point in time is represented by a\n    `std::chrono::time_point`.\n*   Civil time &mdash; This is implemented by the\n    [`include/cctz/civil_time.h`](https://github.com/google/cctz/blob/master/include/cctz/civil_time.h)\n    library that is provided as part of CCTZ. For example, a \"date\" is\n    represented by a `cctz::civil_day`.\n*   Time zone &mdash; This is implemented by the\n    [`include/cctz/time_zone.h`](https://github.com/google/cctz/blob/master/include/cctz/time_zone.h)\n    library that is provided as part of CCTZ. For example, a time zone is\n    represented by an instance of the class `cctz::time_zone`.\n\n# Examples\n\n## Hello February 2016\n\nThis \"hello world\" example uses a for-loop to iterate the days from the first of\nFebruary until the month of March. Each day is streamed to output, and if the\nday happens to be the 29th, we also output the day of the week.\n\n```\n#include <iostream>\n#include \"cctz/civil_time.h\"\n\nint main() {\n  for (cctz::civil_day d(2016, 2, 1); d < cctz::civil_month(2016, 3); ++d) {\n    std::cout << \"Hello \" << d;\n    if (d.day() == 29) {\n      std::cout << \" <- leap day is a \" << cctz::get_weekday(d);\n    }\n    std::cout << \"\\n\";\n  }\n}\n```\n\nThe output of the above program is\n\n```\nHello 2016-02-01\nHello 2016-02-02\nHello 2016-02-03\n[...]\nHello 2016-02-27\nHello 2016-02-28\nHello 2016-02-29 <- leap day is a Monday\n```\n\n## One giant leap\n\nThis example shows how to use all three libraries (`<chrono>`, civil time, and\ntime zone) together. In this example, we know that viewers in New York watched\nNeil Armstrong's first walk on the moon on July 20, 1969 at 10:56 PM. But we'd\nlike to see what time it was for our friend watching in Sydney, Australia.\n\n```\n#include <iostream>\n#include \"cctz/civil_time.h\"\n#include \"cctz/time_zone.h\"\n\nint main() {\n  cctz::time_zone nyc;\n  cctz::load_time_zone(\"America/New_York\", &nyc);\n\n  // Converts the input civil time in NYC to an absolute time.\n  const auto moon_walk =\n    cctz::convert(cctz::civil_second(1969, 7, 20, 22, 56, 0), nyc);\n\n  std::cout << \"Moon walk in NYC: \"\n            << cctz::format(\"%Y-%m-%d %H:%M:%S %Ez\\n\", moon_walk, nyc);\n\n  cctz::time_zone syd;\n  if (!cctz::load_time_zone(\"Australia/Sydney\", &syd)) return -1;\n  std::cout << \"Moon walk in SYD: \"\n            << cctz::format(\"%Y-%m-%d %H:%M:%S %Ez\\n\", moon_walk, syd);\n}\n```\n\nThe output of the above program is\n\n```\nMoon walk in NYC: 1969-07-20 22:56:00 -04:00\nMoon walk in SYD: 1969-07-21 12:56:00 +10:00\n```\n\nThis example shows that the absolute time (the `std::chrono::time_point`) of the\nfirst walk on the moon is the same no matter the time zone of the viewer (the\nsame time point is used in both calls to `format()`). The only difference is the\ntime zone in which the `moon_walk` time point is rendered. And in this case we\ncan see that our friend in Sydney was probably eating lunch while watching that\nhistoric event.\n\n# References\n\n*   CCTZ [FAQ](https://github.com/google/cctz/wiki/FAQ)\n*   See also the [Time Programming Fundamentals](https://youtu.be/2rnIHsqABfM)\n    talk from CppCon 2015 ([slides available here](https://goo.gl/ofof4N)). This\n    talk mostly describes the older CCTZ v1 API, but the *concepts* are the\n    same.\n*   ISO C++ proposal to standardize the Civil-Time Library:\n    https://github.com/devjgm/papers/blob/master/d0215r1.md\n*   ISO C++ proposal to standardize the Time-Zone Library:\n    https://github.com/devjgm/papers/blob/master/d0216r1.md"
}
