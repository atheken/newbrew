{
  "name": "utf8cpp",
  "full_name": "utf8cpp",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "UTF-8 with C++ in a Portable Way",
  "license": "BSL-1.0",
  "homepage": "https://github.com/nemtrif/utfcpp",
  "versions": {
    "stable": "3.2.3",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/nemtrif/utfcpp/archive/v3.2.3.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "3ba9b0dbbff08767bdffe8f03b10e596ca351228862722e4c9d4d126d2865250"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "all": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/utf8cpp/blobs/sha256:c8b82f1b5ab9d42d52df6ea117c78381bf3ff62b44e417901b0e5942ca32ff10",
          "sha256": "c8b82f1b5ab9d42d52df6ea117c78381bf3ff62b44e417901b0e5942ca32ff10"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake"
  ],
  "dependencies": [],
  "test_dependencies": [
    "cmake"
  ],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "aa66a84309b297ea296f7a4b9c424b5c0ec4875c",
  "ruby_source_path": "Formula/utf8cpp.rb",
  "ruby_source_checksum": {
    "sha256": "a87a887076024902263b88f5987b261d744f2b31bb001a9b73d95d7f68d23737"
  },
  "date_added": "2020-11-18T17:06:26+00:00",
  "readme": "# UTF8-CPP: UTF-8 with C++ in a Portable Way\n\n\n## Introduction\n\nC++ developers miss an easy and portable way of handling Unicode encoded strings. The original C++ Standard (known as C++98 or C++03) is Unicode agnostic. C++11 provides some support for Unicode on core language and library level: u8, u, and U character and string literals, char16_t and char32_t character types, u16string and u32string library classes, and codecvt support for conversions between Unicode encoding forms. In the meantime, developers use third party libraries like ICU, OS specific capabilities, or simply roll out their own solutions.\n\nIn order to easily handle UTF-8 encoded Unicode strings, I came up with a small, C++98 compatible generic library. For anybody used to work with STL algorithms and iterators, it should be easy and natural to use. The code is freely available for any purpose - check out the [license](./LICENSE). The library has been used a lot in the past ten years both in commercial and open-source projects and is considered feature-complete now. If you run into bugs or performance issues, please let me know and I'll do my best to address them.\n\nThe purpose of this article is not to offer an introduction to Unicode in general, and UTF-8 in particular. If you are not familiar with Unicode, be sure to check out [Unicode Home Page](http://www.unicode.org/) or some other source of information for Unicode. Also, it is not my aim to advocate the use of UTF-8 encoded strings in C++ programs; if you want to handle UTF-8 encoded strings from C++, I am sure you have good reasons for it.\n\n## Examples of use\n\n### Introductory Sample\n\nTo illustrate the use of the library, let's start with a small but complete program that opens a file containing UTF-8 encoded text, reads it line by line, checks each line for invalid UTF-8 byte sequences, and converts it to UTF-16 encoding and back to UTF-8:\n\n```cpp\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n#include \"utf8.h\"\nusing namespace std;\nint main(int argc, char** argv)\n{\n    if (argc != 2) {\n        cout << \"\\nUsage: docsample filename\\n\";\n        return 0;\n    }\n    const char* test_file_path = argv[1];\n    // Open the test file (must be UTF-8 encoded)\n    ifstream fs8(test_file_path);\n    if (!fs8.is_open()) {\n        cout << \"Could not open \" << test_file_path << endl;\n        return 0;\n    }\n\n    unsigned line_count = 1;\n    string line;\n    // Play with all the lines in the file\n    while (getline(fs8, line)) {\n        // check for invalid utf-8 (for a simple yes/no check, there is also utf8::is_valid function)\n#if __cplusplus >= 201103L // C++ 11 or later\n        auto end_it = utf8::find_invalid(line.begin(), line.end());\n#else\n        string::iterator end_it = utf8::find_invalid(line.begin(), line.end());\n#endif // C++ 11\n        if (end_it != line.end()) {\n            cout << \"Invalid UTF-8 encoding detected at line \" << line_count << \"\\n\";\n            cout << \"This part is fine: \" << string(line.begin(), end_it) << \"\\n\";\n        }\n        // Get the line length (at least for the valid part)\n        int length = utf8::distance(line.begin(), end_it);\n        cout << \"Length of line \" << line_count << \" is \" << length <<  \"\\n\";\n\n        // Convert it to utf-16\n#if __cplusplus >= 201103L // C++ 11 or later\n        u16string utf16line = utf8::utf8to16(line);\n#else\n        vector<unsigned short> utf16line;\n        utf8::utf8to16(line.begin(), end_it, back_inserter(utf16line));\n#endif // C++ 11\n        // And back to utf-8;\n#if __cplusplus >= 201103L // C++ 11 or later\n        string utf8line = utf8::utf16to8(utf16line);\n#else\n        string utf8line; \n        utf8::utf16to8(utf16line.begin(), utf16line.end(), back_inserter(utf8line));\n#endif // C++ 11\n        // Confirm that the conversion went OK:\n        if (utf8line != string(line.begin(), end_it))\n            cout << \"Error in UTF-16 conversion at line: \" << line_count << \"\\n\";        \n\n        line_count++;\n    } \n\n    return 0;\n}\n```\n\nIn the previous code sample, for each line we performed a detection of invalid UTF-8 sequences with `find_invalid`; the number of characters (more precisely - the number of Unicode code points, including the end of line and even BOM if there is one) in each line was determined with a use of `utf8::distance`; finally, we have converted each line to UTF-16 encoding with `utf8to16` and back to UTF-8 with `utf16to8`.\n\nNote a different pattern of usage for old compilers. For instance, this is how we convert\na UTF-8 encoded string to a UTF-16 encoded one with a pre - C++11 compiler:\n```cpp\n    vector<unsigned short> utf16line;\n    utf8::utf8to16(line.begin(), end_it, back_inserter(utf16line));\n```\n\nWith a more modern compiler, the same operation would look like:\n```cpp\n    u16string utf16line = utf8::utf8to16(line);\n```\nIf `__cplusplus` macro points to a C++ 11 or later, the library exposes API that takes into \naccount C++ standard Unicode strings and move semantics. With an older compiler, it is still\npossible to use the same functionality, just in a little less convenient way\n\nIn case you do not trust the `__cplusplus` macro or, for instance, do not want to include\nthe C++ 11 helper functions even with a modern compiler, define `UTF_CPP_CPLUSPLUS` macro\nbefore including `utf8.h` and assign it a value for the standard you want to use - the values are the same as for the `__cplusplus` macro. This can be also useful with compilers that are conservative in setting the `__cplusplus` macro even if they have a good support for a recent standard edition - Microsoft's Visual C++ is one example.\n\n### Checking if a file contains valid UTF-8 text\n\nHere is a function that checks whether the content of a file is valid UTF-8 encoded text without reading the content into the memory:\n\n```cpp\nbool valid_utf8_file(const char* file_name)\n{\n    ifstream ifs(file_name);\n    if (!ifs)\n        return false; // even better, throw here\n\n    istreambuf_iterator<char> it(ifs.rdbuf());\n    istreambuf_iterator<char> eos;\n\n    return utf8::is_valid(it, eos);\n}\n```\n\nBecause the function `utf8::is_valid()` works with input iterators, we were able to pass an `istreambuf_iterator` to `it` and read the content of the file directly without loading it to the memory first.\n\nNote that other functions that take input iterator arguments can be used in a similar way. For instance, to read the content of a UTF-8 encoded text file and convert the text to UTF-16, just do something like:\n\n```cpp\n    utf8::utf8to16(it, eos, back_inserter(u16string));\n```\n\n### Ensure that a string contains valid UTF-8 text\n\nIf we have some text that \"probably\" contains UTF-8 encoded text and we want to replace any invalid UTF-8 sequence with a replacement character, something like the following function may be used:\n\n```cpp\nvoid fix_utf8_string(std::string& str)\n{\n    std::string temp;\n    utf8::replace_invalid(str.begin(), str.end(), back_inserter(temp));\n    str = temp;\n}\n```\n\nThe function will replace any invalid UTF-8 sequence with a Unicode replacement character. There is an overloaded function that enables the caller to supply their own replacement character.\n\n\n## Points of interest\n\n#### Design goals and decisions\n\nThe library was designed to be:\n\n1.  Generic: for better or worse, there are many C++ string classes out there, and the library should work with as many of them as possible.\n2.  Portable: the library should be portable both across different platforms and compilers. The only non-portable code is a small section that declares unsigned integers of different sizes: three typedefs. They can be changed by the users of the library if they don't match their platform. The default setting should work for Windows (both 32 and 64 bit), and most 32 bit and 64 bit Unix derivatives. Support for post C++03 language features is included for modern compilers at API level only, so the library should work even with pretty old compilers.\n3.  Lightweight: follow the \"pay only for what you use\" guideline.\n4.  Unintrusive: avoid forcing any particular design or even programming style on the user. This is a library, not a framework.\n\n#### Alternatives\n\nIn case you want to look into other means of working with UTF-8 strings from C++, here is the list of solutions I am aware of:\n\n1.  [ICU Library](http://icu.sourceforge.net/). It is very powerful, complete, feature-rich, mature, and widely used. Also big, intrusive, non-generic, and doesn't play well with the Standard Library. I definitely recommend looking at ICU even if you don't plan to use it.\n2.  C++11 language and library features. Still far from complete, and not easy to use.\n3.  [Glib::ustring](http://www.gtkmm.org/gtkmm2/docs/tutorial/html/ch03s04.html). A class specifically made to work with UTF-8 strings, and also feel like `std::string`. If you prefer to have yet another string class in your code, it may be worth a look. Be aware of the licensing issues, though.\n4.  Platform dependent solutions: Windows and POSIX have functions to convert strings from one encoding to another. That is only a subset of what my library offers, but if that is all you need it may be good enough.\n\n\n## Reference\n\n### Functions From utf8 Namespace\n\n#### utf8::append\n\nAvailable in version 3.0 and later. Requires a C++ 11 compliant compiler.\n\nEncodes a 32 bit code point as a UTF-8 sequence of octets and appends the sequence to a UTF-8 string.\n\n```cpp\nvoid append(char32_t cp, std::string& s);\n```\n\n`cp`: a code point to append to the string.  \n`s`: a utf-8 encoded string to append the code point to.  \n\nExample of use:\n\n```cpp\nstd::string u;\nappend(0x0448, u);\nassert (u[0] == char(0xd1) && u[1] == char(0x88) && u.length() == 2);\n```\n\nIn case of an invalid code point, a `utf8::invalid_code_point` exception is thrown.\n\n\n#### utf8::append\n\nAvailable in version 1.0 and later.\n\nEncodes a 32 bit code point as a UTF-8 sequence of octets and appends the sequence to a UTF-8 string.\n\n```cpp\ntemplate <typename octet_iterator>\noctet_iterator append(uint32_t cp, octet_iterator result);\n```\n\n`octet_iterator`: an output iterator.  \n`cp`: a 32 bit integer representing a code point to append to the sequence.  \n`result`: an output iterator to the place in the sequence where to append the code point.  \nReturn value: an iterator pointing to the place after the newly appended sequence.\n\nExample of use:\n\n```cpp\nunsigned char u[5] = {0,0,0,0,0};\nunsigned char* end = append(0x0448, u);\nassert (u[0] == 0xd1 && u[1] == 0x88 && u[2] == 0 && u[3] == 0 && u[4] == 0);\n```\n\nNote that `append` does not allocate any memory - it is the burden of the caller to make sure there is enough memory allocated for the operation. To make things more interesting, `append` can add anywhere between 1 and 4 octets to the sequence. In practice, you would most often want to use `std::back_inserter` to ensure that the necessary memory is allocated.\n\nIn case of an invalid code point, a `utf8::invalid_code_point` exception is thrown.\n\n#### utf8::next\n\nAvailable in version 1.0 and later.\n\nGiven the iterator to the beginning of the UTF-8 sequence, it returns the code point and moves the iterator to the next position.\n\n```cpp\ntemplate <typename octet_iterator> \nuint32_t next(octet_iterator& it, octet_iterator end);\n```\n\n`octet_iterator`: an input iterator.  \n`it`: a reference to an iterator pointing to the beginning of an UTF-8 encoded code point. After the function returns, it is incremented to point to the beginning of the next code point.  \n`end`: end of the UTF-8 sequence to be processed. If `it` gets equal to `end` during the extraction of a code point, an `utf8::not_enough_room` exception is thrown.  \nReturn value: the 32 bit representation of the processed UTF-8 code point.\n\nExample of use:\n\n```cpp\nchar* twochars = \"\\xe6\\x97\\xa5\\xd1\\x88\";\nchar* w = twochars;\nint cp = next(w, twochars + 6);\nassert (cp == 0x65e5);\nassert (w == twochars + 3);\n```\n\nThis function is typically used to iterate through a UTF-8 encoded string.\n\nIn case of an invalid UTF-8 sequence, a `utf8::invalid_utf8` exception is thrown.\n\n#### utf8::peek_next\n\nAvailable in version 2.1 and later.\n\nGiven the iterator to the beginning of the UTF-8 sequence, it returns the code point for the following sequence without changing the value of the iterator.\n\n```cpp\ntemplate <typename octet_iterator> \nuint32_t peek_next(octet_iterator it, octet_iterator end);\n```\n\n\n`octet_iterator`: an input iterator.  \n`it`: an iterator pointing to the beginning of an UTF-8 encoded code point.  \n`end`: end of the UTF-8 sequence to be processed. If `it` gets equal to `end` during the extraction of a code point, an `utf8::not_enough_room` exception is thrown.  \nReturn value: the 32 bit representation of the processed UTF-8 code point.\n\nExample of use:\n\n```cpp\nchar* twochars = \"\\xe6\\x97\\xa5\\xd1\\x88\";\nchar* w = twochars;\nint cp = peek_next(w, twochars + 6);\nassert (cp == 0x65e5);\nassert (w == twochars);\n```\n\nIn case of an invalid UTF-8 sequence, a `utf8::invalid_utf8` exception is thrown.\n\n#### utf8::prior\n\nAvailable in version 1.02 and later.\n\nGiven a reference to an iterator pointing to an octet in a UTF-8 sequence, it decreases the iterator until it hits the beginning of the previous UTF-8 encoded code point and returns the 32 bits representation of the code point.\n\n```cpp\ntemplate <typename octet_iterator> \nuint32_t prior(octet_iterator& it, octet_iterator start);\n```\n\n`octet_iterator`: a bidirectional iterator.  \n`it`: a reference pointing to an octet within a UTF-8 encoded string. After the function returns, it is decremented to point to the beginning of the previous code point.  \n`start`: an iterator to the beginning of the sequence where the search for the beginning of a code point is performed. It is a safety measure to prevent passing the beginning of the string in the search for a UTF-8 lead octet.  \n Return value: the 32 bit representation of the previous code point.\n\nExample of use:\n\n```cpp\nchar* twochars = \"\\xe6\\x97\\xa5\\xd1\\x88\";\nunsigned char* w = twochars + 3;\nint cp = prior (w, twochars);\nassert (cp == 0x65e5);\nassert (w == twochars);\n```\n\nThis function has two purposes: one is two iterate backwards through a UTF-8 encoded string. Note that it is usually a better idea to iterate forward instead, since `utf8::next` is faster. The second purpose is to find a beginning of a UTF-8 sequence if we have a random position within a string. Note that in that case `utf8::prior` may not detect an invalid UTF-8 sequence in some scenarios: for instance if there are superfluous trail octets, it will just skip them.\n\n`it` will typically point to the beginning of a code point, and `start` will point to the beginning of the string to ensure we don't go backwards too far. `it` is decreased until it points to a lead UTF-8 octet, and then the UTF-8 sequence beginning with that octet is decoded to a 32 bit representation and returned.\n\nIn case `start` is reached before a UTF-8 lead octet is hit, or if an invalid UTF-8 sequence is started by the lead octet, an `invalid_utf8` exception is thrown.\n\nIn case `start` equals `it`, a `not_enough_room` exception is thrown.\n\n#### utf8::advance\nAvailable in version 1.0 and later.\n\nAdvances an iterator by the specified number of code points within an UTF-8 sequence.\n\n```cpp\ntemplate <typename octet_iterator, typename distance_type> \nvoid advance (octet_iterator& it, distance_type n, octet_iterator end);\n```\n\n`octet_iterator`: an input iterator.  \n`distance_type`: an integral type convertible to `octet_iterator`'s difference type.  \n`it`: a reference to an iterator pointing to the beginning of an UTF-8 encoded code point. After the function returns, it is incremented to point to the nth following code point.  \n`n`: number of code points `it` should be advanced. A negative value means decrement.  \n`end`: limit of the UTF-8 sequence to be processed. If `n` is positive and `it` gets equal to `end` during the extraction of a code point, an `utf8::not_enough_room` exception is thrown. If `n` is negative and `it` reaches `end` while `it` points t a trail byte of a UTF-8 sequence, a `utf8::invalid_code_point` exception is thrown.\n\nExample of use:\n\n```cpp\nchar* twochars = \"\\xe6\\x97\\xa5\\xd1\\x88\";\nunsigned char* w = twochars;\nadvance (w, 2, twochars + 6);\nassert (w == twochars + 5);\nadvance (w, -2, twochars);\nassert (w == twochars);\n```\n\nIn case of an invalid code point, a `utf8::invalid_code_point` exception is thrown.\n\n#### utf8::distance\n\nAvailable in version 1.0 and later.\n\nGiven the iterators to two UTF-8 encoded code points in a sequence, returns the number of code points between them.\n\n```cpp\ntemplate <typename octet_iterator> \ntypename std::iterator_traits<octet_iterator>::difference_type distance (octet_iterator first, octet_iterator last);\n```\n\n`octet_iterator`: an input iterator.  \n`first`: an iterator to a beginning of a UTF-8 encoded code point.  \n`last`: an iterator to a \"post-end\" of the last UTF-8 encoded code point in the sequence we are trying to determine the length. It can be the beginning of a new code point, or not.  \n Return value the distance between the iterators, in code points.\n\nExample of use:\n\n```cpp\nchar* twochars = \"\\xe6\\x97\\xa5\\xd1\\x88\";\nsize_t dist = utf8::distance(twochars, twochars + 5);\nassert (dist == 2);\n```\n\nThis function is used to find the length (in code points) of a UTF-8 encoded string. The reason it is called _distance_, rather than, say, _length_ is mainly because developers are used that _length_ is an O(1) function. Computing the length of an UTF-8 string is a linear operation, and it looked better to model it after `std::distance` algorithm.\n\nIn case of an invalid UTF-8 sequence, a `utf8::invalid_utf8` exception is thrown. If `last` does not point to the past-of-end of a UTF-8 sequence, a `utf8::not_enough_room` exception is thrown.\n\n#### utf8::utf16to8\n\nAvailable in version 3.0 and later. Requires a C++ 11 compliant compiler.\n\nConverts a UTF-16 encoded string to UTF-8.\n\n```cpp\nstd::string utf16to8(const std::u16string& s);\n```\n\n`s`: a UTF-16 encoded string.\nReturn value: A UTF-8 encoded string.\n\nExample of use:\n\n```cpp\n    u16string utf16string = {0x41, 0x0448, 0x65e5, 0xd834, 0xdd1e};\n    string u = utf16to8(utf16string);\n    assert (u.size() == 10);\n```\n\nIn case of invalid UTF-16 sequence, a `utf8::invalid_utf16` exception is thrown.\n\n#### utf8::utf16to8\n\nAvailable in version 3.2 and later. Requires a C++ 17 compliant compiler.\n\nConverts a UTF-16 encoded string to UTF-8.\n\n```cpp\nstd::string utf16to8(std::u16string_view s);\n```\n\n`s`: a UTF-16 encoded string.\nReturn value: A UTF-8 encoded string.\n\nExample of use:\n\n```cpp\n    u16string utf16string = {0x41, 0x0448, 0x65e5, 0xd834, 0xdd1e};\n    u16string_view utf16stringview(u16string);\n    string u = utf16to8(utf16string);\n    assert (u.size() == 10);\n```\n\nIn case of invalid UTF-16 sequence, a `utf8::invalid_utf16` exception is thrown.\n\n\n#### utf8::utf16to8\n\nAvailable in version 1.0 and later.\n\nConverts a UTF-16 encoded string to UTF-8.\n\n```cpp\ntemplate <typename u16bit_iterator, typename octet_iterator>\noctet_iterator utf16to8 (u16bit_iterator start, u16bit_iterator end, octet_iterator result);\n```\n\n`u16bit_iterator`: an input iterator.  \n`octet_iterator`: an output iterator.  \n`start`: an iterator pointing to the beginning of the UTF-16 encoded string to convert.  \n`end`: an iterator pointing to pass-the-end of the UTF-16 encoded string to convert.  \n`result`: an output iterator to the place in the UTF-8 string where to append the result of conversion.  \nReturn value: An iterator pointing to the place after the appended UTF-8 string.\n\nExample of use:\n\n```cpp\nunsigned short utf16string[] = {0x41, 0x0448, 0x65e5, 0xd834, 0xdd1e};\nvector<unsigned char> utf8result;\nutf16to8(utf16string, utf16string + 5, back_inserter(utf8result));\nassert (utf8result.size() == 10);    \n```\n\nIn case of invalid UTF-16 sequence, a `utf8::invalid_utf16` exception is thrown.\n\n#### utf8::utf8to16\n\nAvailable in version 3.0 and later. Requires a C++ 11 compliant compiler.\n\nConverts an UTF-8 encoded string to UTF-16.\n\n```cpp\nstd::u16string utf8to16(const std::string& s);\n```\n\n`s`: an UTF-8 encoded string to convert.  \nReturn value: A UTF-16 encoded string\n\nExample of use:\n\n```cpp\nstring utf8_with_surrogates = \"\\xe6\\x97\\xa5\\xd1\\x88\\xf0\\x9d\\x84\\x9e\";\nu16string utf16result = utf8to16(utf8_with_surrogates);\nassert (utf16result.length() == 4);\nassert (utf16result[2] == 0xd834);\nassert (utf16result[3] == 0xdd1e);\n```\n\nIn case of an invalid UTF-8 sequence, a `utf8::invalid_utf8` exception is thrown.\n\n#### utf8::utf8to16\n\nAvailable in version 3.2 and later. Requires a C++ 17 compliant compiler.\n\nConverts an UTF-8 encoded string to UTF-16.\n\n```cpp\nstd::u16string utf8to16(std::string_view s);\n```\n\n`s`: an UTF-8 encoded string to convert.  \nReturn value: A UTF-16 encoded string\n\nExample of use:\n\n```cpp\nstring_view utf8_with_surrogates = \"\\xe6\\x97\\xa5\\xd1\\x88\\xf0\\x9d\\x84\\x9e\";\nu16string utf16result = utf8to16(utf8_with_surrogates);\nassert (utf16result.length() == 4);\nassert (utf16result[2] == 0xd834);\nassert (utf16result[3] == 0xdd1e);\n```\n\nIn case of an invalid UTF-8 sequence, a `utf8::invalid_utf8` exception is thrown.\n\n\n#### utf8::utf8to16\n\nAvailable in version 1.0 and later.\n\nConverts an UTF-8 encoded string to UTF-16\n\n```cpp\ntemplate <typename u16bit_iterator, typename octet_iterator>\nu16bit_iterator utf8to16 (octet_iterator start, octet_iterator end, u16bit_iterator result);\n```\n\n`octet_iterator`: an input iterator.  \n`u16bit_iterator`: an output iterator.  \n`start`: an iterator pointing to the beginning of the UTF-8 encoded string to convert. < br /> `end`: an iterator pointing to pass-the-end of the UTF-8 encoded string to convert.  \n`result`: an output iterator to the place in the UTF-16 string where to append the result of conversion.  \nReturn value: An iterator pointing to the place after the appended UTF-16 string.\n\nExample of use:\n\n```cpp\nchar utf8_with_surrogates[] = \"\\xe6\\x97\\xa5\\xd1\\x88\\xf0\\x9d\\x84\\x9e\";\nvector <unsigned short> utf16result;\nutf8to16(utf8_with_surrogates, utf8_with_surrogates + 9, back_inserter(utf16result));\nassert (utf16result.size() == 4);\nassert (utf16result[2] == 0xd834);\nassert (utf16result[3] == 0xdd1e);\n```\n\nIn case of an invalid UTF-8 sequence, a `utf8::invalid_utf8` exception is thrown. If `end` does not point to the past-of-end of a UTF-8 sequence, a `utf8::not_enough_room` exception is thrown.\n\n#### utf8::utf32to8\n\nAvailable in version 3.0 and later. Requires a C++ 11 compliant compiler.\n\nConverts a UTF-32 encoded string to UTF-8.\n\n```cpp\nstd::string utf32to8(const std::u32string& s);\n```\n\n`s`: a UTF-32 encoded string.  \nReturn value: a UTF-8 encoded string.\n\nExample of use:\n\n```cpp\nu32string utf32string = {0x448, 0x65E5, 0x10346};\nstring utf8result = utf32to8(utf32string);\nassert (utf8result.size() == 9);\n```\n\nIn case of invalid UTF-32 string, a `utf8::invalid_code_point` exception is thrown.\n\n#### utf8::utf32to8\n\nAvailable in version 3.2 and later. Requires a C++ 17 compliant compiler.\n\nConverts a UTF-32 encoded string to UTF-8.\n\n```cpp\nstd::string utf32to8(std::u32string_view s);\n```\n\n`s`: a UTF-32 encoded string.  \nReturn value: a UTF-8 encoded string.\n\nExample of use:\n\n```cpp\nu32string utf32string = {0x448, 0x65E5, 0x10346};\nu32string_view utf32stringview(utf32string);\nstring utf8result = utf32to8(utf32stringview);\nassert (utf8result.size() == 9);\n```\n\nIn case of invalid UTF-32 string, a `utf8::invalid_code_point` exception is thrown.\n\n\n#### utf8::utf32to8\n\nAvailable in version 1.0 and later.\n\nConverts a UTF-32 encoded string to UTF-8.\n\n```cpp\ntemplate <typename octet_iterator, typename u32bit_iterator>\noctet_iterator utf32to8 (u32bit_iterator start, u32bit_iterator end, octet_iterator result);\n```\n\n`octet_iterator`: an output iterator.  \n`u32bit_iterator`: an input iterator.  \n`start`: an iterator pointing to the beginning of the UTF-32 encoded string to convert.  \n`end`: an iterator pointing to pass-the-end of the UTF-32 encoded string to convert.  \n`result`: an output iterator to the place in the UTF-8 string where to append the result of conversion.  \nReturn value: An iterator pointing to the place after the appended UTF-8 string.\n\nExample of use:\n\n```cpp\nint utf32string[] = {0x448, 0x65E5, 0x10346, 0};\nvector<unsigned char> utf8result;\nutf32to8(utf32string, utf32string + 3, back_inserter(utf8result));\nassert (utf8result.size() == 9);\n```\n\nIn case of invalid UTF-32 string, a `utf8::invalid_code_point` exception is thrown.\n\n#### utf8::utf8to32\n\nAvailable in version 3.0 and later. Requires a C++ 11 compliant compiler.\n\nConverts a UTF-8 encoded string to UTF-32.\n\n```cpp\nstd::u32string utf8to32(const std::string& s);\n```\n\n`s`: a UTF-8 encoded string.\nReturn value: a UTF-32 encoded string.\n\nExample of use:\n\n```cpp\nconst char* twochars = \"\\xe6\\x97\\xa5\\xd1\\x88\";\nu32string utf32result = utf8to32(twochars);\nassert (utf32result.size() == 2);\n```\n\nIn case of an invalid UTF-8 sequence, a `utf8::invalid_utf8` exception is thrown.\n\n#### utf8::utf8to32\n\nAvailable in version 3.2 and later. Requires a C++ 17 compliant compiler.\n\nConverts a UTF-8 encoded string to UTF-32.\n\n```cpp\nstd::u32string utf8to32(std::string_view s);\n```\n\n`s`: a UTF-8 encoded string.\nReturn value: a UTF-32 encoded string.\n\nExample of use:\n\n```cpp\nstring_view twochars = \"\\xe6\\x97\\xa5\\xd1\\x88\";\nu32string utf32result = utf8to32(twochars);\nassert (utf32result.size() == 2);\n```\n\nIn case of an invalid UTF-8 sequence, a `utf8::invalid_utf8` exception is thrown.\n\n\n#### utf8::utf8to32\n\nAvailable in version 1.0 and later.\n\nConverts a UTF-8 encoded string to UTF-32.\n\n```cpp\ntemplate <typename octet_iterator, typename u32bit_iterator>\nu32bit_iterator utf8to32 (octet_iterator start, octet_iterator end, u32bit_iterator result);\n```\n\n`octet_iterator`: an input iterator.  \n`u32bit_iterator`: an output iterator.  \n`start`: an iterator pointing to the beginning of the UTF-8 encoded string to convert.  \n`end`: an iterator pointing to pass-the-end of the UTF-8 encoded string to convert.  \n`result`: an output iterator to the place in the UTF-32 string where to append the result of conversion.  \nReturn value: An iterator pointing to the place after the appended UTF-32 string.\n\nExample of use:\n\n```cpp\nchar* twochars = \"\\xe6\\x97\\xa5\\xd1\\x88\";\nvector<int> utf32result;\nutf8to32(twochars, twochars + 5, back_inserter(utf32result));\nassert (utf32result.size() == 2);\n```\n\nIn case of an invalid UTF-8 sequence, a `utf8::invalid_utf8` exception is thrown. If `end` does not point to the past-of-end of a UTF-8 sequence, a `utf8::not_enough_room` exception is thrown.\n\n#### utf8::find_invalid\n\nAvailable in version 3.0 and later. Requires a C++ 11 compliant compiler.\n\nDetects an invalid sequence within a UTF-8 string.\n\n```cpp\nstd::size_t find_invalid(const std::string& s);\n```\n\n`s`: a UTF-8 encoded string.\nReturn value: the index of the first invalid octet in the UTF-8 string. In case none were found, equals `std::string::npos`.\n\nExample of use:\n\n```cpp\nstring utf_invalid = \"\\xe6\\x97\\xa5\\xd1\\x88\\xfa\";\nauto invalid = find_invalid(utf_invalid);\nassert (invalid == 5);\n```\n\nThis function is typically used to make sure a UTF-8 string is valid before processing it with other functions. It is especially important to call it if before doing any of the _unchecked_ operations on it.\n\n#### utf8::find_invalid\n\nAvailable in version 3.2 and later. Requires a C++ 17 compliant compiler.\n\nDetects an invalid sequence within a UTF-8 string.\n\n```cpp\nstd::size_t find_invalid(std::string_view s);\n```\n\n`s`: a UTF-8 encoded string.\nReturn value: the index of the first invalid octet in the UTF-8 string. In case none were found, equals `std::string_view::npos`.\n\nExample of use:\n\n```cpp\nstring_view utf_invalid = \"\\xe6\\x97\\xa5\\xd1\\x88\\xfa\";\nauto invalid = find_invalid(utf_invalid);\nassert (invalid == 5);\n```\n\nThis function is typically used to make sure a UTF-8 string is valid before processing it with other functions. It is especially important to call it if before doing any of the _unchecked_ operations on it.\n\n\n#### utf8::find_invalid\n\nAvailable in version 1.0 and later.\n\nDetects an invalid sequence within a UTF-8 string.\n\n```cpp\ntemplate <typename octet_iterator> \noctet_iterator find_invalid(octet_iterator start, octet_iterator end);\n```\n\n`octet_iterator`: an input iterator.  \n`start`: an iterator pointing to the beginning of the UTF-8 string to test for validity.  \n`end`: an iterator pointing to pass-the-end of the UTF-8 string to test for validity.  \nReturn value: an iterator pointing to the first invalid octet in the UTF-8 string. In case none were found, equals `end`.\n\nExample of use:\n\n```cpp\nchar utf_invalid[] = \"\\xe6\\x97\\xa5\\xd1\\x88\\xfa\";\nchar* invalid = find_invalid(utf_invalid, utf_invalid + 6);\nassert (invalid == utf_invalid + 5);\n```\n\nThis function is typically used to make sure a UTF-8 string is valid before processing it with other functions. It is especially important to call it if before doing any of the _unchecked_ operations on it.\n\n#### utf8::is_valid\n\nAvailable in version 3.0 and later. Requires a C++ 11 compliant compiler.\n\nChecks whether a string object contains valid UTF-8 encoded text.\n\n```cpp\nbool is_valid(const std::string& s);\n```\n\n`s`: a UTF-8 encoded string.  \nReturn value: `true` if the string contains valid UTF-8 encoded text; `false` if not.\n\nExample of use:\n\n```cpp\nchar utf_invalid[] = \"\\xe6\\x97\\xa5\\xd1\\x88\\xfa\";\nbool bvalid = is_valid(utf_invalid);\nassert (bvalid == false);\n```\n\nYou may want to use `is_valid` to make sure that a string contains valid UTF-8 text without the need to know where it fails if it is not valid.\n\n#### utf8::is_valid\n\nAvailable in version 3.2 and later. Requires a C++ 17 compliant compiler.\n\nChecks whether a string object contains valid UTF-8 encoded text.\n\n```cpp\nbool is_valid(std::string_view s);\n```\n\n`s`: a UTF-8 encoded string.  \nReturn value: `true` if the string contains valid UTF-8 encoded text; `false` if not.\n\nExample of use:\n\n```cpp\nstring_view utf_invalid = \"\\xe6\\x97\\xa5\\xd1\\x88\\xfa\";\nbool bvalid = is_valid(utf_invalid);\nassert (bvalid == false);\n```\n\nYou may want to use `is_valid` to make sure that a string contains valid UTF-8 text without the need to know where it fails if it is not valid.\n\n\n#### utf8::is_valid\n\nAvailable in version 1.0 and later.\n\nChecks whether a sequence of octets is a valid UTF-8 string.\n\n```cpp\ntemplate <typename octet_iterator> \nbool is_valid(octet_iterator start, octet_iterator end);\n```\n\n`octet_iterator`: an input iterator.  \n`start`: an iterator pointing to the beginning of the UTF-8 string to test for validity.  \n`end`: an iterator pointing to pass-the-end of the UTF-8 string to test for validity.  \nReturn value: `true` if the sequence is a valid UTF-8 string; `false` if not.\n\nExample of use:\n\n```cpp\nchar utf_invalid[] = \"\\xe6\\x97\\xa5\\xd1\\x88\\xfa\";\nbool bvalid = is_valid(utf_invalid, utf_invalid + 6);\nassert (bvalid == false);\n```\n\n`is_valid` is a shorthand for `find_invalid(start, end) == end;`. You may want to use it to make sure that a byte sequence is a valid UTF-8 string without the need to know where it fails if it is not valid.\n\n#### utf8::replace_invalid\n\nAvailable in version 3.0 and later. Requires a C++ 11 compliant compiler.\n\nReplaces all invalid UTF-8 sequences within a string with a replacement marker.\n\n```cpp\nstd::string replace_invalid(const std::string& s, char32_t replacement);\nstd::string replace_invalid(const std::string& s);\n```\n\n`s`: a UTF-8 encoded string.  \n`replacement`: A Unicode code point for the replacement marker. The version without this parameter assumes the value `0xfffd`  \nReturn value: A UTF-8 encoded string with replaced invalid sequences.\n\nExample of use:\n\n```cpp\nstring invalid_sequence = \"a\\x80\\xe0\\xa0\\xc0\\xaf\\xed\\xa0\\x80z\";\nstring replace_invalid_result = replace_invalid(invalid_sequence, '?');\nbvalid = is_valid(replace_invalid_result);\nassert (bvalid);\nconst string fixed_invalid_sequence = \"a????z\";\nassert (fixed_invalid_sequence == replace_invalid_result);\n```\n\n#### utf8::replace_invalid\n\nAvailable in version 3.2 and later. Requires a C++ 17 compliant compiler.\n\nReplaces all invalid UTF-8 sequences within a string with a replacement marker.\n\n```cpp\nstd::string replace_invalid(std::string_view s, char32_t replacement);\nstd::string replace_invalid(std::string_view s);\n```\n\n`s`: a UTF-8 encoded string.  \n`replacement`: A Unicode code point for the replacement marker. The version without this parameter assumes the value `0xfffd`  \nReturn value: A UTF-8 encoded string with replaced invalid sequences.\n\nExample of use:\n\n```cpp\nstring_view invalid_sequence = \"a\\x80\\xe0\\xa0\\xc0\\xaf\\xed\\xa0\\x80z\";\nstring replace_invalid_result = replace_invalid(invalid_sequence, '?');\nbool bvalid = is_valid(replace_invalid_result);\nassert (bvalid);\nconst string fixed_invalid_sequence = \"a????z\";\nassert(fixed_invalid_sequence, replace_invalid_result);\n```\n\n\n#### utf8::replace_invalid\n\nAvailable in version 2.0 and later.\n\nReplaces all invalid UTF-8 sequences within a string with a replacement marker.\n\n```cpp\ntemplate <typename octet_iterator, typename output_iterator>\noutput_iterator replace_invalid(octet_iterator start, octet_iterator end, output_iterator out, uint32_t replacement);\ntemplate <typename octet_iterator, typename output_iterator>\noutput_iterator replace_invalid(octet_iterator start, octet_iterator end, output_iterator out);\n```\n\n`octet_iterator`: an input iterator.  \n`output_iterator`: an output iterator.  \n`start`: an iterator pointing to the beginning of the UTF-8 string to look for invalid UTF-8 sequences.  \n`end`: an iterator pointing to pass-the-end of the UTF-8 string to look for invalid UTF-8 sequences.  \n`out`: An output iterator to the range where the result of replacement is stored.  \n`replacement`: A Unicode code point for the replacement marker. The version without this parameter assumes the value `0xfffd`  \nReturn value: An iterator pointing to the place after the UTF-8 string with replaced invalid sequences.\n\nExample of use:\n\n```cpp\nchar invalid_sequence[] = \"a\\x80\\xe0\\xa0\\xc0\\xaf\\xed\\xa0\\x80z\";\nvector<char> replace_invalid_result;\nreplace_invalid (invalid_sequence, invalid_sequence + sizeof(invalid_sequence), back_inserter(replace_invalid_result), '?');\nbvalid = is_valid(replace_invalid_result.begin(), replace_invalid_result.end());\nassert (bvalid);\nchar* fixed_invalid_sequence = \"a????z\";\nassert (std::equal(replace_invalid_result.begin(), replace_invalid_result.end(), fixed_invalid_sequence));\n```\n\n`replace_invalid` does not perform in-place replacement of invalid sequences. Rather, it produces a copy of the original string with the invalid sequences replaced with a replacement marker. Therefore, `out` must not be in the `[start, end]` range.\n\n#### utf8::starts_with_bom\n\nAvailable in version 3.0 and later. Requires a C++ 11 compliant compiler.\n\nChecks whether a string starts with a UTF-8 byte order mark (BOM)\n\n```cpp\nbool starts_with_bom(const std::string& s);\n```\n\n`s`: a UTF-8 encoded string.\nReturn value: `true` if the string starts with a UTF-8 byte order mark; `false` if not.\n\nExample of use:\n\n```cpp\nstring byte_order_mark = {char(0xef), char(0xbb), char(0xbf)};\nbool bbom = starts_with_bom(byte_order_mark);\nassert (bbom == true);\nstring threechars = \"\\xf0\\x90\\x8d\\x86\\xe6\\x97\\xa5\\xd1\\x88\";\nbool no_bbom = starts_with_bom(threechars);\nassert (no_bbom == false);\n ```\n\nThe typical use of this function is to check the first three bytes of a file. If they form the UTF-8 BOM, we want to skip them before processing the actual UTF-8 encoded text.\n\n\n#### utf8::starts_with_bom\n\nAvailable in version 3.2 and later. Requires a C++ 17 compliant compiler.\n\nChecks whether a string starts with a UTF-8 byte order mark (BOM)\n\n```cpp\nbool starts_with_bom(std::string_view s);\n```\n\n`s`: a UTF-8 encoded string.\nReturn value: `true` if the string starts with a UTF-8 byte order mark; `false` if not.\n\nExample of use:\n\n```cpp\nstring byte_order_mark = {char(0xef), char(0xbb), char(0xbf)};\nstring_view byte_order_mark_view(byte_order_mark);\nbool bbom = starts_with_bom(byte_order_mark_view);\nassert (bbom);\nstring_view threechars = \"\\xf0\\x90\\x8d\\x86\\xe6\\x97\\xa5\\xd1\\x88\";\nbool no_bbom = starts_with_bom(threechars);\nassert (!no_bbom);\n ```\n\nThe typical use of this function is to check the first three bytes of a file. If they form the UTF-8 BOM, we want to skip them before processing the actual UTF-8 encoded text.\n\n\n#### utf8::starts_with_bom\n\nAvailable in version 2.3 and later.\n\nChecks whether an octet sequence starts with a UTF-8 byte order mark (BOM)\n\n```cpp\ntemplate <typename octet_iterator> \nbool starts_with_bom (octet_iterator it, octet_iterator end);\n```\n\n`octet_iterator`: an input iterator.  \n`it`: beginning of the octet sequence to check  \n`end`: pass-end of the sequence to check  \nReturn value: `true` if the sequence starts with a UTF-8 byte order mark; `false` if not.\n\nExample of use:\n\n```cpp\nunsigned char byte_order_mark[] = {0xef, 0xbb, 0xbf};\nbool bbom = starts_with_bom(byte_order_mark, byte_order_mark + sizeof(byte_order_mark));\nassert (bbom == true);\n```\n\nThe typical use of this function is to check the first three bytes of a file. If they form the UTF-8 BOM, we want to skip them before processing the actual UTF-8 encoded text.\n\n### Types From utf8 Namespace\n\n#### utf8::exception\n\nAvailable in version 2.3 and later.\n\nBase class for the exceptions thrown by UTF CPP library functions.\n\n```cpp\nclass exception : public std::exception {};\n```\n\nExample of use:\n\n```cpp\ntry {\n  code_that_uses_utf_cpp_library();\n}\ncatch(const utf8::exception& utfcpp_ex) {\n  cerr << utfcpp_ex.what();\n}\n```\n\n#### utf8::invalid_code_point\n\nAvailable in version 1.0 and later.\n\nThrown by UTF8 CPP functions such as `advance` and `next` if an UTF-8 sequence represents and invalid code point.\n\n```cpp\nclass invalid_code_point : public exception {\npublic: \n    uint32_t code_point() const;\n};\n```\n\nMember function `code_point()` can be used to determine the invalid code point that caused the exception to be thrown.\n\n#### utf8::invalid_utf8\n\nAvailable in version 1.0 and later.\n\nThrown by UTF8 CPP functions such as `next` and `prior` if an invalid UTF-8 sequence is detected during decoding.\n\n```cpp\nclass invalid_utf8 : public exception {\npublic: \n    uint8_t utf8_octet() const;\n};\n```\n\nMember function `utf8_octet()` can be used to determine the beginning of the byte sequence that caused the exception to be thrown.\n\n#### utf8::invalid_utf16\n\nAvailable in version 1.0 and later.\n\nThrown by UTF8 CPP function `utf16to8` if an invalid UTF-16 sequence is detected during decoding.\n\n```cpp\nclass invalid_utf16 : public exception {\npublic: \n    uint16_t utf16_word() const;\n};\n```\n\nMember function `utf16_word()` can be used to determine the UTF-16 code unit that caused the exception to be thrown.\n\n#### utf8::not_enough_room\n\nAvailable in version 1.0 and later.\n\nThrown by UTF8 CPP functions such as `next` if the end of the decoded UTF-8 sequence was reached before the code point was decoded.\n\n```cpp\nclass not_enough_room : public exception {};\n```\n\n#### utf8::iterator\n\nAvailable in version 2.0 and later.\n\nAdapts the underlying octet iterator to iterate over the sequence of code points, rather than raw octets.\n\n```cpp\ntemplate <typename octet_iterator>\nclass iterator;\n```\n\n##### Member functions\n\n`iterator();` the deafult constructor; the underlying octet_iterator is constructed with its default constructor.\n\n`explicit iterator (const octet_iterator& octet_it, const octet_iterator& range_start, const octet_iterator& range_end);` a constructor that initializes the underlying octet_iterator with octet_it and sets the range in which the iterator is considered valid.\n\n`octet_iterator base () const;` returns the underlying octet_iterator.\n\n`uint32_t operator * () const;` decodes the utf-8 sequence the underlying octet_iterator is pointing to and returns the code point.\n\n`bool operator == (const iterator& rhs) const;` returns `true` if the two underlying iterators are equal.\n\n`bool operator != (const iterator& rhs) const;` returns `true` if the two underlying iterators are not equal.\n\n`iterator& operator ++ ();` the prefix increment - moves the iterator to the next UTF-8 encoded code point.\n\n`iterator operator ++ (int);` the postfix increment - moves the iterator to the next UTF-8 encoded code point and returns the current one.\n\n`iterator& operator -- ();` the prefix decrement - moves the iterator to the previous UTF-8 encoded code point.\n\n`iterator operator -- (int);` the postfix decrement - moves the iterator to the previous UTF-8 encoded code point and returns the current one.\n\nExample of use:\n\n```cpp\nchar* threechars = \"\\xf0\\x90\\x8d\\x86\\xe6\\x97\\xa5\\xd1\\x88\";\nutf8::iterator<char*> it(threechars, threechars, threechars + 9);\nutf8::iterator<char*> it2 = it;\nassert (it2 == it);\nassert (*it == 0x10346);\nassert (*(++it) == 0x65e5);\nassert ((*it++) == 0x65e5);\nassert (*it == 0x0448);\nassert (it != it2);\nutf8::iterator<char*> endit (threechars + 9, threechars, threechars + 9);  \nassert (++it == endit);\nassert (*(--it) == 0x0448);\nassert ((*it--) == 0x0448);\nassert (*it == 0x65e5);\nassert (--it == utf8::iterator<char*>(threechars, threechars, threechars + 9));\nassert (*it == 0x10346);\n```\n\nThe purpose of `utf8::iterator` adapter is to enable easy iteration as well as the use of STL algorithms with UTF-8 encoded strings. Increment and decrement operators are implemented in terms of `utf8::next()` and `utf8::prior()` functions.\n\nNote that `utf8::iterator` adapter is a checked iterator. It operates on the range specified in the constructor; any attempt to go out of that range will result in an exception. Even the comparison operators require both iterator object to be constructed against the same range - otherwise an exception is thrown. Typically, the range will be determined by sequence container functions `begin` and `end`, i.e.:\n\n```cpp\nstd::string s = \"example\";\nutf8::iterator i (s.begin(), s.begin(), s.end());\n```\n\n### Functions From utf8::unchecked Namespace\n\n#### utf8::unchecked::append\n\nAvailable in version 1.0 and later.\n\nEncodes a 32 bit code point as a UTF-8 sequence of octets and appends the sequence to a UTF-8 string.\n\n```cpp\ntemplate <typename octet_iterator>\noctet_iterator append(uint32_t cp, octet_iterator result);\n```\n\n`cp`: A 32 bit integer representing a code point to append to the sequence.  \n`result`: An output iterator to the place in the sequence where to append the code point.  \nReturn value: An iterator pointing to the place after the newly appended sequence.\n\nExample of use:\n\n```cpp\nunsigned char u[5] = {0,0,0,0,0};\nunsigned char* end = unchecked::append(0x0448, u);\nassert (u[0] == 0xd1 && u[1] == 0x88 && u[2] == 0 && u[3] == 0 && u[4] == 0);\n```\n\nThis is a faster but less safe version of `utf8::append`. It does not check for validity of the supplied code point, and may produce an invalid UTF-8 sequence.\n\n#### utf8::unchecked::next\n\nAvailable in version 1.0 and later.\n\nGiven the iterator to the beginning of a UTF-8 sequence, it returns the code point and moves the iterator to the next position.\n\n```cpp\ntemplate <typename octet_iterator>\nuint32_t next(octet_iterator& it);\n```\n\n`it`: a reference to an iterator pointing to the beginning of an UTF-8 encoded code point. After the function returns, it is incremented to point to the beginning of the next code point.  \n Return value: the 32 bit representation of the processed UTF-8 code point.\n\nExample of use:\n\n```cpp\nchar* twochars = \"\\xe6\\x97\\xa5\\xd1\\x88\";\nchar* w = twochars;\nint cp = unchecked::next(w);\nassert (cp == 0x65e5);\nassert (w == twochars + 3);\n```\n\nThis is a faster but less safe version of `utf8::next`. It does not check for validity of the supplied UTF-8 sequence.\n\n#### utf8::unchecked::peek_next\n\nAvailable in version 2.1 and later.\n\nGiven the iterator to the beginning of a UTF-8 sequence, it returns the code point.\n\n```cpp\ntemplate <typename octet_iterator>\nuint32_t peek_next(octet_iterator it);\n```\n\n`it`: an iterator pointing to the beginning of an UTF-8 encoded code point.  \nReturn value: the 32 bit representation of the processed UTF-8 code point.\n\nExample of use:\n\n```cpp\nchar* twochars = \"\\xe6\\x97\\xa5\\xd1\\x88\";\nchar* w = twochars;\nint cp = unchecked::peek_next(w);\nassert (cp == 0x65e5);\nassert (w == twochars);\n```\n\nThis is a faster but less safe version of `utf8::peek_next`. It does not check for validity of the supplied UTF-8 sequence.\n\n#### utf8::unchecked::prior\n\nAvailable in version 1.02 and later.\n\nGiven a reference to an iterator pointing to an octet in a UTF-8 sequence, it decreases the iterator until it hits the beginning of the previous UTF-8 encoded code point and returns the 32 bits representation of the code point.\n\n```cpp\ntemplate <typename octet_iterator>\nuint32_t prior(octet_iterator& it);\n```\n\n`it`: a reference pointing to an octet within a UTF-8 encoded string. After the function returns, it is decremented to point to the beginning of the previous code point.  \n Return value: the 32 bit representation of the previous code point.\n\nExample of use:\n\n```cpp\nchar* twochars = \"\\xe6\\x97\\xa5\\xd1\\x88\";\nchar* w = twochars + 3;\nint cp = unchecked::prior (w);\nassert (cp == 0x65e5);\nassert (w == twochars);\n```\n\nThis is a faster but less safe version of `utf8::prior`. It does not check for validity of the supplied UTF-8 sequence and offers no boundary checking.\n\n#### utf8::unchecked::advance\n\nAvailable in version 1.0 and later.\n\nAdvances an iterator by the specified number of code points within an UTF-8 sequence.\n\n```cpp\ntemplate <typename octet_iterator, typename distance_type>\nvoid advance (octet_iterator& it, distance_type n);\n```\n\n`it`: a reference to an iterator pointing to the beginning of an UTF-8 encoded code point. After the function returns, it is incremented to point to the nth following code point.\n`n`: number of code points `it` should be advanced. A negative value means decrement.\n\nExample of use:\n\n```cpp\nchar* twochars = \"\\xe6\\x97\\xa5\\xd1\\x88\";\nchar* w = twochars;\nunchecked::advance (w, 2);\nassert (w == twochars + 5);\n```\n\nThis is a faster but less safe version of `utf8::advance`. It does not check for validity of the supplied UTF-8 sequence and offers no boundary checking.\n\n#### utf8::unchecked::distance\n\nAvailable in version 1.0 and later.\n\nGiven the iterators to two UTF-8 encoded code points in a sequence, returns the number of code points between them.\n\n```cpp\ntemplate <typename octet_iterator>\ntypename std::iterator_traits<octet_iterator>::difference_type distance (octet_iterator first, octet_iterator last);\n```\n\n`first`: an iterator to a beginning of a UTF-8 encoded code point.  \n`last`: an iterator to a \"post-end\" of the last UTF-8 encoded code point in the sequence we are trying to determine the length. It can be the beginning of a new code point, or not.  \nReturn value: the distance between the iterators, in code points.\n\nExample of use:\n\n```cpp\nchar* twochars = \"\\xe6\\x97\\xa5\\xd1\\x88\";\nsize_t dist = utf8::unchecked::distance(twochars, twochars + 5);\nassert (dist == 2);\n```\n\nThis is a faster but less safe version of `utf8::distance`. It does not check for validity of the supplied UTF-8 sequence.\n\n#### utf8::unchecked::utf16to8\n\nAvailable in version 1.0 and later.\n\nConverts a UTF-16 encoded string to UTF-8.\n\n```cpp\ntemplate <typename u16bit_iterator, typename octet_iterator>\noctet_iterator utf16to8 (u16bit_iterator start, u16bit_iterator end, octet_iterator result);\n```\n\n`start`: an iterator pointing to the beginning of the UTF-16 encoded string to convert.  \n`end`: an iterator pointing to pass-the-end of the UTF-16 encoded string to convert.  \n`result`: an output iterator to the place in the UTF-8 string where to append the result of conversion.  \nReturn value: An iterator pointing to the place after the appended UTF-8 string.\n\nExample of use:\n\n```cpp\nunsigned short utf16string[] = {0x41, 0x0448, 0x65e5, 0xd834, 0xdd1e};\nvector<unsigned char> utf8result;\nunchecked::utf16to8(utf16string, utf16string + 5, back_inserter(utf8result));\nassert (utf8result.size() == 10);    \n```\n\nThis is a faster but less safe version of `utf8::utf16to8`. It does not check for validity of the supplied UTF-16 sequence.\n\n#### utf8::unchecked::utf8to16\n\nAvailable in version 1.0 and later.\n\nConverts an UTF-8 encoded string to UTF-16\n\n```cpp\ntemplate <typename u16bit_iterator, typename octet_iterator>\nu16bit_iterator utf8to16 (octet_iterator start, octet_iterator end, u16bit_iterator result);\n```\n\n`start`: an iterator pointing to the beginning of the UTF-8 encoded string to convert. < br /> `end`: an iterator pointing to pass-the-end of the UTF-8 encoded string to convert.  \n`result`: an output iterator to the place in the UTF-16 string where to append the result of conversion.  \nReturn value: An iterator pointing to the place after the appended UTF-16 string.\n\nExample of use:\n\n```cpp\nchar utf8_with_surrogates[] = \"\\xe6\\x97\\xa5\\xd1\\x88\\xf0\\x9d\\x84\\x9e\";\nvector <unsigned short> utf16result;\nunchecked::utf8to16(utf8_with_surrogates, utf8_with_surrogates + 9, back_inserter(utf16result));\nassert (utf16result.size() == 4);\nassert (utf16result[2] == 0xd834);\nassert (utf16result[3] == 0xdd1e);\n```\n\nThis is a faster but less safe version of `utf8::utf8to16`. It does not check for validity of the supplied UTF-8 sequence.\n\n#### utf8::unchecked::utf32to8\n\nAvailable in version 1.0 and later.\n\nConverts a UTF-32 encoded string to UTF-8.\n\n```cpp\ntemplate <typename octet_iterator, typename u32bit_iterator>\noctet_iterator utf32to8 (u32bit_iterator start, u32bit_iterator end, octet_iterator result);\n```\n\n`start`: an iterator pointing to the beginning of the UTF-32 encoded string to convert.  \n`end`: an iterator pointing to pass-the-end of the UTF-32 encoded string to convert.  \n`result`: an output iterator to the place in the UTF-8 string where to append the result of conversion.  \nReturn value: An iterator pointing to the place after the appended UTF-8 string.\n\nExample of use:\n\n```cpp\nint utf32string[] = {0x448, 0x65e5, 0x10346, 0};\nvector<unsigned char> utf8result;\nutf32to8(utf32string, utf32string + 3, back_inserter(utf8result));\nassert (utf8result.size() == 9);\n```\n\nThis is a faster but less safe version of `utf8::utf32to8`. It does not check for validity of the supplied UTF-32 sequence.\n\n#### utf8::unchecked::utf8to32\n\nAvailable in version 1.0 and later.\n\nConverts a UTF-8 encoded string to UTF-32.\n\n```cpp\ntemplate <typename octet_iterator, typename u32bit_iterator>\nu32bit_iterator utf8to32 (octet_iterator start, octet_iterator end, u32bit_iterator result);\n```\n\n`start`: an iterator pointing to the beginning of the UTF-8 encoded string to convert.  \n`end`: an iterator pointing to pass-the-end of the UTF-8 encoded string to convert.  \n`result`: an output iterator to the place in the UTF-32 string where to append the result of conversion.  \nReturn value: An iterator pointing to the place after the appended UTF-32 string.\n\nExample of use:\n\n```cpp\nchar* twochars = \"\\xe6\\x97\\xa5\\xd1\\x88\";\nvector<int> utf32result;\nunchecked::utf8to32(twochars, twochars + 5, back_inserter(utf32result));\nassert (utf32result.size() == 2);\n```\n\nThis is a faster but less safe version of `utf8::utf8to32`. It does not check for validity of the supplied UTF-8 sequence.\n\n#### utf8::unchecked::replace_invalid\n\nAvailable in version 3.1 and later.\n\nReplaces all invalid UTF-8 sequences within a string with a replacement marker.\n\n```cpp\ntemplate <typename octet_iterator, typename output_iterator>\noutput_iterator replace_invalid(octet_iterator start, octet_iterator end, output_iterator out, uint32_t replacement);\ntemplate <typename octet_iterator, typename output_iterator>\noutput_iterator replace_invalid(octet_iterator start, octet_iterator end, output_iterator out);\n```\n\n`octet_iterator`: an input iterator.  \n`output_iterator`: an output iterator.  \n`start`: an iterator pointing to the beginning of the UTF-8 string to look for invalid UTF-8 sequences.  \n`end`: an iterator pointing to pass-the-end of the UTF-8 string to look for invalid UTF-8 sequences.  \n`out`: An output iterator to the range where the result of replacement is stored.  \n`replacement`: A Unicode code point for the replacement marker. The version without this parameter assumes the value `0xfffd`  \nReturn value: An iterator pointing to the place after the UTF-8 string with replaced invalid sequences.\n\nExample of use:\n\n```cpp\nchar invalid_sequence[] = \"a\\x80\\xe0\\xa0\\xc0\\xaf\\xed\\xa0\\x80z\";\nvector<char> replace_invalid_result;\nunchecked::replace_invalid (invalid_sequence, invalid_sequence + sizeof(invalid_sequence), back_inserter(replace_invalid_result), '?');\nbvalid = utf8::is_valid(replace_invalid_result.begin(), replace_invalid_result.end());\nassert (bvalid);\nchar* fixed_invalid_sequence = \"a????z\";\nassert (std::equal(replace_invalid_result.begin(), replace_invalid_result.end(), fixed_invalid_sequence));\n```\n\n`replace_invalid` does not perform in-place replacement of invalid sequences. Rather, it produces a copy of the original string with the invalid sequences replaced with a replacement marker. Therefore, `out` must not be in the `[start, end]` range.\n\nUnlike `utf8::replace_invalid`, this function does not verify validity of the replacement marker.\n\n### Types From utf8::unchecked Namespace\n\n#### utf8::iterator\n\nAvailable in version 2.0 and later.\n\nAdapts the underlying octet iterator to iterate over the sequence of code points, rather than raw octets.\n\n```cpp\ntemplate <typename octet_iterator>\nclass iterator;\n```\n\n##### Member functions\n\n`iterator();` the deafult constructor; the underlying octet_iterator is constructed with its default constructor.\n\n`explicit iterator (const octet_iterator& octet_it);` a constructor that initializes the underlying octet_iterator with `octet_it`.\n\n`octet_iterator base () const;` returns the underlying octet_iterator.\n\n`uint32_t operator * () const;` decodes the utf-8 sequence the underlying octet_iterator is pointing to and returns the code point.\n\n`bool operator == (const iterator& rhs) const;` returns `true` if the two underlying iterators are equal.\n\n`bool operator != (const iterator& rhs) const;` returns `true` if the two underlying iterators are not equal.\n\n`iterator& operator ++ ();` the prefix increment - moves the iterator to the next UTF-8 encoded code point.\n\n`iterator operator ++ (int);` the postfix increment - moves the iterator to the next UTF-8 encoded code point and returns the current one.\n\n`iterator& operator -- ();` the prefix decrement - moves the iterator to the previous UTF-8 encoded code point.\n\n`iterator operator -- (int);` the postfix decrement - moves the iterator to the previous UTF-8 encoded code point and returns the current one.\n\nExample of use:\n\n```cpp\nchar* threechars = \"\\xf0\\x90\\x8d\\x86\\xe6\\x97\\xa5\\xd1\\x88\";\nutf8::unchecked::iterator<char*> un_it(threechars);\nutf8::unchecked::iterator<char*> un_it2 = un_it;\nassert (un_it2 == un_it);\nassert (*un_it == 0x10346);\nassert (*(++un_it) == 0x65e5);\nassert ((*un_it++) == 0x65e5);\nassert (*un_it == 0x0448);\nassert (un_it != un_it2);\nutf8::::unchecked::iterator<char*> un_endit (threechars + 9);  \nassert (++un_it == un_endit);\nassert (*(--un_it) == 0x0448);\nassert ((*un_it--) == 0x0448);\nassert (*un_it == 0x65e5);\nassert (--un_it == utf8::unchecked::iterator<char*>(threechars));\nassert (*un_it == 0x10346);\n```\n\nThis is an unchecked version of `utf8::iterator`. It is faster in many cases, but offers no validity or range checks.\n\n## Links\n\n1.  [The Unicode Consortium](http://www.unicode.org/).\n2.  [ICU Library](http://icu.sourceforge.net/).\n3.  [UTF-8 at Wikipedia](http://en.wikipedia.org/wiki/UTF-8)\n4.  [UTF-8 and Unicode FAQ for Unix/Linux](http://www.cl.cam.ac.uk/~mgk25/unicode.html)"
}
