{
  "name": "datatype99",
  "full_name": "datatype99",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Algebraic data types for C99",
  "license": "MIT",
  "homepage": "https://github.com/Hirrolot/datatype99",
  "versions": {
    "stable": "1.6.4",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/Hirrolot/datatype99/archive/refs/tags/v1.6.4.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "f8488decc7ab035e3af77ee62e64fc678d5cb57831457f7270efe003e63d6f09"
    },
    "head": {
      "url": "https://github.com/Hirrolot/datatype99.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "all": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/datatype99/blobs/sha256:f9efbcdf97d7f734efe0cb3f95c22993896bb83c7ed797f44e391878bc98611c",
          "sha256": "f9efbcdf97d7f734efe0cb3f95c22993896bb83c7ed797f44e391878bc98611c"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [
    "metalang99"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/datatype99.rb",
  "ruby_source_checksum": {
    "sha256": "be9f94745583caf0eeb1e39f24d96a6c2233a6578399a0ac5c18342c1afd64f0"
  },
  "date_added": "2022-07-09T15:00:31+00:00",
  "readme": "<div align=\"center\">\n  <a href=\"examples/binary_tree.c\"><img src=\"images/preview.png\" width=\"600\" /></a>\n  <h1>Datatype99</h1>\n  <a href=\"https://github.com/Hirrolot/datatype99/actions\">\n    <img src=\"https://github.com/Hirrolot/datatype99/workflows/C/C++%20CI/badge.svg\">\n  </a>\n  <a href=\"https://lists.sr.ht/~hirrolot/metalang99\">\n    <img src=\"https://img.shields.io/badge/mailing%20list-lists.sr.ht-orange\">\n  </a>\n\n  Safe, intuitive [algebraic data types] with exhaustive pattern matching & compile-time introspection facilities. No external tools required, pure C99.\n</div>\n\n[algebraic data types]: https://en.wikipedia.org/wiki/Algebraic_data_type\n\n## Highlights\n\n - **Type-safe.** Such things as improperly typed variants, non-exhaustive pattern matching, and invalid field access are caught at compile-time.\n\n - **Portable.** Everything you need is a standard-conforming C99 compiler; neither the standard library, nor compiler/platform-specific functionality or VLA are required.\n\n - **Predictable.** Datatype99 comes with formal [code generation semantics], meaning that the generated data layout is guaranteed to always be the same.\n\n - **Comprehensible errors.** Datatype99 is [resilient to bad code].\n\n - **Battle-tested.** Datatype99 is used at [OpenIPC] to develop real-time streaming software for IP cameras; this includes an [RTSP 1.0 implementation] along with ~50k lines of private code.\n\n[resilient to bad code]: #q-what-about-compile-time-errors\n[OpenIPC]: https://openipc.org/\n[RTSP 1.0 implementation]: https://github.com/OpenIPC/smolrtsp/\n\n## Installation\n\nDatatype99 consists of one header file `datatype99.h` and one dependency [Metalang99]. To use it in your project, you need to:\n\n[Metalang99]: https://github.com/Hirrolot/metalang99\n\n 1. Add `datatype99` and `metalang99/include` to your include directories.\n 2. Specify [`-ftrack-macro-expansion=0`] (GCC) or [`-fmacro-backtrace-limit=1`] (Clang) to avoid useless macro expansion errors.\n\n[`-ftrack-macro-expansion=0`]: https://gcc.gnu.org/onlinedocs/gcc/Preprocessor-Options.html\n[`-fmacro-backtrace-limit=1`]: https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-fmacro-backtrace-limit\n\nIf you use CMake, the recommended way is [`FetchContent`]:\n\n[`FetchContent`]: https://cmake.org/cmake/help/latest/module/FetchContent.html\n\n```cmake\ninclude(FetchContent)\n\nFetchContent_Declare(\n    datatype99\n    URL https://github.com/Hirrolot/datatype99/archive/refs/tags/v1.2.3.tar.gz # v1.2.3\n)\n\nFetchContent_MakeAvailable(datatype99)\n\ntarget_link_libraries(MyProject datatype99)\n\n# Disable full macro expansion backtraces for Metalang99.\nif(CMAKE_C_COMPILER_ID STREQUAL \"Clang\")\n  target_compile_options(MyProject PRIVATE -fmacro-backtrace-limit=1)\nelseif(CMAKE_C_COMPILER_ID STREQUAL \"GNU\")\n  target_compile_options(MyProject PRIVATE -ftrack-macro-expansion=0)\nendif()\n```\n\n(By default, `datatype99/CMakeLists.txt` downloads Metalang99 [v1.13.2](https://github.com/Hirrolot/metalang99/releases/tag/v1.13.2) from the GitHub releases; if you want to override this behaviour, you can do so by invoking [`FetchContent_Declare`] earlier.)\n\n[`FetchContent_Declare`]: https://cmake.org/cmake/help/latest/module/FetchContent.html#command:fetchcontent_declare\n\nOptionally, you can [precompile headers] in your project that rely on Datatype99. This will decrease compilation time, because the headers will not be compiled each time they are included.\n\n[precompile headers]: https://en.wikipedia.org/wiki/Precompiled_header\n\nHappy hacking!\n\n## Usage\n\nPut simply, Datatype99 is just a syntax sugar over [tagged unions]; the only difference is that it is more safe and concise. For example, to represent a binary tree, you would normally write something like this:\n\n```c\ntypedef struct {\n    struct BinaryTree *lhs;\n    int x;\n    struct BinaryTree *rhs;\n} BinaryTreeNode;\n\ntypedef struct {\n    enum { Leaf, Node } tag;\n    union {\n        int leaf;\n        BinaryTreeNode node;\n    } data;\n} BinaryTree;\n```\n\nTo avoid this boilerplate, you can use Datatype99:\n\n```c\ndatatype(\n    BinaryTree,\n    (Leaf, int),\n    (Node, BinaryTree *, int, BinaryTree *)\n);\n```\n\nSay you want to sum all nodes and leafs in your binary tree. Then you may write something like this:\n\n```c\nint sum(const BinaryTree *tree) {\n    switch (tree->tag) {\n    case Leaf:\n        return tree->data.leaf;\n    case Node:\n        return sum(tree->data.node.lhs) + tree->data.node.x + sum(tree->data.node.rhs);\n    }\n\n    // Invalid input (no such variant).\n    return -1;\n}\n```\n\n... but what if you accidentally access `tree->data.node` after `case Leaf:`? Your compiler would not warn you, thus resulting in a business logic bug.\n\nWith Datatype99, you can rewrite `sum` as follows, using a technique called _pattern matching_:\n\n```c\nint sum(const BinaryTree *tree) {\n    match(*tree) {\n        of(Leaf, x) return *x;\n        of(Node, lhs, x, rhs) return sum(*lhs) + *x + sum(*rhs);\n    }\n\n    // Invalid input (no such variant).\n    return -1;\n}\n```\n\n`of` gives you variables called _bindings_: `x`, `lhs`, or `rhs`. This design has a few neat aspects:\n\n - **Compile-time safety.** The bindings of `Node` are invisible after `of(Leaf, x)` and vice versa, so compilation will fail to proceed if you access them inappropriately.\n - **Flexibility.** Bindings have pointer types so that you can mutate them, thereby mutating the whole `tree`; in order to obtain a value, you can dereference them, as shown in the example: `return *x;`.\n\nThe last thing unmentioned is how you construct variants. Internally, Datatype99 generates `inline static` functions called _value constructors_; you can use them as follows:\n\n```c\nBinaryTree leaf5 = Leaf(5);\nBinaryTree leaf7 = Leaf(7);\nBinaryTree node = Node(&leaf5, 123, &leaf7);\n```\n\nFinally, just a few brief notes about pattern matching:\n\n - To match the default case, write `otherwise { ... }` at the end of `match`.\n - To ignore a binding, write `_`: `of(Foo, a, b, _, d)`.\n - **PLEASE**, [do **not** use top-level `break`/`continue`](#top-level-breakcontinue) inside statements provided to `of` and `ifLet`; use `goto` labels instead.\n\nCongratulations, this is all you need to know to write most of the stuff! If you feel fancy, you can also introspect your types at compile-time; see [`examples/derive/`](examples/derive/) for the examples.\n\n[tagged unions]: https://en.wikipedia.org/wiki/Tagged_union\n\n## Syntax and semantics\n\nHaving a well-defined semantics of the macros, you can write an FFI which is quite common in C.\n\n### EBNF syntax\n\n```ebnf\n<datatype>      ::= \"datatype(\" [ <derive-clause> \",\" ] <datatype-name> { \",\" <variant> }+ \")\" ;\n<record>        ::= \"record(\"   [ <derive-clause> \",\" ] <record-name>   { \",\" <field>   }* \")\" ;\n<datatype-name> ::= <ident> ;\n<record-name>   ::= <ident> ;\n\n<variant>       ::= \"(\" <variant-name> { \",\" <type> }* \")\" ;\n<field>         ::= \"(\" <type> \",\" <field-name> \")\" ;\n<variant-name>  ::= <ident> ;\n<field-name>    ::= <ident> ;\n\n<derive-clause> ::= \"derive(\" <deriver-name> { \",\" <deriver-name> }* \")\" ;\n<deriver-name>  ::= <ident> ;\n\n<match>         ::= \"match(\" <lvalue> \") {\" { <of> }* [ <otherwise> ] \"}\" ;\n<matches>       ::= \"MATCHES(\" <expr> \",\" <ident> \")\" ;\n<if-let>        ::= \"ifLet(\" <lvalue> \",\" <variant-name> \",\" <ident> { \",\" <ident> }* \")\" <stmt> ;\n<of>            ::= \"of(\" <variant-name> { \",\" <ident> }* \")\" <stmt> ;\n<otherwise>     ::= \"otherwise\" <stmt> ;\n```\n\n<details>\n  <summary>Note: shortened vs. postfixed versions</summary>\n\n  Each listed identifier in the above grammar corresponds to a macro name defined by default -- these are called _shortened versions_. On the other hand, there are also _postfixed versions_ (`match99`, `of99`, `derive99`, etc.), which are defined unconditionally. If you want to avoid name clashes caused by shortened versions, define `DATATYPE99_NO_ALIASES` before including `datatype99.h`. Library headers are strongly advised to use the postfixed macros, but without resorting to `DATATYPE99_NO_ALIASES`.\n</details>\n  \n### Semantics\n\n(It might be helpful to look at the [generated data layout](https://godbolt.org/z/rebxMxW43) of [`examples/binary_tree.c`](examples/binary_tree.c).)\n\n#### `datatype`\n\n 1. Before everything, the following type definition is generated:\n\n```\ntypedef struct <datatype-name> <datatype-name>;\n```\n\n 2. For each non-empty variant, the following type definition is generated (the metavariable `<type>` ranges over a corresponding variant's types):\n\n```\ntypedef struct <datatype-name><variant-name> {\n    <type>0 _0;\n    ...\n    <type>N _N;\n} <datatype-name><variant-name>;\n```\n\n 3. For each non-empty variant, the following type definitions to types of each field of `<datatype-name><variant-name>` are generated:\n\n```\ntypedef <type>0 <variant-name>_0;\n...\ntypedef <type>N <variant-name>_N;\n```\n\n 4. For each variant, the following type definition to a corresponding sum type is generated:\n\n```\ntypedef struct <datatype-name> <variant-name>SumT;\n```\n\n 5. For each sum type, the following tagged union is generated (inside the union, only fields to structures of non-empty variants are generated):\n\n```\ntypedef enum <datatype-name>Tag {\n    <variant-name>0Tag, ..., <variant-name>NTag\n} <datatype-name>Tag;\n\ntypedef union <datatype-name>Variants {\n    char dummy;\n\n    <datatype-name><variant-name>0 <variant-name>0;\n    ...\n    <datatype-name><variant-name>N <variant-name>N;\n} <datatype-name>Variants;\n\nstruct <datatype-name> {\n    <datatype-name>Tag tag;\n    <datatype-name>Variants data;\n};\n```\n\n<details>\n  <summary>Note on char dummy;</summary>\n\n`char dummy;` is needed to make the union contain at least one item, according to the standard, even if all variants are empty. Such a `datatype` would enforce strict type checking unlike plain C `enum`s.\n</details>\n\n 6. For each variant, the following function called a _value constructor_ is generated:\n\n```\ninline static <datatype-name> <variant-name>(/* ... */) { /* ... */ }\n```\n\nIf the variant has no parameters, this function will take `void` and initialise `.data.dummy` to `'\\0'`; otherwise, it will take the corresponding variant parameters and initialise the result value as expected.\n\n 7. Now, when a sum type is fully generated, the derivation process takes place. Each deriver taken from `derive(...)` is invoked sequentially, from left to right, as\n\n```\nML99_call(DATATYPE99_DERIVE_##<deriver-name>I, v(<datatype-name>), variants...)\n```\n\nwhere\n - `<deriver-name>I` corresponds to a [Metalang99-compliant] macro of the form `#define DATATYPE99_DERIVE_##<deriver-name>I_IMPL(name, variants) /* ... */`.\n - `variants...` is a [list] of variants represented as two-place [tuples]: `(<variant-name>, types...)`, where\n   - `types...` is a [list] of types of the corresponding variant.\n\nPut simply, a deriver is meant to generate something global for a sum type, like interface implementations or almost any other stuff. In terms of Rust, you can think of it as of the [`derive` attribute].\n\n[list]: https://metalang99.readthedocs.io/en/latest/list.html\n[tuples]: https://metalang99.readthedocs.io/en/latest/tuple.html\n[`derive` attribute]: https://doc.rust-lang.org/reference/attributes/derive.html\n\n#### `record`\n\n`record` represents a _record type_: it is simply a `struct` for which the derivation process is defined.\n\n 1. The following structure is generated:\n\n```\ntypedef struct <record-name> {\n    // Only if <record-name> has no fields:\n    char dummy;\n\n    <type>0 <field-name>0;\n    ...\n    <type>N <field-name>N;\n} <record-name>;\n```\n\n<details>\n  <summary>Note on char dummy;</summary>\n\n`char dummy;` is needed to make the structure contain at least one item, according to the standard. Such `record(Foo)` can be used to implement interfaces for it (see [Interface99]).\n</details>\n\n[Interface99]: https://github.com/Hirrolot/interface99\n\n 2. Each deriver taken from `derive(...)` is invoked sequentially, from left to right, as\n\n```\nML99_call(DATATYPE99_RECORD_DERIVE_##<deriver-name>I, v(<record-name>), fields...)\n```\n\nwhere\n - `<deriver-name>I` corresponds to a [Metalang99-compliant] macro of the form `#define DATATYPE99_RECORD_DERIVE_##<deriver-name>I_IMPL(name, fields) /* ... */`.\n - `fields...` is a [list] of fields represented as two-place [tuples]: `(<type>, <field-name>)`. If a record contains no fields, the list would consist only of `(char, dummy)`.\n\n#### `match`\n\n`match` has the expected semantics: it sequentially tries to match the given instance of a sum type against the given variants, and, if a match has succeeded, it executes the corresponding statement and moves down to the next instruction (`match(val) { ... } next-instruction;`). If all the matches have failed, it executes the statement after `otherwise` and moves down to the next instruction.\n\nA complete `match` construct results in a single C statement.\n\n#### `of`\n\n`of` accepts a matched variant name as a first argument and the rest of arguments comprise a comma-separated list of bindings.\n\n - A binding equal to `_` is ignored.\n - A binding **not** equal to `_` stands for a pointer to a corresponding data of the variant (e.g., let there be `(Foo, T1, T2)` and `of(Foo, x, y)`, then `x` has the type `T1 *` and `y` is `T2 *`).\n\nThere can be more than one `_` binding, however, non-`_` bindings must be distinct.\n\nTo match an empty variant, write `of(Bar)`.\n\n#### `MATCHES`\n\n`MATCHES` just tests an instance of a sum type for a given variant. If the given instance corresponds to the given variant, it expands to truthfulness, otherwise it expands to falsehood.\n\n#### `matches`\n\n**DEPRECATED**: use [`MATCHES`](#MATCHES) instead.\n\n#### `ifLet`\n\n`ifLet` tries to match the given instance of a sum type against the given variant, and, if a match has succeeded, it executes the corresponding statement.\n\nThink of `ifLet(<expr>, <variant-name>, vars...) { /* ... */ }` as of an abbreviation of\n\n```\nmatch(<expr>) {\n    of(<variant-name>, vars...) { /* ... */ }\n    otherwise {}\n}\n```\n\nA complete `ifLet` construct results in a single C statement.\n\n## Unit type\n\nThe unit type `UnitT99` represents the type of a single value, `unit_v99` (it should not be assigned to anything else). These are defined as follows:\n\n```c\ntypedef char UnitT99;\nstatic const UnitT99 unit_v99 = '\\0';\n```\n\nIf `DATATYPE99_NO_ALIASES` remains undefined prior to `#include <datatype99.h>`, `UnitT99` and `unit_v99` are also accessible through object-like macros `UnitT` & `unit_v`.\n\n## Derive helper attributes\n\nYou can pass named arguments to a deriver; these are called _derive helper attributes_. They must be specified as object-like macros of the form:\n\n```\n#define <variant-name>_<namespace>_<attribute-name> attr(/* attribute value */)\n```\n\nwhere `<namespace>` is either `<datatype-name>`/`<record-name>` or `<variant-name>`/`<field-name>` for `datatype`/`record`-specific and variant/field-specific attributes, respectively.\n\nTo manipulate derive helper attributes, there are a few predefined macros:\n\n - `DATATYPE99_attrIsPresent`/`DATATYPE99_ATTR_IS_PRESENT`\n\n    Accepts an attribute name and checks if it is present or not. It can be used to check the presence of an optional attribute.\n\n - `DATATYPE99_attrValue`/`DATATYPE99_ATTR_VALUE`\n\n    Accepts an attribute name extracts its value. A provided attribute **must** be present.\n\n - `DATATYPE99_assertAttrIsPresent`\n\n    Accepts an attribute name and emits a fatal error if the attribute is not present, otherwise results in emptiness. It can be used for mandatory attributes.\n\n(The naming convention here is the same [as of Metalang99](https://metalang99.readthedocs.io/en/latest/#naming-conventions).)\n\n## Miscellaneous\n\n - The macros `DATATYPE99_MAJOR`, `DATATYPE99_MINOR`, `DATATYPE99_PATCH`, `DATATYPE99_VERSION_COMPATIBLE(x, y, z)`, and `DATATYPE99_VERSION_EQ(x, y, z)` have the [same semantics as of Metalang99](https://metalang99.readthedocs.io/en/latest/#version-manipulation-macros).\n\n - For each macro using `ML99_EVAL`, Datatype99 provides its [Metalang99-compliant] counterpart which can be used inside derivers and other Metalang99-compliant macros:\n\n| Macro | Metalang99-compliant counterpart |\n|----------|----------|\n| `datatype` | `DATATYPE99_datatype` |\n| `record` | `DATATYPE99_record` |\n| `of` | `DATATYPE99_of` |\n| `ifLet` | `DATATYPE99_ifLet` |\n\n(An [arity specifier] and [desugaring macro] are provided for each of the above macros.)\n\n - There is a built-in deriver `dummy` which generates nothing. It is defined both for record and sum types.\n\n[SemVer]: https://semver.org\n[Metalang99-compliant]: https://metalang99.readthedocs.io/en/latest/#definitions\n[arity specifier]: https://hirrolot.gitbook.io/metalang99/partial-application\n[desugaring macro]: https://metalang99.readthedocs.io/en/latest/#definitions\n\n## Guidelines\n\n### Clang-Format issues\n\nIf you use [Clang-Format], cancel formatting for a `datatype` definition using `// clang-format off` & `// clang-format on` to make it look prettier, as in the examples.\n\n### `#undef` derive helper attributes\n\nAlways `#undef` derive helper attributes after a corresponding `datatype` definition not to pollute your namespace.\n\n### Descriptive names\n\nIf the meaning of variant parameters is not clear from the context, give them descriptive names. This can be achieved in several ways:\n\n```c\n// 1. Define type aliases to variant parameters.\ntypedef double XCoordinate;\ntypedef double YCoordinate;\n\ntypedef double Width;\ntypedef double Height;\n\ndatatype(\n    Shape,\n    (Point, XCoordinate, YCoordinate),\n    (Rectangle, Width, Height)\n);\n\n// 2. Define separate structures.\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    double width, height;\n} Rectangle;\n\ndatatype(\n    Shape,\n    (MkPoint, Point),\n    (MkRectangle, Rectangle)\n);\n```\n\nComparison:\n\n - The former option has more concise syntax: `MkPoint(x, y)` instead of `MkPoint((Point){x, y})`.\n - The latter option is more appropriate when the structures are to be used separately from the containing sum type.\n - The latter option allows for more graduate control over the data layout: you can accompain the structures with compiler-specific attributes, alignment properties like `__attribute__ ((__packed__))`, etc.\n\n[Clang-Format]: https://clang.llvm.org/docs/ClangFormatStyleOptions.html\n\n## Pitfalls\n\n### Top-level `break`/`continue`\n\nDo **not** use `break`/`continue` inside a statement provided to `of`/`ifLet` but outside of any `for`/`while` loops in that statement. For example, this code is fine:\n\n```c\nmatch(x) {\n    of(Foo, a, b, c) {\n        for (int i = 0; i < 10; i++) {\n            continue;\n        }\n    }\n}\n```\n\nBut this code is **not** fine:\n\n```c\nfor (int i = 0; i < 10; i++) {\n    match(x) {\n        of(Foo, a, b, c) {\n            if (a == 7) { break; }\n            continue;\n        }\n    }\n}\n```\n\nTo make it valid, you can rewrite it as follows:\n\n```c\nfor (int i = 0; i < 10; i++) {\n    match(x) {\n        of(Foo, a, b, c) {\n            if (a == 7) { goto my_break; }\n            goto my_continue;\n        }\n    }\n\n    // Datatype99 prohibits top-level `break`/`continue`.\n    my_continue:;\n}\nmy_break:;\n```\n\n### Array as a variant parameter\n\nTo specify an array as a variant parameter, you must put it into a separate `struct`; see [`examples/array_in_variant.c`](examples/array_in_variant.c).\n\n### Mutable bindings\n\nBindings introduced by `of` are **always** mutable, so make sure you do **not** mutate them if the value passed to `match` is qualified as `const`.\n\n## Credits\n\nThanks to Rust and ML for their implementations of sum types.\n\n## Publications\n\n - [_Pretty-Printable Enumerations in Pure C_](https://hirrolot.github.io/posts/pretty-printable-enumerations-in-pure-c.html) by Hirrolot.\n - [_What’s the Point of the C Preprocessor, Actually?_](https://hirrolot.github.io/posts/whats-the-point-of-the-c-preprocessor-actually.html) by Hirrolot.\n - [_Macros on Steroids, Or: How Can Pure C Benefit From Metaprogramming_](https://hirrolot.github.io/posts/macros-on-steroids-or-how-can-pure-c-benefit-from-metaprogramming.html) by Hirrolot.\n - [_Extend Your Language, Don’t Alter It_](https://hirrolot.github.io/posts/extend-your-language-dont-alter-it.html) by Hirrolot.\n - [_Compiling Algebraic Data Types in Pure C99_] by Hirrolot.\n - [_Comparing Rust and Datatype99_](https://www.reddit.com/r/ProgrammingLanguages/comments/nc1o18/comparing_algebraic_data_types_rust_and_datatype99/) by Hirrolot.\n - [_Compile-Time Introspection of Sum Types in Pure C99_](https://hirrolot.github.io/posts/compile-time-introspection-of-sum-types-in-pure-c99.html) by Hirrolot.\n - [_Unleashing Sum Types in Pure C99_](https://hirrolot.github.io/posts/unleashing-sum-types-in-pure-c99.html) by Hirrolot.\n\n[_Compiling Algebraic Data Types in Pure C99_]: https://hirrolot.github.io/posts/compiling-algebraic-data-types-in-pure-c99.html\n\n## Release procedure\n\n 1. Update `DATATYPE99_MAJOR`, `DATATYPE99_MINOR`, and `DATATYPE99_PATCH` in `datatype99.h`.\n 2. Update `CHANGELOG.md`.\n 3. Release the project in [GitHub Releases].\n\n[GitHub Releases]: https://github.com/Hirrolot/datatype99/releases\n\n## FAQ\n\n### Q: Why use C instead of Rust/Zig/whatever else?\n\nA: There is a lot of software written in plain C that can benefit from Datatype99; C is #1 programming language as of 2020, [according to TIOBE](https://jaxenter.com/c-programming-may-2020-171598.html). People use C due to technical and social reasons:\n\n - Datatype99 can be seamlessly integrated into existing codebases written in pure C -- just `#include <datatype99.h>` and you are ready to go. On the other hand, other languages force you to separate native C files from their sources, which is clearly less convenient.\n\n - In some environments, developers strick to pure C for historical reasons (e.g., embedded devices, Linux and other operating systems).\n\n - C has a stable ABI which is vital for some projects (e.g., plugin systems such as [MetaCall]).\n\n - C is a mature language with a complete specification and a plenitude of libraries. Rust has no complete specification, and [Zig] is not yet production-ready. I know a few stories when these two languages were rejected for new projects, and I can understand this decision.\n\n - Historically, C has been targeting nearly all platforms. This is not the case with Rust, which depends on LLVM as for now.\n\n - Your company obligates you to use C.\n\n - Etc.\n\n[MetaCall]: https://github.com/metacall/core\n[Zig]: https://ziglang.org/\n\nSee also:\n - [_Rust is not a good C replacement_](https://drewdevault.com/2019/03/25/Rust-is-not-a-good-C-replacement.html) by Drew DeVault.\n\nOverall, if you can afford a more modern/high-level language, I encourage you to do so instead of using old C. However, many people do not have this possibility (or it would be too costly).\n\n### Q: Why not third-party code generators?\n\nA: See [Metalang99's README >>](https://github.com/Hirrolot/metalang99#q-why-not-third-party-code-generators).\n\n### Q: How does it work?\n\nA: In short, `datatype` expands to a tagged union with value constructors; `match` expands to a switch statement. To generate all this stuff, [Metalang99] is used, a preprocessor metaprogramming library.\n\nMore on it in [_Compiling Algebraic Data Types in Pure C99_].\n\n### Q: Does it work on C++?\n\nA: Yes, C++11 and onwards is supported.\n\n### Q: What is the difference between Datatype99 and Metalang99?\n\nA: [Metalang99] is a functional language for metaprogramming, whereas Datatype99 is an implementation of algebraic data types written in this language.\n\n### Q: What about compile-time errors?\n\nA: Some kinds of syntactic errors are detected by the library itself:\n\n#### Error: `Bar(int)` instead of `(Bar, int)`\n\n[`playground.c`]\n```c\ndatatype(A, (Foo, int), Bar(int));\n```\n\n[`/bin/sh`]\n```\n$ gcc playground.c -Imetalang99/include -Idatatype99 -ftrack-macro-expansion=0\nplayground.c:3:1: error: static assertion failed: \"ML99_assertIsTuple: Bar(int) must be (x1, ..., xN)\"\n    3 | datatype(A, (Foo, int), Bar(int));\n      | ^~~~~~~~\n```\n\n----------\n\n#### Error: Missing comma\n\n[`playground.c`]\n```c\ndatatype(A, (Foo, int) (Bar, int));\n```\n\n[`/bin/sh`]\n```\n$ gcc playground.c -Imetalang99/include -Idatatype99 -ftrack-macro-expansion=0\nplayground.c:3:1: error: static assertion failed: \"ML99_assertIsTuple: (Foo, int) (Bar, int) must be (x1, ..., xN), did you miss a comma?\"\n    3 | datatype(A, (Foo, int) (Bar, int));\n      | ^~~~~~~~\n```\n\n----------\n\n#### Error: Trailing comma is prohibited\n\n[`playground.c`]\n```c\ndatatype(A, (Foo, int), (Bar, int), /* trailing comma is prohibited */);\n```\n\n[`/bin/sh`]\n```\n$ gcc playground.c -Imetalang99/include -Idatatype99 -ftrack-macro-expansion=0\nplayground.c:3:1: error: static assertion failed: \"ML99_assertIsTuple: must be (x1, ..., xN)\"\n    3 | datatype(A, (Foo, int), (Bar, int), /* trailing comma is prohibited */);\n      | ^~~~~~~~\n```\n\n(For better diagnostics, use the latest Metalang99.)\n\nThe others are understandable as well:\n\n#### Error: unknown type name specified in `datatype`\n\n[`playground.c`]\n```c\ndatatype(Foo, (FooA, NonExistingType));\n```\n\n[`/bin/sh`]\n```\nplayground.c:3:1: error: unknown type name ‘NonExistingType’\n    3 | datatype(\n      | ^~~~~~~~\nplayground.c:3:1: error: unknown type name ‘NonExistingType’\nplayground.c:3:1: error: unknown type name ‘NonExistingType’\n```\n\n----------\n\n#### Error: non-exhaustive `match`\n\n[`playground.c`]\n```c\nmatch(*tree) {\n    of(Leaf, x) return *x;\n    // of(Node, lhs, x, rhs) return sum(*lhs) + *x + sum(*rhs);\n}\n```\n\n[`/bin/sh`]\n```\nplayground.c: In function ‘sum’:\nplayground.c:6:5: warning: enumeration value ‘NodeTag’ not handled in switch [-Wswitch]\n    6 |     match(*tree) {\n      |     ^~~~~\n```\n\n----------\n\n#### Error: excess binders in `of`\n\n[`playground.c`]\n```c\nmatch(*tree) {\n    of(Leaf, x, excess) return *x;\n    of(Node, lhs, x, rhs) return sum(*lhs) + *x + sum(*rhs);\n}\n```\n\n[`/bin/sh`]\n```\nplayground.c: In function ‘sum’:\nplayground.c:15:9: error: unknown type name ‘Leaf_1’; did you mean ‘Leaf_0’?\n   15 |         of(Leaf, x, excess) return *x;\n      |         ^~\n      |         Leaf_0\nplayground.c:15:9: error: ‘BinaryTreeLeaf’ has no member named ‘_1’; did you mean ‘_0’?\n   15 |         of(Leaf, x, excess) return *x;\n      |         ^~\n      |         _0\n```\n\n----------\n\n#### Error: improperly typed variant arguments\n\n[`playground.c`]\n```c\nBinaryTree tree = Leaf(\"hello world\");\n```\n\n[`/bin/sh`]\n```\nplayground.c: In function ‘main’:\nplayground.c:18:28: warning: passing argument 1 of ‘Leaf’ makes integer from pointer without a cast [-Wint-conversion]\n   18 |     BinaryTree tree = Leaf(\"hello world\");\n      |                            ^~~~~~~~~~~~~\n      |                            |\n      |                            char *\nplayground.c:6:1: note: expected ‘int’ but argument is of type ‘char *’\n    6 | datatype(\n      | ^~~~~~~~\n```\n\n----------\n\n#### Error: an undereferenced binder\n\n[`playground.c`]\n```c\nint sum(const BinaryTree *tree) {\n    match(*tree) {\n        of(Leaf, x) return x; // x is int *\n        of(Node, lhs, x, rhs) return sum(*lhs) + *x + sum(*rhs);\n    }\n}\n```\n\n[`/bin/sh`]\n```\nplayground.c: In function ‘sum’:\nplayground.c:17:28: warning: returning ‘Leaf_0 *’ {aka ‘int *’} from a function with return type ‘int’ makes integer from pointer without a cast [-Wint-conversion]\n   17 |         of(Leaf, x) return x; // x is int *\n      |                            ^\n```\n\n----------\n\nFrom my experience, nearly 95% of errors make sense.\n\nIf an error is not comprehensible at all, try to look at generated code (`-E`). Hopefully, the [code generation semantics] is formally defined so normally you will not see something unexpected.\n\n[code generation semantics]: #semantics\n\n### Q: What about IDE support?\n\n<img src=\"images/suggestion.png\" width=\"600px\" />\n\nA: VS Code automatically enables suggestions of generated types but, of course, it does not support macro syntax highlighting.\n\n### Q: Which compilers are tested?\n\nA: Datatype99 is known to work on these compilers:\n\n - GCC\n - Clang\n - MSVC\n - TCC\n\n## Troubleshooting\n\n### `warning: control reaches end of non-void function [-Wreturn-type]`\n\nThis warning happens when you try to return control from within a `match` statement, and your compiler thinks that not all hypothetical variants are handled. For example:\n\n```c\ndatatype(MyType, (Foo), (Bar));\n\nint handle(MyType val) {\n    match(val) {\n        of(Foo) return 5;\n        of(Bar) return 7;\n    }\n}\n```\n\nThe above code may seem perfect at first glance, but in fact, it is not. The reason is this: `match(val)` boils down to `switch(val.tag)` under the hood, with `val.tag` being an ordinary C enumeration consisting of the variants `Foo` and `Bar`. But what if a caller provides us with neither `Foo` nor `Bar`, but with something like `42` (not a valid variant)? Since `enum` is merely another way to give integers names, a compiler would not complain on the _caller_ site. However, on the _callee_ site, we would have the warning:\n\n```\ntest.c: In function ‘handle’:\ntest.c:10:1: warning: control reaches end of non-void function [-Wreturn-type]\n   10 | }\n      | ^\n```\n\nThe solution is to either panic or return some error-signaling code, like this:\n\n```c\nint handle(MyType val) {\n    match(val) {\n        of(Foo) return 5;\n        of(Bar) return 7;\n    }\n\n    // Invalid input (no such variant).\n    return -1;\n}\n```\n\nSee [issue #9](https://github.com/Hirrolot/datatype99/issues/9)."
}
