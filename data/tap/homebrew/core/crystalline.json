{
  "name": "crystalline",
  "full_name": "crystalline",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Language Server Protocol implementation for Crystal",
  "license": "MIT",
  "homepage": "https://github.com/elbywan/crystalline",
  "versions": {
    "stable": "0.10.0",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/elbywan/crystalline/archive/refs/tags/v0.10.0.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "26c926ba423e4b04fc52af501cd842c8255312014fc4aa1bc3735a8cd0df3426"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": "/opt/homebrew/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/crystalline/blobs/sha256:3cb46e330dab39dad7f95b9bcb62e5cc059a5e223f8f0bbce3ebe1f78447b03f",
          "sha256": "3cb46e330dab39dad7f95b9bcb62e5cc059a5e223f8f0bbce3ebe1f78447b03f"
        },
        "arm64_monterey": {
          "cellar": "/opt/homebrew/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/crystalline/blobs/sha256:52ec44a201cf107c54393203771380e931e85f1a842e2c35f69325f19b3003fe",
          "sha256": "52ec44a201cf107c54393203771380e931e85f1a842e2c35f69325f19b3003fe"
        },
        "arm64_big_sur": {
          "cellar": "/opt/homebrew/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/crystalline/blobs/sha256:baa787f5f7ec0d5503d34740c0b487f9c9202933d652c2d6a2cf834e2352d830",
          "sha256": "baa787f5f7ec0d5503d34740c0b487f9c9202933d652c2d6a2cf834e2352d830"
        },
        "ventura": {
          "cellar": "/usr/local/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/crystalline/blobs/sha256:ebb043ac152b8423a005281c4c479dfbc52cf14bca9603cc9a50cc59973925d7",
          "sha256": "ebb043ac152b8423a005281c4c479dfbc52cf14bca9603cc9a50cc59973925d7"
        },
        "monterey": {
          "cellar": "/usr/local/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/crystalline/blobs/sha256:b62edecae1746cbc0824d08420bece5f42c703786e4240dd508c08e3d7d37d4d",
          "sha256": "b62edecae1746cbc0824d08420bece5f42c703786e4240dd508c08e3d7d37d4d"
        },
        "big_sur": {
          "cellar": "/usr/local/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/crystalline/blobs/sha256:b0398dcc4e016063f67cb5408c44a858061d735784015997e9715ba0495428fb",
          "sha256": "b0398dcc4e016063f67cb5408c44a858061d735784015997e9715ba0495428fb"
        },
        "x86_64_linux": {
          "cellar": "/home/linuxbrew/.linuxbrew/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/crystalline/blobs/sha256:4408fa4fb3a5df0272e21344d5b60656f1b14175b4c37c7b0ca5e067bf903369",
          "sha256": "4408fa4fb3a5df0272e21344d5b60656f1b14175b4c37c7b0ca5e067bf903369"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [
    "crystal",
    "libyaml"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/crystalline.rb",
  "ruby_source_checksum": {
    "sha256": "5d7a11477fa3729f9833257311697ec97405fe3593a61c9c28ac7c520d70719e"
  },
  "date_added": "2023-07-15T00:07:17+02:00",
  "readme": "<div align=\"center\">\n\t<img src=\"assets/icon.svg\" width=\"128\" height=\"128\" />\n\t<h1>crystalline</h1>\n  <h3>A Language Server for Crystal.</h3>\n  <a href=\"https://github.com/elbywan/crystalline/actions?query=branch%3Amaster+workflow%3ABuild\"><img alt=\"Build Status\" src=\"https://github.com/elbywan/crystalline/workflows/Build/badge.svg?branch=master\"></a>\n  <a href=\"https://github.com/elbywan/crystalline/tags\"><img alt=\"GitHub tag (latest SemVer)\" src=\"https://img.shields.io/github/v/tag/elbywan/crystalline\"></a>\n  <a href=\"https://github.com/elbywan/crystalline/blob/master/LICENSE\"><img alt=\"GitHub\" src=\"https://img.shields.io/github/license/elbywan/crystalline\"></a>\n</div>\n\n<hr/>\n\n**`Crystalline` is an implementation of the\n[Language Server Protocol](https://microsoft.github.io/language-server-protocol/)\nwritten in and for the [Crystal Language](https://crystal-lang.org/). It aims to\nprovide limited language features (like go-to, autocompletion, syntax and\nsemantic checking) and ease development with any compatible code editor.**\n\n**Status: in development.**\n\n<hr/>\n\n<div align=\"center\">\n<img src=\"assets/small_demo.gif\" height=\"300\" width=\"360\"/>\n</div>\n\n## Installation\n\n_Recommended method is to download and use pre-built binaries when possible.\nBuilding from source does take a long time._\n\n### Compatibility\n\n| Crystal   | Crystalline |\n| --------- | ----------- |\n| **1.9.x** | **0.10**    |\n| 1.8       | 0.9         |\n| 1.7       | 0.8         |\n| 1.6       | 0.7         |\n| 1.4       | 0.6         |\n| 1.3       | 0.5         |\n| 1.2       | 0.4         |\n| 1.1       | 0.4         |\n| 1.0       | 0.3         |\n| 0.36      | 0.2         |\n| 0.35.1    | 0.1         |\n\n### Pre-built binaries\n\n#### Latest Release\n\n##### Linux (x86_64)\n\n```sh\nwget https://github.com/elbywan/crystalline/releases/latest/download/crystalline_x86_64-unknown-linux-musl.gz -O crystalline.gz &&\\\ngzip -d crystalline.gz &&\\\nchmod u+x crystalline\n```\n\n###### ArchLinux\n\n```sh\nyay -S crystalline\n```\n\n##### MacOS\n\nInstall using [homebrew](https://brew.sh):\n\n```sh\nbrew install crystalline\n```\n\n#### Specific release\n\n[See the releases page.](https://github.com/elbywan/crystalline/releases)\n\n#### Specific commit\n\n[Binaries are uploaded as artifacts during the CI\nbuild.](https://github.com/elbywan/crystalline/actions)\n\n### Build from source\n\n**Warning: this can take a long time! (several minutes - up to 20 minutes,\ndepending on your hardware)**\n\n#### Scoped install\n\nIn the `.shard.yml` file:\n\n```yml\ndevelopment_dependencies:\n  crystalline:\n    github: elbywan/crystalline\n    branch: master\n```\n\nThen:\n\n```sh\n# Produces a binary at ./bin/crystalline\nshards build crystalline --release --no-debug --progress -Dpreview_mt\n```\n\n#### Global install\n\n```sh\ngit clone https://github.com/elbywan/crystalline\ncd crystalline\nshards install\nmkdir bin\ncrystal build ./src/crystalline.cr  -o ./bin/crystalline --release --no-debug --progress -Dpreview_mt\n```\n\n#### Known Build Issues\n\n_Potential errors when building from source._\n\n<details><summary><strong>llvm-config path</strong></summary>\n<p>\n\n`llvm` is required in order to build `crystalline`, if you get the following\nerror message it means that the crystal compiler is unable to locate the\n`llvm-config` binary:\n\n```sh\n--: : command not found\nShowing last frame. Use --error-trace for full trace.\n\nIn /usr/local/Cellar/crystal/0.35.1/src/llvm/lib_llvm.cr:13:17\n\n 13 | VERSION = {{`#{LibLLVM::LLVM_CONFIG} --version`.chomp.stringify}}\n                  ^\nError: error executing command: \"\" --version, got exit status 127\n```\n\nThis can be solved by adding the location of the `llvm-config` binary to the\n`LLVM_CONFIG` environment variable. (or the containing directory to the `PATH`\nenv. variable)\n\nFor instance on a typical macOS setup, prefixing the command with the following\ndeclaration would solve the issue:\n\n```sh\n# Prepend the command with this:\nenv LLVM_CONFIG=/usr/local/opt/llvm/bin/llvm-config\n# For Example:\nenv LLVM_CONFIG=/usr/local/opt/llvm/bin/llvm-config crystal build ./src/crystalline.cr  -o ./bin/crystalline --release --no-debug -Dpreview_mt\n```\n\n> Replace `env` by `export` on Debian and derived (Ubuntu, Mint, ...)\n\n</p>\n</details>\n\n<details><summary><strong>ld: library not found for -llibxml2.tbd</strong></summary>\n<p>\n\nLLVM **10.0.1** has some issues when reporting required system libraries on\nmacOS.\n\nMore info: [here](https://github.com/ziglang/zig/issues/6087)\n\n```sh\n# Wrong: -llibxml2.tbd\n$ llvm-config --system-libs\n-lm -lz -lcurses -llibxml2.tbd\n# `liblibxml2.tbd.dylib` is unlikely to be found during compilation,\n# hence the \"library not found\" errorâ€¦\n```\n\nA hacky solution until llvm produces a solution would be to add a symbolic link\nto the correct shared library file:\n\n`ln -s /usr/lib/libxml2.2.dylib /usr/local/lib/liblibxml2.tbd.dylib`\n\nOr just use a different LLVM major version until this issue is fixed upstream.\n\n</p>\n</details>\n\n## Usage\n\n`Crystalline` is meant to be used alongside an editor extension.\n\n#### VSCode\n\n- Add the\n  [Crystal Language extension](https://marketplace.visualstudio.com/items?itemName=crystal-lang-tools.crystal-lang).\n\n- In the configuration, type the **absolute** location of the binary in the\n  following field:\n\n![vscode screen](assets/vscode_extension_screen.png)\n\n- Reload the window by pressing CMD/CTRL + SHIFT + P and select\n  `Developer: Reload Window` (or as an alternative, restart VSCode).\n\n#### Vim/Neovim\n\nUsing Conquer of Completion we can configure Crystalline as our LSP backend and get all the features of Crystalline\nwe would get with VSCode.\n\n- Download [vim-crystal](https://github.com/vim-crystal/vim-crystal) plugin.\n- Download [CoC](https://github.com/neoclide/coc.nvim) plugin.\n- Make sure `crystalline` binary is in your PATH.\n\nAdd the following snippet to your `coc-settings.json` file:\n\n```json\n{\n\"languageserver\": {\n    \"crystal\": {\n      \"command\": \"crystalline\",\n      \"args\": [\n        \"--stdio\"\n      ],\n      \"filetypes\": [\n        \"crystal\"\n      ],\n      \"rootPatterns\": [\"shard.yml\"]\n    }\n  }\n}\n```\n\n#### Emacs\n\n- Download the `crystal-mode` [package](https://melpa.org/#/crystal-mode).\n- Download the `lsp-mode` [package](https://melpa.org/#/lsp-mode).\n- Make sure `crystalline` binary is in your PATH.\n\nAt the moment, `lsp-mode` only knows about `scry` as the Crystal language server. So, to get it working\nwith `crystalline` we need to configure `lsp-mode` to look for `crystalline`.\n\nYou can use the following config snippet to achieve this:\n```elisp\n(with-eval-after-load 'lsp-mode\n  (add-to-list 'lsp-language-id-configuration\n               '(crystal-mode . \"crystal\"))\n  (lsp-register-client\n  (make-lsp-client :new-connection (lsp-stdio-connection '(\"crystalline\"))\n                   :activation-fn (lsp-activate-on \"crystal\")\n                   :priority '1\n                   :server-id 'crystalline)))\n```\n\nThis will give higher priority to `crystalline`, and Emacs should automatically connect to the\nbackend whenever you're in `crystal-mode`.\n\n\n### Entry point\n\n**Important:** Crystalline will try to determine which file is best suited as an\nentry point when providing language features.\n\nThe default behaviour is to check the `shard.yml` file for a `target` entry\nwith the same name as the shard.\n\n```yml\nname: my_shard\n\ntargets:\n  my_shard:\n    main: src/entry.cr\n```\n\nWith the configuration above, every file required by `src/entry.cr` will use\n`src/entry.cr` as the entry point.\n\nIf this `shard.yml` entry is not present, or if the file is not part of the main\ndependency tree then `crystalline` will use the file itself as the entry point.\n\n**To override this behaviour**, you can add a configuration key in the\n`shard.yml` file.\n\n```yml\ncrystalline:\n  main: .crystalline_main.cr\n```\n\nThis can be extremely important to understand when you are writing a code\nlibrary that does not call any of its own methods - it will skip code analysis.\nIn this case, and if you are writing `specs`, you should point to a file that\nrequire the specs (or anything calling the library) and then `crystalline` will\nuse it as the entry point.\n\n```crystal\n# Contents of a file at the root of the project.\n# Will require the specs that call the library methods and enable the code analysis.\nrequire \"./spec/**\"\n```\n\n## Features\n\n**Disclaimer: `Crystalline` is not as extensive in terms of features as other\nLanguage Servers but still provides very convenient tools.**\n\n#### Code Diagnostics\n\nSyntax and semantic checks on save.\n\n#### Limited Autocompletion\n\nList (depending on the target) method definitions, macros or module/class/struct\nnames or symbols available in the current context.\n\n#### Formatting\n\nA whole document or a text selection.\n\n#### Go to definition\n\nBy clicking on a symbol with the Cmd or Ctrl key pressed (editor/platform\ndependent).\n\n#### Hover information\n\nHovering should display (when possible) either a variable type, a function\ndefinition signature or the expanded macro.\n\n#### Document symbols\n\nFetch all the symbols in a given file, used in VSCode to populate the Outline\nview and the Breadcrumbs.\n\n## Limitations\n\n- Memory usage is high due to the boehm GC behaviour and the crystal compiler\n  itself. See: https://github.com/elbywan/crystalline/issues/23\n\n- Due to Crystal having a wide type inference system (which is incredibly\n  convenient and practical), compilation times can unfortunately be relatively\n  long for big projects and depending on the hardware. This means that the LSP\n  will be stuck waiting for the compiler to finish before being able to provide\n  a response. Crystalline tries to mitigate that by caching compilation outcome\n  when possible.\n\n- Methods that are not called anywhere will not be analyzed, as this is how the\n  Crystal compiler works.\n\n- The parser is not permissive, nor incremental which means that the features\n  will sometimes not work. It would involve a massive amount of work to change\n  that.\n\n## Development\n\n### Dev build\n\n[Sentry](https://github.com/samueleaton/sentry) is used to re-build crystalline\nin debug mode on code change.\n\n```sh\n# To build sentry (once):\nshards build --release sentry\n# Then, to launch it and watch the filesystem:\n./bin/sentry -i\n```\n\n### Logs\n\nLogging is the most practical way to debug the LSP.\n\n```crystal\n# Use the LSP logger to display logs in the editor.\nLSP::Log.info { \"log\" }\n```\n\nDebug logs are deactivated by default, uncomment this line in\n`src/crystalline/lsp/server.cr` to enable them:\n\n```crystal\n# Uncomment:\n# ::Log.setup(:debug, LSP::Log.backend.not_nil!)\n```\n\n## Contributing\n\n1. Fork it (<https://github.com/elbywan/crystalline/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n**Please always `crystal tool format` your code!**\n\n## [Contributors](https://github.com/elbywan/crystalline/graphs/contributors)\n\n## Credit\n\n- [Scry](https://github.com/crystal-lang-tools/scry), the original LSP for\n  Crystal has been a great source of inspiration. I also re-used tiny bits of\n  code from there.\n- Icon made by [Smashicons](https://www.flaticon.com/authors/smashicons) from\n  [www.flaticon.com](https://www.flaticon.com).\n\n## Trivia\n\n#### Why the name `crystalline`?\n\nAside of the obvious reasons (crystal-lang), `cristaline` is a famous bottled\nwater brand in France that published silly TV commercials. It is pronounced the\nsame as `crystalline`.\n\n![guy roux](assets/guyroux.gif)"
}
