{
  "name": "libomemo-c",
  "full_name": "libomemo-c",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Implementation of Signal's ratcheting forward secrecy protocol",
  "license": "GPL-3.0-only",
  "homepage": "https://github.com/dino/libomemo-c",
  "versions": {
    "stable": "0.5.0",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/dino/libomemo-c/archive/refs/tags/v0.5.0.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "03195a24ef7a86c339cdf9069d7f7569ed511feaf55e853bfcb797d2698ba983"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libomemo-c/blobs/sha256:dccc667b31642b280a1ae140c1626efc9a407476f9223008520a78282842478b",
          "sha256": "dccc667b31642b280a1ae140c1626efc9a407476f9223008520a78282842478b"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libomemo-c/blobs/sha256:c90a3715e044536c4650463c4a1def1c66b3cd31231cae668d3bfa2e6c616218",
          "sha256": "c90a3715e044536c4650463c4a1def1c66b3cd31231cae668d3bfa2e6c616218"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libomemo-c/blobs/sha256:ade5ce2ed49545cd401c2f96ef600f36efa1a41701ecd4c3783bed067a66846b",
          "sha256": "ade5ce2ed49545cd401c2f96ef600f36efa1a41701ecd4c3783bed067a66846b"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libomemo-c/blobs/sha256:91d4e7871b7e7f3cac1352590e5da0f6a0ba2e29194d4f5c37c9f4743c2107ca",
          "sha256": "91d4e7871b7e7f3cac1352590e5da0f6a0ba2e29194d4f5c37c9f4743c2107ca"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libomemo-c/blobs/sha256:dfdf9c205d14096770df1c4e7ce0b45e857f379c3ce3d23b14f8f7e09c93afad",
          "sha256": "dfdf9c205d14096770df1c4e7ce0b45e857f379c3ce3d23b14f8f7e09c93afad"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libomemo-c/blobs/sha256:345ad0738741a9d382abd1ac18116128c68f4774785cda97966f9c89fca86693",
          "sha256": "345ad0738741a9d382abd1ac18116128c68f4774785cda97966f9c89fca86693"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/libomemo-c/blobs/sha256:222d7b3ada83cc778fb993e4706db5e6b03891379ad8c0f8272f6cb5693c01c0",
          "sha256": "222d7b3ada83cc778fb993e4706db5e6b03891379ad8c0f8272f6cb5693c01c0"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake"
  ],
  "dependencies": [
    "protobuf-c"
  ],
  "test_dependencies": [
    "pkg-config"
  ],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/libomemo-c.rb",
  "ruby_source_checksum": {
    "sha256": "db9ee31422ed852bb611690cf0f230c68a5ee0a0da68af005248929159fac360"
  },
  "date_added": "2023-05-21T13:05:08+02:00",
  "readme": "# Overview\n\nThis is a fork of [libsignal-protocol-c](https://github.com/whispersystems/libsignal-protocol-c),\nan implementation of Signal's ratcheting forward secrecy protocol that works in synchronous and\nasynchronous messaging.\nThe fork adds support for OMEMO as defined in [XEP-0384](https://xmpp.org/extensions/xep-0384.html)\nversions 0.3.0 and later.\n\n- OMEMO version 0.3.0 uses the original libsignal-protocol-c implementation with its protocol versions 2 and 3.\n- OMEMO version 0.4.0+ is implemented using a new protocol version 4 internally. In comparison with protocol version 3, it changes:\n  - HKDF info strings\n  - Protocol buffer encoding\n  - Signature scheme (uses XEd25519 instead of custom \"Curve25519 signatures\")\n  - Specification-compliant double ratchet\n  - Support for Ed25519 public keys\n  - Various serializations\n  - Removes unused functionality\n\n# Building libomemo-c\n\n## Development host setup\n\n### Build dependencies\n\n* [CMake](https://cmake.org/) 2.8.4 or higher\n* [Check *1](https://libcheck.github.io/check/)\n* [OpenSSL *1](https://www.openssl.org/) 1.0 or higher\n * On MacOS X, [Common Crypto](https://developer.apple.com/library/content/documentation/Security/Conceptual/cryptoservices/GeneralPurposeCrypto/GeneralPurposeCrypto.html) is used instead of OpenSSL\n* [LCOV *2](http://ltp.sourceforge.net/coverage/lcov.php)\n\nMost of these dependencies are required just for the unit test suite and\ndevelopment of the library itself. When integrating into actual applications,\nyou should not need anything beyond CMake. Alternatively, you may integrate\nthe code using a build system of your choice.\nItems marked with *1 are required for tests, with *2 are additionally required for code coverage.\n\n### Setting up a fresh source tree\n\n    $ cd /path/to/libomemo-c\n    $ mkdir build\n    $ cd build\n    $ cmake -DCMAKE_BUILD_TYPE=Debug ..\n    $ make\n\n### Running the unit tests\n\n    $ cd /path/to/libomemo-c/build\n    $ cmake -DCMAKE_BUILD_TYPE=Debug -DBUILD_TESTING=1 ..\n    $ cd tests\n    $ make\n    $ cd ..\n    $ ctest\n\n### Creating the code coverage report\n\n    $ cd /path/to/libomemo-c/build\n    $ cmake -DCMAKE_BUILD_TYPE=Debug -DBUILD_TESTING=1 -DCOVERAGE=1 ..\n    $ make coverage\n\nThe generated code coverage report can be found in:\n`/path/to/libomemo-c/build/coverage`\n\n### Eclipse project setup\n\nCMake provides a tutorial on Eclipse project setup here:\nhttps://cmake.org/Wiki/CMake:Eclipse_UNIX_Tutorial\n\nIt is recommended to follow the more manual \"Option 2,\" since the Eclipse\nproject generator built into CMake tends to be outdated and leads you toward\na very awkward and occasionally broken project configuration.\n\n### Protocol Buffers compiler\n\nThis project uses serialization code based on [Protocol Buffers](https://github.com/google/protobuf).\nSince the official library does not support C, the [protobuf-c](https://github.com/protobuf-c/protobuf-c)\ngenerator is used instead. For the sake of convenience, the generated code and its dependencies are\nincluded in the source tree. The generated code can be regenerated at any time by installing the two\nmentioned packages and running \"make\" in the \"protobuf/\" subdirectory.\n\n## Target platforms\n\nCMake toolchain files have been included from the following sources:\n\n* [iOS](https://code.google.com/archive/p/ios-cmake)\n* [BlackBerry 10](https://github.com/blackberry/OGRE/blob/master/src/CMake/toolchain/blackberry.toolchain.cmake)\n\n# Using libomemo-c\n\n## Library initialization\n\nBefore using the library, a libomemo-c client needs to initialize a global\ncontext. This global context is used to provide callbacks for implementations\nof functions used across the library that need client-specific implementations.\nRefer to \"signal_protocol.h\" for detailed documentation on these functions, and the unit\ntests for example implementations.\n\n```c\nsignal_context *global_context;\nsignal_context_create(&global_context, user_data);\nsignal_context_set_crypto_provider(global_context, &provider);\nsignal_context_set_locking_functions(global_context, lock_function, unlock_function);\n```\n\n## Client install time\n\nAt install time, a libomemo-c client needs to generate its identity keys,\nregistration id, and prekeys.\n\n```c\nratchet_identity_key_pair *identity_key_pair;\nuint32_t registration_id;\nsignal_protocol_key_helper_pre_key_list_node *pre_keys_head;\nsession_signed_pre_key *signed_pre_key;\n\nsignal_protocol_key_helper_generate_identity_key_pair(&identity_key_pair, global_context);\nsignal_protocol_key_helper_generate_registration_id(&registration_id, 0, global_context);\nsignal_protocol_key_helper_generate_pre_keys(&pre_keys_head, start_id, 100, global_context);\nsignal_protocol_key_helper_generate_signed_pre_key(&signed_pre_key, identity_key_pair, 5, timestamp, global_context);\n\n/* Store identity_key_pair somewhere durable and safe. */\n/* Store registration_id somewhere durable and safe. */\n\n/* Store pre keys in the pre key store. */\n/* Store signed pre key in the signed pre key store. */\n```\n\nThe above example is simplified for the sake of clarity. All of these functions return errors\non failure, and those errors should be checked for in real usage.\n\nThere are also iteration and serialization methods for the above types that should\nbe used as appropriate.\n\n## Building a session\n\nA libomemo-c client needs to implement four data store callback interfaces:\n`signal_protocol_identity_key_store`, `signal_protocol_pre_key_store`,\n`signal_protocol_signed_pre_key_store`, and `signal_protocol_session_store`.\nThese will manage loading and storing of identity, prekeys, signed prekeys,\nand session state.\n\nThese callback interfaces are designed such that implementations should treat\nall data flowing through them as opaque binary blobs. Anything necessary for\nreferencing that data will be provided as separate function arguments to those\ncallbacks. If it is ever necessary for clients to directly access stored data\nin terms of library data structures, they should use the accessor functions\ndeclared in \"signal_protocol.h\" for these data stores.\n\nOnce the callbacks for these data stores are implemented, building a session\nis fairly straightforward:\n\n```c\n/* Create the data store context, and add all the callbacks to it */\nsignal_protocol_store_context *store_context;\nsignal_protocol_store_context_create(&store_context, global_context);\nsignal_protocol_store_context_set_session_store(store_context, &session_store);\nsignal_protocol_store_context_set_pre_key_store(store_context, &pre_key_store);\nsignal_protocol_store_context_set_signed_pre_key_store(store_context, &signed_pre_key_store);\nsignal_protocol_store_context_set_identity_key_store(store_context, &identity_key_store);\n\n/* Instantiate a session_builder for a recipient address. */\nsignal_protocol_address address = {\n    \"+14159998888\", 12, 1\n};\nsession_builder *builder;\nsession_builder_create(&builder, store_context, &address, global_context);\nsession_builder_set_version(builder, 4);\n\n/* Build a session with a pre key retrieved from the server. */\nsession_builder_process_pre_key_bundle(builder, retrieved_pre_key);\n\n/* Create the session cipher and encrypt the message */\nsession_cipher *cipher;\nsession_cipher_create(&cipher, store_context, &address, global_context);\nsession_cipher_set_version(cipher, 4);\n\nciphertext_message *encrypted_message;\nsession_cipher_encrypt(cipher, message, message_len, &encrypted_message);\n\n/* Get the serialized content and deliver it */\nsignal_buffer *serialized = ciphertext_message_get_serialized(encrypted_message);\n\ndeliver(signal_buffer_data(serialized), signal_buffer_len(serialized));\n\n/* Cleanup */\nSIGNAL_UNREF(encrypted_message);\nsession_cipher_free(cipher);\nsession_builder_free(builder);\nsignal_protocol_store_context_destroy(store_context);\n```\n\nThe above example is simplified for the sake of clarity. All of these functions return errors\non failure, and those errors should be checked for in real usage.\nNote that the calls to `session_builder_set_version` and `session_cipher_set_version` are only required\nwhen a the session should be set up for OMEMO version 0.4.0 or later.\n\n## Memory management notes\n\nFor every custom data type that the libomemo-c library can allocate and\nreturn, a corresponding way of deallocating an instance of that data type\nis provided.\n\nThe more basic and higher level data types provide a type-specific free or\ndestroy function. These types include `signal_context`,\n`signal_protocol_store_context`, `signal_buffer`, `signal_buffer_list`,\n`signal_int_list`, `signal_protocol_key_helper_pre_key_list_node`, `session_builder`,\n`session_cipher`, `group_session_builder`, `group_cipher`, and\n`fingerprint_generator`.\n\nMost of the other data types, including everything internal, use a reference\ncounting mechanism. If you are going to hold onto a reference to one of these\ntypes, use the `SIGNAL_REF(x)` macro to increment its count. If you are done\nwith a reference, use `SIGNAL_UNREF(x)` to decrement its count. When the count\nreaches 0, the type's destructor function is called.\n\n# Legal things\n## Cryptography Notice\n\nThis distribution includes cryptographic software. The country in which you currently reside may have restrictions on the import, possession, use, and/or re-export to another country, of encryption software.\nBEFORE using any encryption software, please check your country's laws, regulations and policies concerning the import, possession, or use, and re-export of encryption software, to see if this is permitted.\nSee <http://www.wassenaar.org/> for more information.\n\nThe U.S. Government Department of Commerce, Bureau of Industry and Security (BIS), has classified this software as Export Commodity Control Number (ECCN) 5D002.C.1, which includes information security software using or performing cryptographic functions with asymmetric algorithms.\nThe form and manner of this distribution makes it eligible for export under the License Exception ENC Technology Software Unrestricted (TSU) exception (see the BIS Export Administration Regulations, Section 740.13) for both object code and source code.\n\n## License\n```\nCopyright 2015-2016 Open Whisper Systems\nCopyright 2020-2022 Dino Team\n\nLicensed under the GPLv3: http://www.gnu.org/licenses/gpl-3.0.html\n\nAdditional Permissions For Submission to Apple App Store: Provided that you are otherwise in compliance with the GPLv3 for each covered work you convey (including without limitation making the Corresponding Source available in compliance with Section 6 of the GPLv3), Open Whisper Systems also grants you the additional permission to convey through the Apple App Store non-source executable versions of the Program as incorporated into each applicable covered work as Executable Versions only under the Mozilla Public License version 2.0 (https://www.mozilla.org/en-US/MPL/2.0/).\n```"
}
