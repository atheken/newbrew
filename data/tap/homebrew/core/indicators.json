{
  "name": "indicators",
  "full_name": "indicators",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Activity indicators for modern C++",
  "license": "MIT",
  "homepage": "https://github.com/p-ranav/indicators",
  "versions": {
    "stable": "2.3",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/p-ranav/indicators/archive/v2.3.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "70da7a693ff7a6a283850ab6d62acf628eea17d386488af8918576d0760aef7b"
    },
    "head": {
      "url": "https://github.com/p-ranav/indicators.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "all": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/indicators/blobs/sha256:722fdcb2c0acf2eb576eaec0f91171d503b65c10910ec70abf1bf50bd45979bf",
          "sha256": "722fdcb2c0acf2eb576eaec0f91171d503b65c10910ec70abf1bf50bd45979bf"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/indicators.rb",
  "ruby_source_checksum": {
    "sha256": "b46f06c65cfdc3756c242895aa114cea0a1f291ccc49a13e579ce2d9fe9f26b6"
  },
  "date_added": "2021-01-09T13:28:25+00:00",
  "readme": "<p align=\"center\">\n  <img height=\"70\" src=\"img/logo.png\"/>  \n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.codacy.com/manual/p-ranav/indicators?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=p-ranav/indicators&amp;utm_campaign=Badge_Grade\">\n    <img src=\"https://api.codacy.com/project/badge/Grade/93401e73f250407cb32445afec4e3e99\" alt=\"codacy\"/>\n  </a>\n  <a href=\"https://github.com/p-ranav/indicators/blob/master/LICENSE\">\n    <img src=\"https://img.shields.io/badge/License-MIT-yellow.svg\" alt=\"license\"/>\n  </a>\n  <img src=\"https://img.shields.io/badge/version-2.3-blue.svg?cacheSeconds=2592000\" alt=\"version\"/>\n</p>\n\n\n<p align=\"center\">\n  <img src=\"img/demo.gif\"/> \n</p>\n\n## Highlights\n\n* Thread-safe progress bars and spinners\n* Header-only library. Grab a copy of `include/indicators`. \n* Single-header version in `single_include/indicators`.\n* Source for the above GIF can be found [here](demo/demo.cpp)\n* MIT License\n\n## Table of Contents\n\n*    Supported Indicators\n     *    [Basic Progress Bar](#basic-progress-bar)\n     *    [Indeterminate Progress Bar](#indeterminate-progress-bar)\n     *    [Block Progress Bar](#block-progress-bar)\n     *    [Multi Progress](#multiprogress)\n     *    [Dynamic Progress](#dynamicprogress)\n     *    [Progress Spinner](#progress-spinner)\n*    Additional Samples\n     *    [Decremental Progress](#decremental-progress)\n     *    [Working with Iterables](#working-with-iterables)\n     *    [Unicode Support](#unicode-support)\n*    [Building Samples](#building-samples)\n*    [Generating Single Header](#generating-single-header)\n*    [Contributing](#contributing)\n*    [License](#license)\n\n## Basic Progress bar\n\nTo introduce a progress bar in your application, include `indicators/progress_bar.hpp` and create a `ProgressBar` object. Here's the general structure of a progress bar:\n\n```\n{prefix} {start} {fill} {lead} {remaining} {end} {percentage} [{elapsed}<{remaining}] {postfix}\n         ^^^^^^^^^^^^^ Bar Width ^^^^^^^^^^^^^^^   \n```\n\nThe amount of progress in ProgressBar is maintained as a `size_t` in range `[0, 100]`. When progress reaches 100, the progression is complete. \n\nFrom application-level code, there are two ways in which you can update this progress:\n\n### Update progress using `bar.tick()`\n\nYou can update the progress bar using `bar.tick()` which increments progress by exactly `1%`.\n\n<p align=\"center\">\n  <img src=\"img/progress_bar_tick.gif\"/>  \n</p>\n\n```cpp\n#include <indicators/progress_bar.hpp>\n#include <thread>\n#include <chrono>\n\nint main() {\n  using namespace indicators;\n  ProgressBar bar{\n    option::BarWidth{50},\n    option::Start{\"[\"},\n    option::Fill{\"=\"},\n    option::Lead{\">\"},\n    option::Remainder{\" \"},\n    option::End{\"]\"},\n    option::PostfixText{\"Extracting Archive\"},\n    option::ForegroundColor{Color::green},\n    option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}\n  };\n  \n  // Update bar state\n  while (true) {\n    bar.tick();\n    if (bar.is_completed())\n      break;\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n  }\n\n  return 0;\n}\n```\n\nThe above code will print a progress bar that goes from 0 to 100% at the rate of 1% every 100 ms.\n\n### Updating progress using `bar.set_progress(value)`\n\nIf you'd rather control progress of the bar in discrete steps, consider using `bar.set_progress(value)`. Example:\n\n\n<p align=\"center\">\n  <img src=\"img/progress_bar_set_progress.gif\"/>  \n</p>\n\n```cpp\n#include <chrono>\n#include <indicators/cursor_control.hpp>\n#include <indicators/progress_bar.hpp>\n#include <thread>\n\nint main() {\n  using namespace indicators;\n\n  // Hide cursor\n  show_console_cursor(false);\n\n  ProgressBar bar{\n    option::BarWidth{50},\n    option::Start{\"[\"},\n    option::Fill{\"■\"},\n    option::Lead{\"■\"},\n    option::Remainder{\"-\"},\n    option::End{\" ]\"},\n    option::PostfixText{\"Loading dependency 1/4\"},\n    option::ForegroundColor{Color::cyan},\n    option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}\n  };\n\n  // Update bar state\n  bar.set_progress(10); // 10% done\n\n  // do some work\n  std::this_thread::sleep_for(std::chrono::milliseconds(800));\n\n  bar.set_option(option::PostfixText{\"Loading dependency 2/4\"});  \n\n  bar.set_progress(30); // 30% done\n\n  // do some more work\n  std::this_thread::sleep_for(std::chrono::milliseconds(700));\n\n  bar.set_option(option::PostfixText{\"Loading dependency 3/4\"});  \n\n  bar.set_progress(65); // 65% done\n\n  // do final bit of work\n  std::this_thread::sleep_for(std::chrono::milliseconds(900));\n\n  bar.set_option(option::PostfixText{\"Loaded dependencies!\"});\n\n  bar.set_progress(100); // all done\n\n  // Show cursor\n  show_console_cursor(true);\n\n  return 0;\n}\n```\n\n### Showing Time Elapsed/Remaining\n\nAll progress bars and spinners in `indicators` support showing time elapsed and time remaining. Inspired by python's [tqdm](https://github.com/tqdm/tqdm) module, the format of this meter is `[{elapsed}<{remaining}]`:\n\n<p align=\"center\">\n  <img src=\"img/time_meter.gif\"/>  \n</p>\n\n```cpp\n#include <chrono>\n#include <indicators/cursor_control.hpp>\n#include <indicators/progress_bar.hpp>\n#include <thread>\n\nint main() {\n  using namespace indicators;\n\n  // Hide cursor\n  show_console_cursor(false);\n\n  indicators::ProgressBar bar{\n    option::BarWidth{50},\n    option::Start{\" [\"},\n    option::Fill{\"█\"},\n    option::Lead{\"█\"},\n    option::Remainder{\"-\"},\n    option::End{\"]\"},\n    option::PrefixText{\"Training Gaze Network 👀\"},\n    option::ForegroundColor{Color::yellow},\n    option::ShowElapsedTime{true},\n    option::ShowRemainingTime{true},\n    option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}\n  };\n\n  // Update bar state\n  while (true) {\n    bar.tick();\n    if (bar.is_completed())\n      break;\n    std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n  }\n\n  // Show cursor\n  show_console_cursor(true);\n\n  return 0;\n}\n```\n\n## Indeterminate Progress Bar\n\nYou might have a use-case for a progress bar where the maximum amount of progress is unknown, e.g., you're downloading from a remote server that isn't advertising the total bytes. \n\nUse an `indicators::IndeterminateProgressBar` for such cases. An `IndeterminateProgressBar` is similar to a regular progress bar except the total amount to progress towards is unknown. Ticking on this progress bar will happily run forever. \n\nWhen you know progress is complete, simply call `bar.mark_as_completed()`. \n\n<p align=\"center\">\n  <img src=\"img/indeterminate_progress_bar.gif\"/>  \n</p>\n\n```cpp\n#include <chrono>\n#include <indicators/indeterminate_progress_bar.hpp>\n#include <indicators/cursor_control.hpp>\n#include <indicators/termcolor.hpp>\n#include <thread>\n\nint main() {\n  indicators::IndeterminateProgressBar bar{\n      indicators::option::BarWidth{40},\n      indicators::option::Start{\"[\"},\n      indicators::option::Fill{\"·\"},\n      indicators::option::Lead{\"<==>\"},\n      indicators::option::End{\"]\"},\n      indicators::option::PostfixText{\"Checking for Updates\"},\n      indicators::option::ForegroundColor{indicators::Color::yellow},\n      indicators::option::FontStyles{\n          std::vector<indicators::FontStyle>{indicators::FontStyle::bold}}\n  };\n\n  indicators::show_console_cursor(false);\n\n  auto job = [&bar]() {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10000));\n    bar.mark_as_completed();\n    std::cout << termcolor::bold << termcolor::green \n        << \"System is up to date!\\n\" << termcolor::reset;\n  };\n  std::thread job_completion_thread(job);\n\n  // Update bar state\n  while (!bar.is_completed()) {\n    bar.tick();\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n  }\n\n  job_completion_thread.join();\n  \n  indicators::show_console_cursor(true);  \n  return 0;\n}\n```\n\n## Block Progress Bar\n\nAre you in need of a smooth block progress bar using [unicode block elements](https://en.wikipedia.org/wiki/Block_Elements)? Use `BlockProgressBar` instead of `ProgressBar`. Thanks to [this blog post](https://mike42.me/blog/2018-06-make-better-cli-progress-bars-with-unicode-block-characters) for making `BlockProgressBar` an easy addition to the library. \n\n<p align=\"center\">\n  <img src=\"img/block_progress_bar.gif\"/>  \n</p>\n\n```cpp\n#include <indicators/block_progress_bar.hpp>\n#include <indicators/cursor_control.hpp>\n#include <thread>\n#include <chrono>\n\nint main() {\n\n  using namespace indicators;\n\n  // Hide cursor\n  show_console_cursor(false);\n\n  BlockProgressBar bar{\n    option::BarWidth{80},\n    option::Start{\"[\"},\n    option::End{\"]\"},\n    option::ForegroundColor{Color::white}  ,\n    option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}\n  };\n  \n  // Update bar state\n  auto progress = 0.0f;\n  while (true) {\n    bar.set_progress(progress);\n    progress += 0.25f;\n    if (bar.is_completed())\n      break;\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n  }\n\n  // Show cursor\n  show_console_cursor(true);\n\n  return 0;\n}\n```\n\n## MultiProgress\n\n`indicators` supports management of multiple progress bars with the `MultiProgress` class template. \n\n`template <typename Indicator, size_t count> class MultiProgress` is a class template that holds references to multiple progress bars and provides a safe interface to update the state of each bar. `MultiProgress` works with both `ProgressBar` and `BlockProgressBar` classes.\n\nUse this class if you know the number of progress bars to manage at compile time.\n\nBelow is an example `MultiProgress` object that manages three `ProgressBar` objects.\n\n<p align=\"center\">\n  <img src=\"img/multi_progress.gif\"/>  \n</p>\n\n```cpp\n#include <indicators/multi_progress.hpp>\n#include <indicators/progress_bar.hpp>\n\nint main() {\n  using namespace indicators;\n  // Configure first progress bar\n  ProgressBar bar1{\n    option::BarWidth{50},\n    option::Start{\"[\"},\n    option::Fill{\"■\"},\n    option::Lead{\"■\"},\n    option::Remainder{\" \"},\n    option::End{\" ]\"},\n    option::ForegroundColor{Color::yellow},\n    option::ShowElapsedTime{true},\n    option::ShowRemainingTime{true},\n    option::PrefixText{\"Progress Bar #1 \"},\n    option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}\n  };\n\n  // Configure second progress bar\n\n  ProgressBar bar2{\n    option::BarWidth{50},\n    option::Start{\"[\"},\n    option::Fill{\"=\"},\n    option::Lead{\">\"},\n    option::Remainder{\" \"},\n    option::End{\" ]\"},\n    option::ForegroundColor{Color::cyan},\n    option::ShowElapsedTime{true},\n    option::ShowRemainingTime{true},\n    option::PrefixText{\"Progress Bar #2 \"},\n    option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}\n  };\n  \n  // Configure third progress bar\n  indicators::ProgressBar bar3{\n    option::BarWidth{50},\n    option::Start{\"[\"},\n    option::Fill{\"#\"},\n    option::Lead{\"#\"},\n    option::Remainder{\" \"},\n    option::End{\" ]\"},\n    option::ForegroundColor{Color::red},\n    option::ShowElapsedTime{true},\n    option::ShowRemainingTime{true},\n    option::PrefixText{\"Progress Bar #3 \"},\n    option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}\n  };\n\n  // Construct MultiProgress object\n  indicators::MultiProgress<indicators::ProgressBar, 3> bars(bar1, bar2, bar3);\n\n  std::cout << \"Multiple Progress Bars:\\n\";\n\n  auto job1 = [&bars]() {\n    while (true) {\n      bars.tick<0>();\n      if (bars.is_completed<0>())\n        break;\n      std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n  };\n\n  auto job2 = [&bars]() {\n    while (true) {\n      bars.tick<1>();\n      if (bars.is_completed<1>())\n        break;\n      std::this_thread::sleep_for(std::chrono::milliseconds(200));\n    }\n  };\n\n  auto job3 = [&bars]() {\n    while (true) {\n      bars.tick<2>();\n      if (bars.is_completed<2>())\n        break;\n      std::this_thread::sleep_for(std::chrono::milliseconds(60));\n    }\n  };\n\n  std::thread first_job(job1);\n  std::thread second_job(job2);\n  std::thread third_job(job3);\n\n  first_job.join();\n  second_job.join();\n  third_job.join();\n\n  return 0;\n}\n```\n\n## DynamicProgress\n\n`DynamicProgress` is a container class, similar to `MultiProgress`, for managing multiple progress bars. As the name suggests, with `DynamicProgress`, you can dynamically add new progress bars. \n\nTo add new progress bars, call `bars.push_back(new_bar)`. This call will return the index of the appended bar. You can then refer to this bar with the indexing operator, e.g., `bars[4].set_progress(55)`.  \n\nUse this class if you don't know the number of progress bars at compile time.\n\nBelow is an example `DynamicProgress` object that manages six `ProgressBar` objects. Three of these bars are added dynamically.\n\n<p align=\"center\">\n  <img src=\"img/dynamic_progress_bar.gif\"/>  \n</p>\n\n```cpp\n#include <indicators/dynamic_progress.hpp>\n#include <indicators/progress_bar.hpp>\nusing namespace indicators;\n\nint main() {\n\n  ProgressBar bar1{option::BarWidth{50}, option::ForegroundColor{Color::red},\n                   option::ShowElapsedTime{true}, option::ShowRemainingTime{true},\n                   option::PrefixText{\"5c90d4a2d1a8: Downloading \"}};\n\n  ProgressBar bar2{option::BarWidth{50}, option::ForegroundColor{Color::yellow},\n                   option::ShowElapsedTime{true}, option::ShowRemainingTime{true},\n                   option::PrefixText{\"22337bfd13a9: Downloading \"}};\n\n  ProgressBar bar3{option::BarWidth{50}, option::ForegroundColor{Color::green},\n                   option::ShowElapsedTime{true}, option::ShowRemainingTime{true},\n                   option::PrefixText{\"10f26c680a34: Downloading \"}};\n\n  ProgressBar bar4{option::BarWidth{50}, option::ForegroundColor{Color::white},\n                   option::ShowElapsedTime{true}, option::ShowRemainingTime{true},\n                   option::PrefixText{\"6364e0d7a283: Downloading \"}};\n\n  ProgressBar bar5{option::BarWidth{50}, option::ForegroundColor{Color::blue},\n                   option::ShowElapsedTime{true}, option::ShowRemainingTime{true},\n                   option::PrefixText{\"ff1356ba118b: Downloading \"}};\n\n  ProgressBar bar6{option::BarWidth{50}, option::ForegroundColor{Color::cyan},\n                   option::ShowElapsedTime{true}, option::ShowRemainingTime{true},\n                   option::PrefixText{\"5a17453338b4: Downloading \"}};\n\n  std::cout << termcolor::bold << termcolor::white << \"Pulling image foo:bar/baz\\n\";\n\n  // Construct with 3 progress bars. We'll add 3 more at a later point\n  DynamicProgress<ProgressBar> bars(bar1, bar2, bar3);\n  \n  // Do not hide bars when completed\n  bars.set_option(option::HideBarWhenComplete{false});\n\n  std::thread fourth_job, fifth_job, sixth_job;\n\n  auto job4 = [&bars](size_t i) {\n    while (true) {\n      bars[i].tick();\n      if (bars[i].is_completed()) {\n        bars[i].set_option(option::PrefixText{\"6364e0d7a283: Pull complete \"});\n        bars[i].mark_as_completed();\n        break;\n      }\n      std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    }\n  };\n\n  auto job5 = [&bars](size_t i) {\n    while (true) {\n      bars[i].tick();\n      if (bars[i].is_completed()) {\n        bars[i].set_option(option::PrefixText{\"ff1356ba118b: Pull complete \"});\n        bars[i].mark_as_completed();\n        break;\n      }\n      std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n  };\n\n  auto job6 = [&bars](size_t i) {\n    while (true) {\n      bars[i].tick();\n      if (bars[i].is_completed()) {\n        bars[i].set_option(option::PrefixText{\"5a17453338b4: Pull complete \"});\n        bars[i].mark_as_completed();\n        break;\n      }\n      std::this_thread::sleep_for(std::chrono::milliseconds(40));\n    }\n  };\n\n  auto job1 = [&bars, &bar6, &sixth_job, &job6]() {\n    while (true) {\n      bars[0].tick();\n      if (bars[0].is_completed()) {\n        bars[0].set_option(option::PrefixText{\"5c90d4a2d1a8: Pull complete \"});\n        // bar1 is completed, adding bar6\n        auto i = bars.push_back(bar6);\n        sixth_job = std::thread(job6, i);\n        sixth_job.join();\n        break;\n      }\n      std::this_thread::sleep_for(std::chrono::milliseconds(140));\n    }\n  };\n\n  auto job2 = [&bars, &bar5, &fifth_job, &job5]() {\n    while (true) {\n      bars[1].tick();\n      if (bars[1].is_completed()) {\n        bars[1].set_option(option::PrefixText{\"22337bfd13a9: Pull complete \"});\n        // bar2 is completed, adding bar5\n        auto i = bars.push_back(bar5);\n        fifth_job = std::thread(job5, i);\n        fifth_job.join();\n        break;\n      }\n      std::this_thread::sleep_for(std::chrono::milliseconds(25));\n    }\n  };\n\n  auto job3 = [&bars, &bar4, &fourth_job, &job4]() {\n    while (true) {\n      bars[2].tick();\n      if (bars[2].is_completed()) {\n        bars[2].set_option(option::PrefixText{\"10f26c680a34: Pull complete \"});\n        // bar3 is completed, adding bar4\n        auto i = bars.push_back(bar4);\n        fourth_job = std::thread(job4, i);\n        fourth_job.join();\n        break;\n      }\n      std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    }\n  };\n\n  std::thread first_job(job1);\n  std::thread second_job(job2);\n  std::thread third_job(job3);\n\n  third_job.join();\n  second_job.join();\n  first_job.join();\n\n  std::cout << termcolor::bold << termcolor::green << \"✔ Downloaded image foo/bar:baz\" << std::endl;\n  std::cout << termcolor::reset;\n\n  return 0;\n}\n```\n\nIn the above code, notice the option `bars.set_option(option::HideBarWhenComplete{true});`. Yes, you can hide progress bars as and when they complete by setting this option to `true`. If you do so, the above example will look like this:\n\n<p align=\"center\">\n  <img src=\"img/dynamic_progress_bar_hide_completed.gif\"/>  \n</p>\n\n## Progress Spinner\n\nTo introduce a progress spinner in your application, include `indicators/progress_spinner.hpp` and create a `ProgressSpinner` object. Here's the general structure of a progress spinner:\n\n```\n{prefix} {spinner} {percentage} [{elapsed}<{remaining}] {postfix}\n```\n\nProgressSpinner has a vector of strings: `spinner_states`. At each update, the spinner will pick the next string from this sequence to print to the console. The spinner state can be updated similarly to ProgressBars: Using either `tick()` or `set_progress(value)`. \n\n<p align=\"center\">\n  <img src=\"img/progress_spinner.gif\"/>  \n</p>\n\n```cpp\n#include <indicators/progress_spinner.hpp>\n\nint main() {\n  using namespace indicators;\n  indicators::ProgressSpinner spinner{\n    option::PostfixText{\"Checking credentials\"},\n    option::ForegroundColor{Color::yellow},\n    option::SpinnerStates{std::vector<std::string>{\"⠈\", \"⠐\", \"⠠\", \"⢀\", \"⡀\", \"⠄\", \"⠂\", \"⠁\"}},\n    option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}\n  };\n \n  // Update spinner state\n  auto job = [&spinner]() {\n    while (true) {\n      if (spinner.is_completed()) {\n        spinner.set_option(option::ForegroundColor{Color::green});\n        spinner.set_option(option::PrefixText{\"✔\"});\n        spinner.set_option(option::ShowSpinner{false});\n        spinner.set_option(option::ShowPercentage{false});\n        spinner.set_option(option::PostfixText{\"Authenticated!\"});\n        spinner.mark_as_completed();\t\n        break;\n      } else\n        spinner.tick();\n      std::this_thread::sleep_for(std::chrono::milliseconds(40));\n    }\n  };\n  std::thread thread(job);\n  thread.join();  \n\n  return 0;\n}\n```\n\n## Decremental Progress\n\n`indicators` allows you to easily control the progress direction, i.e., incremental or decremental progress by using  `option::ProgressType`. To program a countdown progress bar, use `option::ProgressType::decremental`\n\n<p align=\"center\">\n  <img src=\"img/progress_bar_countdown.gif\"/>  \n</p>\n\n```cpp\n#include <chrono>\n#include <indicators/progress_bar.hpp>\n#include <thread>\nusing namespace indicators;\n\nint main() {\n\n  ProgressBar bar{option::BarWidth{50},\n                  option::ProgressType{ProgressType::decremental},\n                  option::Start{\"[\"},\n                  option::Fill{\"■\"},\n                  option::Lead{\"■\"},\n                  option::Remainder{\"-\"},\n                  option::End{\"]\"},\n                  option::PostfixText{\"Reverting System Restore\"},\n                  option::ForegroundColor{Color::yellow},\n                  option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}};\n\n  // Update bar state\n  while (true) {\n    bar.tick();\n    if (bar.is_completed())\n      break;\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n  }\n\n  std::cout << termcolor::bold << termcolor::white\n            << \"Task Failed Successfully\\n\" << termcolor::reset;\n\n  return 0;\n}\n```\n\n## Working with Iterables\n\nIf you'd like to use progress bars to indicate progress while iterating over iterables, e.g., a list of numbers, this\ncan be achieved by using the `option::MaxProgress`:\n\n<p align=\"center\">\n  <img src=\"img/block_progress_bar_iterable.gif\"/>  \n</p>\n\n```cpp\n#include <chrono>\n#include <indicators/block_progress_bar.hpp>\n#include <indicators/cursor_control.hpp>\n#include <thread>\n\nint main() {\n\n  // Hide cursor\n  indicators::show_console_cursor(false);\n\n  // Random list of numbers\n  std::vector<size_t> numbers;\n  for (size_t i = 0; i < 1259438; ++i) {\n      numbers.push_back(i);\n  }\n\n  using namespace indicators;\n  BlockProgressBar bar{\n    option::BarWidth{80},\n    option::ForegroundColor{Color::white},\n    option::FontStyles{\n          std::vector<FontStyle>{FontStyle::bold}},\n    option::MaxProgress{numbers.size()}\n  };\n\n  std::cout << \"Iterating over a list of numbers (size = \"\n            << numbers.size() << \")\\n\";\n\n  std::vector<size_t> result;\n  for (size_t i = 0; i < numbers.size(); ++i) {\n\n    // Perform some computation\n    result.push_back(numbers[i] * numbers[i]);\n\n    // Show iteration as postfix text\n    bar.set_option(option::PostfixText{\n      std::to_string(i) + \"/\" + std::to_string(numbers.size())\n    });\n\n    // update progress bar\n    bar.tick();\n  }\n\n  bar.mark_as_completed();\n\n  // Show cursor\n  indicators::show_console_cursor(true);\n\n  return 0;\n}\n```\n\n## Unicode Support\n\n`indicators` supports multi-byte unicode characters in progress bars. \n\nIf the `option::BarWidth` is set, the library aims to respect this setting. When filling the bar, if the next `Fill` string has a display width that would exceed the bar width, then the library will fill the remainder of the bar with `' '` space characters instead. \n\nSee below an example of some progress bars, each with a bar width of 50, displaying different unicode characters:\n\n<p align=\"center\">\n  <img src=\"img/unicode.gif\"/>  \n</p>\n\n```cpp\n#include <chrono>\n#include <indicators/progress_bar.hpp>\n#include <indicators/indeterminate_progress_bar.hpp>\n#include <indicators/cursor_control.hpp>\n#include <thread>\n\nint main() {\n\n    indicators::show_console_cursor(false);\n\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    {\n        // Plain old ASCII\n        indicators::ProgressBar bar{\n            indicators::option::BarWidth{50},\n            indicators::option::Start{\"[\"},\n            indicators::option::Fill{\"=\"},\n            indicators::option::Lead{\">\"},\n            indicators::option::Remainder{\" \"},\n            indicators::option::End{\" ]\"},\n            indicators::option::PostfixText{\"Plain-old ASCII\"},\n            indicators::option::ForegroundColor{indicators::Color::green},\n            indicators::option::FontStyles{\n                std::vector<indicators::FontStyle>{indicators::FontStyle::bold}}\n        };\n\n        // Update bar state\n        while (true) {\n            bar.tick();\n            if (bar.is_completed())\n            break;\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n\n    {\n        // Unicode\n        indicators::ProgressBar bar{\n            indicators::option::BarWidth{50},\n            indicators::option::Start{\"[\"},\n            indicators::option::Fill{\"驚くばかり\"},\n            indicators::option::Lead{\">\"},\n            indicators::option::Remainder{\" \"},\n            indicators::option::End{\" ]\"},\n            indicators::option::PostfixText{\"Japanese\"},\n            indicators::option::ForegroundColor{indicators::Color::yellow},\n            indicators::option::FontStyles{\n                std::vector<indicators::FontStyle>{indicators::FontStyle::bold}}\n        };\n\n        // Update bar state\n        while (true) {\n            bar.tick();\n            if (bar.is_completed())\n            break;\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n\n    {\n        // Russian\n        indicators::ProgressBar bar{\n            indicators::option::BarWidth{50},\n            indicators::option::Start{\"[\"},\n            indicators::option::Fill{\"Потрясающие\"},\n            indicators::option::Remainder{\" \"},\n            indicators::option::End{\" ]\"},\n            indicators::option::PostfixText{\"Russian\"},\n            indicators::option::ForegroundColor{indicators::Color::red},\n            indicators::option::FontStyles{\n                std::vector<indicators::FontStyle>{indicators::FontStyle::bold}}\n        };\n\n        // Update bar state\n        while (true) {\n            bar.tick();\n            if (bar.is_completed())\n            break;\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n\n    {\n        // Greek\n        indicators::ProgressBar bar{\n            indicators::option::BarWidth{50},\n            indicators::option::Start{\"[\"},\n            indicators::option::Fill{\"Φοβερός\"},\n            indicators::option::Remainder{\" \"},\n            indicators::option::End{\" ]\"},\n            indicators::option::PostfixText{\"Greek\"},\n            indicators::option::ForegroundColor{indicators::Color::cyan},\n            indicators::option::FontStyles{\n                std::vector<indicators::FontStyle>{indicators::FontStyle::bold}}\n        };\n\n        // Update bar state\n        while (true) {\n            bar.tick();\n            if (bar.is_completed())\n            break;\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n\n    {\n        // Chinese\n        indicators::ProgressBar bar{\n            indicators::option::BarWidth{50},\n            indicators::option::Start{\"[\"},\n            indicators::option::Fill{\"太棒了\"},\n            indicators::option::Remainder{\" \"},\n            indicators::option::End{\" ]\"},\n            indicators::option::PostfixText{\"Chinese\"},\n            indicators::option::ForegroundColor{indicators::Color::green},\n            indicators::option::FontStyles{\n                std::vector<indicators::FontStyle>{indicators::FontStyle::bold}}\n        };\n\n        // Update bar state\n        while (true) {\n            bar.tick();\n            if (bar.is_completed())\n            break;\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }        \n    }\n\n    {\n        // Emojis\n        indicators::ProgressBar bar{\n            indicators::option::BarWidth{50},\n            indicators::option::Start{\"[\"},\n            indicators::option::Fill{\"🔥\"},\n            indicators::option::Lead{\"🔥\"},\n            indicators::option::Remainder{\" \"},\n            indicators::option::End{\" ]\"},\n            indicators::option::PostfixText{\"Emojis\"},\n            indicators::option::ForegroundColor{indicators::Color::white},\n            indicators::option::FontStyles{\n                std::vector<indicators::FontStyle>{indicators::FontStyle::bold}}\n        };\n\n        // Update bar state\n        while (true) {\n            bar.tick();\n            if (bar.is_completed())\n            break;\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n\n    {\n        // Indeterminate progress bar\n        indicators::IndeterminateProgressBar bar{\n            indicators::option::BarWidth{50},\n            indicators::option::Start{\"[\"},\n            indicators::option::Fill{\"✯\"},\n            indicators::option::Lead{\"載入中\"},\n            indicators::option::End{\" ]\"},\n            indicators::option::PostfixText{\"Loading Progress Bar\"},\n            indicators::option::ForegroundColor{indicators::Color::yellow},\n            indicators::option::FontStyles{\n                std::vector<indicators::FontStyle>{indicators::FontStyle::bold}}\n        };\n\n        auto job = [&bar]() {\n            std::this_thread::sleep_for(std::chrono::milliseconds(10000));\n            bar.mark_as_completed();\n        };\n        std::thread job_completion_thread(job);\n\n        // Update bar state\n        while (!bar.is_completed()) {\n            bar.tick();\n            std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        }\n\n        job_completion_thread.join();\n    }\n\n    indicators::show_console_cursor(true);\n\n  return 0;\n}\n```\n\n## Building Samples\n\n```bash\ngit clone https://github.com/p-ranav/indicators\ncd indicators\nmkdir build && cd build\ncmake -DINDICATORS_SAMPLES=ON -DINDICATORS_DEMO=ON ..\nmake\n```\n\n### WinLibs + MinGW\n\nFor Windows, if you use WinLibs like I do, the cmake command would look like this:\n\n```console\nfoo@bar:~$ mkdir build && cd build\nfoo@bar:~$ cmake -G \"MinGW Makefiles\" -DCMAKE_CXX_COMPILER=\"C:/WinLibs/mingw64/bin/g++.exe\" -DINDICATORS_SAMPLES=ON -DINDICATORS_DEMO=ON ..\nfoo@bar:~$ make -j4\n```\n\n## Generating Single Header\n\n```bash\npython3 utils/amalgamate/amalgamate.py -c single_include.json -s .\n```\n\n## Contributing\nContributions are welcome, have a look at the [CONTRIBUTING.md](CONTRIBUTING.md) document for more information.\n\n## License\nThe project is available under the [MIT](https://opensource.org/licenses/MIT) license."
}
