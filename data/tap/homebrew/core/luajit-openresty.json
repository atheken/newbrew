{
  "name": "luajit-openresty",
  "full_name": "luajit-openresty",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "OpenResty's Branch of LuaJIT 2",
  "license": "MIT",
  "homepage": "https://github.com/openresty/luajit2",
  "versions": {
    "stable": "2.1-20230410",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/openresty/luajit2/archive/refs/tags/v2.1-20230410.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "77bbcbb24c3c78f51560017288f3118d995fe71240aa379f5818ff6b166712ff"
    },
    "head": {
      "url": "https://github.com/openresty/luajit2.git",
      "branch": "v2.1-agentzh"
    }
  },
  "revision": 0,
  "version_scheme": 1,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/luajit-openresty/blobs/sha256:e534584c7c3b7eb3a137649e7e6801b98799a1d863466d8db8b09343134f2a9b",
          "sha256": "e534584c7c3b7eb3a137649e7e6801b98799a1d863466d8db8b09343134f2a9b"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/luajit-openresty/blobs/sha256:2e11555a5d4d0be559d01145726d068c4125172532ac5f51bb849f761fe80650",
          "sha256": "2e11555a5d4d0be559d01145726d068c4125172532ac5f51bb849f761fe80650"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/luajit-openresty/blobs/sha256:83badf175a69ce7883c267ab0307204358fa5c705f5e7a004ac8088afb69a15c",
          "sha256": "83badf175a69ce7883c267ab0307204358fa5c705f5e7a004ac8088afb69a15c"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/luajit-openresty/blobs/sha256:02a45febeb8a172ebba48830de9f9c80853efe1382c9723e51b13f40c85b3fc0",
          "sha256": "02a45febeb8a172ebba48830de9f9c80853efe1382c9723e51b13f40c85b3fc0"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/luajit-openresty/blobs/sha256:99fdd703af20ec78bd845c3d6bf6f47b8c150ec425985549e8cd6389afc26628",
          "sha256": "99fdd703af20ec78bd845c3d6bf6f47b8c150ec425985549e8cd6389afc26628"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/luajit-openresty/blobs/sha256:c5ed3c1c9b13b347a14fcb35c053fab22a1cca47a382cc0aa323e6d357dd61dd",
          "sha256": "c5ed3c1c9b13b347a14fcb35c053fab22a1cca47a382cc0aa323e6d357dd61dd"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/luajit-openresty/blobs/sha256:3db66a26e9cbbce3acb24f279da334ebae69d6f319a3f93425aea13490a75c86",
          "sha256": "3db66a26e9cbbce3acb24f279da334ebae69d6f319a3f93425aea13490a75c86"
        }
      }
    }
  },
  "keg_only": true,
  "keg_only_reason": {
    "reason": "it conflicts with the LuaJIT formula",
    "explanation": ""
  },
  "options": [],
  "build_dependencies": [],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/luajit-openresty.rb",
  "ruby_source_checksum": {
    "sha256": "78c8460f0cc7898fb4fc5693b2d6661d4d3ff7fd87b18c9f4f66fef9e7d109e4"
  },
  "date_added": "2021-01-14T17:05:01+00:00",
  "readme": "# Name\n\nopenresty/luajit2 - OpenResty's maintained branch of LuaJIT.\n\nTable of Contents\n=================\n\n* [Name](#name)\n* [Description](#description)\n* [OpenResty extensions](#openresty-extensions)\n    * [New Lua APIs](#new-lua-apis)\n        * [table.isempty](#tableisempty)\n        * [table.isarray](#tableisarray)\n        * [table.nkeys](#tablenkeys)\n        * [table.clone](#tableclone)\n        * [jit.prngstate](#jitprngstate)\n        * [thread.exdata](#threadexdata)\n        * [thread.exdata2](#threadexdata2)\n    * [New C API](#new-c-api)\n        * [lua_setexdata](#lua_setexdata)\n        * [lua_getexdata](#lua_getexdata)\n        * [lua_setexdata2](#lua_setexdata2)\n        * [lua_getexdata2](#lua_getexdata2)\n        * [lua_resetthread](#lua_resetthread)\n    * [New macros](#new-macros)\n        * [`OPENRESTY_LUAJIT`](#openresty_luajit)\n        * [`HAVE_LUA_RESETTHREAD`](#have_lua_resetthread)\n    * [Optimizations](#optimizations)\n        * [Updated JIT default parameters](#updated-jit-default-parameters)\n        * [String hashing](#string-hashing)\n    * [Updated bytecode options](#updated-bytecode-options)\n        * [New `-bL` option](#new--bl-option)\n        * [Updated `-bl` option](#updated--bl-option)\n    * [Miscellaneous](#miscellaneous)\n* [Copyright & License](#copyright--license)\n\n# Description\n\nThis is the official OpenResty branch of LuaJIT. It is not to be considered a\nfork, since we still regularly synchronize changes from the upstream LuaJIT\nproject (https://github.com/LuaJIT/LuaJIT).\n\n# OpenResty extensions\n\nAdditionally to synchronizing upstream changes, we introduce our own changes\nwhich haven't been merged yet (or never will be). This document describes those\nchanges that are specific to this branch.\n\n## New Lua APIs\n\n### table.isempty\n\n**syntax:** *res = isempty(tab)*\n\nReturns `true` when the given Lua table contains neither non-nil array elements\nnor non-nil key-value pairs, or `false` otherwise.\n\nThis API can be JIT compiled.\n\nUsage:\n\n```lua\nlocal isempty = require \"table.isempty\"\n\nprint(isempty({}))  -- true\nprint(isempty({nil, dog = nil}))  -- true\nprint(isempty({\"a\", \"b\"}))  -- false\nprint(isempty({nil, 3}))  -- false\nprint(isempty({cat = 3}))  -- false\n```\n\n[Back to TOC](#table-of-contents)\n\n### table.isarray\n\n**syntax:** *res = isarray(tab)*\n\nReturns `true` when the given Lua table is a pure array-like Lua table, or\n`false` otherwise.\n\nEmpty Lua tables are treated as arrays.\n\nThis API can be JIT compiled.\n\nUsage:\n\n```lua\nlocal isarray = require \"table.isarray\"\n\nprint(isarray{\"a\", true, 3.14})  -- true\nprint(isarray{dog = 3})  -- false\nprint(isarray{})  -- true\n```\n\n[Back to TOC](#table-of-contents)\n\n### table.nkeys\n\n**syntax:** *n = nkeys(tab)*\n\nReturns the total number of elements in a given Lua table (i.e. from both the\narray and hash parts combined).\n\nThis API can be JIT compiled.\n\nUsage:\n\n```lua\nlocal nkeys = require \"table.nkeys\"\n\nprint(nkeys({}))  -- 0\nprint(nkeys({ \"a\", nil, \"b\" }))  -- 2\nprint(nkeys({ dog = 3, cat = 4, bird = nil }))  -- 2\nprint(nkeys({ \"a\", dog = 3, cat = 4 }))  -- 3\n```\n\n[Back to TOC](#table-of-contents)\n\n### table.clone\n\n**syntax:** *t = clone(tab)*\n\nReturns a shallow copy of the given Lua table.\n\nThis API can be JIT compiled.\n\nUsage:\n\n```lua\nlocal clone = require \"table.clone\"\n\nlocal x = {x=12, y={5, 6, 7}}\nlocal y = clone(x)\n... use y ...\n```\n\n**Note:** We observe 7% over-all speedup in the edgelang-fan compiler's\ncompiling speed whose Lua is generated by the fanlang compiler.\n\n**Note bis:** Deep cloning is planned to be supported by adding `true` as a\nsecond argument.\n\n[Back to TOC](#table-of-contents)\n\n### jit.prngstate\n\n**syntax:** *state = jit.prngstate(state?)*\n\nReturns (and optionally sets) the current PRNG state (an array of 8 Lua\nnumbers with 32-bit integer values) currently used by the JIT compiler.\n\nWhen the `state` argument is non-nil, it is expected to be an array of up to 8\nunsigned Lua numbers, each with value less than 2\\*\\*32-1. This will set the\ncurrent PRNG state and return the state that was overridden.\n\n**Note:** For backward compatibility, `state` argument can also be an unsigned\nLua number less than 2\\*\\*32-1.\n\n**Note:** When the `state` argument is an array and less than 8 numbers, or the\n`state` is a number, the remaining positions are filled with zeros.\n\nUsage:\n\n```lua\nlocal state = jit.prngstate()\nlocal oldstate = jit.prngstate{ a, b, c, ... }\n\njit.prngstate(32) -- {32, 0, 0, 0, 0, 0, 0, 0}\njit.prngstate{432, 23, 50} -- {432, 23, 50, 0, 0, 0, 0, 0}\n```\n\n**Note:** This API has no effect if LuaJIT is compiled with\n`-DLUAJIT_DISABLE_JIT`, and will return a table with all `0`.\n\n[Back to TOC](#table-of-contents)\n\n### thread.exdata\n\n**syntax:** *exdata = th_exdata(data?)*\n\nThis API allows for embedding user data into a thread (`lua_State`).\n\nThe retrieved `exdata` value on the Lua land is represented as a cdata object\nof the ctype `void*`.\n\nAs of this version, retrieving the `exdata` (i.e. `th_exdata()` without any\nargument) can be JIT compiled.\n\nUsage:\n\n```lua\nlocal th_exdata = require \"thread.exdata\"\n\nth_exdata(0xdeadbeefLL)  -- set the exdata of the current Lua thread\nlocal exdata = th_exdata()  -- fetch the exdata of the current Lua thread\n```\n\nAlso available are the following public C API functions for manipulating\n`exdata` on the C land:\n\n```C\nvoid lua_setexdata(lua_State *L, void *exdata);\nvoid *lua_getexdata(lua_State *L);\n```\n\nThe `exdata` pointer is initialized to `NULL` when the main thread is created.\nAny child Lua thread will inherit its parent's `exdata`, but still can override\nit.\n\n**Note:** This API will not be available if LuaJIT is compiled with\n`-DLUAJIT_DISABLE_FFI`.\n\n**Note bis:** This API is used internally by the OpenResty core, and it is\nstrongly discouraged to use it yourself in the context of OpenResty.\n\n[Back to TOC](#table-of-contents)\n\n### thread.exdata2\n\n**syntax:** *exdata = th_exdata2(data?)*\n\nSimilar to `thread.exdata` but for a 2nd separate user data as a pointer value.\n\n[Back to TOC](#table-of-contents)\n\n## New C API\n\n### lua_setexdata\n\n```C\nvoid lua_setexdata(lua_State *L, void *exdata);\n```\n\nSets extra user data as a pointer value to the current Lua state or thread.\n\n[Back to TOC](#table-of-contents)\n\n### lua_getexdata\n\n```C\nvoid *lua_getexdata(lua_State *L);\n```\n\nGets extra user data as a pointer value to the current Lua state or thread.\n\n[Back to TOC](#table-of-contents)\n\n### lua_setexdata2\n\n```C\nvoid lua_setexdata2(lua_State *L, void *exdata2);\n```\n\nSimilar to `lua_setexdata` but for a 2nd user data (pointer) value.\n\n[Back to TOC](#table-of-contents)\n\n### lua_getexdata2\n\n```C\nvoid *lua_getexdata2(lua_State *L);\n```\n\nSimilar to `lua_getexdata` but for a 2nd user data (pointer) value.\n\n[Back to TOC](#table-of-contents)\n\n### lua_resetthread\n\n```C\nvoid lua_resetthread(lua_State *L, lua_State *th);\n```\n\nResets the state of `th` to the initial state of a newly created Lua thread\nobject as returned by `lua_newthread()`. This is mainly for Lua thread\nrecycling. Lua threads in arbitrary states (like yielded or errored) can be\nreset properly.\n\nThe current implementation does not shrink the already allocated Lua stack\nthough. It only clears it.\n\n[Back to TOC](#table-of-contents)\n\n## New macros\n\nThe macros described in this section have been added to this branch.\n\n[Back to TOC](#table-of-contents)\n\n### `OPENRESTY_LUAJIT`\n\nIn the `luajit.h` header file, a new macro `OPENRESTY_LUAJIT` was defined to\nhelp distinguishing this OpenResty-specific branch of LuaJIT.\n\n### `HAVE_LUA_RESETTHREAD`\n\nThis macro is set when the `lua_resetthread` C API is present.\n\n[Back to TOC](#table-of-contents)\n\n## Optimizations\n\n### Updated JIT default parameters\n\nWe use more appressive default JIT compiler options to help large OpenResty\nLua applications.\n\nThe following `jit.opt` options are used by default:\n\n```lua\nmaxtrace=8000\nmaxrecord=16000\nminstitch=3\nmaxmcode=40960  -- in KB\n```\n\n[Back to TOC](#table-of-contents)\n\n### String hashing\n\nThis optimization only applies to Intel CPUs supporting the SSE 4.2 instruction\nsets. For such CPUs, and when this branch is compiled with `-msse4.2`, the\nstring hashing function used for strings interning will be based on an\noptimized crc32 implementation (see `lj_str_new()`).\n\nThis optimization still provides constant-time hashing complexity (`O(n)`), but\nmakes hash collision attacks harder for strings up to 127 bytes of size.\n\n[Back to TOC](#table-of-contents)\n\n## Updated bytecode options\n\n### New `-bL` option\n\nThe bytecode option `L` was added to display Lua sources line numbers.\n\nFor example, `luajit -bL -e 'print(1)'` now produces bytecode dumps like below:\n\n```\n-- BYTECODE -- \"print(1)\":0-1\n0001     [1]    GGET     0   0      ; \"print\"\n0002     [1]    KSHORT   1   1\n0003     [1]    CALL     0   1   2\n0004     [1]    RET0     0   1\n```\n\nThe `[N]` column corresponds to the Lua source line number. For example, `[1]`\nmeans \"the first source line\".\n\n[Back to TOC](#table-of-contents)\n\n### Updated `-bl` option\n\nThe bytecode option `l` was updated to display the constant tables of each Lua\nprototype.\n\nFor example, `luajit -bl a.lua'` now produces bytecode dumps like below:\n\n```\n-- BYTECODE -- a.lua:0-48\nKGC    0    \"print\"\nKGC    1    \"hi\"\nKGC    2    table\nKGC    3    a.lua:17\nKN    1    1000000\nKN    2    1.390671161567e-309\n...\n```\n\n[Back to TOC](#table-of-contents)\n\n## Miscellaneous\n\n* Increased the maximum number of allowed upvalues from 60 to 120.\n* Various important bugfixes in the JIT compiler and Lua VM which have\n  not been merged in upstream LuaJIT.\n* Removed the GCC 4 requirement for x86 on older systems such as Solaris i386.\n* In the `Makefile` file, make sure we always install the symlink for \"luajit\"\n  even for alpha or beta versions.\n* Applied a patch to fix DragonFlyBSD compatibility. Note: this is not an\n  officially supported target.\n* feature: jit.dump: output Lua source location after every BC.\n* feature: added internal memory-buffer-based trace entry/exit/start-recording\n  event logging, mainly for debugging bugs in the JIT compiler. it requires\n  `-DLUA_USE_TRACE_LOGS` when building LuaJIT.\n* feature: save `g->jit_base` to `g->saved_jit_base` before `lj_err_throw`\n  clears `g->jit_base` which makes it impossible to get Lua backtrace in such\n  states.\n\n[Back to TOC](#table-of-contents)\n\n# Copyright & License\n\nLuaJIT is a Just-In-Time (JIT) compiler for the Lua programming language.\n\nProject Homepage: http://luajit.org/\n\nLuaJIT is Copyright (C) 2005-2019 Mike Pall.\n\nAdditional patches for OpenResty are copyrighted by Yichun Zhang and OpenResty\nInc.:\n\nCopyright (C) 2017-2019 Yichun Zhang. All rights reserved.\n\nCopyright (C) 2017-2019 OpenResty Inc. All rights reserved.\n\nLuaJIT is free software, released under the MIT license.\nSee full Copyright Notice in the COPYRIGHT file or in luajit.h.\n\nDocumentation for the official LuaJIT is available in HTML format.\nPlease point your favorite browser to:\n\n    doc/luajit.html\n\n[Back to TOC](#table-of-contents)"
}
