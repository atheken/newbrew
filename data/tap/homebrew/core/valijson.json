{
  "name": "valijson",
  "full_name": "valijson",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Header-only C++ library for JSON Schema validation",
  "license": "BSD-2-Clause",
  "homepage": "https://github.com/tristanpenman/valijson",
  "versions": {
    "stable": "1.0.1",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/tristanpenman/valijson/archive/refs/tags/v1.0.1.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "b478b82af1db1d98c2ce47de4ad28647ec66800eaf704dba8b5e785cbca1d785"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "all": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/valijson/blobs/sha256:6d331d066d4ba0664117aa846c81a522a9ec10048e37dc2a3c96acd0e19f6471",
          "sha256": "6d331d066d4ba0664117aa846c81a522a9ec10048e37dc2a3c96acd0e19f6471"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake"
  ],
  "dependencies": [],
  "test_dependencies": [
    "jsoncpp"
  ],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "aa66a84309b297ea296f7a4b9c424b5c0ec4875c",
  "ruby_source_path": "Formula/valijson.rb",
  "ruby_source_checksum": {
    "sha256": "051985b1d4d86de9611671cca9f41de76a9fc770bdecd39fa1895506731ce0d7"
  },
  "date_added": "2022-11-04T22:10:31+00:00",
  "readme": "# Valijson\n\nValijson is a header-only [JSON Schema](http://json-schema.org/) validation library for C++11.\n\nValijson provides a simple validation API that allows you to load JSON Schemas, and validate documents loaded by one of several supported parser libraries.\n\n## Project Goals\n\nThe goal of this project is to support validation of all constraints available in JSON Schema v7, while being competitive with the performance of a hand-written schema validator.\n\n## Usage\n\nClone the repo, including submodules:\n\n    git clone --recurse-submodules git@github.com:tristanpenman/valijson.git\n\nThe following code snippets show how you might implement a simple validator using RapidJson as the underlying JSON Parser.\n\nInclude the necessary headers:\n```cpp\n#include <valijson/adapters/rapidjson_adapter.hpp>\n#include <valijson/utils/rapidjson_utils.hpp>\n#include <valijson/schema.hpp>\n#include <valijson/schema_parser.hpp>\n#include <valijson/validator.hpp>\n```\nThese are the classes that we'll be using:\n```cpp\nusing valijson::Schema;\nusing valijson::SchemaParser;\nusing valijson::Validator;\nusing valijson::adapters::RapidJsonAdapter;\n```\nWe are going to use RapidJSON to load the schema and the target document:\n```cpp\n// Load JSON document using RapidJSON with Valijson helper function\nrapidjson::Document mySchemaDoc;\nif (!valijson::utils::loadDocument(\"mySchema.json\", mySchemaDoc)) {\n    throw std::runtime_error(\"Failed to load schema document\");\n}\n\n// Parse JSON schema content using valijson\nSchema mySchema;\nSchemaParser parser;\nRapidJsonAdapter mySchemaAdapter(mySchemaDoc);\nparser.populateSchema(mySchemaAdapter, mySchema);\n```\nLoad a document to validate:\n```cpp\nrapidjson::Document myTargetDoc;\nif (!valijson::utils::loadDocument(\"myTarget.json\", myTargetDoc)) {\n    throw std::runtime_error(\"Failed to load target document\");\n}\n```\n\nValidate a document:\n```cpp\nValidator validator;\nRapidJsonAdapter myTargetAdapter(myTargetDoc);\nif (!validator.validate(mySchema, myTargetAdapter, NULL)) {\n    throw std::runtime_error(\"Validation failed.\");\n}\n```\n\nNote that Valijson's `SchemaParser` and `Validator` classes expect you to pass in a `RapidJsonAdapter` rather than a `rapidjson::Document`. This is due to the fact that `SchemaParser` and `Validator` are template classes that can be used with any of the JSON parsers supported by Valijson.\n\n### Exceptions\n\nBy default, Valijson classes will not throw exceptions (e.g. when failing to parse a schema). To enable exceptions for these cases, `VALIJSON_USE_EXCEPTIONS` must be defined.\nHowever note that `VALIJSON_USE_EXCEPTIONS` is defined as interface compile definition of the cmake target, and the definition populates all the targets linking Valijson with cmake.\n\n### Strong vs Weak Types\n\nValijson has a notion of strong and weak typing. By default, strong typing is used. For example, the following will create a validator that uses strong typing:\n\n```cpp\nValidator validator;\n```\n\nThis validator will not attempt to cast between types to satisfy a schema. So the string `\"23\"` will not be parsed as a number.\n\nAlternatively, weak typing can be used:\n\n```cpp\nValidator validator(Validator::kWeakTypes);\n```\n\nThis will create a validator that will attempt to cast values to satisfy a schema. The original motivation for this was to support the Boost Property Tree library, which can parse JSON, but stores values as strings.\n\n## Memory Management\n\nValijson has been designed to safely manage, and eventually free, the memory that is allocated while parsing a schema or validating a document. When working with an externally loaded schema (i.e. one that is populated using the `SchemaParser` class) you can rely on RAII semantics.\n\nThings get more interesting when you build a schema using custom code, as illustrated in the following snippet. This code demonstrates how you would create a schema to verify that the value of a 'description' property (if present) is always a string:\n```cpp\n{\n    // Root schema object that manages memory allocated for\n    // constraints or sub-schemas\n    Schema schema;\n\n    // Allocating memory for a sub-schema returns a const pointer\n    // which allows inspection but not mutation. This memory will be\n    // freed only when the root schema goes out of scope\n    const Subschema *subschema = schema.createSubschema();\n\n    {   // Limited scope, for example purposes\n\n        // Construct a constraint on the stack\n        TypeConstraint typeConstraint;\n        typeConstraint.addNamedType(TypeConstraint::kString);\n\n        // Constraints are added to a sub-schema via the root schema,\n        // which will make a copy of the constraint\n        schema.addConstraintToSubschema(typeConstraint, subschema);\n\n        // Constraint on the stack goes out of scope, but the copy\n        // held by the root schema continues to exist\n    }\n\n    // Include subschema in properties constraint\n    PropertiesConstraint propertiesConstraint;\n    propertiesConstraint.addPropertySubschema(\"description\", subschema);\n\n    // Add the properties constraint\n    schema.addConstraint(propertiesConstraint);\n\n    // Root schema goes out of scope and all allocated memory is freed\n}\n```\n## JSON References\n\nThe library includes support for local JSON References. Remote JSON References are supported only when the appropriate callback functions are provided.\n\nValijson's JSON Reference implementation requires that two callback functions are required. The first is expected to return a pointer to a newly fetched document. Valijson takes ownership of this pointer. The second callback function is used to release ownership of that pointer back to the application. Typically, this would immediately free the memory that was allocated for the document.\n\n## Test Suite\n\nValijson's' test suite currently contains several hand-crafted tests and uses the standard [JSON Schema Test Suite](https://github.com/json-schema/JSON-Schema-Test-Suite) to test support for parts of the JSON Schema feature set that have been implemented.\n\n### cmake\n\nThe examples and test suite can be built using cmake:\n```bash\n# Build examples and test suite\nmkdir build\ncd build\ncmake .. -Dvalijson_BUILD_TESTS=ON -Dvalijson_BUILD_EXAMPLES=ON\nmake\n\n# Run test suite (from build directory)\n./test_suite\n```\n## How to add this library to your cmake target\n\nValijson can be integrated either as git submodule or with find_package().\n\n### Valijson as git submodule\n\nDownload this repository into your project\n\n```bash\ngit clone --recurse-submodules https://github.com/tristanpenman/valijson <project-path>/third-party/valijson\n```\n\nIf your project is a git repository\n\n```bash\ncd <project-path>\ngit submodule add https://github.com/tristanpenman/valijson third-party/valijson\n```\n\nBefore the target add the module subdirectory in your CMakeLists.txt\n\n```cmake\nset(valijson_BUILD_TESTS OFF CACHE BOOL \"don't build valijson tests\")\nadd_subdirectory(third-party/valijson)\n\nadd_executable(your-executable ...)\n\ntarget_link_libraries(your-executable ValiJSON::valijson)\n```\n### Install Valijson and import it\n\nIt is possible to install headers by running cmake's install command from the build tree. Once Valijson is installed, use it from other CMake projects using `find_package(Valijson)` in your CMakeLists.txt.\n```bash\n# Install Valijson\ngit clone --recurse-submodules --depth=1 git@github.com:tristanpenman/valijson.git\ncd valijson\nmkdir build\ncd build\ncmake ..\ncmake --install .\n```\n```cmake\n# Import installed valijson and link it to your executable\nfind_package(valijson REQUIRED)\nadd_executable(executable main.cpp)\ntarget_link_libraries(executable valijson)\n```\n\n## Bundled Headers\n\nAn alternative way to include Valijson in your project is to generate a bundled header file, containing support for just one parser/adapter.\n\nYou can generate a header file using the `bundle.sh` script:\n\n    ./bundle.sh nlohmann_json > valijson_nlohmann_bundled.hpp\n\nThis can then be used in your project with a single `#include`:\n\n    #include \"valijson_nlohmann_bundled.hpp\"\n\nAn example can be found in [examples/valijson_nlohmann_bundled_test.cpp](examples/valijson_nlohmann_bundled_test.cpp).\n\nNote: the bundled version of Valijson always embeds a compatibility header in place of `std::optional`.\n\n## Examples\n\nBuilding the Valijson Test Suite, using the instructions above, will also compile two example applications: `custom_schema` and `external_schema`.\n\n`custom_schema` shows how you can hard-code a schema definition into an application, while `external_schema` builds on the example code above to show you how to validate and document and report on any validation errors.\n\n## JSON Schema Support\n\nValijson supports most of the constraints defined in [Draft 7](https://json-schema.org/draft-07/json-schema-release-notes.html)\n\nThe main exceptions are\n - default\n - format\n\nSupport for JSON References is in development. It is mostly working, however some of the test cases added to [JSON Schema Test Suite](https://github.com/json-schema/JSON-Schema-Test-Suite) for v6/v7 are still failing.\n\n## JSON Inspector\n\nAn example application based on Qt is also included under [inspector](./inspector). It can be used to experiment with JSON Schemas and target documents. JSON Inspector is a self-contained CMake project, so it must be built separately:\n\n```bash\ncd inspector\nmkdir build\ncd build\ncmake ..\nmake\n```\n\nSchemas and target documents can be loaded from file or entered manually. Content is parsed dynamically, so you get rapid feedback.\n\nHere is a screenshot of JSON Inspector in action:\n\n![JSON Inspector in action](./doc/screenshots/inspector.png)\n\n## Live Demo\n\nA web-based demo can be found [here](https://letmaik.github.io/valijson-wasm), courtesy of [Maik Riechert](https://github.com/letmaik).\n\nThis demo uses Emscripten to compile Valijson and Nlohmann JSON (JSON for Modern C++) to WebAssembly. The source code can be found [here](https://github.com/letmaik/valijson-wasm) and is available under the MIT license.\n\n![WebAssembly Demo](doc/screenshots/wasm.png)\n\n## Documentation\n\nDoxygen documentation can be built by running 'doxygen' from the project root directory. Generated documentation will be placed in 'doc/html'. Other relevant documentation such as schemas and specifications have been included in the 'doc' directory.\n\n## Dependencies\n\nValijson requires a compiler with full C++11 support. Please note that versions of GCC prior to 4.9.0 had incomplete `<regex>` support, so `pattern` constraints may not work. If using GCC, it is recommended that you use GCC 5.0 or later.\n\nWhen building the test suite, Boost 1.54, Qt 5 and Poco are optional dependencies.\n\n## Supported Parsers\n\nValijson supports JSON documents loaded using various JSON parser libraries. It has been tested against the following versions of these libraries:\n\n - [boost::property_tree 1.54](http://www.boost.org/doc/libs/1_54_0/doc/html/boost_propertytree/synopsis.html)\n - [Boost.JSON 1.75](https://www.boost.org/doc/libs/1_75_0/libs/json/doc/html/index.html)\n - [json11 (commit afcc8d0)](https://github.com/dropbox/json11/tree/afcc8d0d82b1ce2df587a7a0637d05ba493bf5e6)\n - [jsoncpp 1.9.4](https://github.com/open-source-parsers/jsoncpp/archive/1.9.4.tar.gz)\n - [nlohmann/json 1.1.0](https://github.com/nlohmann/json/archive/v1.1.0.tar.gz)\n - [rapidjson (commit 48fbd8c)](https://github.com/Tencent/rapidjson/tree/48fbd8cd202ca54031fe799db2ad44ffa8e77c13)\n - [PicoJSON 1.3.0](https://github.com/kazuho/picojson/archive/v1.3.0.tar.gz)\n - [Poco JSON 1.7.8](https://pocoproject.org/docs/Poco.JSON.html)\n - [Qt 5.8](http://doc.qt.io/qt-5/json.html)\n\nOther versions of these libraries may work, but have not been tested. In particular, versions of jsoncpp going back to 0.5.0 should also work correctly.\n\nWhen compiling with older versions of Boost (< 1.76.0) you may see compiler warnings from the `boost::property_tree` headers. This has been addressed in version 1.76.0 of Boost.\n\n## Package Managers\n\nIf you are using [vcpkg](https://github.com/Microsoft/vcpkg) on your project for external dependencies, then you can use the [valijson](https://github.com/microsoft/vcpkg/tree/master/ports/valijson) package. Please see the vcpkg project for any issues regarding the packaging.\n\nYou can also use [conan](https://conan.io/) as a package manager to handle [valijson](https://conan.io/center/valijson/0.3/) package. Please see the [conan recipe](https://github.com/conan-io/conan-center-index/tree/master/recipes/valijson) for any issues regarding the packaging via conan.\n\n## Test Suite Requirements\n\nSupported versions of these libraries have been included in the 'thirdparty' directory so as to support Valijson's examples and test suite.\n\nThe exceptions to this are boost, Poco and Qt5, which due to their size must be installed to a location that CMake can find.\n\n## Known Issues\n\nWhen using PicoJSON, it may be necessary to include the `picojson.h` before other headers to ensure that the appropriate macros have been enabled.\n\nWhen building Valijson using CMake on macOS, with Qt 5 installed via Homebrew, you may need to set `CMAKE_PREFIX_PATH` so that CMake can find your Qt installation, e.g:\n```bash\nmkdir build\ncd build\ncmake .. -DCMAKE_PREFIX_PATH=$(brew --prefix qt5)\nmake\n```\n## License\n\nValijson is licensed under the Simplified BSD License.\n\nSee the LICENSE file for more information."
}
