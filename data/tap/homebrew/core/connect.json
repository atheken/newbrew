{
  "name": "connect",
  "full_name": "connect",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Provides SOCKS and HTTPS proxy support to SSH",
  "license": "GPL-2.0-or-later",
  "homepage": "https://github.com/gotoh/ssh-connect",
  "versions": {
    "stable": "1.105",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/gotoh/ssh-connect/archive/1.105.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "96c50fefe7ecf015cf64ba6cec9e421ffd3b18fef809f59961ef9229df528f3e"
    },
    "head": {
      "url": "https://github.com/gotoh/ssh-connect.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 1,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/connect/blobs/sha256:25da554388b8d7ccd2dd52576434f92ab8628120d6ba7389959b5e71e9483b97",
          "sha256": "25da554388b8d7ccd2dd52576434f92ab8628120d6ba7389959b5e71e9483b97"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/connect/blobs/sha256:e45ad845a768453d0d0dc278dc9fb39f3a7601f33b79d8c1b5d8e404f1dc3377",
          "sha256": "e45ad845a768453d0d0dc278dc9fb39f3a7601f33b79d8c1b5d8e404f1dc3377"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/connect/blobs/sha256:33e6c06bbe902eea4790679f99c9aef340cce1e647238a13c151300afa46ee1a",
          "sha256": "33e6c06bbe902eea4790679f99c9aef340cce1e647238a13c151300afa46ee1a"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/connect/blobs/sha256:768f3960aaffa61d2b6ff11169d90eed94e3a189c6d5c69fb6d176b7d97c8d4d",
          "sha256": "768f3960aaffa61d2b6ff11169d90eed94e3a189c6d5c69fb6d176b7d97c8d4d"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/connect/blobs/sha256:087274a2b2cd22db73d094b35dbb04389fabe7ce7b3d5d68a18a877bdbf50ac1",
          "sha256": "087274a2b2cd22db73d094b35dbb04389fabe7ce7b3d5d68a18a877bdbf50ac1"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/connect/blobs/sha256:90d0c91146180552a3a023ceba3850804139eb30b146151efe9c6d889ab9c99d",
          "sha256": "90d0c91146180552a3a023ceba3850804139eb30b146151efe9c6d889ab9c99d"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/connect/blobs/sha256:a08dfce847d75746d2b31ed3561e961fdcf950b051c5860e6d137ff5e1bcd1c7",
          "sha256": "a08dfce847d75746d2b31ed3561e961fdcf950b051c5860e6d137ff5e1bcd1c7"
        },
        "mojave": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/connect/blobs/sha256:cc0a39f7e2fea7672f6d691d2e1221d0c5963a9f7e0039317930418fc7c7ebfa",
          "sha256": "cc0a39f7e2fea7672f6d691d2e1221d0c5963a9f7e0039317930418fc7c7ebfa"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/connect/blobs/sha256:69ef58829a226ee7573f34e1b8a6282a7f26dfb8d730700eeff992f65a8f84ac",
          "sha256": "69ef58829a226ee7573f34e1b8a6282a7f26dfb8d730700eeff992f65a8f84ac"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/connect.rb",
  "ruby_source_checksum": {
    "sha256": "a33e98bc6e37ee8e984c542f3e72247c9c82e4560b90b9a36b9bb96aef18d8eb"
  },
  "date_added": "2010-05-25T18:27:24-07:00",
  "readme": "SSH Proxy Command -- connect.c\n==============================\n\n`connect.c` is a simple relaying command to make network connection\nvia SOCKS and https proxy. It is mainly intended to be used as proxy\ncommand of OpenSSH. You can make SSH session beyond the firewall with\nthis command,\n\nFeatures of `connect.c` are:\n\n* Supports SOCKS (version 4/4a/5) and https CONNECT method.\n* Supports NO-AUTH and USERPASS authentication of SOCKS5\n* You can input password from tty, `ssh-askpass` or environment variable.\n* Run on UNIX or Windows platform.\n* You can compile with various C compiler (cc, gcc, Visual C, Borland C. etc.)\n* Simple and general program independent from OpenSSH.\n* You can also relay local socket stream instead of standard I/O.\n\nYou can clone [source code on github](https://github.com/gotoh/ssh-connect) .\n\n\n## What is proxy command?\n\nOpenSSH development team decides to stop supporting SOCKS and any\nother tunneling mechanism. It was aimed to separate complexity to\nsupport various mechanism of proxying from core code. And they\nrecommends more flexible mechanism: ProxyCommand option instead.\n\nProxy command mechanism is delegation of network stream\ncommunication. If ProxyCommand options is specified, SSH invoke\nspecified external command and talk with standard I/O of thid\ncommand. Invoked command undertakes network communication with\nrelaying to/from standard input/output including iniitial\ncommunication or negotiation for proxying. Thus, ssh can split out\nproxying code into external command.\n\nThe `connect.c` program was made for this purpose.\n\n## How to Use\n\n### Get Source\n\nYou can get source code from [project  page](https://github.com/gotoh/ssh-connect).\n```\ngit clone https://github.com/gotoh/ssh-connect.git\n```\n\n### Compile and Install\n\nIn most environment, you can compile `connect.c` simply. On UNIX\nenvironment, you can use cc or gcc. On Windows environment, you can\nuse Microsoft Visual C, Borland C or Cygwin gcc.\n\n| environment | command to compile |\n|-------------|--------------------|\n| UNIX cc | `cc connect.c -o connect` |\n| UNIX gcc | `gcc connect.c -o connect` |\n| Solaris | `gcc connect.c -o connect -lnsl -lsocket -lresolv` |\n| Microsoft Visual C/C++ |  `cl connect.c wsock32.lib advapi32.lib` |\n| Borland C |  `bcc32 connect.c wsock32.lib advapi32.lib` |\n| Cygwin gcc | `gcc connect.c -o connect` |\n| Mac OS/Darwin | `gcc connect.c -o connect -lresolv` |\n\n\nTo install connect command, simply copy compiled binary to directory\nin your `PATH` (ex. `/usr/local/bin`). Like this:\n\n```\n$ cp connect /usr/local/bin\n```\n\n### Modify your `~/.ssh/config`\n\nModify your `~/.ssh/config` file to use connect command as proxy\ncommand. For the case of SOCKS server is running on firewall host\nsocks.local.net with port 1080, you can add `ProxyCommand` option in\n`~/.ssh/config`, like this:\n\n```\nHost remote.outside.net\n  ProxyCommand connect -S socks.local.net %h %p\n```\n\n`%h` and `%p` will be replaced on invoking proxy command with target\nhostname and port specified to SSH command.\n\nIf you hate writing many entries of remote hosts, following example\nmay help you.\n\n```\n## Outside of the firewall, use connect command with SOCKS conenction.\nHost *\n  ProxyCommand connect -S socks.local.net %h %p\n\n## Inside of the firewall, use connect command with direct connection.\nHost *.local.net\n  ProxyCommand connect %h %p\n```\n\nIf you want to use http proxy, use `-H` option instead of `-S` option\nin examle above, like this:\n\n```\n## Outside of the firewall, with HTTP proxy\nHost *\n  ProxyCommand connect -H proxy.local.net:8080 %h %p\n\n## Inside of the firewall, direct\nHost *.local.net\n  ProxyCommand connect %h %p\n```\n\n\n### Use SSH\n\nAfter editing your `~/.ssh/config` file, you are ready to use ssh. You\ncan execute ssh without any special options as if remote host is IP\nreachable host. Following is an example to execute hostname command on\nhost `remote.outside.net`.\n\n```\nlocal$ ssh remote.outside.net hostname\nHello, this is remote.outside.net\nremote$\n```\n\n\n### Have a trouble?\n\nIf you have trouble, execute connect command from command line with `-d`\noption to see what is happened. Some debug message may appear and\nreports progress. This information may tell you what is wrong. In this\nexample, error has occurred on authentication stage of SOCKS5\nprotocol.\n\n```\n$ connect -d -S socks.local.net unknown.remote.outside.net 110\nDEBUG: relay_method = SOCKS (2)\nDEBUG: relay_host=socks.local.net\nDEBUG: relay_port=1080\nDEBUG: relay_user=gotoh\nDEBUG: socks_version=5\nDEBUG: socks_resolve=REMOTE (2)\nDEBUG: local_type=stdio\nDEBUG: dest_host=unknown.remote.outside.net\nDEBUG: dest_port=110\nDEBUG: Program is $Revision: 1.20 $\nDEBUG: connecting to xxx.xxx.xxx.xxx:1080\nDEBUG: begin_socks_relay()\nDEBUG: atomic_out()  [4 bytes]\nDEBUG: >>> 05 02 00 02\nDEBUG: atomic_in() [2 bytes]\nDEBUG: <<< 05 02\nDEBUG: auth method: USERPASS\nDEBUG: atomic_out()  [some bytes]\nDEBUG: >>> xx xx xx xx ...\nDEBUG: atomic_in() [2 bytes]\nDEBUG: <<< 01 01\nERROR: Authentication faield.\nFATAL: failed to begin relaying via SOCKS.\n```\n\n\n## More Detail\n\nCommand line usage is here:\n\n```\nusage:  connect [-dnhs45] [-R resolve] [-p local-port] [-w sec]\n\t\t[-H [user@]proxy-server[:port]]\n\t\t[-S [user@]socks-server[:port]]\n\t\thost port\n```\n\nhost and port is target hostname and port-number to connect.\n\n\n`-H` [user@]server[:port]::\n  Specify hostname and port number of http proxy server to\n  relay. If port is omitted, 80 is used.\n\n`-h`::\n  Use HTTP proxy via proxy server sepcified by environment variable\n  `HTTP_PROXY`.\n\n`-S` \\[_user_@]_server_\\[:_port_]::\n  Specify hostname and port number of SOCKS server to\n  relay. Like `-H` option, port number can be omit and default is 1080.\n\n`-s`::\n  Use SOCKS proxy via SOCKS server sepcified by environment variable\n  `SOCKS5_SERVER`.\n\n\n`-4`:: Use SOCKS version 4 protocol.\n  This option must be used with `-S`.\n`-5`:: Use SOCKS version 5 protocol.\n  This option must be used with `-S`.\n\n`-R` _method_:: The method to resolve hostname.  3 keywords (`local`,\n  `remote`, `both`) or dot-notation IP address is allowed. Keyword\n  both means; _\"Try local first, then remote\"_. If dot-notation IP\n  address is specified, use this host as nameserver (UNIX\n  only). Default is remote for SOCKS5 or local for others. On SOCKS4\n  protocol, remote resolving method (remote and both) use protocol\n  version 4a.\n\n`-p` _port_:: Accept on local TCP port and relay it instead of standard input\nand output. With this option, program will terminate when remote or\nlocal TCP session is closed.\n\n`-w` _timeout_:: Timeout seconds for connecting to remote host.\n\n`-a` _auth_:: option specifiys user intended authentication methods\nseparated by comma. Currently `userpass` and `none` are\nsupported. Default is userpass. You can also specifying this parameter\nby the environment variable `SOCKS5_AUTH`.\n\n`-d`: Run with debug message output. If you fail to connect, use this\noption to see what is done.\n\nAs additional feature, \nyou can omit port argument when program name is special format\ncontaining port number itself like \"connect-25\". For example:\n\n```\n$ ln -s connect connect-25\n$ ./connect-25 smtphost.outside.net\n220 smtphost.outside.net ESMTP Sendmail\nQUIT\n221 2.0.0 smtphost.remote.net closing connection\n$\n```\n\nThis example means that the command name \"connect-25\" indicates port\nnumber 25 so you can omit 2nd argument (and used if specified\nexplicitly).\nThis is usefull for the application which invokes only with hostname\nargument.\n\n\n### Specifying user name via environment variables\n\n\nThere are 5 environemnt variables to specify user name without command\nline option. This mechanism is usefull for the user who using another\nuser name different from system account.\n\n| variable | description |\n| ----- | ---- |\n| `SOCKS5_USER` | Used for SOCKS v5 access.  |\n| `SOCKS4_USER` | Used for SOCKS v4 access.  |\n| `SOCKS_USER` |  Used for SOCKS v5 or v4 access and varaibles above are not defined.  |\n|  `HTTP_PROXY_USER` |   Used for HTTP proxy access.  |\n| `CONNECT_USER` |  Used for all type of access if all above are not defined.  |\n\nFollowing table describes how user name is determined. Left most number is order to check. If variable is not defined, check next variable, and so on.\n\n| Protocol | variables order |\n|----|----|\n| SOCKS v5 | `SOCKS5_USER` or `SOCKS_USER` or `CONNECT_USER` or ask |\n| SOCKS v4 | `SOCKS4_USER` or `SOCKS_USER` or `CONNECT_USER` or ask |\n| HTTP Proxy | `HTTP_PROXY_USER` or `CONNECT_USER`  or ask |\n\n\n### Specifying password via environment variables\n\nThere are 5 environemnt variables to specify password. If you use this\nfeature, please note that it is not secure way.\n\n\n| variable | description |\n|----|----|\n| `SOCKS5_PASSWD` |  Used for SOCKS v5 access. This variables is compatible with NEC SOCKS implementation. |\n| `SOCKS5_PASSWORD` |  Used for SOCKS v5 access if `SOCKS5_PASSWD` is not defined. |\n| `SOCKS_PASSWORD` | Used for SOCKS v5 (or v4) access all above is not defined.  |\n| `HTTP_PROXY_PASSWORD` | Used for HTTP proxy access.  |\n| `CONNECT_PASSWORD` |Used for all type of access if all above are not defined.  |\n\nFollowing table describes how password is determined. First, left most variable is checked.\nIf the variable is not defined, check next variable, and so on. Finally ask to user interactively using external program or tty input.\n\n| Protocol | variables order |\n|----|----|\n| SOCKS v5 | `SOCKS5_PASSWD` or `SOCKS5_PASSWORD` or `SOCKS_PASSWORD` or ask |\n| HTTP Proxy | `HTTP_PROXY_PASSWORD` or `CONNECT_PASSWORD`  or ask |\n\n\n\n\n## Limitations\n\n### SOCKS5 authentication\n\nOnly NO-AUTH and USER/PASSWORD authentications are supported. GSSAPI\nauthentication (RFC 1961) and other draft authentications (CHAP, EAP,\nMAF, etc.) is not supported.\n\n\n### HTTP authentication\n\nBASIC authentication is supported but DIGEST authentication is not.\n\n\n### Switching proxy server on event\n\nThere is no mechanism to switch proxy server regarding to PC\nenvironment. This limitation might be bad news for mobile user. Since\nI do not want to make this program complex, I do not want to support\nalthough this feature is already requested. Please advice me if there\nis good idea of detecting environment to swich and simple way to\nspecify conditioned directive of servers.\n\nOne tricky workaround exists. It is replacing `~/.ssh/config` file by\nscript on ppp up/down.\n\nThere's another example of wrapper script (contributed by Darren\nTucker). This script costs executing ifconfig and grep to detect\ncurrent environment, but it works.  Note that you should modify\naddresses if you use it.\n\n```\n#!/bin/sh\n## ~/bin/myconnect --- Proxy server switching wrapper\n\nif ifconfig eth0 |grep \"inet addr:192\\.168\\.1\" >/dev/null; then\n\topts=\"-S 192.168.1.1:1080\"  \nelif ifconfig eth0 |grep \"inet addr:10\\.\" >/dev/null; then\n\topts=\"-H 10.1.1.1:80\"\nelse\n\topts=\"-s\"\nfi\nexec /usr/local/bin/connect $opts $@\n```\n\n\n## Tips\n\n### Proxying socket connection\n\nIn usual, `connect.c` relays network connection to/from standard\ninput/output. By specifying -p option, however, `connect.c` relays local\nnetwork stream instead of standard input/output. With this option,\nconnect command waits connection from other program, then start\nrelaying between both network stream.\n\nThis feature may be useful for the program which is hard to SOCKSify.\n\n\n### Use with ssh-askpass command\n\n`connect.c` ask you password when authentication is required. If you\nare using on tty/pty terminal, connect can input from terminal with\nprompt. But you can also use ssh-askpass program to input password. If\nyou are graphical environment like X Window or MS Windows, and program\ndoes not have tty/pty, and environment variable `SSH_ASKPASS` is\nspecified, then `connect.c` invoke command specified by environment\nvariable SSH_ASKPASS to input password. ssh-askpass program might be\ninstalled if you are using OpenSSH on UNIX environment. On Windows\nenvironment, pre-compiled binary is available from here.\n\nThis feature is limited on window system environment.\n\nAnd also useful on Emacs on MS Windows (NT Emacs or Meadow). It is\nhard to send passphrase to connect command (and also ssh) because\nexternal command is invoked on hidden terminal and do I/O with this\nterminal. Using ssh-askpass avoids this problem.\n\n\n### Use for Network Stream of Emacs\n\nAlthough `connect.c` is made for OpenSSH, it is generic and independent\nfrom OpenSSH. So we can use this for other purpose. For example, you\ncan use this command in Emacs to open network connection with remote\nhost over the firewall via SOCKS or HTTP proxy without SOCKSifying\nEmacs itself.\n\nThere is sample code: \nhttp://bitbucket.org/gotoh/connect/src/tip/relay.el ... (*url is not exist*)\n\nWith this code, you can use `relay-open-network-stream` function instead\nof `open-network-stream` to make network connection. See top comments of\nthe source for more detail.\n\n\n### Remote resolver\n\n\nIf you are SOCKS4 user on UNIX environment, you might want specify\nnameserver to resolve remote hostname. You can do it specifying `-R`\noption followed by IP address of resolver.\n\n\n### Hopping Connection via SSH\n\nConbination of ssh and connect command have more interesting\nusage. Following command makes indirect connection to host2:port from\nyour current host via host1.\n\n```\n$ ssh host1 connect host2 port\n```\n\nThis method is useful for the situations like:\n\n- You are outside of organizasion now, but you want to access an\n  internal host barriered by firewall.\n\n- You want to use some service which is allowed only from some limited hosts.\n\nFor example, I want to use local NetNews service in my office from\nhome. I cannot make NNTP session directly because NNTP host is\nbarriered by firewall. Fortunately, I have ssh account on internal\nhost and allowed using SOCKS5 on firewall from outside. So I use\nfollowing command to connect to NNTP service.\n\n```\n$ ssh host1 connect news 119\n200 news.my-office.com InterNetNews NNRP server INN 2.3.2 ready (posting ok).\nquit\n205 .\n$\n```\n\nBy combinating hopping connection and relay.el, I can read NetNews\nusing http://www.gohome.org/wl/[Wanderlust] on Emacs at home.\n\n```\n                        |\n    External (internet) | Internal (office)\n                        |\n+------+           +----------+          +-------+           +-----------+\n| HOME |           | firewall |          | host1 |           | NNTP host |\n+------+           +----------+          +-------+           +-----------+\n emacs <-------------- ssh ---------------> sshd <-- connect --> nntpd\n       <-- connect --> socksd <-- SOCKS -->\n```\n\nAs an advanced example, you can use SSH hopping as fetchmail's plug-in\nprogram to access via secure tunnel. This method requires that connect\nprogram is insatalled on remote host. There's example of .fetchmailrc\nbellow. When fetchmail access to mail-server, you will login to remote\nhost using SSH then execute connect program on remote host to relay\nconversation with pop server. Thus fetchmail can retrieve mails in\nsecure.\n\n```\npoll mail-server\n  protocol pop3\n  plugin \"ssh %h connect localhost %p\"\n  username \"username\"\n  password \"password\"\n```\n\n\n## Break The More Restricted Wall\n\nIf firewall does not provide SOCKS nor HTTPS other than port 443, you\ncannot break the wall in usual way. But if you have you own host which\nis accessible from internet, you can make ssh connection to your own\nhost by configuring sshd as waiting at port 443 instead of standard\n\n22. By this, you can login to your own host via port 443. Once you\nhave logged-in to extenal home machine, you can execute connect as\nsecond hop to make connection from your own host to final target host,\nlike this:\n\n```\ninternal$ cat ~/.ssh/config\nHost home\n    ProxyCommand connect -H firewall:8080 %h 443\n\nHost server # internal\n    ProxyCommand ssh home connect %h %p\n    \ninternal$ ssh home\nYou are logged in to home!\nhome# exit\ninternal$ ssh server\nYou are logged in to server!\nserver# exit\ninternal$\n```\n\nThis way is similar to \"Hopping connection via SSH\" except configuring\nouter sshd as waiting at port 443 (https). This means that you have a\ncapability to break the strongly restricted wall if you have own host\nout side of the wall.\n\n```\n                        |\n      Internal (office) | External (internet)\n                        |\n+--------+         +----------+                 +------+          +--------+\n| office |         | firewall |                 | home |          | server |\n+--------+         +----------+                 +------+          +--------+\n   <------------------ ssh --------------------->sshd:443\n    <-- connect --> http-proxy <-- https:443 -->                      any\n                                                 connect <-- tcp -->  port\n```\n\nNOTE: If you wanna use this, you should give up hosting https\n      service at port 443 on you external host 'home'.\n\n\n## F.Y.I.\n\n### Difference between SOCKS versions\n\nSOCKS version 4 is first popular implementation which is documented\n[here](http://www.socks.nec.com/protocol/socks4.protocol). Since this\nprotocol provide IP address based requesting, client program should\nresolve name of outer host by itself. Version 4a (documented [here](http://www.socks.nec.com/protocol/socks4a.protocol) is\nenhanced to allow request by hostname instead of IP address.\n\nSOCKS version 5 is re-designed protocol stands on experience of\nversion 4 and 4a. There is no compativility with previous\nversions. Instead, there's some improvement: IPv6 support, request by\nhostname, UDP proxying, etc.\n\n\n### Configuration to use HTTPS\n\nMany http proxy servers implementation supports https CONNECT method\n(SLL). You might add configuration to allow using https. For the\nexample of [DeleGate](http://www.delegate.org/delegate/) (DeleGate is a\nmulti-purpose application level gateway, or a proxy server) , you\nshould add https to REMITTABLE parameter to allow HTTP-Proxy like\nthis:\n\n```\ndelegated -Pxxxx ...... REMITTABLE='+,https' ...\n```\n\nFor the case of Squid, you should allow target ports via https by ACL,\nand so on.\n\n\n### SOCKS5 Servers\n\n- [NEC SOCKS Reference Implementation](http://www.socks.nec.com/refsoftware.html): \n  Reference implementation of SOKCS server and library.\n\n- [Dante](http://www.inet.no/dante/index.html):\n  Dante is free implementation of SOKCS server and library. Many enhancements and modulalized.\n\n- [DeleGate](http://www.delegate.org/delegate/):\n  DeleGate is multi function proxy service provider. DeleGate 5.x.x\n  or earlier can be SOCKS4 server, and 6.x.x can be SOCKS5 and\n  SOCKS4 server. and 7.7.0 or later can be SOCKS5 and SOCKS4a\n  server.\n\n\n### Specifications\n\n- [socks4.protocol.txt](http://www.socks.nec.com/protocol/socks4.protocol):\n  SOCKS: A protocol for TCP proxy across firewalls \n- [socks4a.protocol.txt](http://www.socks.nec.com/protocol/socks4a.protocol):\n SOCKS 4A: A Simple Extension to SOCKS 4 Protocol \n- [RFC 1928](http://www.socks.nec.com/rfc/rfc1928.txt):\n  SOCKS Protocol Version 5 \n- [RFC 1929](http://www.socks.nec.com/rfc/rfc1929.txt):\n  Username/Password Authentication for SOCKS V5 \n- [RFC 2616](http://www.ietf.org/rfc/rfc2616.txt):\n Hypertext Transfer Protocol -- HTTP/1.1 \n- [RFC 2617](http://www.ietf.org/rfc/rfc2617.txt):\n HTTP Authentication: Basic and Digest Access Authentication \n\n\n### Related Links\n\n- [OpenSSH Home](http://www.openssh.org/)\n- [Proprietary SSH](http://www.ssh.com/)\n- [Using OpenSSH through a SOCKS compatible PROXY on your LAN](http://www.taiyo.co.jp/~gotoh/ssh/openssh-socks.html) (J. Grant)\n\n\n### Similars\n\n- [Proxy Tunnel](http://proxytunnel.sourceforge.net/):\n  Proxying command using https CONNECT.\n- [stunnel](http://www.snurgle.org/~griffon/ssh-https-tunnel):\n  Proxy through an https tunnel (Perl script)"
}
