{
  "name": "glbinding",
  "full_name": "glbinding",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "C++ binding for the OpenGL API",
  "license": "MIT",
  "homepage": "https://github.com/cginternals/glbinding",
  "versions": {
    "stable": "2.1.4",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/cginternals/glbinding/archive/v2.1.4.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "cb5971b086c0d217b2304d31368803fd2b8c12ee0d41c280d40d7c23588f8be2"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 1,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/glbinding/blobs/sha256:8414c2062a0413be5ce4d3104464d77ded39a971883839f5162d1eda60c1dc9e",
          "sha256": "8414c2062a0413be5ce4d3104464d77ded39a971883839f5162d1eda60c1dc9e"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/glbinding/blobs/sha256:6679892b95d63354d1aa3cde01824915003d8decbbe4479a19cea82e31d20be6",
          "sha256": "6679892b95d63354d1aa3cde01824915003d8decbbe4479a19cea82e31d20be6"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/glbinding/blobs/sha256:5c77227ab2d41d56069711ea964f5222feb1d9f1f88228b88ff657131cec9093",
          "sha256": "5c77227ab2d41d56069711ea964f5222feb1d9f1f88228b88ff657131cec9093"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/glbinding/blobs/sha256:7eef393fef969da975966933406213df6d32a9ec757d3a581751c83aa7e0ef4a",
          "sha256": "7eef393fef969da975966933406213df6d32a9ec757d3a581751c83aa7e0ef4a"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/glbinding/blobs/sha256:53e55b3996a3e0a93dda11fe2060a9fd7e9a15f2b5985938b7c04beca5a49542",
          "sha256": "53e55b3996a3e0a93dda11fe2060a9fd7e9a15f2b5985938b7c04beca5a49542"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/glbinding/blobs/sha256:a77f29c6cc40472d39646027e3d9b068ff5cf912edf600087ef4902e30f501a0",
          "sha256": "a77f29c6cc40472d39646027e3d9b068ff5cf912edf600087ef4902e30f501a0"
        },
        "catalina": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/glbinding/blobs/sha256:6a371e47b76cd227e12699de3e7a095e620150532789cdac48e1c9b59bee06b6",
          "sha256": "6a371e47b76cd227e12699de3e7a095e620150532789cdac48e1c9b59bee06b6"
        },
        "mojave": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/glbinding/blobs/sha256:a44cd2f23650ce664d8f61634c27abce3a00f4b5d9efbb10687759a62ca26895",
          "sha256": "a44cd2f23650ce664d8f61634c27abce3a00f4b5d9efbb10687759a62ca26895"
        },
        "high_sierra": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/glbinding/blobs/sha256:ad79687ca8b43832ab27d5a459a71c4cb7e2be5b02d5df15c667ad7689fe38d0",
          "sha256": "ad79687ca8b43832ab27d5a459a71c4cb7e2be5b02d5df15c667ad7689fe38d0"
        },
        "sierra": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/glbinding/blobs/sha256:454bfd4f3f6a983a0614f469388cbe27437350d203c61aed34a8c05fa9bb0710",
          "sha256": "454bfd4f3f6a983a0614f469388cbe27437350d203c61aed34a8c05fa9bb0710"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/glbinding/blobs/sha256:f433dde2dd1326a5d9be03bbc45fcbe33f0d48cee1ea070c17dd878759c87a82",
          "sha256": "f433dde2dd1326a5d9be03bbc45fcbe33f0d48cee1ea070c17dd878759c87a82"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake"
  ],
  "dependencies": [
    "mesa",
    "mesa-glu"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/glbinding.rb",
  "ruby_source_checksum": {
    "sha256": "58978600c31472f836098696df48ae7af87e81ebfac8aa831c1003c3eaa7776a"
  },
  "date_added": "2014-12-13T18:18:33-05:00",
  "readme": "[//]: # (Comment)\n\n<br><a href=\"https://glbinding.org\"><img src=\"https://raw.githubusercontent.com/cginternals/glbinding/master/glbinding-logo.svg?sanitize=true\" width=\"50%\"></a>\n\n*glbinding* is a cross-platform C++ binding for the [OpenGL API](http://www.opengl.org).\n\n![GitHub release](https://img.shields.io/github/release/cginternals/glbinding.svg)\n![C++ CI](https://github.com/cginternals/glbinding/actions/workflows/ci.yml/badge.svg)\n[![Travis](https://img.shields.io/travis/cginternals/glbinding/master.svg?style=flat&logo=travis)](https://travis-ci.org/cginternals/glbinding)\n[![Appveyor](https://img.shields.io/appveyor/build/scheibel/glbinding/master.svg?style=flat&logo=appveyor)](https://ci.appveyor.com/project/scheibel/glbinding)\n[![Tokei](https://tokei.rs/b1/github/cginternals/glbinding)](https://github.com/Aaronepower/tokei)\n\n[![Documentation](https://img.shields.io/badge/documentation-online-blue.svg?style=flat&logo=data%3Aimage%2Fsvg%2Bxml%3Bbase64%2CPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMC41IDEzLjciPjxwYXRoIGQ9Ik0xMS41IDYuOGwtMy43IDYuNEwuNS41aDE0LjdsLTEuMyAyLjFINC4yTDcuOCA5bDIuNS00LjN6bTcuMyA0LjNsMS4yIDIuMWgtOS43TDE3LjYuNWwxLjIgMi4xLTQuOSA4LjV6IiBmaWxsPSIjZmZmIi8%2BPC9zdmc%2B)](https://glbinding.org/docs.html)\n[![Examples](https://img.shields.io/badge/examples-wiki-blue.svg?style=flat&logo=data%3Aimage%2Fsvg%2Bxml%3Bbase64%2CPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMC41IDEzLjciPjxwYXRoIGQ9Ik0xMS41IDYuOGwtMy43IDYuNEwuNS41aDE0LjdsLTEuMyAyLjFINC4yTDcuOCA5bDIuNS00LjN6bTcuMyA0LjNsMS4yIDIuMWgtOS43TDE3LjYuNWwxLjIgMi4xLTQuOSA4LjV6IiBmaWxsPSIjZmZmIi8%2BPC9zdmc%2B)](https://github.com/cginternals/glbinding/wiki/Examples)\n[![Tools](https://img.shields.io/badge/tools-wiki-blue.svg?style=flat&logo=data%3Aimage%2Fsvg%2Bxml%3Bbase64%2CPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMC41IDEzLjciPjxwYXRoIGQ9Ik0xMS41IDYuOGwtMy43IDYuNEwuNS41aDE0LjdsLTEuMyAyLjFINC4yTDcuOCA5bDIuNS00LjN6bTcuMyA0LjNsMS4yIDIuMWgtOS43TDE3LjYuNWwxLjIgMi4xLTQuOSA4LjV6IiBmaWxsPSIjZmZmIi8%2BPC9zdmc%2B)](https://github.com/cginternals/glbinding/wiki/Tools)\n\n[//]: # (HEADER_END)\n\n*glbinding* leverages C++11 features like enum classes, lambdas, and variadic templates, instead of relying on macros;\nall OpenGL symbols are real functions and variables.\nIt provides type-safe parameters, per-feature API headers, lazy function resolution, multi-context and multi-thread support, global and local function callbacks, meta information about the generated OpenGL binding and the OpenGL runtime, as well as tools and examples for quick-starting your projects.\nBased on the OpenGL API specification ([gl.xml](https://github.com/KhronosGroup/OpenGL-Registry/blob/main/xml/gl.xml)) *glbinding* is generated using [python scripts and templates](https://github.com/cginternals/khrbinding-generator) that can be easily adapted to fit custom needs.\n\n![what-is-glbinding](https://raw.githubusercontent.com/cginternals/glbinding/master/docs/what-is-glbinding-v2.png)\n\nCode that is written using a typical C binding for OpenGL, e.g., [GLEW](http://glew.sourceforge.net/), is fully compatible for the use with *glbinding* and causes no significant impact on runtime performance (see [compare example](https://github.com/cginternals/glbinding/wiki/examples#compare)): just replace all includes to the former binding, replace the initialization code and *use* the appropriate API namespace, e.g., ```gl``` for full availability of the OpenGL API.\n\n```cpp\n#include <glbinding/gl/gl.h>\nusing namespace gl;\n\n// ...\nauto shader = glCreateShader(GL_COMPUTE_SHADER);\n// ...\n```\n\n# Resources\n\n* [Tools](https://github.com/cginternals/glbinding/wiki/tools)\n* [Examples](https://github.com/cginternals/glbinding/wiki/examples)\n* [Context Creation Cheat Sheet](https://github.com/cginternals/glbinding/wiki/Context-Creation-Cheat-Sheet)\n\n### Installation and Development\n\n* [Install Instructions](#install-instructions)\n* [Build from Source](#build-instructions)\n* [Updating the Generated Source Code](#update-generated-source-code)\n* [Tips for Linking](#tips-for-linking)\n* [Dependency on KHR Headers](#dependency-on-khr-headers)\n* [Basic Example](#basic-example)\n\n### Feature Documentation and Code Snippets\n\n* [Type-safe Parameters](#type-safe-parameters)\n* [Compilation-Centered Header Design](#compilation-centered-header-design)\n* [Feature-Centered Header Design](#feature-centered-header-design)\n* [Lazy Function Resolution](#lazy-function-pointer-resolution)\n* [Multi-context Support](#multi-context-support)\n* [Multi-thread Support](#multi-threading-support)\n* [Global and Local Function Callbacks](#function-callbacks)\n* [Alternative Signatures for GLboolean and GLenum types](#alternative-signatures)\n* [Meta Information System](#meta-information)\n* [Doxygen Documentations](https://glbinding.org/docs.html) ([stable](https://glbinding.org/docs/v3.1/), [master](https://glbinding.org/docs/master))\n\n# Install Instructions\n\n*glbinding* is available for different platforms using different distribution channels.\nYou can either download the source and manually [compile](#build-instructions) it or use one of the [pre-compiled releases](https://github.com/cginternals/glbinding/releases) of this repository.\nFor systems providing package managers, we generally strive for packages in these package managers.\nAn overview on availability of glbinding can be found on [repology.org](https://repology.org/project/glbinding/versions).\n\n## Windows\n\nThe various *glbinding* packages can be installed either by downloading an installer, e.g., the [x64 installer for glbinding v3.1.0](https://github.com/cginternals/glbinding/releases/download/v3.1.0/glbinding-3.1.0-msvc2017-x64-installer.exe) for Microsoft Visual Studio 2015, or downloading and extracting one of the precompiled archives, e.g. [runtime](https://github.com/cginternals/glbinding/releases/download/v3.1.0/glbinding-3.1.0-msvc2017-x64-runtime.zip),\n[examples](https://github.com/cginternals/glbinding/releases/download/v3.1.0/glbinding-3.1.0-msvc2017-x64-examples.zip),\n[dev](https://github.com/cginternals/glbinding/releases/download/v3.1.0/glbinding-3.1.0-msvc2017-x64-dev.zip), and\n[tools](https://github.com/cginternals/glbinding/releases/download/v3.1.0/glbinding-3.1.0-msvc2017-x64-tools.zip).\nSince lately, glbinding is also available on [vcpkg](https://github.com/Microsoft/vcpkg/tree/master/ports/glbinding) with more recent releases:\n```bash\n> vcpkg install glbinding\n```\nAlternatively, download the source code and commence [building from source](#build-instructions).\n\n## Ubuntu\n\n*glbinding* is provided on Ubuntu using PPAs and in [Ubuntu universe](https://packages.ubuntu.com/source/artful/glbinding) since Artful Aardvark. We maintain our own [PPA](https://launchpad.net/~cginternals/+archive/ubuntu/ppa) for most recent releases.\nUsing the current PPA as example, the following lines install *glbinding* including the GLFW examples:\n\n```shell\n> sudo apt-add-repository ppa:cginternals/ppa\n> sudo apt-get update\n> sudo apt-get install libglbinding-examples-glfw\n> # start example\n> /usr/share/glbinding/cubescape\n```\n\nTo use *glbinding* as dependency, install the development package:\n\n```shell\n> sudo apt-get install libglbinding-dev libglbinding-dbg\n```\n\nAlternatively, download the source code and commence [building from source](#build-instructions).\n\n## Arch Linux\n\nOn Arch, *glbinding* is provided by the [glbinding](https://www.archlinux.org/packages/community/x86_64/glbinding/) package in the community repository. To install *glbinding* execute the following line:\n\n```shell\n> sudo pacman -S glbinding\n```\n\nAlternatively, download the source code and commence [building from source](#build-instructions).\n\n## macOS\n\nThe package manager on macOS we depend on is homebrew. The package there is called [glbinding](http://formulae.brew.sh/formula/glbinding).\nTo install *glbinding* using homebrew, execute the following line:\n\n```bash\n> brew install glbinding\n```\n\nAlternatively, download the source code and commence [building from source](#build-instructions).\n\n## Debian-based Systems\n\n*glbinding* is available for Debian 9 (Stretch), 10 (Buster), 11 (Bullseye) and Sid. Install it using `apt install libglbinding-dev`.\nFor advanced use, download the source code and commence [building from source](#build-instructions).\n\n\n## Cross-Platform Package Managers\n\nAs one of the cross-platform package managers, *conan* provides glbinding in its [center index](https://conan.io/center/glbinding). You can use the following line to install glbinding using conan:\n\n```bash\n> conan install glbinding/3.1.0@\n```\n\n\n# Build Instructions\n\n### Prerequisites and Dependencies\n\nThe only mandatory run-time dependencies of *glbinding* are the STL of the used compiler and an OpenGL driver library, dynamically linked with your application.\nBuilding *glbinding* from source has several mandatory and optional dependencies:\n\n* [CMake](https://cmake.org/) 3.0 or higher for building *glbinding* from source (mandatory for any build from source)\n* [git](https://git-scm.com/) for version control and script supporting tasks\n* [GLFW](http://www.glfw.org/) 3.2 or higher for examples and tools\n* [GLEW](http://glew.sourceforge.net/) 1.6 or higher for the comparison example (optional)\n* [cpplocate](https://github.com/cginternals/cpplocate) for the examples (optional)\n* [Qt5](http://www.qt.io/developers/) 5.0 or higher for the qt-based example (optional)\n* [googletest](https://github.com/google/googletest) for tests (optional)\n* [Doxygen](http://www.stack.nl/~dimitri/doxygen/) 1.8 or higher for generating the documentation on your system\n  * [graphviz](http://www.graphviz.org/) for generating diagrams (optional)\n\n### Compile Instructions\n\nFor compilation, a C++11 compliant compiler, e.g., GCC 4.8, Clang 3.3, MSVC 2013 **Update 3**, is required.\nFirst, download the source code [as archive](https://github.com/cginternals/glbinding/releases) or via git:\n\n```bash\n> git clone https://github.com/cginternals/glbinding.git\n> cd glbinding\n```\n\nThen, depending on the version of *glbinding* you want to build, choose the appropriate tag or branch, e.g., for the 2.1.4 release:\n\n```bash\n> git fetch --tags\n> git checkout v2.1.4\n```\n\nThe actual compilation can be done using CMake and your favorite compiler and IDE.\n\nFor building *glbinding* CMake via command line can be used (should work on all systems):\n\nFirst, create a build directory (we do not recommend in-source builds):\n\n```bash\n> mkdir build\n> cd build\n```\n\nConfigure *glbinding* with your preferred or default generator, e.g., for Visual Studio 2017 in x64 use\n(note: some IDEs have integrated support for CMake projects, e.g., Qt Creator, and allow you to skip the manual project configuration):\n\n```bash\n> cmake .. -G \"Visual Studio 17 2022\" -A x64\n```\n\nIn order to compile the project, either use you favorite Editor/IDE with the created project or use CMake as follows:\n\n```bash\n> cmake --build .\n```\n\nFor multi-configuration projects specific configuration (e.g., on Windows using MSVC) can be built using:\n\n```bash\n> cmake --build . --config Release\n> cmake --build . --config Debug\n```\n\n### Update Generated Source Code\n\nThe generation scripts for *glbinding* are maintained within the [khrbinding-generator](https://github.com/cginternals/khrbinding-generator) project.\nAssuming a directory structure with both projects such as `<projects>/glbinding` and `<projects>/khrbinding-generator`, updating the source code is started as follows:\n\n```bash\n> python3 update.py -p \"profiles/gl.json\"\n> python3 generate.py -p \"profiles/gl.json\" -d \"../glbinding/source\"\n```\n\n# Tips for Linking\n\nWe suggest using the build system [CMake](https://cmake.org/) for a smooth integration.\nFor it, *glbinding* provides a configuration script that should be installed into your system or at least accessible by CMake.\nIn your projects' `CMakeLists.txt`, add one of the following lines:\n\n```cmake\nfind_package(glbinding QUIET) # if you want to check for existence\nfind_package(glbinding REQUIRED) # if it is really required in your project\n```\n\nFinally, just link *glbinding* to your own library or executable:\n\n```cmake\ntarget_link_libraries(${target} ... PUBLIC\n    glbinding::glbinding\n    glbinding::glbinding-aux # for additional, auxiliary features as logging, meta information, or debugging functionality\n)\n```\n\n# Dependency on KHR Headers\n\nAs of mid 2019, the OpenGL API depends on the platform headers from the Khronos group, even on desktop systems.\nThis introduced a direct dependency of *glbinding* to the `KHR/khrplatform.h` header file. For most Linux systems, these headers are easily available (e.g., by installing `libegl1-mesa-dev` on Ubuntu), whereas on other systems, pre-existing packages are scarce. Even in the case of Ubuntu, one can argue that installing the EGL dependency is strange, as glbinding does not depend on EGL in any way.\n\nFor those cases, glbinding comes with a copy of the headers for internal use.\n\nThis solution has one significant downside: As those headers are used by the types of the OpenGL API and the types are used within the public interface of glbinding, the `khrplatform.h` headers needs to be present when building downstream projects, i.e., they need to be installed along glbinding. In order to not conflict with packages providing the official headers, this internal header has to be installed on a separate location. This complicates the project setup and results in the following usage scenarios for you to choose from:\n\n### KHR/khrplatform.h Usage\n\nFor this usage scenario, glbinding needs to get built with the CMake option `OPTION_BUILD_OWN_KHR_HEADERS` set to `Off` and system-wide availability of the `KHR/khrplatform.h` headers, e.g., by having `libegl1-mesa-dev` installed. If either the option is `On` or the system-wide headers are not found, the internally provided headers are used instead.\n\nThis decision is stored as property of the glbinding CMake target and will be used for downstream projects as well.\nThe use and propagation of this decision is transparent to the user as well, i.e., the user should not need to handle this downstream. The only thing to consider is to have the system-wide `KHR/khrplatform.h` headers available when building the downstream project.\n\n### glbinding-internal khrplatform.h Usage\n\nFor this usage scenario, glbinding should get built with the CMake option `OPTION_BUILD_OWN_KHR_HEADERS` set to `On`. Alternatively, this scenario is the fallback if the official `KHR/khrplatform.h` headers are not found.\n\nThis decision is stored as property of the glbinding CMake target and will be used for downstream projects as well.\nThe use and propagation of this decision is transparent to the user as well, i.e., the user should not need to handle this downstream.\n\n# Basic Example\n\nThe following examples are tailored for use with *glbinding* 3.0 and above.\n\n*glbinding* has to be initialized once on the active OpenGL context you want to use *glbinding* with. For initialization, a callback for function pointer resolution must be passed, which your context creation API should provide.\nIn the most basic case, you call ```glbinding::initialize``` once:\n\n```cpp\n#include <glbinding/gl/gl.h>\n#include <glbinding/glbinding.h>\n\nusing namespace gl;\n\nint main()\n{\n  // create context, e.g. using GLFW, Qt, SDL, GLUT, ...\n\n  // Assume context creation using GLFW\n  glbinding::initialize(glfwGetProcAddress);\n\n  glBegin(GL_TRIANGLES);\n  // ...\n  glEnd();\n}\n```\n\n\n# Features\n\nThe following examples are tailored for use with *glbinding* 3.0 and above.\n\n### Type-Safe Parameters\n\nThe original OpenGL API provides several concepts in their interface, namely functions, booleans, bitfields, enums, as well as special values and basic types but mostly does not differentiate between these types.\nHence, actual knowledge about each function and its parameters is required; there is no way for a basic code assistance.\nAs *glbinding* differentiates between all these types, IDEs and compilers can detect wrong usages of the OpenGL API.\n\nOne example is the passing of a named constant in places where a bit combination is expected:\n\n```cpp\nglClear(GL_COLOR_BUFFER_BIT); // valid\nglClear(GL_FRAMEBUFFER);      // compilation error: bitfield of group ClearBufferMask expected, got GLenum\n```\n\nIn the case of bitfields, the OpenGL API offers groups and each parameter states the group valid values must come from.\n*glbinding* uses this information to prevent invalid bit combinations:\n\n```cpp\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // valid\nglClear(GL_COLOR_BUFFER_BIT | GL_MAP_READ_BIT);     // compile error: both bitfields share no group\n\nglClear(GL_STENCIL_BUFFER_BIT | GL_LIGHTING_BIT);   // compile error: bitwise or operation is valid,\n                                                    // the shared group is AttribMask, but the\n                                                    // resulting group does not match the expected.\n```\n\nUnfortunately, such groups are incomplete and unmaintained for enums (named values).\nThus, *glbinding* could not provide any assistance for cases such as:\n\n```cpp\nGLuint vertexShader = glCreateShader(GL_VERTEX_SHADER); // All good\nGLuint colorShader = glCreateShader(GL_COLOR);          // No compilation error but a runtime error!\n```\n\n### Compilation-Centered Header Design\n\nC++ strictly separates interface from implementation.\nFor improving the compilation time of a program or system written in C++ forward declarations of types are commonly used and includes of unnecessary symbols are omitted.\n\nFor an interface of a library, class, or module providing OpenGL related functionality, it is likely that only the type information of OpenGL is needed, not actual functions or constants usually required for implementation.\nIn addition to the customary all-in-one header ```gl.h``` *glbinding* also provides specialized headers:\n\n```cpp\n#include <glbinding/gl/gl.h>        // all of the headers below, meaning the complete OpenGL API\n\n#include <glbinding/gl/bitfield.h>  // bitfield constants (e.g., GL_COLOR_BUFFER_BIT)\n#include <glbinding/gl/boolean.h>   // boolean constants (GL_TRUE and GL_FALSE)\n#include <glbinding/gl/enum.h>      // symbol constants (e.g., GL_VERTEX_SHADER)\n#include <glbinding/gl/functions.h> // functions\n#include <glbinding/gl/types.h>     // type declarations of the OpenGL API (including bitfields, boolean, enum, and extensions)\n#include <glbinding/gl/values.h>    // special values (e.g., GL_INVALID_INDEX)\n```\n\nThere is one additional header that provides all extensions and provide them as an enumeration in terms of C++ enums.\n\n```cpp\n#include <glbinding/gl/extension.h>\n```\n\n### Feature-Centered Header Design\n\nThe OpenGL API is iteratively developed and released in versions, internally (for the API specification) named *features*.\nThe latest feature/version of OpenGL is 4.6.\nThe previous version are 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 2.0, 2.1, 3.0, 3.1, 3.2, 3.3, 4.0, 4.1, 4.2, 4.3, 4.4., and 4.5.\nOpenGL uses a deprecation model for removing outdated parts of its API which results in compatibility (with deprecated API) and core (without deprecated API) usage that is manifested in the targeted OpenGL context.\nOn top of that, new API concepts are suggested as extensions (often vendor specific) that might be integrated into future versions.\nAll this results in many possible specific manifestations of the OpenGL API you can use in your program.\n\nOne tough task is to adhere to one agreed set of functions in your own OpenGL program (e.g., OpenGL 3.2 Core if you want to develop for every Windows, macOS, and Linux released in the last 4 years).\n*glbinding* facilitates this by providing per-feature headers by means of well-defined/generated subsets of the OpenGL API.\n\n#### All-Features OpenGL Headers\n\nIf you do not use per-feature headers the OpenGL program can look like this:\n\n```cpp\n#include <glbinding/gl/gl.h>\n\n// draw code\ngl::glClear(gl::GL_COLOR_BUFFER_BIT | gl::GL_DEPTH_BUFFER_BIT);\ngl::glUniform1i(u_numcubes, m_numcubes);\ngl::glDrawElementsInstanced(gl::GL_TRIANGLES, 18, gl::GL_UNSIGNED_BYTE, 0, m_numcubes * m_numcubes);\n```\n\n#### Single-Feature OpenGL Headers\n\nWhen developing your code on Windows with latest drivers installed, the code above is likely to compile and run.\nBut if you want to port it to systems with less mature driver support (e.g., macOS or Linux using open source drivers), you may wonder if ```glDrawElementsInstanced``` is available.\nIn this case, just switch to per-feature headers of *glbinding* and choose the OpenGL 3.2 Core headers (as you know that at least this version is available on all target platforms):\n\n```cpp\n#include <glbinding/gl32core/gl.h>\n\n// draw code\ngl32core::glClear(gl32core::GL_COLOR_BUFFER_BIT | gl32core::GL_DEPTH_BUFFER_BIT);\ngl32core::glUniform1i(u_numcubes, m_numcubes);\ngl32core::glDrawElementsInstanced(gl32core::GL_TRIANGLES, 18, gl32core::GL_UNSIGNED_BYTE, 0, m_numcubes * m_numcubes);\n```\n\nIf the code compiles you can be sure it is OpenGL 3.2 Core compliant.\nUsing functions that are not yet available or relying on deprecated functionality is prevented.\n\n### Lazy Function Pointer Resolution\n\nBy default, *glbinding* tries to resolve all OpenGL function pointers during initialization, which can consume some time:\n\n```cpp\n// Assume context creation using GLFW\nglbinding::initialize(glfwGetProcAddress); // immediate function pointer resolution\n```\n\nAlternatively, the user can decide that functions pointers are resolved only when used for the first time. This is achieved by:\n\n```cpp\n// Assume context creation using GLFW\nglbinding::initialize(glfwGetProcAddress, false); // lazy function pointer resolution\n```\n\n### Multi-Context Support\n\n*glbinding* has built-in support for multiple contexts. The only requirement is, that the currently active context has to be specified. This feature mixes well with multi-threaded applications, but keep in mind that concurrent use of one context often results in non-meaningful communication with the OpenGL driver.\n\nIn order to use multiple contexts, use your favorite context creation library (e.g., glut, SDL, egl, glfw, Qt) to request the required contexts.\nThe functions to make a context current should be provided by these libraries and is not part of *glbinding* (except that you can get the current context handle).\nWhen using multiple contexts, *glbinding* has to be initialized for each context (when current).\n\nSince each context can correspond to a different feature set of OpenGL and the drivers are free to assign their function pointers, *glbinding* cannot assume any equalities of requested function pointers.\nThus, contexts switches have to be communicated to *glbinding* explicitly in order to have correctly dispatched function pointers:\n\n```cpp\n// use the current active context\nglbinding::useCurrentContext();\n\n// use another context, identified by platform-specific handle\nglbinding::useContext(ContextHandle context);\n```\n\n### Multi-Threading Support\n\nConcurrent use of *glbinding* is mainly intended for usage over multiple contexts in different threads (multiple threads operating on a single OpenGL context requires locking, which *glbinding* will not provide).\nFor it, *glbinding* supports multiple active contexts, one per thread.\nThis necessitates that *glbinding* gets informed in each thread which context is currently active (see [multi-context example](https://github.com/cginternals/glbinding/tree/master/source/examples/multi-context)).\n\nNote: multi-threaded communication with OpenGL will most likely result in a meaningless sequence of OpenGL calls.\nTo avoid this, semantic groups of OpenGL calls should be treated as critical sections.\n\nExample for usage of multiple contexts:\n```cpp\n// Context 1 creation\n// GLFWwindow * window1 = glfwCreateWindow(640, 480, \"\", nullptr, nullptr);\n// glfwMakeContextCurrent(window1);\nglbinding::initialize(0, glfwGetProcAddress); // 0 here is the context identifier\n// Context 1 initialization\nglClearColor(1.0f, 0.0f, 0.0f, 0.0f);\n\n// Context 2 creation\n// GLFWwindow * window2 = glfwCreateWindow(640, 480, \"\", nullptr, nullptr);\n// glfwMakeContextCurrent(window2);\nglbinding::initialize(1, glfwGetProcAddress); // 1 here is the context identifier\n// Context 1 initialization\nglClearColor(0.0f, 1.0f, 0.0f, 0.0f);\n\n// Rendering\nwhile (doNotClose()) {\n  // Make context 1 active\n  // glfwMakeContextCurrent(window1);\n  glbinding::useContext(0);\n\n  // Context 1 rendering\n  glViewport(0, 0, width, height);\n  glClear(GL_COLOR_BUFFER_BIT);\n\n  // Swap buffer for context 1\n  // glfwSwapBuffers(window1);\n\n  // Make context 2 active\n  // glfwMakeContextCurrent(window2);\n  glbinding::useContext(1);\n\n  // Context 2 rendering\n  glViewport(0, 0, width, height);\n  glClear(GL_COLOR_BUFFER_BIT);\n\n  // Swap buffer for context 2\n  // glfwSwapBuffers(window2);\n}\n```\n\n### Multiple OpenGL Contexts in Multiple Threads\n\nThe combination of multiple OpenGL contexts and multiple threads for OpenGL usage is supported by *glbinding* in general.\nYou must tell *glbinding* which OpenGL context is used in which thread by calling the initialize method once the context is used first (```glbinding::initialize```) and if you want to switch the current context for one thread, you have to update the current context, too (```glbinding::useContext```).\nHowever, we discourage the use of one context in multiple threads.\n\n### Function Callbacks\n\nTo support orthogonal features of the OpenGL API, *glbinding* allows attaching a number of callbacks to several concepts of the OpenGL API (e.g. a function).\nSuch orthogonal features include runtime error checking (i.e., ```glGetError``` after each function call), logging, and caching of driver information.\n\n*glbinding* supports different types of callbacks that can be registered.\nThe main types are\n\n * global and local (per-function) before callbacks, that are called before the OpenGL function call,\n * global and local (per-function) after callbacks, that are called after the OpenGL function call,\n * unresolved callbacks, that are called each time an unresolved OpenGL function should be called (instead of a segmentation fault),\n * context switch callbacks, that are called if the internal current OpenGL context of *glbinding* is changed.\n\nThe before callbacks are useful , e.g., for tracing or application-specific parameter checking.\nThe available information in this callback is the wrapped OpenGL function (including its name and bound function address) and all parameters.\nThe after callbacks are useful, e.g., for tracing, logging, or the obligatory error check (```glGetError```).\nAvailable information is extended by the return value.\nThe unresolved callback provides information about the (unresolved) wrapped OpenGL function object.\n\nExample for error checking:\n\n```cpp\nsetCallbackMaskExcept(CallbackMask::After, { \"glGetError\" });\nsetAfterCallback([](const FunctionCall &)\n{\n  const auto error = glGetError();\n  if (error != GL_NO_ERROR)\n    std::cout << \"error: \" << std::hex << error << std::endl;\n});\n\n// OpenGL Code ...\n```\n\nAs a shortcut, *glbinding* 3.0 introduced a debugging interface for error-checking after callbacks within the *glbinding-aux* library:\n\n```cpp\n#include <glbinding-aux/debug.h>\n\nglbinding::aux::enableGetErrorCallback();\n\n// OpenGL Code ...\n```\n\nExample for logging:\n\n```cpp\nsetCallbackMask(CallbackMask::After | CallbackMask::ParametersAndReturnValue);\nsetAfterCallback([](const FunctionCall & call)\n{\n  std::cout << call.function->name() << \"(\";\n  for (unsigned i = 0; i < call.parameters.size(); ++i)\n  {\n    std::cout << call.parameters[i].get();\n    if (i < call.parameters.size() - 1)\n      std::cout << \", \";\n  }\n  std::cout << \")\";\n\n  if (call.returnValue)\n    std::cout << \" -> \" << call.returnValue.get();\n\n  std::cout << std::endl;\n});\n\n// OpenGL Code ...\n```\n\n### Alternative Signatures\n\nThe OpenGL API is designed without function overloading using only simple parameter types.\nThis results in explicit parameter encoding in function names for conceptually overloaded functions (e.g., glTexParameteri and glTexParameterf).\nAnother design decision for the OpenGL API is the high similarity of the integer, boolean, enum, and bitfield data types.\nThis means, that for *overloaded* functions, there is no separate function for ```GLboolean```, ```GLenum```, and ```GLbitfield``` types.\nUsing type-save functions of *glbinding*, some typically compiling code constructs are now deliberately broken.\nFor most of those cases, we provide alternative *overloaded* function signatures.\nAdditionally, we also fix signatures that are semantically broken in the OpenGL API specification, i.e., when base types (C types) are similar such as in the case of enums and integers.\n\nAlternative function signatures are enabled by default, so the following example works out-of-the-box:\n\n```cpp\n#include <glbinding/gl/gl.h>\n\nusing namespace gl;\n\n// ...\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\nglTexImage2D(GL_TEXTURE_2D, 0, GL_R8, 64, 64, 0, GL_RED, GL_UNSIGNED_BYTE, terrain.data());\n```\n\n### Meta Information\n\nBesides an actual OpenGL binding, *glbinding* also supports queries for both compile time and runtime information about the gl.xml and your OpenGL driver within the *glbinding-aux* library. This library comes with own includes and needs to be linked separately.\nTypical use cases are querying the available OpenGL extensions or the associated extensions to an OpenGL feature and their functions and enums.\n\nThe following example prints out a list of all available OpenGL versions/features:\n\n```cpp\n#include <iostream>\n\n#include <glbinding/Version.h>\n\n#include <glbinding-aux/Meta.h>\n#include <glbinding-aux/types_to_string.h>\n\n// ...\nusing namespace glbinding;\n\nfor (const Version & v : aux::Meta::versions())\n  std::cout << v << std::endl;\n```"
}
