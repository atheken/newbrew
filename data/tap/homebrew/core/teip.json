{
  "name": "teip",
  "full_name": "teip",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Masking tape to help commands \"do one thing well\"",
  "license": "MIT",
  "homepage": "https://github.com/greymd/teip",
  "versions": {
    "stable": "2.3.0",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/greymd/teip/archive/v2.3.0.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "4c39466613f39d27fa22ae2a6309ac732ea94fdbc8711ecd4149fc1ecdfbaedf"
    },
    "head": {
      "url": "https://github.com/greymd/teip.git",
      "branch": "main"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/teip/blobs/sha256:76306929a61d06bed2d50e7104f81fd38be5a4256f25b7c5bd4f59df0fc721e7",
          "sha256": "76306929a61d06bed2d50e7104f81fd38be5a4256f25b7c5bd4f59df0fc721e7"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/teip/blobs/sha256:862454d4a7446db7996612e4ff3593e1861e8d2851be1c5d57afcde2ca79e229",
          "sha256": "862454d4a7446db7996612e4ff3593e1861e8d2851be1c5d57afcde2ca79e229"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/teip/blobs/sha256:847c470c7cef50c85c278209412a2bb1694527e0a44011e891ba37401a62ea9e",
          "sha256": "847c470c7cef50c85c278209412a2bb1694527e0a44011e891ba37401a62ea9e"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/teip/blobs/sha256:c412035b3c7484fd79ca768dd7102d805af464ba0c46774a497544b58ae5baf2",
          "sha256": "c412035b3c7484fd79ca768dd7102d805af464ba0c46774a497544b58ae5baf2"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/teip/blobs/sha256:a3ae1dbbd8a3c7d8f0ea1e5713ce669b7184dfa375ee2466923baccb44882138",
          "sha256": "a3ae1dbbd8a3c7d8f0ea1e5713ce669b7184dfa375ee2466923baccb44882138"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/teip/blobs/sha256:58d3e48e0feb2b60cf56f522ac1517dc3952f505298a30159211874f431bef62",
          "sha256": "58d3e48e0feb2b60cf56f522ac1517dc3952f505298a30159211874f431bef62"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/teip/blobs/sha256:009824a80a45f6f54c8b70bd337358dfdcc636e86651e76a546c873bfbfaa25a",
          "sha256": "009824a80a45f6f54c8b70bd337358dfdcc636e86651e76a546c873bfbfaa25a"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "pkg-config",
    "rust"
  ],
  "dependencies": [
    "oniguruma"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [
    {
      "llvm": "build"
    }
  ],
  "uses_from_macos_bounds": [
    {}
  ],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/teip.rb",
  "ruby_source_checksum": {
    "sha256": "42f6d383b8bf9c0f95ae2fb278970cf89bbe2e5dc4917c27f86698d214a0fcd7"
  },
  "date_added": "2023-03-12T05:12:10+00:00",
  "readme": "<h1 align=\"center\">\n  <br />\n  <img src=\"https://raw.githubusercontent.com/wiki/greymd/teip/img/logo.png\" width=\"208\" />\n  <h4 align=\"center\">Masking tape to help commands \"do one thing well\"</h4>\n</h1>\n<p align=\"center\">\n  <a href=\"https://github.com/greymd/teip/releases/latest\"><img src=\"https://img.shields.io/github/release/greymd/teip.svg\" alt=\"Latest version\" /></a>\n  <a href=\"https://crates.io/crates/teip\" alt=\"crate.io\"><img src=\"https://img.shields.io/crates/v/teip.svg\"/></a>\n  <a href=\"https://github.com/greymd/teip/actions?query=workflow%3ATest\"><img src=\"https://github.com/greymd/teip/workflows/Test/badge.svg\" alt=\"Test Status\" /></a>\n  <a href=\"LICENSE\" alt=\"MIT License\"><img src=\"http://img.shields.io/badge/license-MIT-blue.svg?style=flat\" /></a>\n</p>\n\n## Taping\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/wiki/greymd/teip/img/teip_intro2.png\" alt=\"Git Animation for Introduction\" width=\"80%\" />\n</p>\n\n* Convert timestamps in /var/log/secure to UNIX time\n\n```bash\n$ cat /var/log/secure | teip -c 1-15 -- date -f- +%s\n```\n\n* Replace 'WORLD' to 'EARTH' on lines containing 'HELLO'\n\n```bash\n$ cat file | teip -g HELLO -- sed 's/WORLD/EARTH/'\n```\n\n* Make characters upper case on 2nd field of the CSV (RFC4180)\n\n```bash\n$ cat file.csv | teip --csv -f 2 -- tr a-z A-Z\n```\n\n* Edit 2nd, 3rd and 4th fields of TSV file\n\n```bash\n$ cat file.tsv | teip -D '\\t' -f 2-4 -- tr a-z A-Z\n```\n\n* Edit lines containing 'hello' and the three lines before and after it\n\n```bash\n$ cat access.log | teip -e 'grep -n -C 3 hello' -- sed 's/./@/g'\n```\n\n## Performance enhancement\n`teip` allows a command to focus on its own task.\n\nHere is the comparison of processing time to replace approx 761,000 IP addresses with dummy ones in 100 MiB text file.\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/wiki/greymd/teip/benchmark/secure_bench.svg\" width=\"80%\" alt=\"benchmark bar chart\" />\n</p>\n\nSee detail on <a href=\"https://github.com/greymd/teip/wiki/Benchmark\">wiki > Benchmark</a>.\n\n## Features\n\n* Taping: Help the command \"do one thing well\"\n  - Bypassing a partial range of standard input to any command whatever you want\n  - The targeted command just handles bypassed parts of the standard input\n  - Flexible methods for selecting a range (Select like AWK, `cut` or `grep`)\n\n* High performer\n  - The targeted command's standard input/output are intercepted by multiple `teip`'s threads asynchronously.\n  - If general UNIX commands on your environment can process a few hundred MB files in a few seconds, then `teip` can do the same or better performance.\n\n## Installation\n\n\n### macOS (x86_64, ARM64) / Linux (x86_64)\n\nInstall [Homebrew](https://brew.sh/), and\n\n```bash\nbrew install teip\n```\n\n### Linux (x86_64, ARM64)\n\n#### `dpkg`\n\n<!-- deb_url_start -->\n```bash\nwget https://github.com/greymd/teip/releases/download/v2.3.0/teip-2.3.0.$(uname -m)-unknown-linux-musl.deb\nsudo dpkg -i ./teip*.deb\n```\n<!-- deb_url_end -->\n\n#### `apt`\n\n<!-- deb_url_start -->\n```bash\nwget https://github.com/greymd/teip/releases/download/v2.3.0/teip-2.3.0.$(uname -m)-unknown-linux-musl.deb\nsudo apt install ./teip*.deb\n```\n<!-- deb_url_end -->\n\n#### `dnf`\n\n<!-- rpm_url_start -->\n```bash\nsudo dnf install https://github.com/greymd/teip/releases/download/v2.3.0/teip-2.3.0.$(uname -m)-unknown-linux-musl.rpm\n```\n<!-- rpm_url_end -->\n\n#### `yum`\n\n<!-- rpm_url_start -->\n```bash\nsudo yum install https://github.com/greymd/teip/releases/download/v2.3.0/teip-2.3.0.$(uname -m)-unknown-linux-musl.rpm\n```\n<!-- rpm_url_end -->\n\n<!-- release_url_start -->\nIf necessary, check the hash value from the [latest release page](https://github.com/greymd/teip/releases/tag/v2.3.0).\nFiles whose filenames end with `sha256` have hash values listed.\n<!-- release_url_end -->\n\n\n\n### Windows (x86_64)\n\n<!-- ins_url_start -->\nDownload installer from [here](https://github.com/greymd/teip/releases/download/v2.3.0/teip_installer-2.3.0-x86_64-pc-windows-msvc.exe).\n<!-- ins_url_end -->\n\nSee [Wiki > Use on Windows](https://github.com/greymd/teip/wiki/Use-on-Windows) in detail.\n\n### Other architectures\n\n<!-- release_url_start -->\nCheck the [latest release page](https://github.com/greymd/teip/releases/tag/v2.3.0) for executables for the platform you are using.\n<!-- release_url_end -->\n\nIf not, please build it from source.\n\n### Build from source\n\nWith Rust's package manager cargo\n\n```\ncargo install teip\n```\n\nTo enable Oniguruma regular expression (`-G` option), build with `--features oniguruma` option.\nPlease make sure `libclang` shared library is on your environment in advance.\n\n```bash\n### Ubuntu\n$ sudo apt install cargo clang\n$ cargo install teip --features oniguruma\n```\n\n```bash\n### Red Hat base OS\n$ sudo dnf install cargo clang\n$ cargo install teip --features oniguruma\n```\n\n```powershell\n### Windows (PowerShell) and choco (chocolatey.org)\nPS C:\\> choco install llvm\nPS C:\\> cargo install teip --features oniguruma\n```\n\n## Usage\n\n```\nUSAGE:\n  teip -g <pattern> [-Gosvz] [--] [<command>...]\n  teip -c <list> [-svz] [--] [<command>...]\n  teip -l <list> [-svz] [--] [<command>...]\n  teip -f <list> [-d <delimiter> | -D <pattern> | --csv] [-svz] [--] [<command>...]\n  teip -e <string> [-svz] [--] [<command>...]\n\nOPTIONS:\n    -g <pattern>        Bypassing lines that match the regular expression <pattern>\n        -o              -g bypasses only matched parts\n        -G              -g interprets Oniguruma regular expressions.\n    -c <list>           Bypassing these characters\n    -l <list>           Bypassing these lines\n    -f <list>           Bypassing these white-space separated fields\n        -d <delimiter>  Use <delimiter> for field delimiter of -f\n        -D <pattern>    Use regular expression <pattern> for field delimiter of -f\n        --csv           -f interprets <list> as field number of a CSV according to\n                        RFC 4180, instead of white-space separated fields\n    -e <string>         Execute <string> on another process that will receive identical\n                        standard input as the teip, and numbers given by the result\n                        are used as line numbers for bypassing\n\nFLAGS:\n    -h, --help          Prints help information\n    -V, --version       Prints version information\n    -s                  Execute new command for each bypassed chunk\n        --chomp         Command spawned by -s receives standard input without trailing\n                        newlines\n    -I  <replace-str>   Replace the <replace-str> with bypassed chunk in the <command>\n                        then -s is forcefully enabled.\n    -v                  Invert the range of bypassing\n    -z                  Line delimiter is NUL instead of a newline\n\nALIASES:\n    -g <pattern>\n        -A <number>     Alias of -e 'grep -n -A <number> <pattern>'\n        -B <number>     Alias of -e 'grep -n -B <number> <pattern>'\n        -C <number>     Alias of -e 'grep -n -C <number> <pattern>'\n    --sed <pattern>     Alias of -e 'sed -n \"<pattern>=\"'\n    --awk <pattern>     Alias of -e 'awk \"<pattern>{print NR}\"'\n```\n\n## Getting Started\n\nTry this at first.\n\n```bash\n$ echo \"100 200 300 400\" | teip -f 3\n```\n\nThe result is almost the same as the input but \"300\" is highlighted and surrounded by `[...]`.\nBecause `-f 3` specifies the 3rd field of space-separated input.\n\n```bash\n100 200 [300] 400\n```\n\nUnderstand that the area enclosed in `[...]` is a **hole** on the masking tape.\n\n<img src=\"https://raw.githubusercontent.com/wiki/greymd/teip/img/teip_hole.png\" width=\"300\" />\n\nNext, put the `sed` and its arguments at the end.\n\n```bash\n$ echo \"100 200 300 400\" | teip -f 3 sed 's/./@/g'\n```\n\nThe result is as below.\nHighlight and `[...]` is gone then.\n\n```\n100 200 @@@ 400\n```\n\nAs you can see, the `sed` only processed the input in the \"hole\" and ignores masked parts.\nTechnically, `teip` passes only highlighted part to the `sed` and replaces it with the result of the `sed`.\n\nOff-course, any command whatever you like can be specified.\nIt is called the **targeted command** in this article.\n\nLet's try the `cut` as the targeted command to extract the first character only.\n\n```bash\n$ echo \"100 200 300 400\" | teip -f 3 cut -c 1\nteip: Invalid arguments.\n```\n\nOops? Why is it failed?\n\nThis is because the `cut` uses the `-c` option.\nThe option of the same name is also provided by `teip`, which is confusing.\n\nWhen entering a targeted command with `teip`, it is better to enter it after `--`.\nThen, `teip` interprets the arguments after `--` as the targeted command and its argument.\n\n```bash\n$ echo \"100 200 300 400\" | teip -f 3 -- cut -c 1\n100 200 3 400\n```\n\nGreat, the first character `3` is extracted from `300`!\n\nAlthough `--` is not always necessary, it is always better to be used.\nSo, `--` is used in all the examples from here.\n\nNow let's double this number with the `awk`.\nThe command looks like the following (Note that the variable to be doubled is not `$3`).\n\n```bash\n$ echo \"100 200 300 400\" | teip -f 3 -- awk '{print $1*2}'\n100 200 600 400\n```\n\nOK, the result went from 300 to 600.\n\nNow, let's change `-f 3` to `-f 3,4` and run it.\n\n```bash\n$ echo \"100 200 300 400\" | teip -f 3,4 -- awk '{print $1*2}'\n100 200 600 800\n```\n\nThe numbers in the 3rd and 4th were doubled!\n\nAs some of you may have noticed, the argument of `-f` is compatible with the __LIST__ of `cut`.\n\nLet's see how it works with `cut --help`.\n\n```bash\n$ echo \"100 200 300 400\" | teip -f -3 -- sed 's/./@/g'\n@@@ @@@ @@@ 400\n\n$ echo \"100 200 300 400\" | teip -f 2-4 -- sed 's/./@/g'\n100 @@@ @@@ @@@\n\n$ echo \"100 200 300 400\" | teip -f 1- -- sed 's/./@/g'\n@@@ @@@ @@@ @@@\n```\n\n## Select range by character\n\nThe `-c` option allows you to specify a range by character-base.\nThe below example is specifing 1st, 3rd, 5th, 7th characters and apply the `sed` command to them.\n\n```bash\n$ echo ABCDEFG | teip -c 1,3,5,7\n[A]B[C]D[E]F[G]\n\n$ echo ABCDEFG | teip -c 1,3,5,7 -- sed 's/./@/'\n@B@D@F@\n```\n\nAs same as `-f`, `-c`'s argument is compatible with `cut`'s __LIST__.\n\n## Processing delimited text like CSV, TSV\n\nThe `-f` option recognizes delimited fields [like `awk`](https://www.gnu.org/software/gawk/manual/html_node/Regexp-Field-Splitting.html) by default.\n\nThe continuous white spaces (all forms of whitespace categorized by [Unicode](https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt)) is interpreted as a single delimiter.\n\n```bash\n$ printf \"A       B \\t\\t\\t\\   C \\t D\" | teip -f 3 -- sed s/./@@@@/\nA       B                       @@@@   C         D\n```\n\nThis behavior might be inconvenient for the processing of CSV and TSV.\n\nHowever, the `-d` option in conjunction with the `-f` can be used to specify a delimiter.\nNow you can process the CSV file like this.\n\n```bash\n$ echo \"100,200,300,400\" | teip -f 3 -d , -- sed 's/./@/g'\n100,200,@@@,400\n```\n\nIn order to process TSV, the TAB character need to be typed.\nIf you are using Bash, type `$'\\t'` which is one of [ANSI-C Quoting](https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html).\n\n```bash\n$ printf \"100\\t200\\t300\\t400\\n\" | teip -f 3 -d $'\\t' -- sed 's/./@/g'\n100     200     @@@     400\n```\n\n`teip` also provides `-D` option to specify an extended regular expression as the delimiter.\nThis is useful when you want to ignore consecutive delimiters, or when there are multiple types of delimiters.\n\n```bash\n$ echo 'A,,,,,B,,,,C' | teip -f 2 -D ',+'\nA,,,,,[B],,,,C\n```\n\n```bash\n$ echo \"1970-01-02 03:04:05\" | teip -f 2-5 -D '[-: ]'\n1970-[01]-[02] [03]:[04]:05\n```\n\nThe regular expression of TAB character (`\\t`) can also be specified with the `-D` option.\n\n```\n$ printf \"100\\t200\\t300\\t400\\n\" | teip -f 3 -D '\\t' -- sed 's/./@/g'\n100     200     @@@     400\n```\n\nRegarding available notations of the regular expression, refer to [regular expression of Rust](https://docs.rs/regex/1.3.7/regex/).\n\n## Complex CSV processing\n\nIf you want to process a complex CSV file, such as the one below, which has columns surrounded by double quotes, use the `-f` option together with the `--csv` option.\n\n```csv\nName,Address,zipcode\nSola Harewatar,\"Doreami Road 123\nSorashido city\",12877\nYui Nagomi,\"Nagomi Street 456, Nagomitei, Oishina town\",26930-0312\n\"Conectol Motimotit Hooklala Glycogen Comex II a.k.a \"\"Kome kome\"\"\",\"Cooking dam\",513123\n```\n\nWith `--csv`, teip will parse the input as a CSV file according to [RFC4180](https://www.rfc-editor.org/rfc/rfc4180). Thus, you can use `-f` to specify column numbers for CSV files with complex structures.\n\nFor example, the CSV just mentioned above will have a \"hole\" as shown below.\n\n```\n$ cat tests/sample.csv | teip --csv -f2 \nName,[Address],zipcode\nSola Harewatar,[\"Doreami Road 123]\n[Sorashido city\"],12877\nYui Nagomi,[\"Nagomi Street 456, Nagomitei, Oishina town\"],26930-0312\n\"Conectol Motimotit Hooklala Glycogen Comex II a.k.a \"\"Kome kome\"\"\",[\"Cooking dam\"],513123\n```\n\nBecause `-f2` was specified, there is a hole in the second column of each row.\nThe following command is an example of rewriting all characters in the second column to \"@\".\n\n```\n$ cat tests/sample.csv  | teip --csv -f2 -- sed 's/[^\"]/@/g'\nName,@@@@@@@,zipcode\nSola Harewatar,\"@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@\",12877\nYui Nagomi,\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\",26930-0312\n\"Conectol Motimotit Hooklala Glycogen Comex II a.k.a \"\"Kome kome\"\"\",\"@@@@@@@@@@@\",513123\n```\n\nNote for `--csv` option:\n\n* Double quotation `\"` surrounding fields are also included in the holes.\n* Escaped double quotes `\"\"` are treated as is; two double quotes `\"\"` are given as input to the targeted command.\n* Fields containing newlines will have multiple holes, separated by newlines, instead of a single hole.\n  * However, if the `-s` or `-z` option is used, it is treated as a single hole, including line breaks.\n\n## Matching with Regular Expression\n\nYou can also use `-g` to select a specific line matching a regular expression as the hole location.\n\n```bash\n$ echo -e \"ABC1\\nEFG2\\nHIJ3\" | teip -g '[GJ]\\d'\nABC1\n[EFG2]\n[HIJ3]\n```\n\nBy default, the entire line containing the pattern is the range of holes.\nWith the -o option, the range of holes will be only at matched range.\n\n```bash\n$ echo -e \"ABC1\\nEFG2\\nHIJ3\" | teip -og '[GJ]\\d'\nABC1\nEF[G2]\nHI[J3]\n```\n\nNote that `-og` is one of the useful idiom and frequently used in this manual.\n\nHere is an example of using `\\d` which matches numbers.\n\n```bash\n$ echo ABC100EFG200 | teip -og '\\d+'\nABC[100]EFG[200]\n\n$ echo ABC100EFG200 | teip -og '\\d+' -- sed 's/.*/@@@/g'\nABC@@@EFG@@@\n```\n\nThis feature is quite versatile and can be useful for handling the file that has no fixed form like logs, markdown, etc.\n\n## What commands are appropriate?\n\n`teip` bypasses the string in the hole line by line so that each hole is one line of input.\nTherefore, a targeted command must follow the below rule.\n\n* **A targeted command must print a single line of result for each line of input.**\n\nIn the simplest example, the `cat` command always succeeds.\nBecause the `cat` prints the same number of lines against the input.\n\n```bash\n$ echo ABCDEF | teip -og . -- cat\nABCDEF\n```\n\nIf the above rule is not satisfied, the result will be inconsistent.\nFor example, `grep` may fail.\nHere is an example.\n\n```bash\n$ echo ABCDEF | teip -og .\n[A][B][C][D][E][F]\n\n$ echo ABCDEF | teip -og . -- grep '[ABC]'\nABC\nteip: Output of given command is exhausted\n\n$ echo $?\n1\n```\n\n`teip` could not get the result corresponding to the hole of D, E, and F.\nThat is why the above example fails.\n\nIf an inconsistency occurs, `teip` will exit with the error message.\nAlso, the exit status will be 1.\n\nTo learn more about `teip`'s behavior, see [Wiki > Chunking](https://github.com/greymd/teip/wiki/Chunking).\n\n## Advanced usage\n\n### Solid mode (`-s`)\n\nIf you want to use a command that does not satisfy the condition, **\"A targeted command must print a single line of result for each line of input\"**, enable \"Solid mode\" which is available with the `-s` option.\n\nSolid mode spawns the targeted command for each hole and executes it each time.\n\n```bash\n$ echo ABCDEF | teip -s -og . -- grep '[ABC]'\n```\n\nIn the above example, understand the following commands are executed in `teip`'s internal procedure.\n\n```bash\n$ echo A | grep '[ABC]' # => A\n$ echo B | grep '[ABC]' # => B\n$ echo C | grep '[ABC]' # => C\n$ echo D | grep '[ABC]' # => Empty\n$ echo E | grep '[ABC]' # => Empty\n$ echo F | grep '[ABC]' # => Empty\n```\n\nThe empty result is replaced with an empty string.\nTherefore, D, E, and F are replaced with empty as expected.\n\n```bash\n$ echo ABCDEF | teip -s -og . -- grep '[ABC]'\nABC\n\n$ echo $?\n0\n```\n\nHowever, this option is not suitable for processing large files because of its high processing overhead, which can significantly degrade performance.\n\n#### Solid mode with placeholder (`-I <replace-str>`)\n\nIf you want to use the contents of the hole as an argument of the targeted command, use the `-I` option.\n\n```bash\n$ echo AAA BBB CCC | teip -f 2 -I @ -- echo '[@]'\nAAA [BBB] CCC\n```\n\n`<replace-str>` can be any strings and multiple characters are allowed.\n\n```bash\n$ seq 5 | teip -f 1 -I NUMBER -- awk 'BEGIN{print NUMBER * 3}'\n3\n6\n9\n12\n15\n```\n\nPlease note that `-s` is automatically enabled with `-I`.\nTherefore, it is not suitable for processing huge files.\nIn addition, the targeted command does not get any input from stdin.\nThe targeted command is expected to work without stdin.\n\n#### Solid mode with `--chomp` \n\nIf `-s` option does not work as expected, `--chomp` may be helpful.\n\nA targeted command in solid mode always accepts input with a line field (`\\x0A`) at the end.\nThis is because `teip` assumes the use of commands that return a single line of result in response to a single line of input.\nTherefore, even if there is no line break in the hole, a line break is given to treat it as a single line of input.\n\nHowever, there are situations where this behavior is inconvenient.\nFor example, when using commands whose behavior changes depending on the presence or absence of line field.\n\n```\n$ echo AAABBBCCC | teip -og BBB -s\nAAA[BBB]CCC\n$ echo AAABBBCCC | teip -og BBB -s -- tr '\\n' '@'\nAAABBB@CCC\n```\n\nThe above is an example where the targeted command is a \"tr command that converts line field (`\\x0A`) to @\".\n\"BBB\" does not contain a newline, but the result is \"BBB@\", because implicitly added line breaks have been processed.\nTo prevent this behavior, use the `--chomp` option.\nThis option gives the targeted command pure input with no newlines added.\n\n```\n$ echo AAABBBCCC | teip -og BBB -s --chomp -- tr '\\n' '@'\nAAABBBCCC\n```\n\nFor example, it is useful when using commands that interpret and process input as binary like `tr`.\nBelow is an example of \"removing newlines from the second column of a CSV that contains newlines.\n\n```\n$ cat tests/sample.csv\nName,Address,zipcode\nSola Harewatar,\"Doreami Road 123\nSorashido city\",12877\n```\n\nThe result is.\n\n```\n$ cat tests/sample.csv | teip --csv -f 2 -s --chomp -- tr '\\n' '@'\nName,Address,zipcode\nSola Harewatar,\"Doreami Road 123@Sorashido city\",12877\n```\n\n### Line number (`-l`)\n\nYou can specify a line number and drill holes only in that line.\n  \n```bash\n$ echo -e \"ABC\\nDEF\\nGHI\" | teip -l 2\nABC\n[DEF]\nGHI\n```\n\n```bash\n$ echo -e \"ABC\\nDEF\\nGHI\" | teip -l 1,3\n[ABC]\nDEF\n[GHI]\n```\n\n### Overlay `teip`s\n\nAny command can be used with `teip`, surprisingly, even if it is **`teip` itself**.\n\n```bash\n$ echo \"AAA@@@@@AAA@@@@@AAA\" | teip -og '@.*@'\nAAA[@@@@@AAA@@@@@]AAA\n\n$ echo \"AAA@@@@@AAA@@@@@AAA\" | teip -og '@.*@' -- teip -og 'A+'\nAAA@@@@@[AAA]@@@@@AAA\n\n$ echo \"AAA@@@@@AAA@@@@@AAA\" | teip -og '@.*@' -- teip -og 'A+' -- tr A _\nAAA@@@@@___@@@@@AAA\n```\n\nIn other words, by connecting multiple functions of `teip` with AND conditions, it is possible to drill holes in a more complex range.\nFurthermore, it works asynchronously and in multi-processes, similar to the shell pipeline.\nIt will hardly degrade performance unless the machine faces the limits of parallelism.\n\n### Oniguruma regular expressior (`-G`)\n\nIf `-G` option is given together with `-g`, the regular expressin is interpreted as [Oniguruma regular expression](https://github.com/kkos/oniguruma/blob/master/doc/RE). For example, \"keep\" and \"look-ahead\" syntax can be used.\n\n```bash\n$ echo 'ABC123DEF456' | teip -G -og 'DEF\\K\\d+'\nABC123DEF[456]\n\n$ echo 'ABC123DEF456' | teip -G -og '\\d+(?=D)'\nABC[123]DEF456\n```\n\n### Empty hole\n\nIf a blank field exists when the `-f` option is used, the blank is not ignored and treated as an empty hole.\n\n```bash\n$ echo ',,,' | teip -d , -f 1-\n[],[],[],[]\n```\n\nTherefore, the following command can work (Note that `*` matches empty as well).\n\n```bash\n$ echo ',,,' | teip -f 1- -d, sed 's/.*/@@@/'\n@@@,@@@,@@@,@@@\n```\n\nIn the above example, the `sed` loads four newline characters and prints `@@@` four times.\n\n### Invert match (`-v`)\n\nThe `-v` option allows you to invert the range of holes.\nWhen the `-f` or `-c` option is used with `-v`, holes to be made in the complement of the specified field instead.\n\n```bash\n$ echo 1 2 3 4 5 | teip -v -f 1,3,5 -- sed 's/./_/'\n1 _ 3 _ 5\n```\n\nOf course, it can also be used for the `-og` option.\n\n```bash\n$ printf 'AAA\\n123\\nBBB\\n' | teip -vg '\\d+' -- sed 's/./@/g'\n@@@\n123\n@@@\n```\n\n### Zero-terminated mode (`-z`)\n\nIf you want to process the data in a more flexible way, the `-z` option may be useful.\nThis option allows you to use the NUL character (the ASCII NUL character) instead of the newline character.\nIt behaves like `-z` provided by GNU sed or GNU grep, or `-0` option provided by xargs.\n\n```bash\n$ printf '111,\\n222,33\\n3\\0\\n444,55\\n5,666\\n' | teip -z -f3 -d,\n111,\n222,[33\n3]\n444,55\n5,[666]\n```\n\nWith this option, the standard input is interpreted per a NUL character rather than per a newline character.\nYou should also pay attention to that strings in the hole are concatenated with the NUL character instead of a newline character in `teip`'s procedure.\n\nIn other words, if you use a targeted command that cannot handle NUL characters (and cannot print NUL-separated results), the final result can be unintended.\n\n```bash\n$ printf '111,\\n222,33\\n3\\0\\n444,55\\n5,666\\n' | teip -z -f3 -d, -- sed -z 's/.*/@@@/g'\n111,\n222,@@@\n444,55\n5,@@@\n\n$ printf '111,\\n222,33\\n3\\0\\n444,55\\n5,666\\n' | teip -z -f3 -d, -- sed 's/.*/@@@/g'\n111,\n222,@@@\n@@@\n444,55\n5,teip: Output of given command is exhausted\n```\n\nSpecifying from one line to another is a typical use case for this option.\n\n```bash\n$ cat test.html | teip -z -og '<body>.*</body>'\n<html>\n<head>\n  <title>AAA</title>\n</head>\n[<body>\n  <div>AAA</div>\n  <div>BBB</div>\n  <div>CCC</div>\n</body>]\n</html>\n\n$ cat test.html | teip -z -og '<body>.*</body>' -- grep -a BBB\n<html>\n<head>\n  <title>AAA</title>\n</head>\n  <div>BBB</div>\n</html>\n```\n\n### External execution for match offloading (`-e`)\n\n`-e` is the option to use external commands for pattern matching.\nUntil the above, you had to use `teip`'s own functions, such as `-c` or `-g`, to control the position of the holes on the masking tape.\nWith `-e`, however, you can use the external commands you are familiar with to specify the range of holes.\n\n`-e` allows you to specify the shell pipeline as a string.\nOn UNIX-like OS, this pipeline is executed in `/bin/sh`, on Windows in `cmd.exe`.\n\nFor example, with a pipeline `echo 3` that outputs `3`, then only the third line will be bypassed.\n\n```bash\n$ echo -e 'AAA\\nBBB\\nCCC' | teip -e 'echo 3'\nAAA\nBBB\n[CCC]\n```\n\nIt works even if the output is somewhat 'dirty'.\nFor example, if any spaces or tab characters are included at the beginning of a line, they are ignored.\nAlso, once a number is given, it does not matter if there are non-numerical characters to the right of the number.\n\n```bash\n$ echo -e 'AAA\\nBBB\\nCCC' | teip -e 'echo \" 3\"'\nAAA\nBBB\n[CCC]\n$ echo -e 'AAA\\nBBB\\nCCC' | teip -e 'echo \" 3:testtest\"'\nAAA\nBBB\n[CCC]\n```\n\nTechnically, the first captured group in the regular expression `^\\s*([0-9]+)` is interpreted as a line number.\n\n`-e` will also recognize multiple numbers if the pipeline provides multiple lines of numbers.\nFor example, the `seq` command to display only odd numbers up to 10 is.\n\n```bash\n$ seq 1 2 10\n1\n3\n5\n7\n9\n```\n\nThis means that only odd-numbered rows can be bypassed by specifying the following.\n\n```bash\n$ echo -e 'AAA\\nBBB\\nCCC\\nDDD\\nEEE\\nFFF' | teip -e 'seq 1 2 10' -- sed 's/. /@/g'\n@@@\nBBB\n@@@\nDDD\n@@@\nFFF\n```\n\nNote that the order of the numbers must be in ascending order.\nNow, on its own, this looks like a feature that is just a slight development of the `-l` option.\n\nHowever, the breakthrough of this feature is that **the pipeline obtains identical standard input as `teip`**.\nThus, it can output any number using not only `seq` and `echo`, but also commands such as `grep`, `sed`, and `awk`, which process the standard input.\n\nLet's look at a more concrete example.\nThe following command is a `grep` command that prints **the line numbers of the line containing the string \"CCC\" and the two lines after it**.\n\n```bash\n$ echo -e 'AAA\\nBBB\\nCCC\\nDDD\\nEEE\\nFFF' | grep -n -A 2 CCC\n3:CCC\n4-DDD\n5-EEE\n```\n\nIf you give this command to `-e`, you can punch holes in **the line containing the string \"CCC\" and the two lines after it**!\n\n```bash\n$ echo -e 'AAA\\nBBB\\nCCC\\nDDD\\nEEE\\nFFF' | teip -e 'grep -n -A 2 CCC'\nAAA\nBBB\n[CCC]\n[DDD]\n[EEE]\nFFF\n```\n\n`grep` is not the only one.\nGNU `sed` has `=`, which prints the line number being processed.\nBelow is an example of how to drill from the line containing \"BBB\" to the line containing \"EEE\".\n\n```bash\n$ echo -e 'AAA\\nBBB\\nCCC\\nDDD\\nEEE\\nFFF' | teip -e 'sed -n \"/BBB/,/EEE/=\"'\nAAA\n[BBB]\n[CCC]\n[DDD]\n[EEE]\nFFF\n```\n\nOf course, similar operations can also be done with `awk`.\n\n```bash\n$ echo -e 'AAA\\nBBB\\nCCC\\nDDD\\nEEE\\nFFF' | teip -e 'awk \"/BBB/,/EEE/{print NR}\"'\n```\n\nThe following is an example of combining the commands `nl` and `tail`.\nYou can only make holes in the last three lines of input!\n\n```bash\n$ echo -e 'AAA\\nBBB\\nCCC\\nDDD\\nEEE\\nFFF' | teip -e 'nl -ba | tail -n 3'\nAAA\nBBB\nCCC\n[DDD]\n[EEE]\n[FFF]\n```\n\nThe `-e` argument is a single string.\nTherefore, pipe `|` and other symbols can be used as it is.\n\n### Alias options (`-A`, `-B`, `-C`, `--awk`, `--sed`)\n\nThere are several **experimental options** which are alias of `-e` and specific string.\nThese options may be discontinued in the future since they are just experimental ones.\nDo not use them in the script or something that is not a one-off.\n\n#### `-A <number>`\nThis is an alias of `-e 'grep -n -A <number> <pattern>'`.\nIf it is used together with `-g <pattern>` option, it makes holes in row matching `<pattern>` and `<number>` rows after the row.\n\n```\n$ cat AtoG.txt | teip -g B -A 2\nA\n[B]\n[C]\n[D]\nE\nF\nG\n```\n\n\n#### `-B <number>`\n\nThis is an alias of `-e 'grep -n -B <number> <pattern>'`\nIf it is used together with `-g <pattern>` option, it makes holes in row matching `<pattern>` and `<number>` rows before the row.\n\n```\n$ cat AtoG.txt | teip -g E -B 2\nA\nB\n[C]\n[D]\n[E]\nF\nG\n```\n\n\n\n#### `-C <number>`\nThis is an alias of `-e 'grep -n -C <number> <pattern>'`.\nIf it is used together with `-g <pattern>` option, it makes holes in row matching `<pattern>` and `<number>` rows before and after the row.\n\n```\n$ cat AtoG.txt | teip -g E -C 2\nA\nB\n[C]\n[D]\n[E]\n[F]\n[G]\n```\n\n#### `--sed <pattern>`\n\nThis is an alias of `-e 'sed -n \"<pattern>=\"`.\n\n```\n$ cat AtoG.txt | teip --sed '/B/,/E/'\nA\n[B]\n[C]\n[D]\n[E]\nF\nG\n```\n\n```\n$ cat AtoG.txt | teip --sed '1~3'\n[A]\nB\nC\n[D]\nE\nF\n[G]\n```\n\n#### `--awk <pattern>`\n\nThis is an alias of `-e 'awk \"<pattern>{print NR}\"`.\n\n```\n$ cat AtoG.txt | teip --awk '/B/,/E/'\nA\n[B]\n[C]\n[D]\n[E]\nF\nG\n```\n\n```\n$ cat AtoG.txt | teip --awk 'NR%3==0'\nA\nB\n[C]\nD\nE\n[F]\nG\n```\n\n\n## Environment variables\n\n`teip` refers to the following environment variables.\nAdd the statement to your default shell's startup file (i.e `.bashrc`, `.zshrc`) to change them as you like.\n\n### `TEIP_HIGHLIGHT`\n\n**DEFAULT VALUE:** `\\x1b[36m[\\x1b[0m\\x1b[01;31m{}\\x1b[0m\\x1b[36m]\\x1b[0m`\n\nThe default format for highlighting hole.\nIt must include at least one `{}` as a placeholder.\n\nExample:\n```\n$ export TEIP_HIGHLIGHT=\"<<<{}>>>\"\n$ echo ABAB | teip -og A\n<<<A>>>B<<<A>>>B\n\n$ export TEIP_HIGHLIGHT=$'\\x1b[01;31m{}\\x1b[0m'\n$ echo ABAB | teip -og A\nABAB  ### Same color as grep\n```\n\n[ANSI Escape Sequences](https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797) and [ANSI-C Quoting](https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html) are helpful to customize this value.\n\n### `TEIP_GREP_PATH`\n\n**DEFAULT VALUE:** `grep`\n\nThe path to `grep` command used by `-A`, `-B`, `-C` options.\nFor example, if you want to use `ggrep` instead of `grep`, set this variable to `ggrep`.\n\n```\n$ export TEIP_GREP_PATH=/opt/homebrew/bin/ggrep\n$ echo -e 'AAA\\nBBB\\nCCC\\nDDD\\nEEE\\nFFF' | teip -g CCC -A 2\nAAA\nBBB\n[CCC]\n[DDD]\n[EEE]\nFFF\n```\n\n### `TEIP_SED_PATH`\n\n**DEFAULT VALUE:** `sed`\n\nThe path to `sed` command used by `--sed` option.\nFor example, if you want to use `gsed` instead of `sed`, set this variable to `gsed`.\n\n### `TEIP_AWK_PATH`\n\n**DEFAULT VALUE:** `awk`\n\nThe path to `awk` command used by `--awk` option.\nFor example, if you want to use `gawk` instead of `awk`, set this variable to `gawk`.\n\n## Background\n\n### Why made it?\nSee this [post](https://dev.to/greymd/teip-masking-tape-for-shell-is-what-we-needed-5e05).\n\n### Why \"teip\"?\n\n* [tee](https://en.wikipedia.org/wiki/Tee_%28command%29) + in-place.\n* And it sounds similar to Masking-\"tape\".\n\n## License\n\n### Modules imported/referenced from other repositories\n\nThank you so much for helpful modules!\n\n* ./src/list/ranges.rs\n  - One of the module used in `cut` command of [uutils/coreutils](https://github.com/uutils/coreutils)\n  - Original souce codes are distributed under MIT license\n  - The license file is on the same directory\n\n* ./src/csv/parser.rs\n  - Many parts of the source code are referenced from [BurntSushi/rust-csv](https://github.com/BurntSushi/rust-csv).\n  - Original source codes are distributed under dual-licensed under MIT and Unlicense\n\n### Source code\nThe scripts are available as open source under the terms of the [MIT License](http://opensource.org/licenses/MIT).\n\n### Logo\n<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc/4.0/88x31.png\" /></a><br />The logo of teip is licensed under a <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\">Creative Commons Attribution-NonCommercial 4.0 International License</a>."
}
