{
  "name": "syft",
  "full_name": "syft",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "CLI for generating a Software Bill of Materials from container images",
  "license": "Apache-2.0",
  "homepage": "https://github.com/anchore/syft",
  "versions": {
    "stable": "0.85.0",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/anchore/syft.git",
      "tag": "v0.85.0",
      "revision": "4fc17edd146af34ab06f5b0443ef8ddac3aaf076",
      "checksum": null
    },
    "head": {
      "url": "https://github.com/anchore/syft.git",
      "branch": "main"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/syft/blobs/sha256:27cdd71d527e3d63482a8cb596cb461ed13c3d91ad2ff7def37e74534da60da0",
          "sha256": "27cdd71d527e3d63482a8cb596cb461ed13c3d91ad2ff7def37e74534da60da0"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/syft/blobs/sha256:6386fc5f518d8ec96eee0694e870d6499525db6881343da8f8d5ab0ca1f671e1",
          "sha256": "6386fc5f518d8ec96eee0694e870d6499525db6881343da8f8d5ab0ca1f671e1"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/syft/blobs/sha256:6e232a139d183565c2d0a6e9e1bb66f97678fa9f6ba76be14ff66de5f0401db4",
          "sha256": "6e232a139d183565c2d0a6e9e1bb66f97678fa9f6ba76be14ff66de5f0401db4"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/syft/blobs/sha256:e3e72590bdb60d47eccf8e7906390da550f46a111edcc81282a8a29a9533aebf",
          "sha256": "e3e72590bdb60d47eccf8e7906390da550f46a111edcc81282a8a29a9533aebf"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/syft/blobs/sha256:e937105cb7a3bea0a13281bb7d72bdce9cef967a8d6c5c92725f66a26a47e75d",
          "sha256": "e937105cb7a3bea0a13281bb7d72bdce9cef967a8d6c5c92725f66a26a47e75d"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/syft/blobs/sha256:d5e6d93ef1a8c896e087312d9d44a85b0d116060ac086126e8580297d5b7bda0",
          "sha256": "d5e6d93ef1a8c896e087312d9d44a85b0d116060ac086126e8580297d5b7bda0"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/syft/blobs/sha256:45d014cbbed54b74cf6640740ef37c5cc09051b9515bc8acb84385b15acb80b9",
          "sha256": "45d014cbbed54b74cf6640740ef37c5cc09051b9515bc8acb84385b15acb80b9"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "go"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/syft.rb",
  "ruby_source_checksum": {
    "sha256": "01ebde875a9a238f85568c23b46f6b13658e0767decbcc57bcfb27c45303aa91"
  },
  "date_added": "2022-12-26T04:19:53+00:00",
  "readme": "<p align=\"center\">\n    <img src=\"https://user-images.githubusercontent.com/5199289/136844524-1527b09f-c5cb-4aa9-be54-5aa92a6086c1.png\" width=\"271\" alt=\"Cute pink owl syft logo\">\n</p>\n\n[![Validations](https://github.com/anchore/syft/actions/workflows/validations.yaml/badge.svg)](https://github.com/anchore/syft/actions/workflows/validations.yaml)\n[![Go Report Card](https://goreportcard.com/badge/github.com/anchore/syft)](https://goreportcard.com/report/github.com/anchore/syft)\n[![GitHub release](https://img.shields.io/github/release/anchore/syft.svg)](https://github.com/anchore/syft/releases/latest)\n[![GitHub go.mod Go version](https://img.shields.io/github/go-mod/go-version/anchore/syft.svg)](https://github.com/anchore/syft)\n[![License: Apache-2.0](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://github.com/anchore/syft/blob/main/LICENSE)\n[![Slack Invite](https://img.shields.io/badge/Slack-Join-blue?logo=slack)](https://anchore.com/slack)\n\nA CLI tool and Go library for generating a Software Bill of Materials (SBOM) from container images and filesystems. Exceptional for vulnerability detection when used with a scanner like [Grype](https://github.com/anchore/grype).\n\n### Join our community meetings!\n\n- Calendar: https://calendar.google.com/calendar/u/0/r?cid=Y182OTM4dGt0MjRtajI0NnNzOThiaGtnM29qNEBncm91cC5jYWxlbmRhci5nb29nbGUuY29t\n- Agenda: https://docs.google.com/document/d/1ZtSAa6fj2a6KRWviTn3WoJm09edvrNUp4Iz_dOjjyY8/edit?usp=sharing (join [this group](https://groups.google.com/g/anchore-oss-community) for write access)\n- All are welcome!\n\nFor commercial support options with Syft or Grype, please [contact Anchore](https://get.anchore.com/contact/)\n\n![syft-demo](https://user-images.githubusercontent.com/590471/90277200-2a253000-de33-11ea-893f-32c219eea11a.gif)\n\n## Features\n- Generates SBOMs for container images, filesystems, archives, and more to discover packages and libraries\n- Supports OCI, Docker and [Singularity](https://github.com/sylabs/singularity) image formats\n- Linux distribution identification\n- Works seamlessly with [Grype](https://github.com/anchore/grype) (a fast, modern vulnerability scanner)\n- Able to create signed SBOM attestations using the [in-toto specification](https://github.com/in-toto/attestation/blob/main/spec/README.md)\n- Convert between SBOM formats, such as CycloneDX, SPDX, and Syft's own format.\n\n### Supported Ecosystems\n\n- Alpine (apk)\n- C (conan)\n- C++ (conan)\n- Dart (pubs)\n- Debian (dpkg)\n- Dotnet (deps.json)\n- Objective-C (cocoapods)\n- Elixir (mix)\n- Erlang (rebar3)\n- Go (go.mod, Go binaries)\n- Haskell (cabal, stack)\n- Java (jar, ear, war, par, sar, nar, native-image)\n- JavaScript (npm, yarn)\n- Jenkins Plugins (jpi, hpi)\n- Linux kernel archives (vmlinz)\n- Linux kernel modules (ko)\n- Nix (outputs in /nix/store)\n- PHP (composer)\n- Python (wheel, egg, poetry, requirements.txt)\n- Red Hat (rpm)\n- Ruby (gem)\n- Rust (cargo.lock)\n- Swift (cocoapods, swift-package-manager)\n\n## Installation\n\n**Note**: Currently, Syft is built only for Linux, macOS and Windows.\n\n### Recommended\n```bash\ncurl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin\n```\n\n... or, you can specify a release version and destination directory for the installation:\n\n```\ncurl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b <DESTINATION_DIR> <RELEASE_VERSION>\n```\n\n### Chocolatey\n\nThe chocolatey distribution of syft is community maintained and not distributed by the anchore team\n\n```powershell\nchoco install syft -y\n```\n\n### Scoop\n\n```powershell\nscoop install syft\n```\n\n### Homebrew\n```bash\nbrew install syft\n```\n\n### Nix\n\n**Note**: Nix packaging of Syft is [community maintained](https://github.com/NixOS/nixpkgs/blob/master/pkgs/tools/admin/syft/default.nix). Syft is available in the [stable channel](https://nixos.wiki/wiki/Nix_channels#The_official_channels) since NixOS `22.05`.\n\n```bash\nnix-env -i syft\n```\n\n... or, just try it out in an ephemeral nix shell:\n\n```bash\nnix-shell -p syft\n```\n\n## Getting started\n\n### SBOM\n\nTo generate an SBOM for a container image:\n\n```\nsyft <image>\n```\n\nThe above output includes only software that is visible in the container (i.e., the squashed representation of the image). To include software from all image layers in the SBOM, regardless of its presence in the final image, provide `--scope all-layers`:\n\n```\nsyft <image> --scope all-layers\n```\n\n### Supported sources\n\nSyft can generate a SBOM from a variety of sources:\n\n```\n# catalog a container image archive (from the result of `docker image save ...`, `podman save ...`, or `skopeo copy` commands)\nsyft path/to/image.tar\n\n# catalog a Singularity Image Format (SIF) container\nsyft path/to/image.sif\n\n# catalog a directory\nsyft path/to/dir\n```\n\nSources can be explicitly provided with a scheme:\n\n```\ndocker:yourrepo/yourimage:tag            use images from the Docker daemon\npodman:yourrepo/yourimage:tag            use images from the Podman daemon\ndocker-archive:path/to/yourimage.tar     use a tarball from disk for archives created from \"docker save\"\noci-archive:path/to/yourimage.tar        use a tarball from disk for OCI archives (from Skopeo or otherwise)\noci-dir:path/to/yourimage                read directly from a path on disk for OCI layout directories (from Skopeo or otherwise)\nsingularity:path/to/yourimage.sif        read directly from a Singularity Image Format (SIF) container on disk\ndir:path/to/yourproject                  read directly from a path on disk (any directory)\nfile:path/to/yourproject/file            read directly from a path on disk (any single file)\nregistry:yourrepo/yourimage:tag          pull image directly from a registry (no container runtime required)\n```\n\nIf an image source is not provided and cannot be detected from the given reference it is assumed the image should be pulled from the Docker daemon.\nIf docker is not present, then the Podman daemon is attempted next, followed by reaching out directly to the image registry last.\n\n\nThis default behavior can be overridden with the `default-image-pull-source` configuration option (See [Configuration](https://github.com/anchore/syft#configuration) for more details).\n\n### Default Cataloger Configuration by scan type\n\nSyft uses different default sets of catalogers depending on what it is scanning: a container image or a directory on disk. The default catalogers for an image scan assumes that package installation steps have already been completed. For example, Syft will identify Python packages that have egg or wheel metadata files under a site-packages directory, since this indicates software actually installed on an image.\n\nHowever, if you are scanning a directory, Syft doesn't assume that all relevant software is installed, and will use catalogers that can identify declared dependencies that may not yet be installed on the final system: for example, dependencies listed in a Python requirements.txt.\n\nYou can override the list of enabled/disabled catalogers by using the \"catalogers\" keyword in the [Syft configuration file](https://github.com/anchore/syft#configuration).\n\n##### Image Scanning:\n- alpmdb\n- apkdb\n- binary\n- dotnet-deps\n- dpkgdb\n- go-module-binary\n- graalvm-native-image\n- java\n- javascript-package\n- linux-kernel\n- nix-store\n- php-composer-installed\n- portage\n- python-package\n- rpm-db\n- ruby-gemspec\n- sbom\n\n##### Directory Scanning:\n- alpmdb\n- apkdb\n- binary\n- cocoapods\n- conan\n- dartlang-lock\n- dotnet-deps\n- dpkgdb\n- elixir-mix-lock\n- erlang-rebar-lock\n- go-mod-file\n- go-module-binary\n- graalvm-native-image\n- haskell\n- java\n- java-gradle-lockfile\n- java-pom\n- javascript-lock\n- linux-kernel\n- nix-store\n- php-composer-lock\n- portage\n- python-index\n- python-package\n- rpm-db\n- rpm-file\n- ruby-gemfile\n- rust-cargo-lock\n- sbom\n- swift-package-manager\n\n##### Non Default:\n- cargo-auditable-binary\n\n### Excluding file paths\n\nSyft can exclude files and paths from being scanned within a source by using glob expressions\nwith one or more `--exclude` parameters:\n```\nsyft <source> --exclude './out/**/*.json' --exclude /etc\n```\n**Note:** in the case of _image scanning_, since the entire filesystem is scanned it is\npossible to use absolute paths like `/etc` or `/usr/**/*.txt` whereas _directory scans_\nexclude files _relative to the specified directory_. For example: scanning `/usr/foo` with\n`--exclude ./package.json` would exclude `/usr/foo/package.json` and `--exclude '**/package.json'`\nwould exclude all `package.json` files under `/usr/foo`. For _directory scans_,\nit is required to begin path expressions with `./`, `*/`, or `**/`, all of which\nwill be resolved _relative to the specified scan directory_. Keep in mind, your shell\nmay attempt to expand wildcards, so put those parameters in single quotes, like:\n`'**/*.json'`.\n\n### Output formats\n\nThe output format for Syft is configurable as well using the\n`-o` (or `--output`) option:\n\n```\nsyft <image> -o <format>\n```\n\nWhere the `formats` available are:\n- `json`: Use this to get as much information out of Syft as possible!\n- `text`: A row-oriented, human-and-machine-friendly output.\n- `cyclonedx-xml`: A XML report conforming to the [CycloneDX 1.4 specification](https://cyclonedx.org/specification/overview/).\n- `cyclonedx-json`: A JSON report conforming to the [CycloneDX 1.4 specification](https://cyclonedx.org/specification/overview/).\n- `spdx-tag-value`: A tag-value formatted report conforming to the [SPDX 2.3 specification](https://spdx.github.io/spdx-spec/v2.3/).\n- `spdx-tag-value@2.2`: A tag-value formatted report conforming to the [SPDX 2.2 specification](https://spdx.github.io/spdx-spec/v2.2.2/).\n- `spdx-json`: A JSON report conforming to the [SPDX 2.3 JSON Schema](https://github.com/spdx/spdx-spec/blob/v2.3/schemas/spdx-schema.json).\n- `spdx-json@2.2`: A JSON report conforming to the [SPDX 2.2 JSON Schema](https://github.com/spdx/spdx-spec/blob/v2.2/schemas/spdx-schema.json).\n- `github`: A JSON report conforming to GitHub's dependency snapshot format.\n- `table`: A columnar summary (default).\n- `template`: Lets the user specify the output format. See [\"Using templates\"](#using-templates) below.\n\n## Using templates\n\nSyft lets you define custom output formats, using [Go templates](https://pkg.go.dev/text/template). Here's how it works:\n\n- Define your format as a Go template, and save this template as a file.\n\n- Set the output format to \"template\" (`-o template`).\n\n- Specify the path to the template file (`-t ./path/to/custom.template`).\n\n- Syft's template processing uses the same data models as the `json` output format â€” so if you're wondering what data is available as you author a template, you can use the output from `syft <image> -o json` as a reference.\n\n**Example:** You could make Syft output data in CSV format by writing a Go template that renders CSV data and then running `syft <image> -o template -t ~/path/to/csv.tmpl`.\n\nHere's what the `csv.tmpl` file might look like:\n```gotemplate\n\"Package\",\"Version Installed\",\"Found by\"\n{{- range .Artifacts}}\n\"{{.Name}}\",\"{{.Version}}\",\"{{.FoundBy}}\"\n{{- end}}\n```\n\nWhich would produce output like:\n```text\n\"Package\",\"Version Installed\",\"Found by\"\n\"alpine-baselayout\",\"3.2.0-r20\",\"apkdb-cataloger\"\n\"alpine-baselayout-data\",\"3.2.0-r20\",\"apkdb-cataloger\"\n\"alpine-keys\",\"2.4-r1\",\"apkdb-cataloger\"\n...\n```\n\nSyft also includes a vast array of utility templating functions from [sprig](http://masterminds.github.io/sprig/) apart from the default Golang [text/template](https://pkg.go.dev/text/template#hdr-Functions) to allow users to customize the output format.\n\nLastly, Syft has custom templating functions defined in `./syft/format/template/encoder.go` to help parse the passed-in JSON structs.\n\n## Multiple outputs\n\nSyft can also output _multiple_ files in differing formats by appending\n`=<file>` to the option, for example to output Syft JSON and SPDX JSON:\n\n```shell\nsyft <image> -o json=sbom.syft.json -o spdx-json=sbom.spdx.json\n```\n\n## Private Registry Authentication\n\n### Local Docker Credentials\nWhen a container runtime is not present, Syft can still utilize credentials configured in common credential sources (such as `~/.docker/config.json`). It will pull images from private registries using these credentials. The config file is where your credentials are stored when authenticating with private registries via some command like `docker login`. For more information see the `go-containerregistry` [documentation](https://github.com/google/go-containerregistry/tree/main/pkg/authn).\n\nAn example `config.json` looks something like this:\n```json\n{\n\t\"auths\": {\n\t\t\"registry.example.com\": {\n\t\t\t\"username\": \"AzureDiamond\",\n\t\t\t\"password\": \"hunter2\"\n\t\t}\n\t}\n}\n```\n\nYou can run the following command as an example. It details the mount/environment configuration a container needs to access a private registry:\n\n```\ndocker run -v ./config.json:/config/config.json -e \"DOCKER_CONFIG=/config\" anchore/syft:latest  <private_image>\n```\n\n### Docker Credentials in Kubernetes\n\nHere's a simple workflow to mount this config file as a secret into a container on Kubernetes.\n\n1. Create a secret. The value of `config.json` is important. It refers to the specification detailed [here](https://github.com/google/go-containerregistry/tree/main/pkg/authn#the-config-file). Below this section is the `secret.yaml` file that the pod configuration will consume as a volume. The key `config.json` is important. It will end up being the name of the file when mounted into the pod.\n\n    ```yaml\n    # secret.yaml\n\n    apiVersion: v1\n    kind: Secret\n    metadata:\n      name: registry-config\n      namespace: syft\n    data:\n      config.json: <base64 encoded config.json>\n    ```\n\n   `kubectl apply -f secret.yaml`\n\n\n2. Create your pod running syft. The env `DOCKER_CONFIG` is important because it advertises where to look for the credential file. In the below example, setting `DOCKER_CONFIG=/config` informs syft that credentials can be found at `/config/config.json`. This is why we used `config.json` as the key for our secret. When mounted into containers the secrets' key is used as the filename. The `volumeMounts` section mounts our secret to `/config`. The `volumes` section names our volume and leverages the secret we created in step one.\n\n    ```yaml\n    # pod.yaml\n\n    apiVersion: v1\n    kind: Pod\n    metadata:\n      name: syft-k8s-usage\n    spec:\n      containers:\n        - image: anchore/syft:latest\n          name: syft-private-registry-demo\n          env:\n            - name: DOCKER_CONFIG\n              value: /config\n          volumeMounts:\n          - mountPath: /config\n            name: registry-config\n            readOnly: true\n          args:\n            - <private_image>\n      volumes:\n      - name: registry-config\n        secret:\n          secretName: registry-config\n    ```\n\n   `kubectl apply -f pod.yaml`\n\n\n3. The user can now run `kubectl logs syft-private-registry-demo`. The logs should show the Syft analysis for the `<private_image>` provided in the pod configuration.\n\nUsing the above information, users should be able to configure private registry access without having to do so in the `grype` or `syft` configuration files.  They will also not be dependent on a Docker daemon, (or some other runtime software) for registry configuration and access.\n\n## Format conversion (experimental)\n\nThe ability to convert existing SBOMs means you can create SBOMs in different formats quickly, without the need to regenerate the SBOM from scratch, which may take significantly more time.\n\n```\nsyft convert <ORIGINAL-SBOM-FILE> -o <NEW-SBOM-FORMAT>[=<NEW-SBOM-FILE>]\n```\n\nThis feature is experimental and data might be lost when converting formats. Packages are the main SBOM component easily transferable across formats, whereas files and relationships, as well as other information Syft doesn't support, are more likely to be lost.\n\nWe support formats with wide community usage AND good encode/decode support by Syft. The supported formats are:\n- Syft JSON\n- SPDX 2.2 JSON\n- SPDX 2.2 tag-value\n- CycloneDX 1.4 JSON\n- CycloneDX 1.4 XML\n\nConversion example:\n```sh\nsyft alpine:latest -o syft-json=sbom.syft.json # generate a syft SBOM\nsyft convert sbom.syft.json -o cyclonedx-json=sbom.cdx.json  # convert it to CycloneDX\n```\n\n## Attestation (experimental)\n### Keyless support\nSyft supports generating attestations using cosign's [keyless](https://github.com/sigstore/cosign/blob/main/KEYLESS.md) signatures.\n\nNote: users need to have >= v1.12.0 of cosign installed for this command to function\n\nTo use this feature with a format like CycloneDX json simply run:\n```\nsyft attest --output cyclonedx-json <IMAGE WITH OCI WRITE ACCESS>\n```\nThis command will open a web browser and allow the user to authenticate their OIDC identity as the root of trust for the attestation (Github, Google, Microsoft).\n\nAfter authenticating, Syft will upload the attestation to the OCI registry specified by the image that the user has write access to.\n\nYou will need to make sure your credentials are configured for the OCI registry you are uploading to so that the attestation can write successfully.\n\nUsers can then verify the attestation(or any image with attestations) by running:\n```\nCOSIGN_EXPERIMENTAL=1 cosign verify-attestation <IMAGE_WITH_ATTESTATIONS>\n```\n\nUsers should see that the uploaded attestation claims are validated, the claims exist within the transparency log, and certificates on the attestations were verified against [fulcio](https://github.com/SigStore/fulcio).\nThere will also be a printout of the certificates subject `<user identity>` and the certificate issuer URL: `<provider of user identity (Github, Google, Microsoft)>`:\n```\nCertificate subject:  test.email@testdomain.com\nCertificate issuer URL:  https://accounts.google.com\n```\n\n### Local private key support\n\nTo generate an SBOM attestation for a container image using a local private key:\n```\nsyft attest --output [FORMAT] --key [KEY] [SOURCE] [flags]\n```\n\nThe above output is in the form of the [DSSE envelope](https://github.com/secure-systems-lab/dsse/blob/master/envelope.md#dsse-envelope).\nThe payload is a base64 encoded `in-toto` statement with the generated SBOM as the predicate. For details on workflows using this command see [here](#adding-an-sbom-to-an-image-as-an-attestation-using-syft).\n\n\n\n## Configuration\n\nConfiguration search paths:\n\n- `.syft.yaml`\n- `.syft/config.yaml`\n- `~/.syft.yaml`\n- `<XDG_CONFIG_HOME>/syft/config.yaml`\n\nConfiguration options (example values are the default):\n\n```yaml\n# the output format(s) of the SBOM report (options: table, text, json, spdx, ...)\n# same as -o, --output, and SYFT_OUTPUT env var\n# to specify multiple output files in differing formats, use a list:\n# output:\n#   - \"json=<syft-json-output-file>\"\n#   - \"spdx-json=<spdx-json-output-file>\"\noutput: \"table\"\n\n# suppress all output (except for the SBOM report)\n# same as -q ; SYFT_QUIET env var\nquiet: false\n\n# same as --file; write output report to a file (default is to write to stdout)\nfile: \"\"\n\n# enable/disable checking for application updates on startup\n# same as SYFT_CHECK_FOR_APP_UPDATE env var\ncheck-for-app-update: true\n\n# allows users to specify which image source should be used to generate the sbom\n# valid values are: registry, docker, podman\ndefault-image-pull-source: \"\"\n\n# a list of globs to exclude from scanning. same as --exclude ; for example:\n# exclude:\n#   - \"/etc/**\"\n#   - \"./out/**/*.json\"\nexclude: []\n\n# allows users to exclude synthetic binary packages from the sbom\n# these packages are removed if an overlap with a non-synthetic package is found\nexclude-binary-overlap-by-ownership: true\n\n# os and/or architecture to use when referencing container images (e.g. \"windows/armv6\" or \"arm64\")\n# same as --platform; SYFT_PLATFORM env var\nplatform: \"\"\n\n# set the list of package catalogers to use when generating the SBOM\n# default = empty (cataloger set determined automatically by the source type [image or file/directory])\n# catalogers:\n#   - alpmdb-cataloger\n#   - apkdb-cataloger\n#   - binary-cataloger\n#   - cargo-auditable-binary-cataloger\n#   - cocoapods-cataloger\n#   - conan-cataloger\n#   - dartlang-lock-cataloger\n#   - dotnet-deps-cataloger\n#   - dpkgdb-cataloger\n#   - elixir-mix-lock-cataloger\n#   - erlang-rebar-lock-cataloger\n#   - go-mod-file-cataloger\n#   - go-module-binary-cataloger\n#   - graalvm-native-image-cataloger\n#   - haskell-cataloger\n#   - java-cataloger\n#   - java-gradle-lockfile-cataloger\n#   - java-pom-cataloger\n#   - javascript-lock-cataloger\n#   - javascript-package-cataloger\n#   - linux-kernel-cataloger\n#   - nix-store-cataloger\n#   - php-composer-installed-cataloger\n#   - php-composer-lock-cataloger\n#   - portage-cataloger\n#   - python-index-cataloger\n#   - python-package-cataloger\n#   - rpm-db-cataloger\n#   - rpm-file-cataloger\n#   - ruby-gemfile-cataloger\n#   - ruby-gemspec-cataloger\n#   - rust-cargo-lock-cataloger\n#   - sbom-cataloger\n#   - spm-cataloger\ncatalogers:\n\n# cataloging packages is exposed through the packages and power-user subcommands\npackage:\n\n  # search within archives that do contain a file index to search against (zip)\n  # note: for now this only applies to the java package cataloger\n  # SYFT_PACKAGE_SEARCH_INDEXED_ARCHIVES env var\n  search-indexed-archives: true\n\n  # search within archives that do not contain a file index to search against (tar, tar.gz, tar.bz2, etc)\n  # note: enabling this may result in a performance impact since all discovered compressed tars will be decompressed\n  # note: for now this only applies to the java package cataloger\n  # SYFT_PACKAGE_SEARCH_UNINDEXED_ARCHIVES env var\n  search-unindexed-archives: false\n\n  cataloger:\n    # enable/disable cataloging of packages\n    # SYFT_PACKAGE_CATALOGER_ENABLED env var\n    enabled: true\n\n    # the search space to look for packages (options: all-layers, squashed)\n    # same as -s ; SYFT_PACKAGE_CATALOGER_SCOPE env var\n    scope: \"squashed\"\n\ngolang:\n   # search for go package licences in the GOPATH of the system running Syft, note that this is outside the\n   # container filesystem and potentially outside the root of a local directory scan\n   # SYFT_GOLANG_SEARCH_LOCAL_MOD_CACHE_LICENSES env var\n   search-local-mod-cache-licenses: false\n   \n   # specify an explicit go mod cache directory, if unset this defaults to $GOPATH/pkg/mod or $HOME/go/pkg/mod\n   # SYFT_GOLANG_LOCAL_MOD_CACHE_DIR env var\n   local-mod-cache-dir: \"\"\n\n   # search for go package licences by retrieving the package from a network proxy\n   # SYFT_GOLANG_SEARCH_REMOTE_LICENSES env var\n   search-remote-licenses: false\n\n   # remote proxy to use when retrieving go packages from the network,\n   # if unset this defaults to $GOPROXY followed by https://proxy.golang.org\n   # SYFT_GOLANG_PROXY env var\n   proxy: \"\"\n\n   # specifies packages which should not be fetched by proxy\n   # if unset this defaults to $GONOPROXY\n   # SYFT_GOLANG_NOPROXY env var\n   no-proxy: \"\"\n\nlinux-kernel:\n   # whether to catalog linux kernel modules found within lib/modules/** directories\n   # SYFT_LINUX_KERNEL_CATALOG_MODULES env var\n   catalog-modules: true\n\npython:\n   # when running across entries in requirements.txt that do not specify a specific version \n   # (e.g. \"sqlalchemy >= 1.0.0, <= 2.0.0, != 3.0.0, <= 3.0.0\"), attempt to guess what the version could\n   # be based on the version requirements specified (e.g. \"1.0.0\"). When enabled the lowest expressible version \n   # when given an arbitrary constraint will be used (even if that version may not be available/published).\n   guess-unpinned-requirements: false\n\n# cataloging file contents is exposed through the power-user subcommand\nfile-contents:\n  cataloger:\n    # enable/disable cataloging of secrets\n    # SYFT_FILE_CONTENTS_CATALOGER_ENABLED env var\n    enabled: true\n\n    # the search space to look for secrets (options: all-layers, squashed)\n    # SYFT_FILE_CONTENTS_CATALOGER_SCOPE env var\n    scope: \"squashed\"\n\n  # skip searching a file entirely if it is above the given size (default = 1MB; unit = bytes)\n  # SYFT_FILE_CONTENTS_SKIP_FILES_ABOVE_SIZE env var\n  skip-files-above-size: 1048576\n\n  # file globs for the cataloger to match on\n  # SYFT_FILE_CONTENTS_GLOBS env var\n  globs: []\n\n# cataloging file metadata is exposed through the power-user subcommand\nfile-metadata:\n  cataloger:\n    # enable/disable cataloging of file metadata\n    # SYFT_FILE_METADATA_CATALOGER_ENABLED env var\n    enabled: true\n\n    # the search space to look for file metadata (options: all-layers, squashed)\n    # SYFT_FILE_METADATA_CATALOGER_SCOPE env var\n    scope: \"squashed\"\n\n  # the file digest algorithms to use when cataloging files (options: \"md5\", \"sha1\", \"sha224\", \"sha256\", \"sha384\", \"sha512\")\n  # SYFT_FILE_METADATA_DIGESTS env var\n  digests: [\"sha256\"]\n\n# maximum number of workers used to process the list of package catalogers in parallel\nparallelism: 1\n\n# cataloging secrets is exposed through the power-user subcommand\nsecrets:\n  cataloger:\n    # enable/disable cataloging of secrets\n    # SYFT_SECRETS_CATALOGER_ENABLED env var\n    enabled: true\n\n    # the search space to look for secrets (options: all-layers, squashed)\n    # SYFT_SECRETS_CATALOGER_SCOPE env var\n    scope: \"all-layers\"\n\n  # show extracted secret values in the final JSON report\n  # SYFT_SECRETS_REVEAL_VALUES env var\n  reveal-values: false\n\n  # skip searching a file entirely if it is above the given size (default = 1MB; unit = bytes)\n  # SYFT_SECRETS_SKIP_FILES_ABOVE_SIZE env var\n  skip-files-above-size: 1048576\n\n  # name-regex pairs to consider when searching files for secrets. Note: the regex must match single line patterns\n  # but may also have OPTIONAL multiline capture groups. Regexes with a named capture group of \"value\" will\n  # use the entire regex to match, but the secret value will be assumed to be entirely contained within the\n  # \"value\" named capture group.\n  additional-patterns: {}\n\n  # names to exclude from the secrets search, valid values are: \"aws-access-key\", \"aws-secret-key\", \"pem-private-key\",\n  # \"docker-config-auth\", and \"generic-api-key\". Note: this does not consider any names introduced in the\n  # \"secrets.additional-patterns\" config option.\n  # SYFT_SECRETS_EXCLUDE_PATTERN_NAMES env var\n  exclude-pattern-names: []\n\n# options that apply to all scan sources\nsource:\n  # alias name for the source\n  # SYFT_SOURCE_NAME env var; --source-name flag\n  name: \"\"\n   \n  # alias version for the source\n  # SYFT_SOURCE_VERSION env var; --source-version flag\n  version: \"\"\n   \n  # options affecting the file source type\n  file:\n    # the file digest algorithms to use on the scanned file (options: \"md5\", \"sha1\", \"sha224\", \"sha256\", \"sha384\", \"sha512\")\n    digests: [\"sha256\"]\n\n# options when pulling directly from a registry via the \"registry:\" scheme\nregistry:\n  # skip TLS verification when communicating with the registry\n  # SYFT_REGISTRY_INSECURE_SKIP_TLS_VERIFY env var\n  insecure-skip-tls-verify: false\n\n  # use http instead of https when connecting to the registry\n  # SYFT_REGISTRY_INSECURE_USE_HTTP env var\n  insecure-use-http: false\n\n  # credentials for specific registries\n  auth:\n      # the URL to the registry (e.g. \"docker.io\", \"localhost:5000\", etc.)\n      # SYFT_REGISTRY_AUTH_AUTHORITY env var\n    - authority: \"\"\n      # SYFT_REGISTRY_AUTH_USERNAME env var\n      username: \"\"\n      # SYFT_REGISTRY_AUTH_PASSWORD env var\n      password: \"\"\n      # note: token and username/password are mutually exclusive\n      # SYFT_REGISTRY_AUTH_TOKEN env var\n      token: \"\"\n      # - ... # note, more credentials can be provided via config file only\n\n# generate an attested SBOM\nattest:\n  # path to the private key file to use for attestation\n  # SYFT_ATTEST_KEY env var\n  key: \"cosign.key\"\n\n  # password to decrypt to given private key\n  # SYFT_ATTEST_PASSWORD env var, additionally responds to COSIGN_PASSWORD\n  password: \"\"\n\nlog:\n  # use structured logging\n  # same as SYFT_LOG_STRUCTURED env var\n  structured: false\n\n  # the log level; note: detailed logging suppress the ETUI\n  # same as SYFT_LOG_LEVEL env var\n  level: \"error\"\n\n  # location to write the log file (default is not to have a log file)\n  # same as SYFT_LOG_FILE env var\n  file: \"\"\n```\n\n### Adding an SBOM to an image as an attestation using Syft\n\n`syft attest --output [FORMAT] --key [KEY] [SOURCE] [flags]`\n\nSBOMs themselves can serve as input to different analysis tools. [Grype](https://github.com/anchore/grype), a vulnerability scanner CLI tool from Anchore, is one such tool. Publishers of container images can use attestations to enable their consumers to trust Syft-generated SBOM descriptions of those container images. To create and provide these attestations, image publishers can run `syft attest` in conjunction with the [cosign](https://github.com/sigstore/cosign) tool to attach SBOM attestations to their images.\n\n#### Example attestation\nNote for the following example replace `docker.io/image:latest` with an image you own. You should also have push access to\nits remote reference. Replace `$MY_PRIVATE_KEY` with a private key you own or have generated with cosign.\n\n```bash\nsyft attest --key $MY_PRIVATE_KEY -o spdx-json docker.io/image:latest > image_latest_sbom_attestation.json\ncosign attach attestation --attestation image_latest_sbom_attestation.json docker.io/image:latest\n```\n\nVerify the new attestation exists on your image.\n\n```bash\ncosign verify-attestation --key $MY_PUBLIC_KEY --type spdxjson docker.io/image:latest | jq '.payload | @base64d | .payload | fromjson | .predicate'\n```\n\nYou should see this output along with the attached SBOM:\n\n```\nVerification for docker.io/image:latest --\nThe following checks were performed on each of these signatures:\n  - The cosign claims were validated\n  - The signatures were verified against the specified public key\n  - Any certificates were verified against the Fulcio roots.\n```\n\nConsumers of your image can now trust that the SBOM associated with your image is correct and from a trusted source.\n\nThe SBOM can be piped to Grype:\n\n\n```bash\ncosign verify-attestation --key $MY_PUBLIC_KEY --type spdxjson docker.io/image:latest | jq '.payload | @base64d | .payload | fromjson | .predicate' | grype\n```"
}
