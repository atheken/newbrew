{
  "name": "clitest",
  "full_name": "clitest",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Command-Line Tester",
  "license": "MIT",
  "homepage": "https://github.com/aureliojargas/clitest",
  "versions": {
    "stable": "0.5.0",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/aureliojargas/clitest/archive/refs/tags/0.5.0.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "4005de0bc27e4676e418ab1e1e64861272aa74af1212c73a1173760fc449b049"
    },
    "head": {
      "url": "https://github.com/aureliojargas/clitest.git",
      "branch": "main"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "all": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/clitest/blobs/sha256:3a334de308496969553a04f02121d467c8d4ac05eaa028260096d87b0a9b9e1d",
          "sha256": "3a334de308496969553a04f02121d467c8d4ac05eaa028260096d87b0a9b9e1d"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/clitest.rb",
  "ruby_source_checksum": {
    "sha256": "9e6c87fb238a303ea11f39747d7fe0f68d87c192ce398cf93e702966a7438fca"
  },
  "date_added": "2022-12-09T13:46:48+00:00",
  "readme": "# clitest – Command Line Tester\n\nclitest is a [portable][1] POSIX shell script that performs automatic\ntesting in Unix command lines.\n\nIt's the same concept as in Python's [doctest][2] module: you document\nboth the commands and their expected output, using the familiar\ninteractive prompt format, and a specialized tool tests them.\n\nIn fact, the doctest [official][3] description can also be used for\nclitest:\n\n* The **doctest** module searches for pieces of text that look like\n  interactive **Python sessions**, and then executes those **sessions**\n  to verify that they work exactly as shown.\n\n* The **clitest** command searches for pieces of text that look like\n  interactive **Unix command lines**, and then executes those\n  **command lines** to verify that they work exactly as shown.\n\n\n## Download & install\n\nThe full program is just [a single shell script file][4].\n\nSave it, make it executable and move it to a `$PATH` directory:\n\n```bash\ncurl -sOL https://raw.githubusercontent.com/aureliojargas/clitest/master/clitest\nchmod +x clitest\nsudo mv clitest /usr/bin\n```\n\nNow check if everything is fine:\n\n```\nclitest --help\n```\n\n\n## Docker image\n\nYou can also run clitest in a Docker container ([more info in Docker Hub](https://hub.docker.com/r/aureliojargas/clitest)).\n\n```\ndocker run --rm -t aureliojargas/clitest --help\n```\n\n\n## Quick Intro\n\nSave the commands and their expected output in a text file:\n\n♦ [examples/intro.txt][5]\n\n```\n$ echo \"Hello World\"\nHello World\n$ cd /tmp\n$ pwd\n/tmp\n$ cd \"$OLDPWD\"\n$\n```\n\nUse clitest to run these commands and check their output:\n\n```console\n$ clitest examples/intro.txt\n#1\techo \"Hello World\"\n#2\tcd /tmp\n#3\tpwd\n#4\tcd \"$OLDPWD\"\nOK: 4 of 4 tests passed\n$\n```\n\n\n## CLI Syntax\n\nThere's no syntax to learn.\n\nThe test files are identical to the good old command line interface\n(CLI) you're so familiar:\n\n♦ [examples/cut.txt][6]\n\n```\n$ echo \"one:two:three:four:five:six\" | cut -d : -f 1\none\n$ echo \"one:two:three:four:five:six\" | cut -d : -f 4\nfour\n$ echo \"one:two:three:four:five:six\" | cut -d : -f 1,4\none:four\n$ echo \"one:two:three:four:five:six\" | cut -d : -f 4,1\none:four\n$ echo \"one:two:three:four:five:six\" | cut -d : -f 1-4\none:two:three:four\n$ echo \"one:two:three:four:five:six\" | cut -d : -f 4-\nfour:five:six\n$\n```\n\nThat's it.\n\nJust paste your shell session inside a text file and you have a\nready-to-use test suite.\n\n```console\n$ clitest examples/cut.txt\n#1\techo \"one:two:three:four:five:six\" | cut -d : -f 1\n#2\techo \"one:two:three:four:five:six\" | cut -d : -f 4\n#3\techo \"one:two:three:four:five:six\" | cut -d : -f 1,4\n#4\techo \"one:two:three:four:five:six\" | cut -d : -f 4,1\n#5\techo \"one:two:three:four:five:six\" | cut -d : -f 1-4\n#6\techo \"one:two:three:four:five:six\" | cut -d : -f 4-\nOK: 6 of 6 tests passed\n$\n```\n\nThere are more examples and instructions in the [examples folder][10].\nFor a real-life collection of hundreds of test files, see\n[funcoeszz test files][24].\n\n\n## Testable Documentation\n\nClitest can also **extract and run command lines from documentation**,\nsuch as Markdown files. This very `README.md` file you are now reading\nis testable with `clitest README.md`. All the command lines inside it\nwill be run and checked.\n\nNo more malfunctioning shell commands in your READMEs, you can have\ntestable documentation.\n\nGiven the following Markdown sample document:\n\n♦ [examples/cut.md][7]\n\n```\nThe numeric ranges of the Unix command \"cut\"\n============================================\n\nUse single numbers to extract one specific field:\n\n\t$ echo \"one:two:three:four:five:six\" | cut -d : -f 1\n\tone\n\t$ echo \"one:two:three:four:five:six\" | cut -d : -f 4\n\tfour\n\nUse commas to inform more than one field:\n\n\t$ echo \"one:two:three:four:five:six\" | cut -d : -f 1,4\n\tone:four\n\nNote that inverting the order will *not* invert the output:\n\n\t$ echo \"one:two:three:four:five:six\" | cut -d : -f 4,1\n\tone:four\n\nUse an hyphen to inform a range of fields, from one to four:\n\n\t$ echo \"one:two:three:four:five:six\" | cut -d : -f 1-4\n\tone:two:three:four\n\nIf you omit the second range number, it matches until the last:\n\n\t$ echo \"one:two:three:four:five:six\" | cut -d : -f 4-\n\tfour:five:six\n\ncut is cool, isn't it?\n```\n\nIt is a technical article, not a boring code-only test file. You can\nread its final (formatted) version [here][7].\n\nYou can give this article to clitest, who will identify all the shell\ncommand lines inside it, run them and check if the results are the\nsame.\n\n```console\n$ clitest --prefix tab examples/cut.md\n#1\techo \"one:two:three:four:five:six\" | cut -d : -f 1\n#2\techo \"one:two:three:four:five:six\" | cut -d : -f 4\n#3\techo \"one:two:three:four:five:six\" | cut -d : -f 1,4\n#4\techo \"one:two:three:four:five:six\" | cut -d : -f 4,1\n#5\techo \"one:two:three:four:five:six\" | cut -d : -f 1-4\n#6\techo \"one:two:three:four:five:six\" | cut -d : -f 4-\nOK: 6 of 6 tests passed\n$\n```\n\nNote the use of `--prefix tab` option, to inform clitest that the code\nblocks are prefixed by a tab in this Markdown file. For files with\n4-spaces indented code blocks, use `--prefix 4`. When using\nnon-indented fenced code blocks (\\`\\`\\`), such as this [README.md][8],\nno prefix option is needed.\n\nExamples of testable documentation handled by clitest:\n\n* https://github.com/aureliojargas/txt2regex/blob/master/tests/features.md\n* https://github.com/aureliojargas/txt2regex/blob/master/tests/cmdline.md\n* https://github.com/aureliojargas/sedsed/blob/master/test/command_line.md\n* https://github.com/aureliojargas/replace/blob/master/README.md\n* https://github.com/aureliojargas/clitest/blob/master/test.md\n* https://github.com/caarlos0/jvm/blob/master/tests/test.clitest.md\n* https://github.com/caarlos0/git-add-remote/blob/master/tests/suite.clitest.md\n\n\n## Alternative Syntax: Inline Output\n\nNow a nice extension to the original idea. Using the special marker\n`#=>` you can embed the expected command output at the end of the\ncommand line.\n\n```console\n$ echo \"foo\"                      #=> foo\n$ echo $((10 + 2))                #=> 12\n```\n\nThis is the same as doing:\n\n```console\n$ echo \"foo\"\nfoo\n$ echo $((10 + 2))\n12\n$\n```\n\nInline outputs are very readable when testing series of commands that\nresult in short texts.\n\n```console\n$ echo \"abcdef\" | cut -c 1        #=> a\n$ echo \"abcdef\" | cut -c 4        #=> d\n$ echo \"abcdef\" | cut -c 1,4      #=> ad\n$ echo \"abcdef\" | cut -c 1-4      #=> abcd\n```\n\n> Note: If needed, you can change this marker (i.e., to `#→` or `###`)\n> at the top of the script or using the `--inline-prefix` option.\n\n\n## Advanced Tests\n\nWhen using the `#=>` marker, you can take advantage of special options\nto change the default output matching method.\n\n```console\n$ head /etc/passwd            #=> --lines 10\n$ tac /etc/passwd | tac       #=> --file /etc/passwd\n$ cat /etc/passwd             #=> --egrep ^root:\n$ echo $((2 + 10))            #=> --regex ^\\d+$\n$ make test                   #=> --exit 0\n$ pwd                         #=> --eval echo $PWD\n```\n\n* Using `#=> --lines` the test will pass if the command output has\n  exactly `N` lines. Handy when the output text is variable\n  (unpredictable), but the number of resulting lines is constant.\n\n* Using `#=> --file` the test will pass if the command output matches\n  the contents of an external file. Useful to organize long/complex\n  outputs into files.\n\n* Using `#=> --egrep` the test will pass if `grep -E` matches at least\n  one line of the command output.\n\n* Using `#=> --regex` the test will pass if the command output is\n  matched by a [Perl regular expression][9]. A multiline output is\n  matched as a single string, with inner `\\n`'s. Use the `(?ims)`\n  modifiers when needed.\n\n* Using `#=> --exit` the test will pass if the exit code of the command\n  is equal to the code specified. Useful when testing commands that\n  generate variable output (or no output at all), and the exit code is\n  the best indication of success. Both STDIN and STDOUT are ignored\n  when using this option.\n\n* Using `#=> --eval` the test will pass if both commands result in the\n  same output. Useful to expand variables which store the full or\n  partial output.\n\n## Options\n\n```console\n$ clitest --help\nUsage: clitest [options] <file ...>\n\nOptions:\n  -1, --first                 Stop execution upon first failed test\n  -l, --list                  List all the tests (no execution)\n  -L, --list-run              List all the tests with OK/FAIL status\n  -t, --test RANGE            Run specific tests, by number (1,2,4-7)\n  -s, --skip RANGE            Skip specific tests, by number (1,2,4-7)\n      --pre-flight COMMAND    Execute command before running the first test\n      --post-flight COMMAND   Execute command after running the last test\n  -q, --quiet                 Quiet operation, no output shown\n  -V, --version               Show program version and exit\n\nCustomization options:\n  -P, --progress TYPE         Set progress indicator: test, number, dot, none\n      --color WHEN            Set when to use colors: auto, always, never\n      --diff-options OPTIONS  Set diff command options (default: '-u')\n      --inline-prefix PREFIX  Set inline output prefix (default: '#=> ')\n      --prefix PREFIX         Set command line prefix (default: '')\n      --prompt STRING         Set prompt string (default: '$ ')\n$\n```\n\n\n## Exit codes\n\n* `0` - All tests passed, or normal operation (--help, --list, …)\n* `1` - One or more tests have failed\n* `2` - An error occurred (file not found, invalid range, …)\n\n\n## Fail fast\n\nUse the `--first` option (or the short version `-1`) to abort the\nexecution when any test fails.\n\nUseful for Continuous Integration (CI), or when running sequential\ntests where the next test depends on the correct result of the\nprevious.\n\n\n## Quiet operation\n\nWhen automating the tests execution, use `--quiet` to show no output and\njust check the exit code to make sure all tests have passed. Using\n`--first` to fail fast is also a good idea in this case.\n\n```bash\nif clitest --quiet --first tests.txt\nthen\n    # all tests passed\nelse\n    # one or more tests failed :(\nfi\n```\n\n\n## Run specific tests\n\nTo rerun a specific problematic test, or to limit the execution to a\nset of tests, use `--test`. To ignore one or more tests, use `--skip`.\nIf needed, you can combine both options to inform a very specific test\nrange. Examples:\n\n```bash\nclitest --test 1-10    tests.txt   # Run the first 10 tests\nclitest --test 1,2,6-8 tests.txt   # Run tests #1, #2, #6, #7 and #8\nclitest --skip 11,15   tests.txt   # Run all tests, except #11 and #15\nclitest -t 1-10 -s 5   tests.txt   # Run first 10 tests, but skip #5\n```\n\n\n## Pre/post scripts\n\nYou can run a preparing script or command before the first test with\n`--pre-flight`, for setting env variables and create auxiliary files.\nAt the end of all tests, run a final cleanup script/command with\n`--post-flight` to remove temporary files or other transient data.\n\n```bash\nclitest --pre-flight ./test-init.sh --post-flight 'rm *.tmp' tests.txt\n```\n\n\n## Customization\n\nUse the customization options to extract and test command lines from\ndocuments or wiki pages. For example, to test all the command line\nexamples listed inside a Markdown file using the 4-spaces syntax for\ncode blocks:\n\n```bash\nclitest --prefix 4 README.md\n```\n\nOr maybe you use a different prompt (`$PS1`) in your documentation?\n\n```bash\nclitest  --prefix 4 --prompt '[john@localhost ~]$ ' README.md\n```\n\n\n\n\n## Nerdiness\n\n* Use any text file format for the tests, it doesn't matter. The command\n  lines just need to be grepable and have a fixed prefix (or even none).\n  Even Windows text files (CR+LF) will work fine.\n\n* The command line power is available in your test files: use variables,\n  pipes, redirection, create files, folders, move around…\n\n* All the commands are tested using a single shell session. This means\n  that variables, aliases and functions defined in one test will persist\n  in the following tests.\n\n* Both STDOUT and STDERR are captured, so you can also test error\n  messages.\n\n* To test STDOUT/STDERR and the exit code at the same time, add a\n  `;echo $?` after the command.\n\n* Use an empty `$` prompt to close the last command output.\n\n* In the output, every single char (blank or not) counts. Any\n  difference will cause a test to fail. To ignore the difference in\n  blanks, use `--diff-options '-u -w'`.\n\n* Unlike doctest's `<BLANKLINE>`, in clitest blank lines in the\n  command output aren't a problem. Just insert them normally.\n\n* To test outputs with no final `\\n`, such as `printf foo`, use `#=>\n  --regex ^foo$`.\n\n* In multifile mode, the current folder (`$PWD`) is reset when\n  starting to test a new file. This avoids that a `cd` command in a\n  previous file will affect the next.\n\n* Multiline prompts (`$PS2`) are not yet supported.\n\n* Ellipsis (as in doctest) are not supported. Use `#=> --regex`\n  instead.\n\n* Simple examples in [examples/][10]. Hardcore examples in\n  [test.md][11] and [test/][12], the clitest own test-suite.\n\n\n## Choose the execution shell\n\nThe clitest shebang is `#!/bin/sh`. That's the default shell that will\nbe used to run your test command lines. Depending on the system, that\npath points to a different shell, such as ash, dash, or bash\n([running in POSIX mode][23]).\n\nTo force your test commands to always run on a specific shell, just call\nthe desired shell before:\n\n```bash\nclitest tests.txt            # Uses /bin/sh\nbash clitest tests.txt       # Uses Bash\nksh clitest tests.txt        # Uses Korn Shell\n```\n\n## Portability\n\nThis script was carefully coded to be portable between [POSIX][13]\nshells. It's code is validated by [checkbashisms][25] and\n[shellcheck][26].\n\nTo make sure it keeps working as expected, after every change clitest is\nautomatically tested in the CI, using the following shells:\n\n- bash\n- dash\n- ksh\n- sh (busybox)\n- zsh\n\n> Fish shell is not supported (it's not POSIX), but you \n> can use [doctest.fish][27] instead.\n\nPortability issues are considered serious bugs, please\n[report them][14]!\n\nDevelopers: Learn more about portability in POSIX shells:\n\n* [How to make bash scripts work in dash][15]\n* [Ubuntu — Dash as /bin/sh][16]\n* [Rich’s sh (POSIX shell) tricks][17]\n* [lintsh][18]\n* [Official POSIX specification: Shell & Utilities][19]\n\n\n## [KISS][20]\n\nA shell script to test shell commands.  \nNo other language or environment involved.\n\n\n## Meta\n\n* Author:   [Aurelio Jargas][21]\n* Created:  2013-07-24\n* Language: Shell Script\n* License:  [MIT][22]\n\n\n[1]: #portability\n[2]: http://en.wikipedia.org/wiki/Doctest\n[3]: http://docs.python.org/3/library/doctest.html\n[4]: https://raw.github.com/aureliojargas/clitest/master/clitest\n[5]: https://github.com/aureliojargas/clitest/blob/master/examples/intro.txt\n[6]: https://github.com/aureliojargas/clitest/blob/master/examples/cut.txt\n[7]: https://github.com/aureliojargas/clitest/blob/master/examples/cut.md\n[8]: https://github.com/aureliojargas/clitest/blob/master/README.md\n[9]: http://perldoc.perl.org/perlre.html\n[10]: https://github.com/aureliojargas/clitest/tree/master/examples\n[11]: https://github.com/aureliojargas/clitest/blob/master/test.md\n[12]: https://github.com/aureliojargas/clitest/blob/master/test/\n[13]: http://en.wikipedia.org/wiki/POSIX\n[14]: https://github.com/aureliojargas/clitest/issues\n[15]: http://mywiki.wooledge.org/Bashism\n[16]: https://wiki.ubuntu.com/DashAsBinSh\n[17]: http://www.etalabs.net/sh_tricks.html\n[18]: http://code.dogmap.org/lintsh/\n[19]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/contents.html\n[20]: http://en.wikipedia.org/wiki/KISS_principle\n[21]: http://aurelio.net/about.html\n[22]: https://github.com/aureliojargas/clitest/blob/master/LICENSE.txt\n[23]: https://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html\n[24]: https://github.com/funcoeszz/funcoeszz/tree/master/testador\n[25]: https://linux.die.net/man/1/checkbashisms\n[26]: https://www.shellcheck.net/\n[27]: https://github.com/aureliojargas/doctest.fish"
}
