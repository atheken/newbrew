{
  "name": "natalie",
  "full_name": "natalie",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Storyboard Code Generator (for Swift)",
  "license": "MIT",
  "homepage": "https://github.com/krzyzanowskim/Natalie",
  "versions": {
    "stable": "0.7.0",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/krzyzanowskim/Natalie/archive/0.7.0.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "f7959915595495ce922b2b6987368118fa28ba7d13ac3961fd513ec8dfdb21c8"
    },
    "head": {
      "url": "https://github.com/krzyzanowskim/Natalie.git",
      "branch": "master"
    }
  },
  "revision": 1,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/natalie/blobs/sha256:149e46b9c1fd6dc56e855583824fc194f68f6c910b671bebe4fa68ac43915041",
          "sha256": "149e46b9c1fd6dc56e855583824fc194f68f6c910b671bebe4fa68ac43915041"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/natalie/blobs/sha256:df7c39d8bcb8d60b095d9b9b90207042791d994f22a53c97e709aa16768a9b28",
          "sha256": "df7c39d8bcb8d60b095d9b9b90207042791d994f22a53c97e709aa16768a9b28"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/natalie/blobs/sha256:5bb0e910fe6f93ec2a190e3a36e51baa2550bd08c64a83ebd6f8d9ca78296510",
          "sha256": "5bb0e910fe6f93ec2a190e3a36e51baa2550bd08c64a83ebd6f8d9ca78296510"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/natalie/blobs/sha256:6e745ce1d0a34e0887319f32d39ae10e7ae34475fcb9a54916569f7672074b22",
          "sha256": "6e745ce1d0a34e0887319f32d39ae10e7ae34475fcb9a54916569f7672074b22"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/natalie/blobs/sha256:218ec8bb0ac3ac4de7a6fa8489f3ad7013b1beb051a7c0e74a6e37ade79eee6c",
          "sha256": "218ec8bb0ac3ac4de7a6fa8489f3ad7013b1beb051a7c0e74a6e37ade79eee6c"
        },
        "mojave": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/natalie/blobs/sha256:9dcc093fc648175eb165aec20413246ace7427d0d3c4a9884d37cfad9a851dca",
          "sha256": "9dcc093fc648175eb165aec20413246ace7427d0d3c4a9884d37cfad9a851dca"
        },
        "high_sierra": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/natalie/blobs/sha256:dd51e00a1969ffdd478e954bed48bedd1c5a9813b67931aa146711f49cb58223",
          "sha256": "dd51e00a1969ffdd478e954bed48bedd1c5a9813b67931aa146711f49cb58223"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [
    {
      "name": "xcode",
      "cask": null,
      "download": null,
      "version": "9.4",
      "contexts": [
        "build"
      ],
      "specs": [
        "stable",
        "head"
      ]
    }
  ],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": true,
  "disable_date": "2022-07-31",
  "disable_reason": "repo_archived",
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/natalie.rb",
  "ruby_source_checksum": {
    "sha256": "0151f56251b20c339a206e317c4fe3ff419061f04ba31dc87d94262009fb296d"
  },
  "date_added": "2015-05-08T19:58:27-07:00",
  "readme": "# Natalie\nNatalie - Storyboard Code Generator (for Swift)\n\n## Swift\n\nCurrent codebase is Swift 4 compatible.\n\nSwift 3.x code may be found from [swift3](https://github.com/krzyzanowskim/Natalie/tree/swift3) branch\n\nSwift 2.x code may be found from [swift2](https://github.com/krzyzanowskim/Natalie/tree/swift2) branch\n\nSwift 1.x code may be found from [swift2](https://github.com/krzyzanowskim/Natalie/tree/swift12) branch\n\n## Synopsis\nNatalie generates Swift code based on storyboard files to make work with Storyboards and segues easier. Generated file **reduce usage of Strings** as identifiers for Segues or Storyboards.\n\nProof of concept implementation to address the String issue for strongly typed Swift language. Natalie is a Swift command-line application (written in Swift) that produces a single `.swift` file with a bunch of extensions to project classes along the generated Storyboard enum.\n\nNatalie is written in Swift and requires Swift to run. The project uses [SWXMLHash](https://github.com/drmohundro/SWXMLHash) as a dependency to parse XML and due to framework limitations.\n\n### Enumerate Storyboards\nGenerated enum Storyboards with a convenient interface (drop-in replacement for UIStoryboard).\n\n```swift\nstruct Storyboards {\n    struct Main {...}\n    struct Second {...}\n    ...\n```\n\nInstantiate initial view controller for storyboard\n```swift\nlet vc = Storyboards.Main.instantiateInitialViewController()\n```\n\nInstantiate ScreenTwoViewController in storyboard, using storyboard id\n```swift\nlet vc = Storyboards.Main.instantiateScreenTwoViewController()\n```\n\nexample usage for prepareForSegue()\n\n```swift\noverride func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {\n  if segue == MainViewController.Segue.ScreenOneSegue {    \n    let viewController = segue.destinationViewController as? MyViewController\n    viewController?.view.backgroundColor = UIColor.yellowColor()\n  }\n}\n```\n\n...it could be `switch { }` statement, but [it's broken](https://twitter.com/krzyzanowskim/status/611686899732869121).\n\n### Segues\n\nPerform segue\n```swift\nself.perform(segue: MainViewController.Segue.ScreenOneSegue, sender: nil)\n```\n\nEach custom view controller is extended with this code and provide a list of available segues and additional information from Storyboard.\n\n`Segue` enumeration contains list of available segues\n\n`kind` property represent types Segue\n\n`destination` property return type of destination view controller.\n\n```swift\nextension MainViewController {\n\n    enum Segue: String, Printable, SegueProtocol {\n        case ScreenOneSegueButton = \"Screen One Segue Button\"\n        case ScreenOneSegue = \"ScreenOneSegue\"\n\n        var kind: SegueKind? {\n            ...\n        }\n\n        var destination: UIViewController.Type? {\n            switch (self) {\n            case ScreenOneSegueButton:\n                return ScreenOneViewController.self\n            case ScreenOneSegue:\n                return ScreenOneViewController.self\n            default:\n                assertionFailure(\"Unknown destination\")\n                return nil\n            }\n        }\n\n        var identifier: String { return self.description }\n        var description: String { return self.rawValue }\n    }\n}\n```\n\n### Reusable Views To Improve Performance\n\nCollections and tables views use `reuseidentifier` on cell to recycle a view.\n\nIf you define it, their custom view controllers will be extended with a `Reusable` enumeration, which contains list of available reusable identifiers\n\nexample to dequeue a view with `Reusable` enumeration with `UITableView`:\n```swift\nfunc tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {\n    let cell = tableView.dequeueReusableCell(ScreenTwoViewController.Reusable.MyCell, forIndexPath: indexPath) as! UITableViewCell\n    cell.textLabel?.text = \"\\(indexPath.row)\"\n    return cell\n}\n```\n\nBefore dequeuing your view, you must register a class or a xib for each identifier.\nIf your cell view has custom class defined in storyboard, in your controller you can call directly\n```swift\noverride func viewDidLoad()  {\n    tableView.registerReusableCell(MainViewController.Reusable.MyCell)\n}\n```\nYou can pass the view instead - the view must define the `reuseidentifier`\n```swift\n    tableView.registerReusableCell(tableViewCell)\n```\n\nIf your reusable custom view, you can also execute code according to reusable values\n```swift\nclass MyCustomTableViewCell: UITableViewCell {\n    override func prepareForReuse() {\n        if self == MyCustomTableViewController.Reusable.MyCell {\n            ...\n        }\n        else if self == MyCustomTableViewController.Reusable.mySecondCellId {\n            ...\n        }\n    }\n}\n```\n\n### Colors (iOS 11, macOS 10.13)\n\nGenerate an `UIColor` (or `NSColor`) static property for each asset colors used in your storyboard.\n\n## Installation\n\n#### Swift Package Manager\n\n```\n$ git clone https://github.com/krzyzanowskim/Natalie.git\n$ cd Natalie\n$ ./scripts/build.sh\n$ Binary at path ./Natalie/natalie\n```\n\nif you want easy Xcode integration you may want to install the binary to be easily accessible for any application from `/usr/local/bin`\n\n```\n$ cp natalie /usr/local/bin\n```\n\n#### Homebrew\n\n```\n$ brew install natalie\n```\n\nYou can also put `natalie` executable file at the root of your project folder and keep it under version control. This way everyone even your CI will be able to generate the files.\n\n\n### Xcode Integration\n\nNatalie can be integrated with Xcode in such a way that the `Storyboards.swift` the file will be updated with every build of the project, so you don't have to do it manually every time.\n\nThis is my setup created with **New Run Script Phase** on **Build Phase** Xcode target setting. It is important to move this phase above Compilation phase because this file is expected to be up to date for the rest of the application.\n\n- Select the project in the Project Navigator on the left of your Xcode window\n- Select your App Target in the list\n- Go in the \"Build Phases\" tab\n- Click on the \"+\" button on the upper left corner and choose \"New Run Script Phase\" and copy/paste script:\n\n```sh\n# Adjust path to \"natalie\" binary\n# NATALIE_PATH=\"$PROJECT_DIR/natalie\"\nNATALIE_PATH=\"/usr/local/bin/natalie\"\n\nif [ -f $NATALIE_PATH ]; then\n    echo \"Natalie Generator: Determining if generated Swift file is up-to-date.\"\n    \n    BASE_PATH=\"$PROJECT_DIR/$PROJECT_NAME\"\n    OUTPUT_PATH=\"$BASE_PATH/Storyboards.swift\"\n\n    if [ ! -e \"$OUTPUT_PATH\" ] || [ -n \"$(find \"$BASE_PATH\" -type f -name \"*.storyboard\" -newer \"$OUTPUT_PATH\" -print -quit)\" ]; then\n        echo \"Natalie Generator: Generated Swift is out-of-date; re-generating...\"\n\n        /usr/bin/chflags nouchg \"$OUTPUT_PATH\"\n        \"$NATALIE_PATH\" \"$BASE_PATH\" > \"$OUTPUT_PATH\"\n        /usr/bin/chflags uchg \"$OUTPUT_PATH\"\n\n        echo \"Natalie Generator: Done.\"\n    else\n        echo \"Natalie Generator: Generated Swift is up-to-date; skipping re-generation.\"\n    fi\nelse \n    echo \"error: Could not find Natalie Generator at $NATALIE_PATH; Please visit https://github.com/krzyzanowskim/Natalie for installation instructions.\"\n    exit 1\nfi\n```\n\n- add `Storyboards.swift` to the project.\n\n## Usage:\n\nDownload Natalie from Github: https://github.com/krzyzanowskim/Natalie and use it in the console, for example like this:\n```\n$ git clone https://github.com/krzyzanowskim/Natalie.git\n$ cd Natalie\n```\n\nThe command expects one of two types of parameters:\n\n* path to a single .storyboard file\n* path to a folder\n\nIf the parameter is a Storyboard file, then this file will be used. If a path to a folder is provided Natalie will generate code for every storyboard found inside.\n\n```\n$ natalie NatalieExample/NatalieExample/Base.lproj/Main.storyboard > NatalieExample/NatalieExample/Storyboards.swift\n```\n\n## Contribution\n\nPlease submit Pull Request against current development branch.\n\n## Author and contact\nMarcin Krzyżanowski\n\n* [@krzyzanowskim](http://twitter.com/krzyzanowskim)\n* http://blog.krzyzanowskim.com\n\n## Licence\nThe MIT License (MIT)\n\nCopyright (c) 2015 Marcin Krzyzanowski\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
}
