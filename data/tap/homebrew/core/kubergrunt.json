{
  "name": "kubergrunt",
  "full_name": "kubergrunt",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Collection of commands to fill in the gaps between Terraform, Helm, and Kubectl",
  "license": "Apache-2.0",
  "homepage": "https://github.com/gruntwork-io/kubergrunt",
  "versions": {
    "stable": "0.12.0",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/gruntwork-io/kubergrunt/archive/v0.12.0.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "6744144aff555363aff8e39c5d9f4c3da14f45651cc7dcaa588a6af6e8e9753d"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/kubergrunt/blobs/sha256:63abe2b4a54a1e23523f682889d60cfa7af14a7f25c7782ee373524a55c20cae",
          "sha256": "63abe2b4a54a1e23523f682889d60cfa7af14a7f25c7782ee373524a55c20cae"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/kubergrunt/blobs/sha256:63abe2b4a54a1e23523f682889d60cfa7af14a7f25c7782ee373524a55c20cae",
          "sha256": "63abe2b4a54a1e23523f682889d60cfa7af14a7f25c7782ee373524a55c20cae"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/kubergrunt/blobs/sha256:63abe2b4a54a1e23523f682889d60cfa7af14a7f25c7782ee373524a55c20cae",
          "sha256": "63abe2b4a54a1e23523f682889d60cfa7af14a7f25c7782ee373524a55c20cae"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/kubergrunt/blobs/sha256:bbfda8c965e9c350423ad7942f7cf99dab8b7ad297b3a82056bbebbdae95af6b",
          "sha256": "bbfda8c965e9c350423ad7942f7cf99dab8b7ad297b3a82056bbebbdae95af6b"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/kubergrunt/blobs/sha256:bbfda8c965e9c350423ad7942f7cf99dab8b7ad297b3a82056bbebbdae95af6b",
          "sha256": "bbfda8c965e9c350423ad7942f7cf99dab8b7ad297b3a82056bbebbdae95af6b"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/kubergrunt/blobs/sha256:bbfda8c965e9c350423ad7942f7cf99dab8b7ad297b3a82056bbebbdae95af6b",
          "sha256": "bbfda8c965e9c350423ad7942f7cf99dab8b7ad297b3a82056bbebbdae95af6b"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/kubergrunt/blobs/sha256:b05a09f8ec0f5e3eb7ffc60080a7ec52bb858345695dd1f65ab962157b79e693",
          "sha256": "b05a09f8ec0f5e3eb7ffc60080a7ec52bb858345695dd1f65ab962157b79e693"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "go"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/kubergrunt.rb",
  "ruby_source_checksum": {
    "sha256": "26ccc5b9064a1f333a35e41d1a590af641cf5f6631bdf8200000e8dd614b4cf9"
  },
  "date_added": "2021-02-17T12:45:56+00:00",
  "readme": "[![Maintained by Gruntwork.io](https://img.shields.io/badge/maintained%20by-gruntwork.io-%235849a6.svg)](https://gruntwork.io/?ref=repo_kubergrunt)\n[![GitHub tag (latest SemVer)](https://img.shields.io/github/tag/gruntwork-io/kubergrunt.svg?label=latest)](https://github.com/gruntwork-io/kubergrunt/releases/latest)\n\n# kubergrunt\n\n`kubergrunt` is a standalone go binary with a collection of commands that attempts to fill in the gaps between Terraform,\nHelm, and Kubectl for managing a Kubernetes Cluster.\n\nSome of the features of `kubergrunt` include:\n\n* Configuring `kubectl` to authenticate with a given EKS cluster. Learn more about authenticating `kubectl` to EKS\n  in the [our production deployment guide](https://gruntwork.io/guides/kubernetes/how-to-deploy-production-grade-kubernetes-cluster-aws/#authenticate).\n* Managing Helm and associated TLS certificates on any Kubernetes cluster.\n* Setting up Helm client with TLS certificates on any Kubernetes cluster.\n* Generating TLS certificate key pairs and storing them as Kubernetes `Secrets` on any Kubernetes cluster.\n\n\n## Installation\n\nThe binaries are all built as part of the CI pipeline on each release of the package, and is appended to the\ncorresponding release in the [Releases Page](/../../releases). You can download the corresponding binary for your\nplatform from the releases page.\n\nAlternatively, you can install `kubergrunt` using the [Gruntwork\nInstaller](https://github.com/gruntwork-io/gruntwork-installer). For example, to install version `v0.5.13`:\n\n```bash\ngruntwork-install --binary-name \"kubergrunt\" --repo \"https://github.com/gruntwork-io/kubergrunt\" --tag \"v0.5.13\"\n```\n\n### 3rd party package managers\n\nNote that third-party Kubergrunt packages may not be updated with the latest version, but are often close. Please check your version against the latest available on the [Releases Page](/../../releases).\n\nChocolatey (Windows):\n\n```cmd\nchoco install kubergrunt\n```\n\n### AWS CLI authentication\nYou need to authenticate with the AWS CLI before you can run kubergrunt/eksctl commands, please see our [authentication guide](https://blog.gruntwork.io/a-comprehensive-guide-to-authenticating-to-aws-on-the-command-line-63656a686799)\n\n## Building from source\n\nThe main package is in `cmd`. To build the binary, you can run:\n\n```\ngo build -o bin/kubergrunt ./cmd\n```\n\nIf you need to set a version on the binary (so that `kubergrunt --version` works), you use `ldflags` to set the version\nstring on the compiled binary:\n\n```\ngo build -o kubergrunt -ldflags \"-X main.VERSION=v0.7.6 -extldflags '-static'\" ./cmd\n```\n\n\n## Commands\n\nThe following commands are available as part of `kubergrunt`:\n\n1. [eks](#eks)\n    * [verify](#verify)\n    * [configure](#configure)\n    * [token](#token)\n    * [oidc-thumbprint](#oidc-thumbprint)\n    * [deploy](#deploy)\n    * [sync-core-components](#sync-core-components)\n    * [cleanup-security-group](#cleanup-security-group)\n    * [schedule-coredns](#schedule-coredns)\n    * [drain](#drain)\n1. [k8s](#k8s)\n    * [wait-for-ingress](#wait-for-ingress)\n    * [kubectl](#kubectl)\n1. [tls](#tls)\n    * [gen](#gen)\n1. [Deprecated commands](#deprecated-commands)\n    * [helm](#helm)\n\n\n### eks\n\nThe `eks` subcommand of `kubergrunt` is used to setup the operator machine to interact with a Kubernetes cluster running\non EKS.\n\n#### verify\n\nThis subcommand verifies that the specified EKS cluster is up and ready. An EKS cluster is considered ready when:\n\n- The cluster status reaches ACTIVE state.\n- The cluster Kubernetes API server endpoint responds to http requests.\n\nWhen passing `--wait` to the command, this command will wait until the EKS cluster reaches the ready state, or it\ntimes out. The timeout parameters are configurable with the `--max-retries` and `--sleep-between-retries` options, where\n`--max-retries` specifies the number of times the command will try to verify a specific condition before giving up, and\n`--sleep-between-retries` specifies the duration of time (e.g 10m = 10 minutes) to wait between each trial. So for\nexample, if you ran the command:\n\n```bash\nkubergrunt eks verify --eks-cluster-arn $EKS_CLUSTER_ARN --wait --max-retries 10 --sleep-between-retries 15s\n```\n\nand the cluster was not active yet, this command will query the AWS API up to 10 times, waiting 15 seconds inbetween\neach try for a total of 150 seconds (2.5 minutes) before timing out.\n\nRun `kubergrunt eks verify --help` to see all the available options.\n\nSimilar Commands:\n\n- AWS CLI (`aws eks wait`): This command will wait until the EKS cluster reaches the ACTIVE state. Note that oftentimes\n  the Kubernetes API endpoint has a delay in accepting traffic even after reaching the ACTIVE state. We have observed it\n  take up to 1.5 minutes after the cluster becomes ACTIVE before we can have a valid TCP connection with the Kubernetes\n  API endpoint.\n\n#### configure\n\nThis subcommand will setup the installed `kubectl` with config contexts that will allow it to authenticate to a\nspecified EKS cluster by leveraging the `kubergrunt eks token` command. This binary is designed to be used as part of\none of the modules in the package, although this binary supports running as a standalone binary. For example, this\nbinary might be used to setup a new operator machine to be able to talk to an existing EKS cluster.\n\nFor example to setup a `kubectl` install on an operator machine to authenticate with EKS:\n\n```bash\nkubergrunt eks configure --eks-cluster-arn $EKS_CLUSTER_ARN\n```\n\nRun `kubergrunt eks configure --help` to see all the available options.\n\nSimilar Commands:\n\n- AWS CLI (`aws eks update-kubeconfig`): This command will configure `kubeconfig` in a similar manner. Instead of using\n  `kubergrunt eks token`, this version will use the `get-token` subcommand built into the AWS CLI.\n\n#### token\n\nThis subcommand is used by `kubectl` to retrieve an authentication token using the AWS API authenticated with IAM\ncredentials. This token is then used to authenticate to the Kubernetes cluster. This command embeds the\n`aws-iam-authenticator` tool into `kubergrunt` so that operators don't have to install a separate tool to manage\nauthentication into Kubernetes.\n\nThe `configure` subcommand of `kubergrunt eks` assumes you will be using this method to authenticate with the Kubernetes\ncluster provided by EKS. If you wish to use `aws-iam-authenticator` instead, replace the auth info clause of the `kubectl`\nconfig context.\n\nThis subcommand also supports outputting the token in a format that is consumable by terraform as an [external data\nsource](https://www.terraform.io/docs/providers/external/data_source.html) when you pass in the `--as-tf-data` CLI arg.\nYou can then pass the token directly into the `kubernetes` provider configuration. For example:\n\n```hcl\n# NOTE: Terraform does not allow you to interpolate resources in a provider config. We work around this by using the\n# template_file data source as a means to compute the resource interpolations.\nprovider \"kubernetes\" {\n  load_config_file       = false\n  host                   = \"${data.template_file.kubernetes_cluster_endpoint.rendered}\"\n  cluster_ca_certificate = \"${base64decode(data.template_file.kubernetes_cluster_ca.rendered)}\"\n  token                  = \"${lookup(data.external.kubernetes_token.result, \"token_data\")}\"\n}\n\ndata \"template_file\" \"kubernetes_cluster_endpoint\" {\n  template = \"${module.eks_cluster.eks_cluster_endpoint}\"\n}\n\ndata \"template_file\" \"kubernetes_cluster_ca\" {\n  template = \"${module.eks_cluster.eks_cluster_certificate_authority}\"\n}\n\ndata \"external\" \"kubernetes_token\" {\n  program = [\"kubergrunt\", \"--loglevel\", \"error\", \"eks\", \"token\", \"--as-tf-data\", \"--cluster-id\", \"${module.eks_cluster.eks_cluster_name}\"]\n}\n```\n\nThis will configure the `kubernetes` provider in Terraform without setting up kubeconfig, allowing you to do everything\nin Terraform without side effects to your local machine.\n\nSimilar Commands:\n\n- AWS CLI (`aws eks get-token`): This command will do the same thing, but does not provide any specific optimizations\n  for terraform.\n- Terraform [`aws_eks_cluster_auth`](https://www.terraform.io/docs/providers/aws/d/eks_cluster_auth.html) data source:\n  This data source can be used to retrieve a temporary auth token for EKS in Terraform. This can only be used in\n  Terraform.\n- [`aws-iam-authenticator`](https://github.com/kubernetes-sigs/aws-iam-authenticator): This is a standalone binary that\n  can be used to fetch a temporary auth token.\n\n#### oidc-thumbprint\n\nThis subcommand will take the EKS OIDC Issuer URL and retrieve the root CA thumbprint. This is used to set the trust\nrelation for any certificates signed by that CA for the issuer domain. This is necessary to setup the OIDC provider,\nwhich is used for the IAM Roles for Service Accounts feature of EKS.\n\nYou can read more about the general procedure for retrieving the root CA thumbprint of an OIDC Provider in [the official\ndocumentation](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_oidc_verify-thumbprint.html).\n\nTo retrieve the thumbprint, call the command with the issuer URL:\n\n```bash\nkubergrunt eks oidc-thumbprint --issuer-url $ISSUER_URL\n```\n\nThis will output the thumbprint to stdout in JSON format, with the key `thumbprint`.\n\nRun `kubergrunt eks oidc-thumbprint --help` to see all the available options.\n\nSimilar Commands:\n\n- You can use `openssl` to retrieve the thumbprint as described by [the official\n  documentation](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_oidc_verify-thumbprint.html).\n- `eksctl` provides routines for directly configuring the OIDC provider so you don't need to retrieve the thumbprint.\n\n#### deploy\n\nThis subcommand will initiate a rolling deployment of the current AMI config to the EC2 instances in your EKS cluster.\nThis command will not deploy or update an application deployed on your Kubernetes cluster (e.g `Deployment` resource,\n`Pod` resource, etc). We provide helm charts that you can use to deploy your applications on to a Kubernetes cluster.\nSee our [`helm-kubernetes-services` repo](https://github.com/gruntwork-io/helm-kubernetes-services/) for more info.\nInstead, this command is for managing and deploying an update to the EC2 instances underlying your EKS cluster.\n\nTerraform and AWS do not provide a way to automatically roll out a change to the Instances in an EKS Cluster. Due to\nTerraform limitations (see [here for a\ndiscussion](https://github.com/terraform-providers/terraform-provider-aws/issues/567)), there is currently no way to\nimplement this purely in Terraform code. Therefore, we've created this subcommand that can do a zero-downtime roll out\nfor you.\n\nTo deploy a change (such as rolling out a new AMI) to all EKS workers using this command:\n\n1. Make sure the `cluster_max_size` is at least twice the size of `cluster_min_size`. The extra capacity will be used to\n   deploy the updated instances.\n1. Update the Terraform code with your changes (e.g. update the `cluster_instance_ami` variable to a new AMI).\n1. Run `terraform apply`.\n1. Run the command:\n\n```bash\nkubergrunt eks deploy --region REGION --asg-name ASG_NAME\n```\n\nWhen you call the command, it will:\n\n1. Double the desired capacity of the Auto Scaling Group that powers the EKS Cluster. This will launch new EKS workers\n   with the new launch configuration.\n1. Wait for the new nodes to be ready for Pod scheduling in Kubernetes. This includes waiting for the new nodes to be\n   registered to any external load balancers managed by Kubernetes.\n1. Cordon the old instances in the ASG so that they won't schedule new Pods.\n1. Drain the pods scheduled on the old EKS workers (using the equivalent of `kubectl drain`), so that they will be\n   rescheduled on the new EKS workers.\n1. Wait for all the pods to migrate off of the old EKS workers.\n1. Set the desired capacity down to the original value and remove the old EKS workers from the ASG.\n\nNote that to minimize service disruption from this command, your services should setup [a\nPodDisruptionBudget](https://kubernetes.io/docs/tasks/run-application/configure-pdb/), [a readiness\nprobe](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#define-readiness-probes)\nthat fails on container shutdown events, and implement graceful handling of SIGTERM in the container. You can learn more\nabout these features in [our blog post series covering\nthem](https://blog.gruntwork.io/zero-downtime-server-updates-for-your-kubernetes-cluster-902009df5b33).\n\nCurrently `kubergrunt` does not implement any checks for these resources to be implemented. However in the future, we\nplan to bake in checks into the deployment command to verify that all services have a disruption budget set, and warn\nthe user of any services that do not have a check.\n\n**`eks deploy` recovery file**\n\nDue to the nature of rolling update, the `deploy` subcommand performs multiple sequential actions that \ndepend on success of the previous operations. To mitigate intermittent failures, the `deploy` subcommand creates a\nrecovery file in the working directory for storing current deploy state. The recovery file is updated after \neach stage and if the `deploy` subcommand fails for some reason, execution resumes from the last successful state.\nThe existing recovery file can also be ignored with the `--ignore-recovery-file` flag. In this case the recovery \nfile will be re-initialized.\n\n#### sync-core-components\n\nThis subcommand will sync the core components of an EKS cluster to match the deployed Kubernetes version by following\nthe steps listed [in the official documentation](https://docs.aws.amazon.com/eks/latest/userguide/update-cluster.html).\n\nThe core components managed by this command are:\n\n- kube-proxy\n- Amazon VPC CNI plug-in\n- CoreDNS\n\nBy default, this command will rotate the images without waiting for the Pods to be redeployed. You can use the `--wait`\noption to force the command to wait until all the Pods have been replaced.\n\nExample:\n\n```bash\nkubergrunt eks sync-core-components --eks-cluster-arn EKS_CLUSTER_ARN\n```\n\n#### cleanup-security-group\nThis subcommand cleans up the leftover AWS-managed security groups that are associated with an EKS cluster you intend\nto destroy. It accepts\n- `--eks-cluster-arn`: the ARN of the EKS cluster\n- `--security-group-id`: a known security group ID associated with the EKS cluster\n- `--vpc-id`: the VPC ID where the cluster is located\n\nIt also looks for other security groups associated with the EKS cluster, such as the security group created by the AWS\nLoad Balancer Controller. To safely delete these resources, it detaches and deletes any associated AWS Elastic Network\nInterfaces.\n\nExample:\n\n```bash\nkubergrunt eks cleanup-security-group --eks-cluster-arn EKS_CLUSTER_ARN --security-group-id SECURITY_GROUP_ID \\\n--vpc-id VPC_ID\n```\n\n#### schedule-coredns\nThis subcommand can be used to toggle the CoreDNS service between scheduling on Fargate and EC2 worker types. During\nthe creation of an EKS cluster that uses Fargate, `schedule-coredns fargate` will annotate the deployment so that\nCoreDNS can find and allow EKS to use Fargate nodes. To switch back to EC2, you can run `schedule-coredns ec2` to\nreset the annotations such that EC2 nodes can be found by CoreDNS.\n\nThis command is useful when creating Fargate only EKS clusters. By default, EKS will schedule the `coredns` service\nassuming EC2 workers. You can use this command to force the service to run on Fargate.\n\nYou can also use this command in `local-exec` provisioners on an `aws_eks_fargate_profile` resource so you can\nschedule the CoreDNS service after creating the profile, and revert back when destroying the profile.\n\nCurrently `fargate` and `ec2` are the only subcommands that `schedule-coredns` accepts.\n\nExamples:\n\n```bash\nkubergrunt eks schedule-coredns fargate --eks-cluster-name EKS_CLUSTER_NAME --fargate-profile-arn FARGATE_PROFILE_ARN\n```\n\n```bash\nkubergrunt eks schedule-coredns ec2 --eks-cluster-name EKS_CLUSTER_NAME --fargate-profile-arn FARGATE_PROFILE_ARN\n```\n\n#### drain\n\nThis subcommand can be used to drain Pods from the instances in the provided Auto Scaling Groups. This can be used to\ngracefully retire existing Auto Scaling Groups by ensuring the Pods are evicted in a manner that respects disruption\nbudgets.\n\nYou can read more about the drain operation in [the official\ndocumentation](https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/).\n\nTo drain the Auto Scaling Group `my-asg` in the region `us-east-2`:\n\n```bash\nkubergrunt eks drain --asg-name my-asg --region us-east-2\n```\n\nYou can drain multiple ASGs by providing the `--name` option multiple times:\n\n```bash\nkubergrunt eks drain --asg-name my-asg-a --name my-asg-b --name my-asg-c --region us-east-2\n```\n\n\n### k8s\n\nThe `k8s` subcommand of `kubergrunt` includes commands that directly interact with the Kubernetes resources.\n\n#### wait-for-ingress\n\nThis subcommand waits for the Ingress endpoint to be provisioned. This will monitor the Ingress resource, continuously\nchecking until the endpoint is allocated to the Ingress resource or times out. By default, this will try for 5 minutes\n(max retries 60 and time betweeen sleep of 5 seconds).\n\nYou can configure the timeout settings using the --max-retries and --sleep-between-retries CLI args. This will check for\n--max-retries times, sleeping for --sleep-between-retries inbetween tries.\n\nFor example, if you ran the command:\n\n```bash\nkubergrunt k8s wait-for-ingress \\\n    --ingress-name $INGRESS_NAME \\\n    --namespace $NAMESPACE \\\n    --max-retries 10 \\\n    --sleep-between-retries 15s\n```\n\nthis command will query the Kubernetes API to check the `Ingress` resource up to 10 times, waiting for 15 seconds\ninbetween each try for a total of 150 seconds (2.5 minutes) before timing out.\n\nRun `kubergrunt k8s wait-for-ingress --help` to see all the available options.\n\n#### kubectl\n\nThis subcommand will call out to kubectl with a temporary file that acts as the kubeconfig, set up with the parameters\n`--kubectl-server-endpoint`, `--kubectl-certificate-authority`, `--kubectl-token`. Unlike using kubectl directly, this\ncommand allows you to pass in the base64 encoded certificate authority data directly as opposed to as a file.\n\nTo forward args to kubectl, pass all the args you wish to forward after a `--`. For example, the following command runs\n`kubectl get pods -n kube-system`:\n\n```\nkubergrunt k8s kubectl \\\n  --kubectl-server-endpoint $SERVER_ENDPOINT \\\n  --kubectl-certificate-authority $SERVER_CA \\\n  --kubectl-token $TOKEN \\\n  -- get pods -n kube-system\n```\n\nRun `kubergrunt k8s kubectl --help` to see all the available options.\n\n\n### tls\n\nThe `tls` subcommand of `kubergrunt` is used to manage TLS certificate key pairs as Kubernetes Secrets.\n\n#### gen\n\nThis subcommand will generate new TLS certificate key pairs based on the provided configuration arguments. Once the\ncertificates are generated, they will be stored on your targeted Kubernetes cluster as\n[Secrets](https://kubernetes.io/docs/concepts/configuration/secret/). This supports features such as:\n\n- Generating a new CA key pair and storing the generated key pair in your Kubernetes cluster.\n- Issuing a new signed TLS certificate key pair using an existing CA stored in your Kubernetes cluster.\n- Replacing the stored certificate key pair in your Kubernetes cluster with a newly generated one.\n- Controlling which Namespace the Secrets are stored in.\n\nFor example, to generate a new CA key pair, issue a TLS certificate key pair, storing each of those as the Secrets\n`ca-keypair` and `tls-keypair` respectively:\n\n```bash\n# Generate the CA key pair\nkubergrunt tls gen \\\n    --namespace kube-system \\\n    --secret-name ca-keypair \\\n    --ca \\\n    --tls-common-name kiam-ca \\\n    --tls-org Gruntwork \\\n    --tls-org-unit IT \\\n    --tls-city Phoenix \\\n    --tls-state AZ \\\n    --tls-country US \\\n    --secret-annotation \"gruntwork.io/version=v1\"\n# Generate a signed TLS key pair using the previously created CA\nkubergrunt tls gen \\\n    --namespace kube-system \\\n    --secret-name tls-keypair \\\n    --ca-secret-name ca-keypair \\\n    --tls-common-name kiam-server \\\n    --tls-org Gruntwork \\\n    --tls-org-unit IT \\\n    --tls-city Phoenix \\\n    --tls-state AZ \\\n    --tls-country US \\\n    --secret-annotation \"gruntwork.io/version=v1\"\n```\n\nThe first command will generate a CA key pair and store it as the Secret `ca-keypair`. The `--ca` argument signals to\n`kubergrunt` that the TLS certificate is for a CA.\n\nThe second command uses the generated CA key pair to issue a new TLS key pair. The `--ca-secret-name` signals\n`kubergrunt` to use the CA key pair stored in the Kubernetes Secret `ca-keypair`.\n\nThis command should be run by a **cluster administrator** to ensure access to the Secrets are tightly controlled.\n\nSee the command help for all the available options: `kubergrunt tls gen --help`.\n\n\n### Deprecated commands\n\n#### helm\n\nThe `helm` subcommand contained utilities for managing Helm v2, and is not necessary for Helm v3. This subcommand was\nremoved as of `kubergrunt` version `v0.6.0` with Helm v2 reaching end of life.\n\n\n\n\n## Who maintains this project?\n\n`kubergrunt` is maintained by [Gruntwork](http://www.gruntwork.io/). If you are looking for help or commercial support,\nsend an email to [support@gruntwork.io](mailto:support@gruntwork.io?Subject=kubergrunt).\n\nGruntwork can help with:\n\n* Setup, customization, and support for this project.\n* Modules and submodules for other types of infrastructure in major cloud providers, such as VPCs, Docker clusters,\n  databases, and continuous integration.\n* Modules and Submodules that meet compliance requirements, such as HIPAA.\n* Consulting & Training on AWS, GCP, Terraform, and DevOps.\n\n\n## How do I contribute?\n\nContributions are very welcome! Check out the [Contribution Guidelines](/CONTRIBUTING.md) for instructions.\n\n\n## How is this project versioned?\n\nThis project follows the principles of [Semantic Versioning](http://semver.org/). You can find each new release, along\nwith the changelog, in the [Releases Page](../../releases).\n\nDuring initial development, the major version will be 0 (e.g., `0.x.y`), which indicates the code does not yet have a\nstable API. Once we hit `1.0.0`, we will make every effort to maintain a backwards compatible API and use the MAJOR,\nMINOR, and PATCH versions on each release to indicate any incompatibilities.\n\n\n## License\n\nPlease see [LICENSE](/LICENSE) and [NOTICE](/NOTICE) for how the code in this repo is licensed.\n\nCopyright &copy; 2020 Gruntwork, Inc."
}
