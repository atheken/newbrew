{
  "name": "emacs-clang-complete-async",
  "full_name": "emacs-clang-complete-async",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Emacs plugin using libclang to complete C/C++ code",
  "license": "GPL-3.0",
  "homepage": "https://github.com/Golevka/emacs-clang-complete-async",
  "versions": {
    "stable": "0.5",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/Golevka/emacs-clang-complete-async/archive/v0.5.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "151a81ae8dd9181116e564abafdef8e81d1e0085a1e85e81158d722a14f55c76"
    },
    "head": {
      "url": "https://github.com/Golevka/emacs-clang-complete-async.git",
      "branch": "master"
    }
  },
  "revision": 7,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/emacs-clang-complete-async/blobs/sha256:d98ddff053cb22024c2edf5a57d87f3e0c6ce35a7564cd02d77de2df76617204",
          "sha256": "d98ddff053cb22024c2edf5a57d87f3e0c6ce35a7564cd02d77de2df76617204"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/emacs-clang-complete-async/blobs/sha256:35afe0fc0c8a0e576b2dda2f27235d51b993bb125d308b4eca8e8cf785d6feb6",
          "sha256": "35afe0fc0c8a0e576b2dda2f27235d51b993bb125d308b4eca8e8cf785d6feb6"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/emacs-clang-complete-async/blobs/sha256:9e656250e970d8d29241331c93f8fb96a9bd3ade44a72b96f4dc48341dc1a064",
          "sha256": "9e656250e970d8d29241331c93f8fb96a9bd3ade44a72b96f4dc48341dc1a064"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/emacs-clang-complete-async/blobs/sha256:d6b9df18bb4f4a75278afdb31ee7dac53b969205da6169c9a6cfbe8e9f88d84a",
          "sha256": "d6b9df18bb4f4a75278afdb31ee7dac53b969205da6169c9a6cfbe8e9f88d84a"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/emacs-clang-complete-async/blobs/sha256:c0369e9c9f3478cc55864811ddfd144cbdfedb5468c35dd7ed638792f7a22c98",
          "sha256": "c0369e9c9f3478cc55864811ddfd144cbdfedb5468c35dd7ed638792f7a22c98"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/emacs-clang-complete-async/blobs/sha256:0cc47180b3732f46e0d5fd3e551cf22f4d5a73a089b841a213b3df29e5999e07",
          "sha256": "0cc47180b3732f46e0d5fd3e551cf22f4d5a73a089b841a213b3df29e5999e07"
        },
        "catalina": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/emacs-clang-complete-async/blobs/sha256:fab75b269e2d7d3a1f8560579f3e845b0fcbca3202a3d384510a9c8bb22705b2",
          "sha256": "fab75b269e2d7d3a1f8560579f3e845b0fcbca3202a3d384510a9c8bb22705b2"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/emacs-clang-complete-async/blobs/sha256:40581606a267a0ae64dc7f85c994f7d6eb80a2c50c1ffd9dfa92a2d985ce80d1",
          "sha256": "40581606a267a0ae64dc7f85c994f7d6eb80a2c50c1ffd9dfa92a2d985ce80d1"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [
    "llvm"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/emacs-clang-complete-async.rb",
  "ruby_source_checksum": {
    "sha256": "809b79344365c6e6451104ee58b7f5f05d7e9958ec03a9d79478c1adaca78f47"
  },
  "date_added": "2013-08-05T14:19:17-07:00",
  "readme": "* Introduction\n\nemacs-clang-complete-async is an emacs extension to complete C and C++ code, \nit uses libclang to parse the source code on the fly and provides completion candidates to\nauto-complete (http://cx4a.org/software/auto-complete).\n\n[[https://github.com/Golevka/emacs-clang-complete-async/raw/master/screenshots/showcase.png]]\n\nThis extension is not implemented in pure elisp, it is made up of a client part\n(auto-complete-clang-async.el, written in elisp) and a server part\n(clang-complete binary, written in C), they work cooperately in asynchonous\nclient-server fashion.\n\n* Experimental Feature - On the fly syntax checking\n\nAn experimental feature is added to this branch --- running\n=ac-clang-syntax-check= to highlight errornous lines in your souce code.\n\n[[https://github.com/Golevka/emacs-clang-complete-async/raw/master/screenshots/syntax_check.png]]\n\n\n* Setup\n\nCompile the server part (clang-complete binary) first, by executing\n=make=. The build process uses =llvm-config= to determine the location of\nlibclang and the appropriate compile flags to use. If =llvm-config= is not in\nyour path or has a different name, you can pass =make= an =LLVM_CONFIG=\nargument, e.g.  =make LLVM_CONFIG=llvm-config-3.4=.\n\nCopy auto-complete-clang-async.el and the previously compiled\nclang-complete executable to ~/.emacs.d/, and add the following code to your\n.emacs file.\n\n#+BEGIN_SRC elisp\n(require 'auto-complete-clang-async)\n\n(defun ac-cc-mode-setup ()\n  (setq ac-clang-complete-executable \"~/.emacs.d/clang-complete\")\n  (setq ac-sources '(ac-source-clang-async))\n  (ac-clang-launch-completion-process)\n)\n\n(defun my-ac-config ()\n  (add-hook 'c-mode-common-hook 'ac-cc-mode-setup)\n  (add-hook 'auto-complete-mode-hook 'ac-common-setup)\n  (global-auto-complete-mode t))\n\n(my-ac-config)\n#+END_SRC\n\nNow emacs-clang-complete-async will show completion candidates automatically\nwhen you type as usual in C or C++ mode.\n\n\n* Usage\n\nThis extension fades in emacs C/C++ mode and provides candidates\nautomatically while you typing code, if you want to add parameters to clang\n(libclang, actually), such as -Ipath, just call ac-clang-set-cflags\ninteractively or set the value of ac-clang-flags in .emacs or .dir-locals.el,\nmaybe you need an explicit call to ac-clang-update-cmdlineargs to make changes \nto cflags take effect, which is a niggling part of it T T\n\n\n* Note\n\nMost code of auto-complete-clang-async.el is taken from brainjcj's\nauto-complete-clang.el, The only difference between this one and bj's\nac-clang-complete is: This one interacts with a process geared with libclang to\nretrieve completion candidates instead of calling clang process, which is way\nslower, and the asynchonous nature of our C-S based working model won't block\nthe editor while parsing source code and resolving completion candidates,\nwhich provides a \"smooth\" coding experience."
}
