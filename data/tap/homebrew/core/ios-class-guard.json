{
  "name": "ios-class-guard",
  "full_name": "ios-class-guard",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Objective-C obfuscator for Mach-O executables",
  "license": "GPL-2.0",
  "homepage": "https://github.com/Polidea/ios-class-guard/",
  "versions": {
    "stable": "0.8",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/Polidea/ios-class-guard/archive/0.8.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "4446993378f1e84ce1d1b3cbace0375661e3fe2fa1a63b9bf2c5e9370a6058ff"
    },
    "head": {
      "url": "https://github.com/Polidea/ios-class-guard.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/ios-class-guard/blobs/sha256:2cfa45ab4d2e9f5ff160c3e88426c890c83d5a87997fff438e04d07cd4d68467",
          "sha256": "2cfa45ab4d2e9f5ff160c3e88426c890c83d5a87997fff438e04d07cd4d68467"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/ios-class-guard/blobs/sha256:b4953b61e871a9935955ce26115619c081b15a5712decba1502b1d50b8d311cc",
          "sha256": "b4953b61e871a9935955ce26115619c081b15a5712decba1502b1d50b8d311cc"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/ios-class-guard/blobs/sha256:80da4446b7d4838b965d12546d9b10ad777c24c2026248e6d49c415aad3f9771",
          "sha256": "80da4446b7d4838b965d12546d9b10ad777c24c2026248e6d49c415aad3f9771"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/ios-class-guard/blobs/sha256:4864bb18b6e3712c92bede68182d7d8345e35b98da0327b8bbffbfc07891ddee",
          "sha256": "4864bb18b6e3712c92bede68182d7d8345e35b98da0327b8bbffbfc07891ddee"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/ios-class-guard/blobs/sha256:c6ac0f4d85d53a86ee0de247c7119f776506830d4d7d2df26eb2ecebc1fa20f4",
          "sha256": "c6ac0f4d85d53a86ee0de247c7119f776506830d4d7d2df26eb2ecebc1fa20f4"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/ios-class-guard/blobs/sha256:159991d0922d6ea71dceb5f97c3024659f70c48fb91c0222186e8c108885db54",
          "sha256": "159991d0922d6ea71dceb5f97c3024659f70c48fb91c0222186e8c108885db54"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/ios-class-guard/blobs/sha256:807b425c949e9a25331abd13967721d6f58d3a1674fcc8175744e713e81ee5d3",
          "sha256": "807b425c949e9a25331abd13967721d6f58d3a1674fcc8175744e713e81ee5d3"
        },
        "mojave": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/ios-class-guard/blobs/sha256:480f0437e5217cb8a47fcc0e9ffb6ffc62e4f81a79d5df9529320edeed479217",
          "sha256": "480f0437e5217cb8a47fcc0e9ffb6ffc62e4f81a79d5df9529320edeed479217"
        },
        "high_sierra": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/ios-class-guard/blobs/sha256:1962e7dde167e41141680b1347318396c0878fb8eeae55ec9f09460fcee33142",
          "sha256": "1962e7dde167e41141680b1347318396c0878fb8eeae55ec9f09460fcee33142"
        },
        "sierra": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/ios-class-guard/blobs/sha256:a7843a0767e916aa6be1509a984eb698bb54d125d06ad762fd25f4a3d6a55db1",
          "sha256": "a7843a0767e916aa6be1509a984eb698bb54d125d06ad762fd25f4a3d6a55db1"
        },
        "el_capitan": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/ios-class-guard/blobs/sha256:0bb9abaac82cbc4e66a12493548659197559a01a779db6ceda4cf6c4439ea0bb",
          "sha256": "0bb9abaac82cbc4e66a12493548659197559a01a779db6ceda4cf6c4439ea0bb"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [
    {
      "name": "xcode",
      "cask": null,
      "download": null,
      "version": null,
      "contexts": [
        "build"
      ],
      "specs": [
        "stable",
        "head"
      ]
    },
    {
      "name": "macos",
      "cask": null,
      "download": null,
      "version": null,
      "contexts": [],
      "specs": [
        "stable",
        "head"
      ]
    }
  ],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/ios-class-guard.rb",
  "ruby_source_checksum": {
    "sha256": "95f984dd5501be813d152c1f9c4d6790eadf095d43106398373823534c098fa6"
  },
  "date_added": "2014-10-14T18:59:34+01:00",
  "readme": "---\n\n__This repository is no longer maintained. Issue reports and pull requests will not be attended.__\n\n---\n\niOS Class Guard\n=========\n\niOS-Class-Guard is a command-line utility for obfuscating Objective-C class, protocol, property and method names. It was made as an extension for [class-dump](https://github.com/nygard/class-dump). The utility generates a symbol table which is then included during compilation. It effectively hides most of class, protocol, method, property and i-var names.\n\n**iOS Class Guard itself is not the silver bullet for security of your application. However, it will definitiely make your application harder to read by an attacker.**\n\nRead the official announcement at [Polidea Blog](http://www.polidea.com/#!heartbeat/blog/Protecting_iOS_Applications)\n\nVersion\n-----------\n0.8\n\nDo I need It?\n-----------\nThis utility makes code analyzing and runtime inspection more difficult, which can be referred to as a simple/basic method of obfuscation. You may ask yourself why it is needed; due to Objective-C architecture any dissection of iOS applications is rather simple. You may want to check out the following links:\n\n* http://www.infointox.net/?p=123\n* http://www.cycript.org/\n* http://resources.infosecinstitute.com/ios-application-security-part-2-getting-class-information-of-ios-apps/\n* http://timourrashed.com/decrypting-ios-app/\n\nHow does it work?\n----------\nThe utility works on the compiled version of an application. It reads the Objective-C portion of Mach-O object files. It parses all classes, properties, methods and i-vars defined in that file adding all symbols to the list. Then it reads all dependent frameworks doing the same (parsing Objective-C code structure), but now adding symbols to a forbidden list. Then all symbols from your executable that aren't in the forbidden list are obfuscated. For each symbol a random identifier consisting of letters and digits is generated. Every time you do obfuscation, a unique symbol map is generated. The generated map is then formatted as a header file with C-preprocessor defines. This file is then included in .pch file. Then it finds all XIBs and Storyboards and updates names inside (so effectively Interface Builder files are also obfuscated). The utility also finds xcdatamodel files inside your project and adds symbols (class and property names) to the forbidden list. During compilation any symbol defined in the header is compiled with a different identifier, the generated one.\n\niOS Class Guard also provides support for obfuscating CocoaPods libraries. When you provide paths to Pods the project utility automatically goes through all listed targets and finds .xcconfig files and precompiled header paths to be modified. Then it adds the previously generated header to library .pch header and updates the header search path in .xcconfig file for a target.\n\niOS Class Guard also generates symbol mapping in a JSON format. It’s needed for reversing the process when e.g. you get a crash report. It is important to note that iOS Class Guard does not obfuscate system symbols, so if some of the methods/properties have the same name in a custom class they won’t be obfuscated.\n\nExample generated symbols header:\n``` C\n// Properties\n#ifndef _parentCell\n#define _parentCell _m5c\n#endif // _parentCell\n#ifndef parentCell\n#define parentCell m5c\n#endif // parentCell\n#ifndef setParentCell\n#define setParentCell setM5c\n#endif // setParentCell\n#ifndef _buttonIndex\n#define _buttonIndex _f8q\n```\n\nInstallation\n-----------\nExecute this simple bash script in Terminal. When asked for the password, enter your account. It's needed, because the utility is installed in /usr/local/bin.\n\n``` sh\nbrew install ios-class-guard\n```\n\nTo install bleeding edge version:\n``` sh\nbrew install --HEAD ios-class-guard\n```\n\nHow to use it?\n-----------\nA few steps are required to integrate iOS Class Guard in a project.\n\n1. Download ```obfuscate_project``` in to your project root path.\n\n``` sh\ncurl -o obfuscate_project https://raw.githubusercontent.com/Polidea/ios-class-guard/master/contrib/obfuscate_project && chmod +x obfuscate_project\n```\n\n2. Update the project file, scheme and configuration name.\n\n3. Do ```bash obfuscate_project``` every time when you want to obfuscate your project. It should be done every release. Store the json file containing symbol mapping so you can get the original symbol names in case of a crash.\n\n4. Build, test and archive your project using Xcode or other tools.\n\nThe presented way is the simplest one. You can also add additional target that will automatically regenerate the symbols map during compilation.\n\nPre compiled header file\n-----------\nAfter obfuscation, iOS-Class-Guard will try to add generated symbols header (`symbols.h`) to your project's `*.pch` file. However, projects created in Xcode 6 and above don't contain `*.pch` file by default. In case your project doesnt have any `*.pch` file, you have to add it manually **before obfuscation**. \n\nTo add `*.pch` file to your project follow the steps below:\n\n1. Create `PCH` file in your project's root directory. In Xcode go to `File -> New -> File -> iOS -> Other -> PCH File`.\nTo ensure backward compatibility iOS-Class-Guard will be looking for a file matching the `*-Prefix.pch` mask, as an example `MyProject-Prefix.pch`\n\n\n2. At the target's *Build Settings*, in *Apple LLVM - Language* section, set **Prefix Header** to your PCH file name.\n\n3. At the target's *Build Settings*, in *Apple LLVM - Language* section, set **Precompile Prefix Header** to `YES`.\n\n\nFor more details please refer to [this](http://stackoverflow.com/a/24524692/1219382) Stack Overflow question.\n\nExample\n-----------\nYou can take a look what changes are required and how it works in some example projects.\n\n``` sh\ngit clone https://github.com/Polidea/ios-class-guard-example ios-class-guard-example\ncd ios-class-guard-example\nmake compile\n```\n\nHere is *class-dump* for non-obfuscated sources: \nhttps://github.com/Polidea/ios-class-guard-example/tree/master/SWTableViewCell-no-obfuscated.xcarchive/Headers\n\nWhat it will look like when you use *iOS Class Guard*:\nhttps://github.com/Polidea/ios-class-guard-example/tree/master/SWTableViewCell-obfuscated.xcarchive/Headers\n\nCommand Line Options\n-----------\n```\nios-class-guard 0.8 (64 bit)\nUsage: ios-class-guard [options] <mach-o-file>\n\n  where options are:\n        -F <class>     specify class filter for symbols obfuscator (also protocol))\n        -i <symbol>    ignore obfuscation of specific symbol)\n        --arch <arch>  choose a specific architecture from a universal binary (ppc, ppc64, i386, x86_64, armv6, armv7, armv7s, arm64)\n        --list-arches  list the arches in the file, then exit\n        --sdk-ios      specify iOS SDK version (will look for /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS<version>.sdk\n                       or /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS<version>.sdk)\n        --sdk-mac      specify Mac OS X version (will look for /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX<version>.sdk\n                       or /Developer/SDKs/MacOSX<version>.sdk)\n        --sdk-root     specify the full SDK root path (or use --sdk-ios/--sdk-mac for a shortcut)\n        -X <directory> base directory for XIB, storyboards (will be searched recursively)\n        -P <path>      path to project.pbxproj of Pods project (located inside Pods.xcodeproj)\n        -O <path>      path to file where obfuscated symbols are written\n        -m <path>      path to symbol file map (default value symbols.json)\n        -c <path>      path to symbolicated crash dump\n```\n\nThe utility requires you to get familiar with a few options.\n\n### Output header path\niOS Class Guard requires you to provide path to generated symbols header.\n\n#### Example\n```\n-O SWTableView/symbols.h\n```\n\n### Class filter\niOS Class Guard allows to filter out some of the classes that can't be obfuscated. For example, because you use it as a precompiled static library.\n\niOS Code Style assumes that every class is prefixed with a two-or-three-symbol identifier - namespace (ie. NS* for Foundation class). This allows you to filter in or filter out the whole namespace.\n\n#### Example\n```\n-F '!APH*' -F '!MC*'\n```\n\nThis will filter out any class in namespace *APH* and *MC*.\n\n### Ignored symbols\nIt may happen that some symbols get obfuscated even though they shouldn’t, e.g. if you use C method and name Objective-C method using the same name. It will lead to a linker error (*unresolved external*). You have to find what symbol is it and add it to the list of ignored symbols.\n\n#### Example\n```\n-i 'deflate' -i 'curl_*'\n```\nThis will not obfuscate symbols named *deflate* and symbols that start with *curl_\\**.\n\n### CocoaPods\nIf you’re using CocoaPods in your project you can also obfuscate symbols inside external libraries. The only thing you need is to specify path to Pods PBX project file. It’s located inside the .xcodeproj directory. Utility will modify configurations and precompiled headers so that they’re also obfuscated.\n\n#### Example\n```\n-P Pods/Pods.xcodeproj/project.pbxproj\n```\n\n### Other options\n\n#### Xib directory\nThis is optional argument. By default utility searches for all XIB/Storyboard files recursively from directory of execution (in most cases root directory of the project). If you store those files in a different directory you can provide a path to the directory where they can be found.\n\n##### Example\n```\n-X SWTableView/Xib\n```\n\n#### Symbol mapping file\nYou can provide the path where utility will save symbol mapping. By default it’s symbols.json.\n\n#####\n```\n-m release/symbols_1.0.0.json\n```\n\n#### Reversing obfuscation in crash dump\niOS Class Guard lets you reverse the process of obfuscation. It might come in handy when you get a crash report from a user and you’re trying to find the reason. You can provide a path to a file with crash dump or a file with the output of ```atos``` command. Symbols in the file which was provided will be replaced using the symbol mapping file. The result will be saved in the same file.\n\n##### Example\n```\n-c crashdump -m symbols_1.0.0.json\n```\n\n#### Reversing obfuscation in dSYMs\niOS Class Guard lets you reverse the process of obfuscation for automatic crash reporting tools such as Crashlytics, Fabric, BugSense/Splunk Mint, Crittercism or HockeyApp. With ```--dsym``` parameter, iOS Class Guard will exchange obfuscated symbols with original ones within provided dSYM file. We highly recommend you adding in the very beginnig of your Build Phases/Run script one line shown in the example below to automate dSYM translation process. Feature has been tested with the tools mentioned above.\n\n##### Build Phases/Run script example\n```\nif [ -f \"$PROJECT_DIR/symbols.json\" ]; then\n/usr/local/bin/ios-class-guard -m $PROJECT_DIR/symbols.json --dsym $DWARF_DSYM_FOLDER_PATH/$DWARF_DSYM_FILE_NAME --dsym-out $DWARF_DSYM_FOLDER_PATH/$DWARF_DSYM_FILE_NAME\nfi\n\n# Another invocations eg.: ./Crashlytics.framework/run <Crashlytics secret #1> <Crashlytics secret #2>\n```\n\n##### Manual usage example\n```\nios-class-guard -m symbols.json --dsym MyProject_obfuscated.app.dSYM --dsym-out MyProject_unobfuscated.app.dSYM\n```\n\nLimitations\n-----------\n\nDue to the way iOS Class Guard works you should be aware of two main limitations of that approach.\n\n### XIB and Storyboards\n*ios-class-guard* works pretty well with XIB and Storyboard files, but if you’re using external libraries which provide their bundle with Interface Builder files be sure to ignore those symbols, as they won’t work when you launch the app and try to use them. You can do that using *Class filter*.\n\n### Key-Value Observing (KVO)\nIt is possible that during obfuscation KVO will stop working. Most developers use hardcoded strings to specify *KeyPath*.\n\n``` objc\n- (void)registerObserver {\n    [self.otherObject addObserver:self\n                       forKeyPath:@\"isFinished\"\n                          options:NSKeyValueObservingOptionNew\n                          context:nil];\n}\n\n- (void)unregisterObserver {\n    [otherObject removeObserver:self\n                     forKeyPath:@\"isFinished\"\n                        context:nil];\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath\n              ofObject:(id)object\n                change:(NSDictionary *)change\n               context:(void *)context\n{\n  if ([keyPath isEqualToString:@\"isFinished\"]) {\n    // ...\n  }\n}\n```\n\nThis will simply not work. The property *isFinished* will get a new name and the hardcoded string will not reflect the change.\n\nRemove any *keyPath* and change it to ```NSStringFromSelector(@selector(keyPath))```.\n\n**The fixed code should look like this:**\n\n``` objc\n- (void)registerObserver {\n    [self.otherObject addObserver:self\n                       forKeyPath:NSStringFromSelector(@selector(isFinished))\n                          options:NSKeyValueObservingOptionNew\n                          context:nil];\n}\n\n- (void)unregisterObserver {\n    [otherObject removeObserver:self\n                     forKeyPath:NSStringFromSelector(@selector(isFinished))\n                        context:nil];\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath\n              ofObject:(id)object\n                change:(NSDictionary *)change\n               context:(void *)context\n{\n  if ([keyPath isEqualToString:NSStringFromSelector(@selector(isFinished))]) {\n    // ...\n  }\n}\n```\n\n### Serialization\nIf you use classes that are saved to the disk or user defaults using `NSCoding` protocol you’ll have to exclude them from obfuscation. If you don’t, after generating symbols again your app will start crashing as it won’t be able to read that class from serialized data.\n\n### Undefined symbols\nWhen using `iOS-Class-Guard` it is more than probable that you will encounter issues similar to this:\n\n```\nUndefined symbols for architecture i386:\n  \"_OBJC_CLASS_$_n9z\", referenced from:\n      objc-class-ref in GRAppDelegate.o\n```\n\nTo fix it, copy `n9z` and search for it in `symbols.h`. Most probably it will be a class. You simply have to exclude it from obfuscation by specifying: `-F '!UnresolvedClassName'` and retest.\n\nNote\n---\niOS-Class-Guard works alongside LLVM Obfuscator: https://github.com/obfuscator-llvm/obfuscator. However, this has not been tested.\n\nLicense\n----\nThis file is part of ios-class-guard, a utility for obfuscating the Objective-C applications. Copyright (C) 2014 Polidea.\nThe application is made as an extension for class-dump, a utility for examining the Objective-C segment of Mach-O files. Copyright (C) 1997-1998, 2000-2001, 2004-2013 Steve Nygard.\n\nThis program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA."
}
