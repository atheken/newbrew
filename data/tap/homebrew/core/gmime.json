{
  "name": "gmime",
  "full_name": "gmime",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "MIME mail utilities",
  "license": "LGPL-2.1-or-later",
  "homepage": "https://github.com/jstedfast/gmime",
  "versions": {
    "stable": "3.2.13",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/jstedfast/gmime/releases/download/3.2.13/gmime-3.2.13.tar.xz",
      "tag": null,
      "revision": null,
      "checksum": "2e10a54d4821daf8b16c019ad5d567e0fb8e766f8ffe5fec3d4c6a37373d6406"
    },
    "head": {
      "url": "https://github.com/jstedfast/gmime.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": "/opt/homebrew/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/gmime/blobs/sha256:35dc9d92ec33ec3d84b118fe2bbc0ec55d639fc0c26ca1f288db2041b8cc66f5",
          "sha256": "35dc9d92ec33ec3d84b118fe2bbc0ec55d639fc0c26ca1f288db2041b8cc66f5"
        },
        "arm64_monterey": {
          "cellar": "/opt/homebrew/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/gmime/blobs/sha256:f27bc95fba280b579a93fda869ecb738e84593cf02e4fb689f668ef3b8668b40",
          "sha256": "f27bc95fba280b579a93fda869ecb738e84593cf02e4fb689f668ef3b8668b40"
        },
        "arm64_big_sur": {
          "cellar": "/opt/homebrew/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/gmime/blobs/sha256:616305d3cdeb697de0139126e9f85138bed8beab38b79f6aa982b7b846be23cb",
          "sha256": "616305d3cdeb697de0139126e9f85138bed8beab38b79f6aa982b7b846be23cb"
        },
        "ventura": {
          "cellar": "/usr/local/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/gmime/blobs/sha256:b3543eda3347b28808d6881d6b175d25192484563ffc5877a4ba5f82a26046da",
          "sha256": "b3543eda3347b28808d6881d6b175d25192484563ffc5877a4ba5f82a26046da"
        },
        "monterey": {
          "cellar": "/usr/local/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/gmime/blobs/sha256:9a2055499bf7a18b01bfa67d3637ca0a376a0353a52a984a1864ff0890280a27",
          "sha256": "9a2055499bf7a18b01bfa67d3637ca0a376a0353a52a984a1864ff0890280a27"
        },
        "big_sur": {
          "cellar": "/usr/local/Cellar",
          "url": "https://ghcr.io/v2/homebrew/core/gmime/blobs/sha256:26ba4775f26d0549b57240711b9d446dacd825b52a11b0e1ff1c77410f2fe36c",
          "sha256": "26ba4775f26d0549b57240711b9d446dacd825b52a11b0e1ff1c77410f2fe36c"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gmime/blobs/sha256:343edd8abff04d84cba81782ee2c447da2be52b2187581d25e989fe107c65b26",
          "sha256": "343edd8abff04d84cba81782ee2c447da2be52b2187581d25e989fe107c65b26"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "gobject-introspection",
    "pkg-config"
  ],
  "dependencies": [
    "glib",
    "gpgme"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/gmime.rb",
  "ruby_source_checksum": {
    "sha256": "c62867854e18fb31e5648f51ee14132f3ba550726909551750665e01a1a062d4"
  },
  "head_dependencies": {
    "build_dependencies": [
      "autoconf",
      "automake",
      "gtk-doc",
      "libtool",
      "gobject-introspection",
      "pkg-config"
    ],
    "dependencies": [
      "glib",
      "gpgme"
    ],
    "test_dependencies": [],
    "recommended_dependencies": [],
    "optional_dependencies": [],
    "uses_from_macos": [],
    "uses_from_macos_bounds": []
  },
  "date_added": "2010-02-11T12:04:21-08:00",
  "readme": "# GMime\n\n[![Build Status](https://github.com/jstedfast/gmime/actions/workflows/build.yml/badge.svg?event=push)](https://github.com/jstedfast/gmime/actions/workflows/build.yml)[![Coverity Scan Build Status](https://scan.coverity.com/projects/11948/badge.svg)](https://scan.coverity.com/projects/jstedfast-gmime)[![Coverage Status](https://coveralls.io/repos/github/jstedfast/gmime/badge.svg?branch=master)](https://coveralls.io/github/jstedfast/gmime?branch=master)\n\n## What is GMime?\n\nGMime is a C/C++ library which may be used for the creation and parsing of messages using the Multipurpose\nInternet Mail Extension (MIME) as defined by [numerous IETF specifications](https://github.com/jstedfast/gmime/blob/master/RFCs.md).\n\nGMime features an extremely robust high-performance parser designed to be able to preserve byte-for-byte information\nallowing developers to re-seralize the parsed messages back to a stream exactly as the parser found them. It also features\nintegrated GnuPG and S/MIME v3.2 support.\n\nBuilt on top of GObject (the object system used by the [GNOME desktop](https://www.gnome.org)), many developers should find\nits API design and memory management very familiar.\n\n## History\n\nAs a developer and user of Electronic Mail clients, I had come to\nrealize that the vast majority of E-Mail client (and server) software\nhad less-than-satisfactory MIME implementations. More often than not\nthese E-Mail clients created broken MIME messages and/or would\nincorrectly try to parse a MIME message thus subtracting from the full\nbenefits that MIME was meant to provide. GMime is meant to address\nthis issue by following the MIME specification as closely as possible\nwhile also providing programmers with an extremely easy to use\nhigh-level application programming interface (API).\n\n## License Information\n\nThe GMime library is Copyright (C) 2000-2022 Jeffrey Stedfast and is licensed under the LGPL v2.1\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n\n\n## Getting the Source Code\n\nYou can download official public release tarballs of GMime at\n[https://download.gnome.org/sources/gmime/](https://download.gnome.org/sources/gmime/)\nor\n[ftp://ftp.gnome.org/pub/GNOME/sources/gmime/](ftp://ftp.gnome.org/pub/GNOME/sources/gmime/).\n\nIf you would like to contribute to the GMime project, it is recommended that you grab the\nsource code from the official GitHub repository at\n[http://github.com/jstedfast/gmime](https://github.com/jstedfast/gmime). Cloning this repository\ncan be done using the following command:\n\n    git clone https://github.com/jstedfast/gmime.git\n\n\n## Requirements\n\nFor proper compilation and functionality of GMime, the following packages\nare REQUIRED:\n\n  - Glib version >= 2.68.0\n\n    Glib provides a number of portability-enhancing functions and types.\n    Glib is included in most GMime-supported operating system\n    distributions.  Glib sources may be obtained from:\n      ftp://ftp.gtk.org/pub/glib\n\nThe following packages are RECOMMENDED:\n\n  - Libidn2 >= 2.0.0\n\n    Libidn2 provides APIs needed for encoding and decoding Internationalized\n    Domain Names. Libidn2 sources may be obtained from:\n      https://www.gnu.org/software/libidn/#downloading\n\n  - GPGME >= 1.8.0 (will build with 1.6.0, but will be missing some functionality)\n\n    GPGME (GnuPG Made Easy) provides high-level crypto APIs needed for\n    encryption, decryption, signing and signature verification for both\n    OpenPGP and S/MIME. GPGME sources may be obtained from:\n      https://www.gnupg.org/download/index.html#gpgme\n\n## Using GMime\n\n### Parsing Messages\n\nOne of the more common operations that GMime is meant for is parsing email messages from arbitrary streams.\nTo do this, you will need to use a `GMimeParser`:\n\n```c\n/* load a GMimeMessage from a stream */\nGMimeMessage *message;\nGMimeStream *stream;\nGMimeParser *parser;\n\nstream = g_mime_stream_fs_open (\"message.eml\", O_RDONLY, 0644, NULL);\nparser = g_mime_parser_new_with_stream (stream);\n\n/* Note: we can unref the stream now since the GMimeParser has a reference to it... */\ng_object_unref (stream);\n\nmessage = g_mime_parser_construct_message (parser, NULL);\n\n/* unref the parser since we no longer need it */\ng_object_unref (parser);\n```\n\nIf you are planning to parse messages from an mbox stream, you can do something like this:\n\n```c\nGMimeMessage *message;\nGMimeStream *stream;\nGMimeParser *parser;\ngint64 offset;\nchar *marker;\n\nstream = g_mime_stream_fs_open (\"Inbox.mbox\", O_RDONLY, 0644, NULL);\nparser = g_mime_parser_new_with_stream (stream);\n\n/* tell the parser to scan mbox-style \"From \" markers */\ng_mime_parser_set_format (parser, GMIME_FORMAT_MBOX);\n\n/* Note: we can unref the stream now since the GMimeParser has a reference to it... */\ng_object_unref (stream);\n\nwhile (!g_mime_parser_eos (parser)) {\n    /* load the next message from the mbox */\n    if ((message = g_mime_parser_construct_message (parser, NULL)) != NULL)\n        g_object_unref (message);\n\n    /* get information about the mbox \"From \" marker... */\n    offset = g_mime_parser_get_mbox_marker_offset (parser);\n    marker = g_mime_parser_get_mbox_marker (parser);\n}\n\ng_object_unref (parser);\n```\n\n### Getting the Body of a Message\n\nA common misunderstanding about email is that there is a well-defined message body and then a list\nof attachments. This is not really the case. The reality is that MIME is a tree structure of content,\nmuch like a file system.\n\nLuckily, MIME does define a set of general rules for how mail clients should interpret this tree\nstructure of MIME parts. The `Content-Disposition` header is meant to provide hints to the receiving\nclient as to which parts are meant to be displayed as part of the message body and which are meant\nto be interpreted as attachments.\n\nThe `Content-Disposition` header will generally have one of two values: `inline` or `attachment`.\n\nThe meaning of these value should be fairly obvious. If the value is `attachment`, then the content\nof said MIME part is meant to be presented as a file attachment separate from the core message.\nHowever, if the value is `inline`, then the content of that MIME part is meant to be displayed inline\nwithin the mail client's rendering of the core message body. If the `Content-Disposition` header does\nnot exist, then it should be treated as if the value were `inline`.\n\nTechnically, every part that lacks a `Content-Disposition` header or that is marked as `inline`, then,\nis part of the core message body.\n\nThere's a bit more to it than that, though.\n\nModern MIME messages will often contain a `multipart/alternative` MIME container which will generally contain\na `text/plain` and `text/html` version of the text that the sender wrote. The `text/html` version is typically\nformatted much closer to what the sender saw in his or her WYSIWYG editor than the `text/plain` version.\n\nThe reason for sending the message text in both formats is that not all mail clients are capable of displaying\nHTML.\n\nThe receiving client should only display one of the alternative views contained within the `multipart/alternative`\ncontainer. Since alternative views are listed in order of least faithful to most faithful with what the sender\nsaw in his or her WYSIWYG editor, the receiving client *should* walk over the list of alternative views starting\nat the end and working backwards until it finds a part that it is capable of displaying.\n\nExample:\n```\nmultipart/alternative\n  text/plain\n  text/html\n```\n\nAs seen in the example above, the `text/html` part is listed last because it is the most faithful to\nwhat the sender saw in his or her WYSIWYG editor when writing the message.\n\nTo make matters even more complicated, sometimes modern mail clients will use a `multipart/related`\nMIME container instead of a simple `text/html` part in order to embed images and other content\nwithin the HTML.\n\nExample:\n```\nmultipart/alternative\n  text/plain\n  multipart/related\n    text/html\n    image/jpeg\n    video/mp4\n    image/png\n```\n\nIn the example above, one of the alternative views is a `multipart/related` container which contains\nan HTML version of the message body that references the sibling video and images.\n\nNow that you have a rough idea of how a message is structured and how to interpret various MIME entities,\nthe next step is learning how to traverse the MIME tree using GMime.\n\n### Traversing a GMimeMessage\n\nThe top-level MIME entity of the message will generally either be a `GMimePart` or a `GMimeMultipart`.\n\nAs an example, if you wanted to rip out all of the attachments of a message, your code might look\nsomething like this:\n\n```c\nGMimePartIter *iter = g_mime_part_iter_new (message);\nGPtrArray *attachments = g_ptr_array_new ();\nGPtrArray *multiparts = g_ptr_array_new ();\n\n/* collect our list of attachments and their parent multiparts */\nwhile (g_mime_part_iter_next (iter)) {\n    GMimeObject *current = g_mime_part_iter_get_current (iter);\n    GMimeObject *parent = g_mime_part_iter_get_parent (iter);\n\n    if (GMIME_IS_MULTIPART (parent) && GMIME_IS_PART (current)) {\n        GMimePart *part = (GMimePart *) current;\n\n        if (g_mime_part_is_attachment (part)) {\n            /* keep track of each attachment's parent multipart */\n            g_ptr_array_add (multiparts, parent);\n            g_ptr_array_add (attachments, part);\n        }\n    }\n}\n\n/* now remove each attachment its parent multipart... */\nfor (int i = 0; i < attachments->len; i++) {\n    GMimeMultipart *multipart = (GMimeMultipart *) multiparts->pdata[i];\n    GMimeObject *attachment = (GMimeObject *) attachments->pdata[i];\n\n    g_mime_multipart_remove (multipart, attachment);\n}\n```\n\n### Creating a Simple Message\n\nCreating MIME messages using GMime is really trivial.\n\n```csharp\nGMimeMessage *message;\nGMimeTextPart *body;\n\nmessage = g_mime_message_new (TRUE);\n\ng_mime_message_add_mailbox (message, GMIME_ADDRESS_TYPE_FROM, \"Joey\", \"joey@friends.com\");\ng_mime_message_add_mailbox (message, GMIME_ADDRESS_TYPE_TO, \"Alice\", \"alice@wonderland.com\");\ng_mime_message_set_subject (message, \"How you doin?\", NULL);\n\nbody = g_mime_text_part_new_with_subtype (\"plain\");\ng_mime_text_part_set_text (body, \"Hey Alice,\\n\\n\"\n    \"What are you up to this weekend? Monica is throwing one of her parties on\\n\"\n    \"Saturday and I was hoping you could make it.\\n\\n\"\n    \"Will you be my +1?\\n\\n\"\n    \"-- Joey\\n\");\n\ng_mime_message_set_mime_part (message, (GMimeObject *) body);\ng_object_unref (body);\n```\n\n### Creating a Message with Attachments\n\nAttachments are just like any other `GMimePart`, the only difference is that they typically have\na `Content-Disposition` header with a value of \"attachment\" instead of \"inline\" or no\n`Content-Disposition` header at all.\n\nTypically, when a mail client adds attachments to a message, it will create a `multipart/mixed`\npart and add the text body part and all of the file attachments to the `multipart/mixed`.\n\nHere's how you can do that with GMime:\n\n```c\nGMimeMultipart *multipart;\nGMimeDataWrapper *content;\nGMimeMessage *message;\nGMimePart *attachment;\nGMimeTextPart *body;\nGMimeStream *stream;\n\nmessage = g_mime_message_new (TRUE);\ng_mime_message_add_mailbox (message, GMIME_ADDRESS_TYPE_FROM, \"Joey\", \"joey@friends.com\");\ng_mime_message_add_mailbox (message, GMIME_ADDRESS_TYPE_TO, \"Alice\", \"alice@wonderland.com\");\ng_mime_message_set_subject (message, \"How you doin?\", NULL);\n\n/* create our message text, just like before... */\nbody = g_mime_text_part_new_with_subtype (\"plain\");\ng_mime_text_part_set_text (body, \"Hey Alice,\\n\\n\"\n    \"What are you up to this weekend? Monica is throwing one of her parties on\\n\"\n    \"Saturday and I was hoping you could make it.\\n\\n\"\n    \"Will you be my +1?\\n\\n\"\n    \"-- Joey\\n\");\n\n/* create an image attachment for the file located at path */\nattachment = g_mime_part_new_with_type (\"image\", \"gif\");\ng_mime_part_set_filename (attachment, basename (path));\n\n/* create the content for the image attachment */\nstream = g_mime_stream_fs_open (path, O_RDONLY, 0644, NULL);\ncontent = g_mime_data_wrapper_new_with_stream (stream, GMIME_CONTENT_ENCODING_DEFAULT);\ng_object_unref (stream);\n\n/* set the content of the attachment */\ng_mime_part_set_content (attachment, content);\ng_object_unref (content);\n\n/* set the Content-Transfer-Encoding to base64 */\ng_mime_part_set_content_encoding (attachment, GMIME_CONTENT_ENCODING_BASE64);\n\n/* now create the multipart/mixed container to hold the message text and the image attachment */\nmultipart = g_mime_multipart_new_with_subtype (\"mixed\");\n\n/* add the text body first */\ng_mime_multipart_add (multipart, (GMimeObject *) body);\ng_object_unref (body);\n\n/* now add the attachment(s) */\ng_mime_multipart_add (multipart, (GMimeObject *) attachment);\ng_object_unref (attachment);\n\n/* set the multipart/mixed as the message body */\ng_mime_message_set_mime_part (message, (GMimeObject *) multipart);\ng_object_unref (multipart);\n```\n\nOf course, that is just a simple example. A lot of modern mail clients such as Outlook or Thunderbird will \nsend out both a `text/html` and a `text/plain` version of the message text. To do this, you'd create a\n`GMimeTextPart` for the `text/plain` part and another `GMimeTextPart` for the `text/html` part and then add\nthem to a `multipart/alternative` like so:\n\n```c\nGMimeMultipart *mixed, *alternative;\nGMimeTextPart *plain, *html;\nGMimePart *attachment;\n\n/* see above for how to create each of these... */\nattachment = CreateAttachment ();\nplain = CreateTextPlainPart ();\nhtml = CreateTextHtmlPart ();\n\n/* Note: it is important that the text/html part is added second, because it is the\n * most expressive version and (probably) the most faithful to the sender's WYSIWYG \n * editor. */\nalternative = g_mime_multipart_new_with_subtype (\"alternative\");\n\ng_mime_multipart_add (alternative, (GMimeObject *) plain);\ng_object_unref (plain);\n\ng_mime_multipart_add (alternative, (GMimeObject *) html);\ng_object_unref (html);\n\n/* now create the multipart/mixed container to hold the multipart/alternative\n * and the image attachment */\nmixed = g_mime_multipart_new_with_subtype (\"mixed\");\n\ng_mime_multipart_add (mixed, (GMimeObject *) alternative);\ng_object_unref (alternative);\n\ng_mime_multipart_add (mixed, (GMimeObject *) attachment);\ng_object_unref (attachment);\n\n/* now set the multipart/mixed as the message body */\ng_mime_message_set_mime_part (message, (GMimeObject *) mixed);\ng_object_unref (mixed);\n```\n\n### Encrypting Messages with S/MIME\n\nS/MIME uses an `application/pkcs7-mime` MIME part to encapsulate encrypted content (as well as other things).\n\n```c\nGMimeApplicationPkcs7Mime *encrypted;\nGMimeMessage *message;\nGError *err = NULL;\nGMimeObject *body;\nGPtrArray *rcpts;\n\nmessage = g_mime_message_new (TRUE);\ng_mime_message_add_mailbox (message, GMIME_ADDRESS_TYPE_FROM, \"Joey\", \"joey@friends.com\");\ng_mime_message_add_mailbox (message, GMIME_ADDRESS_TYPE_TO, \"Alice\", \"alice@wonderland.com\");\ng_mime_message_set_subject (message, \"How you doin?\", NULL);\n\n/* create our message body (perhaps a multipart/mixed with the message text and some\n * image attachments, for example) */\nbody = CreateMessageBody ();\n\n/* create a list of key ids to encrypt to */\nrcpts = g_ptr_array_new ();\ng_ptr_array_add (rcpts, \"alice@wonderland.com\"); // or use her fingerprint\n\n/* now to encrypt our message body */\nif (!(encrypted = g_mime_application_pkcs7_mime_encrypt (body, GMIME_ENCRYPT_NONE, rcpts, &err))) {\n    fprintf (stderr, \"encrypt failed: %s\\n\", err->message);\n    g_object_unref (body);\n    g_error_free (err);\n    return;\n}\n\ng_object_unref (body);\n\ng_mime_message_set_mime_part (message, encrypted);\ng_object_unref (encrypted);\n```\n\n### Decrypting S/MIME Messages\n\nAs mentioned earlier, S/MIME uses an `application/pkcs7-mime` part with an \"smime-type\" parameter with a value of\n\"enveloped-data\" to encapsulate the encrypted content.\n\nThe first thing you must do is find the `GMimeApplicationPkcs7Mime` part (see the section on traversing MIME parts).\n\n```c\nif (GMIME_IS_APPLICATION_PKCS7_MIME (entity)) {\n    GMimeApplicationPkcs7Mime *pkcs7 = (GMimeApplicationPkcs7Mime *) entity;\n    GMimeSecureMimeType smime_type;\n    GError *err = NULL;\n\n    smime_type = g_mime_application_pkcs7_mime_get_smime_type (pkcs7_mime);\n    if (smime_type == GMIME_SECURE_MIME_TYPE_ENVELOPED_DATA)\n        return g_mime_application_pkcs7_mime_decrypt (pkcs7, 0, NULL, NULL, &err);\n}\n```\n\n### Encrypting Messages with PGP/MIME\n\nUnlike S/MIME, PGP/MIME uses `multipart/encrypted` to encapsulate its encrypted data.\n\n```c\nGMimeMultipartEncrypted *encrypted;\nGMimeCryptoContext *ctx;\nGMimeMessage *message;\nGError *err = NULL;\nGMimeObject *body;\nGPtrArray *rcpts;\n\nmessage = g_mime_message_new (TRUE);\ng_mime_message_add_mailbox (message, GMIME_ADDRESS_TYPE_FROM, \"Joey\", \"joey@friends.com\");\ng_mime_message_add_mailbox (message, GMIME_ADDRESS_TYPE_TO, \"Alice\", \"alice@wonderland.com\");\ng_mime_message_set_subject (message, \"How you doin?\", NULL);\n\n/* create our message body (perhaps a multipart/mixed with the message text and some\n * image attachments, for example) */\nbody = CreateMessageBody ();\n\n/* create a list of key ids to encrypt to */\nrcpts = g_ptr_array_new ();\ng_ptr_array_add (rcpts, \"alice@wonderland.com\"); // or use her fingerprint\n\n/* now to encrypt our message body */\nctx = g_mime_gpg_context_new ();\n\nencrypted = g_mime_multipart_encrypted_encrypt (ctx, body, FALSE, NULL, GMIME_ENCRYPT_NONE, rcpts, &err);\ng_ptr_array_free (rcpts, TRUE);\ng_object_unref (body);\ng_object_unref (ctx);\n\nif (encrypted == NULL) {\n    fprintf (stderr, \"encrypt failed: %s\\n\", err->message);\n    g_error_free (err);\n    return;\n}\n\ng_mime_message_set_mime_part (message, (GMimeObject *) encrypted);\ng_object_unref (encrypted);\n```\n\n### Decrypting PGP/MIME Messages\n\nAs mentioned earlier, PGP/MIME uses a `multipart/encrypted` part to encapsulate the encrypted content.\n\nA `multipart/encrypted` contains exactly 2 parts: the first `GMimeObject` is the version information while the\nsecond `GMimeObject` is the actual encrypted content and will typically be an `application/octet-stream`.\n\nThe first thing you must do is find the `GMimeMultipartEncrypted` part (see the section on traversing MIME parts).\n\n```c\nif (GMIME_IS_MULTIPART_ENCRYPTED (entity)) {\n    GMimeMultipartEncrypted *encrypted = (GMimeMultipartEncrypted *) entity;\n    GMimeDecryptResult *result = NULL;\n    GError *err = NULL;\n\n    return g_mime_multipart_encrypted_decrypt (encrypted, GMIME_DECRYPT_NONE, NULL, &result, &err);\n}\n```\n\n### Digitally Signing Messages with S/MIME or PGP/MIME\n\nBoth S/MIME and PGP/MIME use a `multipart/signed` to contain the signed content and the detached signature data.\n\nHere's how you might digitally sign a message using S/MIME:\n\n```c\nGMimeApplicationPkcs7Mime *pkcs7;\nGMimeMessage *message;\nGError *err = NULL;\nGMimeObject *body;\n\nmessage = g_mime_message_new (TRUE);\ng_mime_message_add_mailbox (message, GMIME_ADDRESS_TYPE_FROM, \"Joey\", \"joey@friends.com\");\ng_mime_message_add_mailbox (message, GMIME_ADDRESS_TYPE_TO, \"Alice\", \"alice@wonderland.com\");\ng_mime_message_set_subject (message, \"How you doin?\", NULL);\n\n/* create our message body (perhaps a multipart/mixed with the message text and some\n * image attachments, for example) */\nbody = CreateMessageBody ();\n\n/* now to sign our message body */\nif (!(pkcs7 = g_mime_application_pkcs7_mime_sign (body, \"joey@friends.com\", &err))) {\n    fprintf (stderr, \"sign failed: %s\\n\", err->message);\n    g_object_unref (body);\n    g_error_free (err);\n    return;\n}\n\ng_object_unref (body);\n\ng_mime_message_set_mime_part (message, (GMimeObject *) pkcs7);\ng_object_unref (pkcs7);\n```\n\nS/MIME also gives you the option of using a `multipart/signed` method of signing a message.\n\n```c\nGMimeMultipartSigned *ms;\nGMimeCryptoContext *ctx;\nGMimeMessage *message;\nGError *err = NULL;\nGMimeObject *body;\n\nmessage = g_mime_message_new (TRUE);\ng_mime_message_add_mailbox (message, GMIME_ADDRESS_TYPE_FROM, \"Joey\", \"joey@friends.com\");\ng_mime_message_add_mailbox (message, GMIME_ADDRESS_TYPE_TO, \"Alice\", \"alice@wonderland.com\");\ng_mime_message_set_subject (message, \"How you doin?\", NULL);\n\n/* create our message body (perhaps a multipart/mixed with the message text and some\n * image attachments, for example) */\nbody = CreateMessageBody ();\n\n/* create our crypto context - needed because multipart/signed works for both S/MIME and PGP/MIME */\nctx = g_mime_pkcs7_context_new ();\n\n/* now to sign our message body */\nif (!(ms = g_mime_multipart_signed_sign (ctx, body, \"joey@friends.com\", &err))) {\n    fprintf (stderr, \"sign failed: %s\\n\", err->message);\n    g_object_unref (body);\n    g_object_unref (ctx);\n    g_error_free (err);\n    return;\n}\n\ng_object_unref (body);\ng_object_unref (ctx);\n\ng_mime_message_set_mime_part (message, (GMimeObject *) ms);\ng_object_unref (ms);\n```\n\nIf you'd prefer to use PGP instead of S/MIME, things work almost exactly the same except that you\nwould use the `GMimeGpgContext`.\n\n```c\nGMimeMultipartSigned *ms;\nGMimeCryptoContext *ctx;\nGMimeMessage *message;\nGError *err = NULL;\nGMimeObject *body;\n\nmessage = g_mime_message_new (TRUE);\ng_mime_message_add_mailbox (message, GMIME_ADDRESS_TYPE_FROM, \"Joey\", \"joey@friends.com\");\ng_mime_message_add_mailbox (message, GMIME_ADDRESS_TYPE_TO, \"Alice\", \"alice@wonderland.com\");\ng_mime_message_set_subject (message, \"How you doin?\", NULL);\n\n/* create our message body (perhaps a multipart/mixed with the message text and some\n * image attachments, for example) */\nbody = CreateMessageBody ();\n\n/* create our crypto context - needed because multipart/signed works for both S/MIME and PGP/MIME */\nctx = g_mime_gpg_context_new ();\n\n/* now to sign our message body */\nif (!(ms = g_mime_multipart_signed_sign (ctx, body, \"joey@friends.com\", &err))) {\n    fprintf (stderr, \"sign failed: %s\\n\", err->message);\n    g_object_unref (body);\n    g_object_unref (ctx);\n    g_error_free (err);\n    return;\n}\n\ng_object_unref (body);\ng_object_unref (ctx);\n\ng_mime_message_set_mime_part (message, (GMimeObject *) ms);\ng_object_unref (ms);\n```\n\n### Verifying S/MIME and PGP/MIME Digital Signatures\n\nAs mentioned earlier, both S/MIME and PGP/MIME typically use a `multipart/signed` part to contain the\nsigned content and the detached signature data.\n\nA `multipart/signed` contains exactly 2 parts: the first `GMimeObject` is the signed content while the second\n`GMimeObject` is the detached signature and, by default, will either be a `GMimeApplicationPgpSignature` part\nor a `GMimeApplicationPkcs7Signature` part (depending on whether the sending client signed using OpenPGP or\nS/MIME).\n\nBecause the `multipart/signed` part may have been signed by multiple signers, the\n`g_mime_multipart_signed_verify()` function returns a `GMimeSignatureList` which contains a list of\ndigital signatures (one for each signer) that each contain their own metadata describing who that\nsigner is and what the status of their signature is.\n\n```c\nif (GMIME_IS_MULTIPART_SIGNED (entity)) {\n    GMimeMultipartSigned *ms = (GMimeMultipartSigned *) entity;\n    GMimeSignatureList *signatures;\n    GError *err = NULL;\n    int i, count;\n\n    if (!(signatures = g_mime_multipart_signed_verify (ms, GMIME_VERIFY_ENABLE_KEYSERVER_LOOKUPS, &err))) {\n        fprintf (stderr, \"verify failed: %s\\n\", err->message);\n        g_error_free (err);\n        return;\n    }\n\n    fputs (\"\\nSignatures:\\n\", stdout);\n    count = g_mime_signature_list_length (signatures);\n    for (i = 0; i < count; i++) {\n        GMimeSignature *sig = g_mime_signature_list_get_signature (signatures, i);\n        GMimeSignatureStatus status = g_mime_signature_get_status (sig);\n        GMimeCertificate *cert = g_mime_signature_get_certificate (sig);\n        time_t created = g_mime_signature_get_created (sig);\n        time_t expires = g_mime_signature_get_expires (sig);\n\n        fprintf (stdout, \"\\tName: %s\\n\", g_mime_certificate_get_name (cert));\n        fprintf (stdout, \"\\tKeyId: %s\\n\", g_mime_certificate_get_key_id (cert));\n        fprintf (stdout, \"\\tFingerprint: %s\\n\", g_mime_certificate_get_fingerprint (cert));\n\n        fprintf (stdout, \"\\tTrust: \");\n        switch (g_mime_certificate_get_trust (cert)) {\n        case GMIME_TRUST_UNKNOWN:   fputs (\"Unknown\\n\", stdout); break;\n        case GMIME_TRUST_NEVER:     fputs (\"Never\\n\", stdout); break;\n        case GMIME_TRUST_UNDEFINED: fputs (\"Undefined\\n\", stdout); break;\n        case GMIME_TRUST_MARGINAL:  fputs (\"Marginal\\n\", stdout); break;\n        case GMIME_TRUST_FULL:      fputs (\"Full\\n\", stdout); break;\n        case GMIME_TRUST_ULTIMATE:  fputs (\"Ultimate\\n\", stdout); break;\n        }\n\n        fprintf (stdout, \"\\tStatus: \");\n        if (status & GMIME_SIGNATURE_STATUS_RED)\n            fputs (\"BAD\\n\", stdout);\n        else if (status & GMIME_SIGNATURE_STATUS_GREEN)\n            fputs (\"GOOD\\n\", stdout);\n        else if (status & GMIME_SIGNATURE_STATUS_VALID)\n            fputs (\"VALID\\n\", stdout);\n        else\n            fputs (\"UNKNOWN\\n\", stdout);\n\n        fprintf (stdout, \"\\tSignature made on %s\", ctime (&created));\n        if (expires != (time_t) 0)\n            fprintf (stdout, \"\\tSignature expires on %s\", ctime (&expires));\n        else\n            fprintf (stdout, \"\\tSignature never expires\\n\");\n\t\n        fprintf (stdout, \"\\tErrors: \");\n        if (status & GMIME_SIGNATURE_STATUS_KEY_REVOKED)\n            fputs (\"Key Revoked, \", stdout);\n        if (status & GMIME_SIGNATURE_STATUS_KEY_EXPIRED)\n            fputs (\"Key Expired, \", stdout);\n        if (status & GMIME_SIGNATURE_STATUS_SIG_EXPIRED)\n            fputs (\"Sig Expired, \", stdout);\n        if (status & GMIME_SIGNATURE_STATUS_KEY_MISSING)\n            fputs (\"Key Missing, \", stdout);\n        if (status & GMIME_SIGNATURE_STATUS_CRL_MISSING)\n            fputs (\"CRL Missing, \", stdout);\n        if (status & GMIME_SIGNATURE_STATUS_CRL_TOO_OLD)\n            fputs (\"CRL Too Old, \", stdout);\n        if (status & GMIME_SIGNATURE_STATUS_BAD_POLICY)\n            fputs (\"Bad Policy, \", stdout);\n        if (status & GMIME_SIGNATURE_STATUS_SYS_ERROR)\n            fputs (\"System Error, \", stdout);\n        if (status & GMIME_SIGNATURE_STATUS_TOFU_CONFLICT)\n            fputs (\"Tofu Conflict\", stdout);\n        if ((status & GMIME_SIGNATURE_STATUS_ERROR_MASK) == 0)\n            fputs (\"None\", stdout);\n        fputs (\"\\n\\n\", stdout);\n    }\n\n    g_object_unref (signatures);\n}\n```\n\nIt should be noted, however, that while most S/MIME clients will use the preferred `multipart/signed`\napproach, it is possible that you may encounter an `application/pkcs7-mime` part with an \"smime-type\"\nparameter set to \"signed-data\". Luckily, GMime can handle this format as well:\n\n```c\nif (GMIME_IS_APPLICATION_PKCS7_MIME (entity)) {\n    GMimeApplicationPkcs7Mime *pkcs7 = (GMimeApplicationPkcs7Mime *) entity;\n    GMimeSecureMimeType smime_type;\n\n    smime_type = g_mime_application_pkcs7_mime_get_smime_type (pkcs7);\n\n    if (smime_type == GMIME_SECURE_MIME_TYPE_SIGNED_DATA) {\n        /* extract the original content and get a list of signatures */\n        GMimeSignatureList *signatures;\n        GMimeObject *extracted;\n        GError *err = NULL;\n        int i, count;\n\n        /* Note: if you are rendering the message, you'll want to render the\n         * extracted mime part rather than the application/pkcs7-mime part. */\n\n        if (!(signatures = g_mime_application_pkcs7_mime_verify (pkcs7, GMIME_VERIFY_NONE, &extracted, &err))) {\n            fprintf (stderr, \"verify failed: %s\\n\", err->message);\n            g_error_free (err);\n            return;\n        }\n\n        count = g_mime_signature_list_length (signatures);\n        for (i = 0; i < count; i++) {\n            GMimeSignature *sig = g_mime_signature_list_get_signature (signatures, i);\n            /* ... */\n        }\n\n        g_object_unref (signatures);\n    }\n}\n```\n\n## Understanding Memory Management in GMime\n\n- Functions that return `const char *` return a pointer to a string stored on the `GObject` that will be released\nwhen the object itself is finalized and therefore should *never* be fed to `g_free()` by the caller.\n\n- Functions that return `char *` are left up to the caller to `g_free()` when the caller is done with them.\n\n### For functions throughout the GMime API that return an object reference:\n\n- If the function that returned the object allocated the object, then you need to unref it, otherwise you don't.\n\nFor example, the `stream` in the following code would need to be unreffed (using `g_object_unref()`) because it was\nfreshly allocated by the function:\n\n```c\nGMimeStream *stream = g_mime_stream_mem_new ();\n```\n\nThe next example shows a function that returns a reference to an *existing* `GMimeStream` object that is stored on\n(and therefor managed by) the `GMimeDataWrapper` object:\n\n```c\nGMimeStream *stream = g_mime_data_wrapper_get_stream (wrapper);\n```\n\nIn the above example, the `stream` *should not* be unreffed because the `stream` object's memory is managed by the\n`wrapper` object. In other words, when the `wrapper` object is freed, the `stream` will be freed as well.\n\nWhere many developers get confused is when they create a new object and then add it to another object.\n\nFor example:\n\n```c\nGMimeStream *stream = g_mime_stream_mem_new ();\nGMimeDataWrapper *wrapper = g_mime_data_wrapper_new_with_stream (stream, GMIME_CONTENT_ENCODING_DEFAULT);\ng_object_unref (stream);\n```\n\nEven in this situation, it is necessary to unref the allocated object because all GMime functions that add an\nobject to another object will ref that object themselves.\n\nIn other words, in the above example, the `GMimeStream` is being added to the `GMimeDataWrapper`. The\n`GMimeDataWrapper` calls `g_object_ref()` on the `stream` which means that the `stream` object now has\na ref count of 2.\n\nWhen `g_object_unref()` is called on the stream after adding it to the `GMimeDataWrapper`, the ref count drops\ndown to 1.\n\nAnd when the `wrapper` object is eventually finalized after calling `g_object_unref()` on it, the ref count\non the `stream` object will be reduced to 0 as well, thereby freeing the `stream` object.\n\n## Documentation\n\nThis is the README file for GMime. Additional documentation related to\ndevelopment using GMime has been included within the source release\nof GMime.\n\n|               |Description                                                  |\n|---------------|-------------------------------------------------------------|\n|docs/reference/|Contains SGML and HTML versions of the GMime reference manual|\n|docs/tutorial/ |Contains SGML and HTML versions of the GMime tutorial|\n|AUTHORS        |List of primary authors (source code developers)|\n|COPYING        |The GNU Lesser General Public License, version 2|\n|INSTALL        |In-depth installation instructions|\n|TODO           |Description of planned GMime development|\n|PORTING        |Guide for developers porting their application from an older version of GMime|\n\nYou can find online developer documentation at\nhttps://developer-old.gnome.org/gmime/stable/\n\n\n## Mailing Lists\n\nFor discussion of GMime development (either of GMime itself or using\nGMime in your own application), you may find the GMime-Devel\nmailing-list helpful. To subscribe, please see\n[http://mail.gnome.org/mailman/listinfo/gmime-devel-list](http://mail.gnome.org/mailman/listinfo/gmime-devel-list)\n\n\n## Bindings\n\nOther developers have been working to make GMime available to programmers in other languages.\nThe current list of known bindings are:\n\n|Language   |Location                                |\n|-----------|----------------------------------------|\n|Go         |https://github.com/sendgrid/go-gmime    |\n|Perl       |http://search.cpan.org/dist/MIME-Fast   |\n|C#         |https://github.com/jstedfast/MimeKit    |\n\n\n## Reporting Bugs\n\nBugs may be reported to the GMime development team by creating a new\n[issue](https://github.com/jstedfast/gmime/issues).\n\n## Reporting Security Issues\n\nSecurity issues should be reported to <a href=\"mailto:jestedfa@microsoft.com?subject=GMime%20security%20issue\">jestedfa@microsoft.com</a>.\n\nUsing a Subject along the lines of \"GMime security issue\" would be helpful in helping to spot the email message."
}
