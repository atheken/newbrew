{
  "name": "powerman-dockerize",
  "full_name": "powerman-dockerize",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Utility to simplify running applications in docker containers",
  "license": "MIT",
  "homepage": "https://github.com/powerman/dockerize",
  "versions": {
    "stable": "0.19.0",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/powerman/dockerize/archive/refs/tags/v0.19.0.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "192c142ab25893c7a1e8a135280d8e72f05f12b56c1e2b5d932946707ec68c6b"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/powerman-dockerize/blobs/sha256:22a49e6780e8e00a054aaa35c6749d21095d374eac84c5c773ff549b38adae4a",
          "sha256": "22a49e6780e8e00a054aaa35c6749d21095d374eac84c5c773ff549b38adae4a"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/powerman-dockerize/blobs/sha256:22a49e6780e8e00a054aaa35c6749d21095d374eac84c5c773ff549b38adae4a",
          "sha256": "22a49e6780e8e00a054aaa35c6749d21095d374eac84c5c773ff549b38adae4a"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/powerman-dockerize/blobs/sha256:22a49e6780e8e00a054aaa35c6749d21095d374eac84c5c773ff549b38adae4a",
          "sha256": "22a49e6780e8e00a054aaa35c6749d21095d374eac84c5c773ff549b38adae4a"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/powerman-dockerize/blobs/sha256:8ab1eff297eb25f14338b89b7bd198978b3541e619203fa92ef2450b0045e098",
          "sha256": "8ab1eff297eb25f14338b89b7bd198978b3541e619203fa92ef2450b0045e098"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/powerman-dockerize/blobs/sha256:8ab1eff297eb25f14338b89b7bd198978b3541e619203fa92ef2450b0045e098",
          "sha256": "8ab1eff297eb25f14338b89b7bd198978b3541e619203fa92ef2450b0045e098"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/powerman-dockerize/blobs/sha256:8ab1eff297eb25f14338b89b7bd198978b3541e619203fa92ef2450b0045e098",
          "sha256": "8ab1eff297eb25f14338b89b7bd198978b3541e619203fa92ef2450b0045e098"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/powerman-dockerize/blobs/sha256:02c820b472202d7146338d7c94989edf2ce8f8c6223abf57f688224a9f92cc0e",
          "sha256": "02c820b472202d7146338d7c94989edf2ce8f8c6223abf57f688224a9f92cc0e"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "go"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [
    "dockerize"
  ],
  "conflicts_with_reasons": [
    "powerman-dockerize and dockerize install conflicting executables"
  ],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/powerman-dockerize.rb",
  "ruby_source_checksum": {
    "sha256": "96402c8f50e86f0cb12c16a44112d32f4247b2e1c95950184fa2998aaa8a677f"
  },
  "date_added": "2022-03-29T08:02:15+00:00",
  "readme": "# dockerize\n\n[![Release](https://img.shields.io/github/v/release/powerman/dockerize.svg)](https://github.com/powerman/dockerize/releases/latest)\n[![Docker Automated Build](https://img.shields.io/docker/automated/powerman/dockerize.svg)](https://hub.docker.com/r/powerman/dockerize/tags)\n[![CI/CD](https://github.com/powerman/dockerize/actions/workflows/CI&CD.yml/badge.svg)](https://github.com/powerman/dockerize/actions/workflows/CI&CD.yml)\n[![Go Report Card](https://goreportcard.com/badge/github.com/powerman/dockerize)](https://goreportcard.com/report/github.com/powerman/dockerize)\n[![Coverage Status](https://coveralls.io/repos/github/powerman/dockerize/badge.svg?branch=master)](https://coveralls.io/github/powerman/dockerize?branch=master)\n\nUtility to simplify running applications in docker containers.\n\n**About this fork:** This fork is supposed to become a community-maintained replacement for\n[not maintained](https://github.com/powerman/dockerize/issues/19)\n[original repo](https://github.com/jwilder/dockerize). Everyone who has\ncontributed to the project may become a collaborator - just ask for it\nin PR comments after your PR has being merged.\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n**Table of Contents**\n\n- [Overview](#overview)\n- [Installation](#installation)\n  - [Docker Base Image](#docker-base-image)\n- [Usage](#usage)\n  - [Command-line Options](#command-line-options)\n  - [Waiting for other dependencies](#waiting-for-other-dependencies)\n  - [Timeout](#timeout)\n  - [Delay before retrying](#delay-before-retrying)\n  - [Use custom CA for SSL cert verification for https/amqps connections](#use-custom-ca-for-ssl-cert-verification-for-httpsamqps-connections)\n  - [Skip SSL cert verification for https/amqps connections](#skip-ssl-cert-verification-for-httpsamqps-connections)\n  - [Injecting env vars from INI file](#injecting-env-vars-from-ini-file)\n- [Using Templates](#using-templates)\n  - [jsonQuery](#jsonquery)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n## Overview\n\ndockerize is a utility to simplify running applications in docker containers.  It allows you to:\n* generate application configuration files at container startup time from templates and container environment variables\n* Tail multiple log files to stdout and/or stderr\n* Wait for other services to be available using TCP, HTTP(S), unix before starting the main process.\n\nThe typical use case for dockerize is when you have an application that has one or more configuration files and you would like to control some of the values using environment variables.\n\nFor example, a Python application using Sqlalchemy might not be able to use environment variables directly.\nIt may require that the database URL be read from a python settings file with a variable named\n`SQLALCHEMY_DATABASE_URI`.  dockerize allows you to set an environment variable such as\n`DATABASE_URL` and update the python file when the container starts.\nIn addition, it can also delay the starting of the python application until the database container is running and listening on the TCP port.\n\nAnother use case is when the application logs to specific files on the filesystem and not stdout\nor stderr. This makes it difficult to troubleshoot the container using the `docker logs` command.\nFor example, nginx will log to `/var/log/nginx/access.log` and\n`/var/log/nginx/error.log` by default. While you can sometimes work around this, it's tedious to find a solution for every application. dockerize allows you to specify which logs files should be tailed and where they should be sent.\n\nSee [A Simple Way To Dockerize Applications](http://jasonwilder.com/blog/2014/10/13/a-simple-way-to-dockerize-applications/)\n\n\n## Installation\n\nDockerize is a statically compiled binary, so it should work with any base image.\n\nTo download it with most base images all you need is to install `curl` first:\n\n```sh\n### alpine:\napk add curl\n\n### debian, ubuntu:\napt update && apt install -y curl\n```\n\nand then either install the latest version:\n\n```sh\ncurl -sfL $(curl -s https://api.github.com/repos/powerman/dockerize/releases/latest | grep -i /dockerize-$(uname -s)-$(uname -m)\\\" | cut -d\\\" -f4) | install /dev/stdin /usr/local/bin/dockerize\n```\n\nor specific version:\n\n```sh\ncurl -sfL https://github.com/powerman/dockerize/releases/download/v0.11.5/dockerize-`uname -s`-`uname -m` | install /dev/stdin /usr/local/bin/dockerize\n```\n\nIf `curl` is not available (e.g. busybox base image) then you can use `wget`:\n\n```\n### busybox: latest version\nwget -O - $(wget -O - https://api.github.com/repos/powerman/dockerize/releases/latest | grep -i /dockerize-$(uname -s)-$(uname -m)\\\" | cut -d\\\" -f4) | install /dev/stdin /usr/local/bin/dockerize\n\n### busybox: specific version\nwget -O - https://github.com/powerman/dockerize/releases/download/v0.11.5/dockerize-`uname -s`-`uname -m` | install /dev/stdin /usr/local/bin/dockerize\n```\n\nPGP public key for verifying signed binaries: https://powerman.name/about/Powerman.asc\n\n```\ncurl -sfL https://powerman.name/about/Powerman.asc | gpg --import\ncurl -sfL https://github.com/powerman/dockerize/releases/download/v0.11.5/dockerize-`uname -s`-`uname -m`.asc >dockerize.asc\ngpg --verify dockerize.asc /usr/local/bin/dockerize\n```\n\n### Docker Base Image\n\nThe `powerman/dockerize` image is a base image based on `alpine linux`.  `dockerize` is installed in the `$PATH` and can be used directly.\n\n```\nFROM powerman/dockerize\n...\nENTRYPOINT dockerize ...\n```\n\n### Install in Docker Image\n\nYou can use multi-stage build feature to install `dockerize` in your docker image without changing base image:\n\n```dockerfile\nFROM powerman/dockerize:0.19.0 AS dockerize\nFROM node:18-slim\n...\nCOPY --from=dockerize /usr/local/bin/dockerize /usr/local/bin/\n...\nENTRYPOINT [\"dockerize\", ...]\n```\n\n## Usage\n\ndockerize works by wrapping the call to your application using the `ENTRYPOINT` or `CMD` directives.\n\nThis would generate `/etc/nginx/nginx.conf` from the template located at `/etc/nginx/nginx.tmpl` and\nsend `/var/log/nginx/access.log` to `STDOUT` and `/var/log/nginx/error.log` to `STDERR` after running\n`nginx`, only after waiting for the `web` host to respond on `tcp 8000`:\n\n``` Dockerfile\nCMD dockerize -template /etc/nginx/nginx.tmpl:/etc/nginx/nginx.conf -stdout /var/log/nginx/access.log -stderr /var/log/nginx/error.log -wait tcp://web:8000 nginx\n```\n\n### Command-line Options\n\nYou can specify multiple templates by passing using `-template` multiple times:\n\n```\n$ dockerize -template template1.tmpl:file1.cfg -template template2.tmpl:file3\n\n```\n\nTemplates can be generated to `STDOUT` by not specifying a dest:\n\n```\n$ dockerize -template template1.tmpl\n\n```\n\nTemplate may also be a directory. In this case all files within this directory are recursively processed as template and stored with the same name in the destination directory.\nIf the destination directory is omitted, the output is sent to `STDOUT`. The files in the source directory are processed in sorted order (as returned by `ioutil.ReadDir`).\n\n```\n$ dockerize -template src_dir:dest_dir\n\n```\n\nIf the destination file already exists, dockerize will overwrite it. The -no-overwrite flag overrides this behaviour.\n\n```\n$ dockerize -no-overwrite -template template1.tmpl:file\n```\n\nYou can tail multiple files to `STDOUT` and `STDERR` by passing the options multiple times.\n(These options can't be combined with `-exec`.)\n\n```\n$ dockerize -stdout info.log -stdout perf.log\n\n```\n\nIf your file uses `{{` and `}}` as part of it's syntax, you can change the template escape characters using the `-delims`.\n\n```\n$ dockerize -delims \"<%:%>\" -template template1.tmpl\n```\n\nYou can require all environment variables mentioned in template exists\nwith `-template-strict`:\n\n```\n$ dockerize -template-strict -template template1.tmpl\n```\n\nHTTP headers can be specified for http/https protocols.\nIf header is specified as a file path then file must contain single string with `Header: value`.\n\n```\n$ dockerize -wait http://web:80 -wait-http-header \"Authorization:Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\"\n```\n\nRequired HTTP status codes can be specified, otherwise any 2xx status will\nbe accepted.\n\n```\n$ dockerize -wait http://web:80 -wait-http-status-code 302 -wait-http-status-code 200\n```\n\nHTTP redirects can be ignored:\n\n```\n$ dockerize -wait http://web:80 -wait-http-skip-redirect\n```\n\nDockerize process can be replaced with given command:\n\n```\n$ dockerize -exec some-command args...\n```\n\n### Waiting for other dependencies\n\nIt is common when using tools like [Docker Compose](https://docs.docker.com/compose/) to depend on services in other linked containers, however oftentimes relying on [links](https://docs.docker.com/compose/compose-file/#links) is not enough - whilst the container itself may have _started_, the _service(s)_ within it may not yet be ready - resulting in shell script hacks to work around race conditions.\n\nDockerize gives you the ability to wait for services on a specified protocol (`file`, `tcp`, `tcp4`, `tcp6`, `http`, `https`, `amqp`, `amqps` and `unix`) before starting your application:\n\n```\n$ dockerize -wait tcp://db:5432 -wait http://web:80 -wait file:///tmp/generated-file\n```\n\nMultiple URLs can also be specified with `-wait-list` flag, that accept a space-separated list of URLs. The behaviour is equivalent to use multiple `-wait` flags.\nThe two flags can be combined.\n\nThis command is equivalent to the one above:\n\n```\n$ dockerize -wait-list \"tcp://db:5432 http://web:80 file:///tmp/generated-file\"\n```\n\n### Timeout\n\nYou can optionally specify how long to wait for the services to become available by using the `-timeout #` argument (Default: 10 seconds).  If the timeout is reached and the service is still not available, the process exits with status code 123.\n\n```\n$ dockerize -wait tcp://db:5432 -wait http://web:80 -timeout 10s\n```\n\nSee [this issue](https://github.com/docker/compose/issues/374#issuecomment-126312313) for a deeper discussion, and why support isn't and won't be available in the Docker ecosystem itself.\n\n### Delay before retrying\n\nYou can optionally specify how long to wait after a failed `-wait` check by using the `-wait-retry-interval #` argument (Default: 1 second).\n\nWaiting for 5 seconds before checking again of a currently unavailable service:\n\n```\n$ dockerize -wait tcp://db:5432 -wait-retry-interval 5s\n```\n\n### Use custom CA for SSL cert verification for https/amqps connections\n\n```\n$ dockerize -cacert /path/to/ca.pem -wait https://web:80\n```\n\n### Skip SSL cert verification for https/amqps connections\n\n```\n$ dockerize -skip-tls-verify -wait https://web:80\n```\n\n### Injecting env vars from INI file\n\nYou can load defaults for missing env vars from INI file.\nMultiline flag allows parsing multiline INI entries.\nFile with header must contain single string with `Header: value`.\n\n```\n$ dockerize -env /path/to/file.ini -env-section SectionName -multiline …\n$ dockerize -env http://localhost:80/file.ini \\\n    -env-header \"Header: value\" -env-header /path/to/file/with/header …\n```\n\n## Using Templates\n\nTemplates use Golang [text/template](http://golang.org/pkg/text/template/). You can access environment\nvariables within a template with `.Env`.\n\n```\n{{ .Env.PATH }} is my path\n```\n\nIn template you can use a lot of [functions provided by\nSprig](http://masterminds.github.io/sprig/) plus a few built in functions as well:\n\n  * `exists $path` - Determines if a file path exists or not. `{{ if exists \"/etc/default/myapp\" }}`\n  * `parseUrl $url` - Parses a URL into it's [protocol, scheme, host, etc. parts](https://golang.org/pkg/net/url/#URL). Alias for [`url.Parse`](https://golang.org/pkg/net/url/#Parse)\n  * `isTrue $value` - Parses a string $value to a boolean value. `{{ if isTrue .Env.ENABLED }}`\n  * `jsonQuery $json $query` - Returns the result of a selection query against a json document.\n  * `readFile $fileName` - Returns the content of the named file or empty string if file not exists.\n\n**WARNING! Incompatibility with [original dockerize\nv0.6.1](https://github.com/jwilder/dockerize)!** These template functions\nwas changed because of adding Sprig functions, so carefully review your\ntemplates before upgrading:\n\n* `default` - order of params has changed.\n* `contains` - now it works on string instead of map, use `hasKey` instead.\n* `split` - now it split into map instead of list, use `splitList` instead.\n* `replace` - order and amount of params has changed.\n* `loop` - removed, use `untilStep` instead.\n\n### jsonQuery\n\nObjects and fields are accessed by name. Array elements are accessed by index in square brackets (e.g. `[1]`). Nested elements are separated by dots (`.`).\n\n**Examples:**\n\nWith the following JSON in `.Env.SERVICES`\n\n```\n{\n  \"services\": [\n    {\n      \"name\": \"service1\",\n      \"port\": 8000,\n    },{\n      \"name\": \"service2\",\n      \"port\": 9000,\n    }\n  ]\n}\n```\n\nthe template expression `jsonQuery .Env.SERVICES \"services.[1].port\"` returns `9000`."
}
