{
  "name": "libucl",
  "full_name": "libucl",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Universal configuration library parser",
  "license": "BSD-2-Clause",
  "homepage": "https://github.com/vstakhov/libucl",
  "versions": {
    "stable": "0.8.2",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/vstakhov/libucl/archive/0.8.2.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "d95a0e2151cc167a0f3e51864fea4e8977a0f4c473faa805269a347f7fb4e165"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libucl/blobs/sha256:f9e944d05b49df899f5b5cf0e655f4f23fc6978abd38e6b420e69f54b2d0b334",
          "sha256": "f9e944d05b49df899f5b5cf0e655f4f23fc6978abd38e6b420e69f54b2d0b334"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libucl/blobs/sha256:09a3e260d36bcdc45e887b82eb7ec003509866fc34d781024bec94577e2e48c2",
          "sha256": "09a3e260d36bcdc45e887b82eb7ec003509866fc34d781024bec94577e2e48c2"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libucl/blobs/sha256:2cb2ecaf50cddcaf11d401e0f9af425ba31b9a39010aaf320421403104445321",
          "sha256": "2cb2ecaf50cddcaf11d401e0f9af425ba31b9a39010aaf320421403104445321"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libucl/blobs/sha256:247a34b8fdfd55c25c6bb432bf0a99c46a33137491d9073bf64feb5f468ded44",
          "sha256": "247a34b8fdfd55c25c6bb432bf0a99c46a33137491d9073bf64feb5f468ded44"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libucl/blobs/sha256:91209890a1a2666cb79822dde2bb7c4914472c145f53019a546271e8845be9f2",
          "sha256": "91209890a1a2666cb79822dde2bb7c4914472c145f53019a546271e8845be9f2"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libucl/blobs/sha256:7496b34362a2cab89c43a44f76bacedf44f62835d80f651ab7348c8163b88e4d",
          "sha256": "7496b34362a2cab89c43a44f76bacedf44f62835d80f651ab7348c8163b88e4d"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/libucl/blobs/sha256:79b85d68fee133cdc1c58d8b290500e8e6dd8aab787e247e9f4cc2a166b1b0f7",
          "sha256": "79b85d68fee133cdc1c58d8b290500e8e6dd8aab787e247e9f4cc2a166b1b0f7"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "autoconf",
    "automake",
    "libtool",
    "pkg-config"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/libucl.rb",
  "ruby_source_checksum": {
    "sha256": "d9e7d12c86466bcb79a53bfe4d08db4d8c91f6bf002093db59ee8a3f6aae0206"
  },
  "date_added": "2016-03-06T13:14:15+08:00",
  "readme": "# LIBUCL\n\n**Table of Contents**  *generated with [DocToc](http://doctoc.herokuapp.com/)*\n\n- [Introduction](#introduction)\n- [Basic structure](#basic-structure)\n- [Improvements to the json notation](#improvements-to-the-json-notation)\n\t- [General syntax sugar](#general-syntax-sugar)\n\t- [Automatic arrays creation](#automatic-arrays-creation)\n\t- [Named keys hierarchy](#named-keys-hierarchy)\n\t- [Convenient numbers and booleans](#convenient-numbers-and-booleans)\n- [General improvements](#general-improvements)\n\t- [Comments](#comments)\n\t- [Macros support](#macros-support)\n\t- [Variables support](#variables-support)\n\t- [Multiline strings](#multiline-strings)\n\t- [Single quoted strings](#single-quoted-strings)\n- [Emitter](#emitter)\n- [Validation](#validation)\n- [Performance](#performance)\n- [Conclusion](#conclusion)\n\n## Introduction\n\nThis document describes the main features and principles of the configuration\nlanguage called `UCL` - universal configuration language.\n\nIf you are looking for the libucl API documentation you can find it at [this page](doc/api.md).\n\n## Basic structure\n\nUCL is heavily infused by `nginx` configuration as the example of a convenient configuration\nsystem. However, UCL is fully compatible with `JSON` format and is able to parse json files.\nFor example, you can write the same configuration in the following ways:\n\n* in nginx like:\n\n```nginx\nparam = value;\nsection {\n    param = value;\n    param1 = value1;\n    flag = true;\n    number = 10k;\n    time = 0.2s;\n    string = \"something\";\n    subsection {\n        host = {\n            host = \"hostname\";\n            port = 900;\n        }\n        host = {\n            host = \"hostname\";\n            port = 901;\n        }\n    }\n}\n```\n\n* or in JSON:\n\n```json\n{\n    \"param\": \"value\",\n    \"section\": {\n        \"param\": \"value\",\n        \"param1\": \"value1\",\n        \"flag\": true,\n        \"number\": 10000,\n        \"time\": \"0.2s\",\n        \"string\": \"something\",\n        \"subsection\": {\n            \"host\": [\n                {\n                    \"host\": \"hostname\",\n                    \"port\": 900\n                },\n                {\n                    \"host\": \"hostname\",\n                    \"port\": 901\n                }\n            ]\n        }\n    }\n}\n```\n\n## Improvements to the json notation.\n\nThere are various things that make ucl configuration more convenient for editing than strict json:\n\n### General syntax sugar\n\n* Braces are not necessary to enclose a top object: it is automatically treated as an object:\n\n```json\n\"key\": \"value\"\n```\nis equal to:\n```json\n{\"key\": \"value\"}\n```\n\n* There is no requirement of quotes for strings and keys, moreover, `:` may be replaced `=` or even be skipped for objects:\n\n```nginx\nkey = value;\nsection {\n    key = value;\n}\n```\nis equal to:\n```json\n{\n    \"key\": \"value\",\n    \"section\": {\n        \"key\": \"value\"\n    }\n}\n```\n\n* No commas mess: you can safely place a comma or semicolon for the last element in an array or an object:\n\n```json\n{\n    \"key1\": \"value\",\n    \"key2\": \"value\",\n}\n```\n### Automatic arrays creation\n\n* Non-unique keys in an object are allowed and are automatically converted to the arrays internally:\n\n```json\n{\n    \"key\": \"value1\",\n    \"key\": \"value2\"\n}\n```\nis converted to:\n```json\n{\n    \"key\": [\"value1\", \"value2\"]\n}\n```\n\n### Named keys hierarchy\n\nUCL accepts named keys and organize them into objects hierarchy internally. Here is an example of this process:\n```nginx\nsection \"blah\" {\n\tkey = value;\n}\nsection foo {\n\tkey = value;\n}\n```\n\nis converted to the following object:\n\n```nginx\nsection {\n\tblah {\n\t\tkey = value;\n\t}\n\tfoo {\n\t\tkey = value;\n\t}\n}\n```\n\nPlain definitions may be more complex and contain more than a single level of nested objects:\n\n```nginx\nsection \"blah\" \"foo\" {\n\tkey = value;\n}\n```\n\nis presented as:\n\n```nginx\nsection {\n\tblah {\n\t\tfoo {\n\t\t\tkey = value;\n\t\t}\n\t}\n}\n```\n\n### Convenient numbers and booleans\n\n* Numbers can have suffixes to specify standard multipliers:\n    + `[kKmMgG]` - standard 10 base multipliers (so `1k` is translated to 1000)\n    + `[kKmMgG]b` - 2 power multipliers (so `1kb` is translated to 1024)\n    + `[s|min|d|w|y]` - time multipliers, all time values are translated to float number of seconds, for example `10min` is translated to 600.0 and `10ms` is translated to 0.01\n* Hexadecimal integers can be used by `0x` prefix, for example `key = 0xff`. However, floating point values can use decimal base only.\n* Booleans can be specified as `true` or `yes` or `on` and `false` or `no` or `off`.\n* It is still possible to treat numbers and booleans as strings by enclosing them in double quotes.\n\n## General improvements\n\n### Comments\n\nUCL supports different style of comments:\n\n* single line: `#`\n* multiline: `/* ... */`\n\nMultiline comments may be nested:\n```c\n# Sample single line comment\n/*\n some comment\n /* nested comment */\n end of comment\n*/\n```\n\n### Macros support\n\nUCL supports external macros both multiline and single line ones:\n```nginx\n.macro_name \"sometext\";\n.macro_name {\n    Some long text\n    ....\n};\n```\n\nMoreover, each macro can accept an optional list of arguments in braces. These\narguments themselves are the UCL object that is parsed and passed to a macro as\noptions:\n\n```nginx\n.macro_name(param=value) \"something\";\n.macro_name(param={key=value}) \"something\";\n.macro_name(.include \"params.conf\") \"something\";\n.macro_name(#this is multiline macro\nparam = [value1, value2]) \"something\";\n.macro_name(key=\"()\") \"something\";\n```\n\nUCL also provide a convenient `include` macro to load content from another files\nto the current UCL object. This macro accepts either path to file:\n\n```nginx\n.include \"/full/path.conf\"\n.include \"./relative/path.conf\"\n.include \"${CURDIR}/path.conf\"\n```\n\nor URL (if ucl is built with url support provided by either `libcurl` or `libfetch`):\n\n\t.include \"http://example.com/file.conf\"\n\n`.include` macro supports a set of options:\n\n* `try` (default: **false**) - if this option is `true` than UCL treats errors on loading of\nthis file as non-fatal. For example, such a file can be absent but it won't stop the parsing\nof the top-level document.\n* `sign` (default: **false**) - if this option is `true` UCL loads and checks the signature for\na file from path named `<FILEPATH>.sig`. Trusted public keys should be provided for UCL API after\nparser is created but before any configurations are parsed.\n* `glob` (default: **false**) - if this option is `true` UCL treats the filename as GLOB pattern and load\nall files that matches the specified pattern (normally the format of patterns is defined in `glob` manual page\nfor your operating system). This option is meaningless for URL includes.\n* `url` (default: **true**) - allow URL includes.\n* `path` (default: empty) - A UCL_ARRAY of directories to search for the include file.\nSearch ends after the first match, unless `glob` is true, then all matches are included.\n* `prefix` (default false) - Put included contents inside an object, instead\nof loading them into the root. If no `key` is provided, one is automatically generated based on each files basename()\n* `key` (default: <empty string>) - Key to load contents of include into. If\nthe key already exists, it must be the correct type\n* `target` (default: object) - Specify if the `prefix` `key` should be an\nobject or an array.\n* `priority` (default: 0) - specify priority for the include (see below).\n* `duplicate` (default: 'append') - specify policy of duplicates resolving:\n\t- `append` - default strategy, if we have new object of higher priority then it replaces old one, if we have new object with less priority it is ignored completely, and if we have two duplicate objects with the same priority then we have a multi-value key (implicit array)\n\t- `merge` - if we have object or array, then new keys are merged inside, if we have a plain object then an implicit array is formed (regardless of priorities)\n\t- `error` - create error on duplicate keys and stop parsing\n\t- `rewrite` - always rewrite an old value with new one (ignoring priorities)\n\nPriorities are used by UCL parser to manage the policy of objects rewriting during including other files\nas following:\n\n* If we have two objects with the same priority then we form an implicit array\n* If a new object has bigger priority then we overwrite an old one\n* If a new object has lower priority then we ignore it\n\nBy default, the priority of top-level object is set to zero (lowest priority). Currently,\nyou can define up to 16 priorities (from 0 to 15). Includes with bigger priorities will\nrewrite keys from the objects with lower priorities as specified by the policy. The priority\nof the top-level or any other object can be changed with the `.priority` macro, which has no\noptions and takes the new priority:\n\n```\n# Default priority: 0.\nfoo = 6\n.priority 5\n# The following will have priority 5.\nbar = 6\nbaz = 7\n# The following will be included with a priority of 3, 5, and 6 respectively.\n.include(priority=3) \"path.conf\"\n.include(priority=5) \"equivalent-path.conf\"\n.include(priority=6) \"highpriority-path.conf\"\n```\n\n### Variables support\n\nUCL supports variables in input. Variables are registered by a user of the UCL parser and can be presented in the following forms:\n\n* `${VARIABLE}`\n* `$VARIABLE`\n\nUCL currently does not support nested variables. To escape variables one could use double dollar signs:\n\n* `$${VARIABLE}` is converted to `${VARIABLE}`\n* `$$VARIABLE` is converted to `$VARIABLE`\n\nHowever, if no valid variables are found in a string, no expansion will be performed (and `$$` thus remains unchanged). This may be a subject\nto change in future libucl releases.\n\n### Multiline strings\n\nUCL can handle multiline strings as well as single line ones. It uses shell/perl like notation for such objects:\n```\nkey = <<EOD\nsome text\nsplitted to\nlines\nEOD\n```\n\nIn this example `key` will be interpreted as the following string: `some text\\nsplitted to\\nlines`.\nHere are some rules for this syntax:\n\n* Multiline terminator must start just after `<<` symbols and it must consist of capital letters only (e.g. `<<eof` or `<< EOF` won't work);\n* Terminator must end with a single newline character (and no spaces are allowed between terminator and newline character);\n* To finish multiline string you need to include a terminator string just after newline and followed by a newline (no spaces or other characters are allowed as well);\n* The initial and the final newlines are not inserted to the resulting string, but you can still specify newlines at the beginning and at the end of a value, for example:\n\n```\nkey <<EOD\n\nsome\ntext\n\nEOD\n```\n\n### Single quoted strings\n\nIt is possible to use single quoted strings to simplify escaping rules. All values passed in single quoted strings are *NOT* escaped, with two exceptions: a single `'` character just before `\\` character, and a newline character just after `\\` character that is ignored.\n\n```\nkey = 'value'; # Read as value\nkey = 'value\\n\\'; # Read as  value\\n\\\nkey = 'value\\''; # Read as value'\nkey = 'value\\\nbla'; # Read as valuebla\n```\n\n## Emitter\n\nEach UCL object can be serialized to one of the four supported formats:\n\n* `JSON` - canonic json notation (with spaces indented structure);\n* `Compacted JSON` - compact json notation (without spaces or newlines);\n* `Configuration` - nginx like notation;\n* `YAML` - yaml inlined notation;\n* `messagepack` - MessagePack binary format.\n\n## Validation\n\nUCL allows validation of objects. It uses the same schema that is used for json: [json schema v4](http://json-schema.org). UCL supports the full set of json schema with the exception of remote references. This feature is unlikely useful for configuration objects. Of course, a schema definition can be in UCL format instead of JSON that simplifies schemas writing. Moreover, since UCL supports multiple values for keys in an object it is possible to specify generic integer constraints `maxValues` and `minValues` to define the limits of values count in a single key. UCL currently is not absolutely strict about validation schemas themselves, therefore UCL users should supply valid schemas (as it is defined in json-schema draft v4) to ensure that the input objects are validated properly.\n\n## Performance\n\nAre UCL parser and emitter fast enough? Well, there are some numbers.\nI got a 19Mb file that consist of ~700 thousand lines of json (obtained via\nhttp://www.json-generator.com/). Then I checked jansson library that performs json\nparsing and emitting and compared it with UCL. Here are results:\n\n```\njansson: parsed json in 1.3899 seconds\njansson: emitted object in 0.2609 seconds\n\nucl: parsed input in 0.6649 seconds\nucl: emitted config in 0.2423 seconds\nucl: emitted json in 0.2329 seconds\nucl: emitted compact json in 0.1811 seconds\nucl: emitted yaml in 0.2489 seconds\n```\n\nSo far, UCL seems to be significantly faster than jansson on parsing and slightly faster on emitting. Moreover,\nUCL compiled with optimizations (-O3) performs significantly faster:\n```\nucl: parsed input in 0.3002 seconds\nucl: emitted config in 0.1174 seconds\nucl: emitted json in 0.1174 seconds\nucl: emitted compact json in 0.0991 seconds\nucl: emitted yaml in 0.1354 seconds\n```\n\nYou can do your own benchmarks by running `make check` in libucl top directory.\n\n## Conclusion\n\nUCL has clear design that should be very convenient for reading and writing. At the same time it is compatible with\nJSON language and therefore can be used as a simple JSON parser. Macro logic provides an ability to extend configuration\nlanguage (for example by including some lua code) and comments allow to disable or enable the parts of a configuration\nquickly."
}
