{
  "name": "go-statik",
  "full_name": "go-statik",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Embed files into a Go executable",
  "license": "Apache-2.0",
  "homepage": "https://github.com/rakyll/statik",
  "versions": {
    "stable": "0.1.7",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/rakyll/statik/archive/v0.1.7.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "cd05f409e63674f29cff0e496bd33eee70229985243cce486107085fab747082"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 1,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-statik/blobs/sha256:26f7b3d318ee90136abccb38d929251dd06a2b689191ad9c34a29acde10a4645",
          "sha256": "26f7b3d318ee90136abccb38d929251dd06a2b689191ad9c34a29acde10a4645"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-statik/blobs/sha256:1c5a13a7d21ea10888bdfb31153624ca587b2b3424ecf8c97f5bfa512aedf898",
          "sha256": "1c5a13a7d21ea10888bdfb31153624ca587b2b3424ecf8c97f5bfa512aedf898"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-statik/blobs/sha256:5960b8ab88990df3e2a3ef0578da24b674d72c620466af263fdad6b479133fe9",
          "sha256": "5960b8ab88990df3e2a3ef0578da24b674d72c620466af263fdad6b479133fe9"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-statik/blobs/sha256:ad26269af443084182676494a9d351fd977e0d8d4644f465b22e2f92498fc492",
          "sha256": "ad26269af443084182676494a9d351fd977e0d8d4644f465b22e2f92498fc492"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-statik/blobs/sha256:bc500cc264e19fa299d10cee767ea23b79750b4e5891359aa465898e1de6590f",
          "sha256": "bc500cc264e19fa299d10cee767ea23b79750b4e5891359aa465898e1de6590f"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-statik/blobs/sha256:0f05d7b15227e1bdf7be3876d90135232083ae1789c08d32641777b9291ef8a7",
          "sha256": "0f05d7b15227e1bdf7be3876d90135232083ae1789c08d32641777b9291ef8a7"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-statik/blobs/sha256:d6d3e13adce186f49cf35be7be414baec7cfa02e8d884e0a97ec9f15108f4cb4",
          "sha256": "d6d3e13adce186f49cf35be7be414baec7cfa02e8d884e0a97ec9f15108f4cb4"
        },
        "mojave": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-statik/blobs/sha256:93f27ec30935befbde2afab7ac3382a2e576b8a51024db2dd8a911860fb5b10f",
          "sha256": "93f27ec30935befbde2afab7ac3382a2e576b8a51024db2dd8a911860fb5b10f"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/go-statik/blobs/sha256:c8dac98a1bcf9c946d1ec00fcf2249f1796796f1f52f549988b95d96f9e94fc7",
          "sha256": "c8dac98a1bcf9c946d1ec00fcf2249f1796796f1f52f549988b95d96f9e94fc7"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "go"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [
    "statik"
  ],
  "conflicts_with_reasons": [
    "both install `statik` binaries"
  ],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/go-statik.rb",
  "ruby_source_checksum": {
    "sha256": "ef6df22fb6d3077c6d7fb91e38241077477ed6cec90a8d2a3dfe4e90a21cf215"
  },
  "date_added": "2018-01-07T01:16:41-08:00",
  "readme": "# statik\n\n[![Build Status](https://travis-ci.org/rakyll/statik.svg?branch=master)](https://travis-ci.org/rakyll/statik)\n\nstatik allows you to embed a directory of static files into your Go binary to be later served from an http.FileSystem.\n\nIs this a crazy idea? No, not necessarily. If you're building a tool that has a Web component, you typically want to serve some images, CSS and JavaScript. You like the comfort of distributing a single binary, so you don't want to mess with deploying them elsewhere. If your static files are not large in size and will be browsed by a few people, statik is a solution you are looking for.\n\n## Usage\n\nInstall the command line tool first.\n\n\tgo get github.com/rakyll/statik\n\nstatik is a tiny program that reads a directory and generates a source file that contains its contents. The generated source file registers the directory contents to be used by statik file system.\n\nThe command below will walk on the public path and generate a package called `statik` under the current working directory.\n\n    $ statik -src=/path/to/your/project/public\n\nThe command below will filter only files on listed extensions.\n\n    $ statik -include=*.jpg,*.txt,*.html,*.css,*.js\n\nIn your program, all your need to do is to import the generated package, initialize a new statik file system and serve.\n\n~~~ go\nimport (\n  \"github.com/rakyll/statik/fs\"\n\n  _ \"./statik\" // TODO: Replace with the absolute import path\n)\n\n  // ...\n\n  statikFS, err := fs.New()\n  if err != nil {\n    log.Fatal(err)\n  }\n  \n  // Serve the contents over HTTP.\n  http.Handle(\"/public/\", http.StripPrefix(\"/public/\", http.FileServer(statikFS)))\n  http.ListenAndServe(\":8080\", nil)\n~~~\n\nVisit http://localhost:8080/public/path/to/file to see your file.\n\nYou can also read the content of a single file:\n\n~~~ go\nimport (\n  \"github.com/rakyll/statik/fs\"\n\n  _ \"./statik\" // TODO: Replace with the absolute import path\n)\n\n  // ...\n\n  statikFS, err := fs.New()\n  if err != nil {\n    log.Fatal(err)\n  }\n  \n  // Access individual files by their paths.\n  r, err := statikFS.Open(\"/hello.txt\")\n  if err != nil {\n    log.Fatal(err)\n  }    \n  defer r.Close()\n  contents, err := ioutil.ReadAll(r)\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  fmt.Println(string(contents))\n~~~\n\nThere is also a working example under [example](https://github.com/rakyll/statik/tree/master/example) directory, follow the instructions to build and run it.\n\nNote: The idea and the implementation are hijacked from [camlistore](http://camlistore.org/). I decided to decouple it from its codebase due to the fact I'm actively in need of a similar solution for many of my projects.\n\n## Deterministic output\n\nBy default, statik includes the \"last modified\" (mtime) time on files that it packs. This allows an HTTP FileServer to present the correct file modification times to clients.\n\nHowever, if you have a continuous integration task that checks that your checked-in static files in a git repository match the code that is generated on your CI system, you'll run into a problem: The mtime on the git checkout does not match what you have locally, causing tests to fail.\n\nYou can fix the test in one of two ways:\n\n1. In CI, manually set the mtime on the freshly checked out tree: [here's a stackoverflow answer](https://stackoverflow.com/a/22638823/93405) that provides a shell command to do that; or,\n2. Instruct statik not to store the \"last modified\" time.\n\nTo ignore the last modified time, use the `-m` to statik, like so:\n\n    $ statik -m -include=*.jpg,*.txt,*.html,*.css,*.js\n\nNote that this will cause http.FileServer to consider the file to always have changed & serve it with a \"Last-Modified\" of the time of the request."
}
