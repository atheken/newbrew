{
  "name": "gx",
  "full_name": "gx",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Language-agnostic, universal package manager",
  "license": "MIT",
  "homepage": "https://github.com/whyrusleeping/gx",
  "versions": {
    "stable": "0.14.3",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/whyrusleeping/gx/archive/v0.14.3.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "2c0b90ddfd3152863f815c35b37e94d027216c6ba1c6653a94b722bf6e2b015d"
    },
    "head": {
      "url": "https://github.com/whyrusleeping/gx.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gx/blobs/sha256:a49ac2040542b71f63e9c30592e102b07fc10561a79b99014773f7c88ffe7c47",
          "sha256": "a49ac2040542b71f63e9c30592e102b07fc10561a79b99014773f7c88ffe7c47"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gx/blobs/sha256:f1323ff13674b582766dccca83ee63a63314eb3fbc0ccfd815dd9138e073b1f1",
          "sha256": "f1323ff13674b582766dccca83ee63a63314eb3fbc0ccfd815dd9138e073b1f1"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gx/blobs/sha256:7099419ae5d6da42d66de65b1a4b9355f586f7484a6a738d1caa1c77ff917670",
          "sha256": "7099419ae5d6da42d66de65b1a4b9355f586f7484a6a738d1caa1c77ff917670"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gx/blobs/sha256:e707d45bd29a98762cee6992eccec4b0015c75d6d009488abfafeb96f63684f5",
          "sha256": "e707d45bd29a98762cee6992eccec4b0015c75d6d009488abfafeb96f63684f5"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gx/blobs/sha256:800b33c5da09b5165c011858adf22f136390f84c3636a66c32f6114fd9294ea4",
          "sha256": "800b33c5da09b5165c011858adf22f136390f84c3636a66c32f6114fd9294ea4"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gx/blobs/sha256:5171470b8fe21652a1ae5fef81f0b463a3c10fdac821134f2e8d7635af1ccdda",
          "sha256": "5171470b8fe21652a1ae5fef81f0b463a3c10fdac821134f2e8d7635af1ccdda"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gx/blobs/sha256:f737f5829c0e1ce2ff58c56515e77f3797c30d614a53ebbf663985d5564c62db",
          "sha256": "f737f5829c0e1ce2ff58c56515e77f3797c30d614a53ebbf663985d5564c62db"
        },
        "mojave": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gx/blobs/sha256:bd03f428c3e52561caefaa09c6abc92b21faa226ad02abeeb6c74217ca1dfbbf",
          "sha256": "bd03f428c3e52561caefaa09c6abc92b21faa226ad02abeeb6c74217ca1dfbbf"
        },
        "high_sierra": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gx/blobs/sha256:e6634c1b68abcb48984a7d681248393ca26824a81496c567ef23029ff9a892f5",
          "sha256": "e6634c1b68abcb48984a7d681248393ca26824a81496c567ef23029ff9a892f5"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/gx/blobs/sha256:40fe8e9f82a981fbf440651d85215bdc246ef4da138b5378da7318b4f3f04645",
          "sha256": "40fe8e9f82a981fbf440651d85215bdc246ef4da138b5378da7318b4f3f04645"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "go"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/gx.rb",
  "ruby_source_checksum": {
    "sha256": "73c9511ce4cd3677c5d0c669438b341af32dcb66ae3dc8d12bdf5a4c73f39b2c"
  },
  "date_added": "2016-04-17T19:23:10+01:00",
  "readme": "![gx logo](logo.jpeg)\n\n# gx\n> The language-agnostic, universal package manager\n\n[![](https://img.shields.io/badge/made%20by-Protocol%20Labs-blue.svg?style=flat-square)](http://protocol.ai) [![](https://img.shields.io/badge/freenode-%23gx-blue.svg?style=flat-square)](http://webchat.freenode.net/?channels=%23ipfs,%23gx)\n\ngx is a packaging tool built around the distributed, content addressed filesystem\n[IPFS](//github.com/ipfs/ipfs). It aims to be flexible, powerful and simple.\n\ngx is **Alpha Quality**. While not perfect, gx is reliable enough\nto manage dependencies in [go-ipfs](https://github.com/ipfs/go-ipfs/) and\nis ready for use by developers of all skill levels.\n\n## Table of Contents\n- [Background](#background)\n- [Requirements](#requirements)\n- [Installation](#installation)\n- [Usage](#usage)\n- [Dependencies](#dependencies)\n- [Updating](#updating)\n- [Repos](#repos)\n  - [Usage](#usage-1)\n- [Hooks](#hooks)\n- [The vendor directory](#the-vendor-directory)\n- [Using gx as a Go package manager](#using-gx-as-a-go-package-manager)\n- [Using gx as a Javascript package manager](#using-gx-as-a-javascrit-package-manager)\n- [Using gx as a package manager for language/environment X](#using-gx-as-a-package-manager-for-languageenvironment-x)\n- [Why is it called gx?](#why-is-it-called-gx)\n- [License](#license)\n\n## Background\n\ngx was originally designed to handle dependencies in Go projects in a\ndistributed fashion, and pulls ideas from other beloved package managers (like\n[npm](http://npmjs.org/)).\n\ngx was designed with the following major goals in mind:\n\n1. Be language/ecosystem agnostic by providing [git-like hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks) for adding [new ecosystems](https://github.com/whyrusleeping/gx-go).\n2. Provide completely reproducible packages through content addressing.\n3. Use [a flexible, distributed storage backend](http://ipfs.io/).\n\n\n## Requirements\nUsers are encouraged to have a running [IPFS daemon](//github.com/ipfs/go-ipfs) of at least version 0.4.2 on their machines.\nIf not present, gx will use the public gateway.\nIf you wish to publish a package, a local running daemon is a hard requirement. If your IPFS repo is in a non-standard location, remember to set $IPFS_PATH. Alternatively, you can explicitly set $IPFS_API to $IPFS_API_IPADDR:$PORT.\n\n\n## Installation\n\n```\n$ (cd ~ && GO111MODULE=on go get github.com/whyrusleeping/gx)\n```\n\nThis will download, build, and install a binary to `$GOPATH/bin`. To modify gx,\njust change the source in that directory, and run `go build`.\n\n## Usage\n\nCreating and publishing new generic package:\n\n```bash\n$ gx init\n$ gx publish\n```\n\nThis will output a 'package-hash' unique to the content of the\npackage at the time of publishing. If someone downloads the package and\nrepublishes it, the *exact* same hash will be produced.\n\n### package.json\n\nIt should be noted that gx is meant to *work with* existing `package.json` files. If you are adding a package to gx that already has a `package.json` file in its root, gx will try and work with it. Any shared fields will have the same types, and any fields unique to gx will kept separate. \n\nE.g. A single `package.json` file could be used to serve both gx and another packaging tool, such as npm. Since gx is **Alpha Quality** there may be some exceptions to the above statements, if you notice one, please file an issue.\n\n## Installing a gx package\nIf you've cloned down a gx package, simply run `gx install` or `gx i` to\ninstall it (and its dependencies).\n\n## Dependencies\nTo add a dependency of another package to your package, simply import it by its\nhash:\n\n```bash\n$ gx import QmaDFJvcHAnxpnMwcEh6VStYN4v4PB4S16j4pAuC2KSHVr\n```\n\nThis downloads the package specified by the hash into the `vendor` directory in your\nworkspace. It also adds an entry referencing the package to the local `package.json`.\n\nGx has a few nice tools to view and analyze dependencies. First off, the simple:\n\n```bash\n$ gx deps\ngo-log              QmSpJByNKFX1sCsHBEp3R73FL4NF6FnQTEGyNAXHm2GS52 1.2.0\ngo-libp2p-peer      QmWXjJo15p4pzT7cayEwZi2sWgJqLnGDof6ZGMh9xBgU1p 2.0.4\ngo-libp2p-peerstore QmYkwVGkwoPbMVQEbf6LonZg4SsCxGP3H7PBEtdNCNRyxD 1.2.5\ngo-testutil         QmYpVUnnedgGrp6cX2pBii5HRQgcSr778FiKVe7o7nF5Z3 1.0.2\ngo-ipfs-util        QmZNVWh8LLjAavuQ2JXuFmuYH3C11xo988vSgp7UQrTRj1 1.0.0\n```\n\nThis just lists out the immediate dependencies of this package. To see\ndependencies of dependencies, use the `-r` option: (and optionally the `-s`\noption to sort them)\n\n```bash\n$ gx deps -r -s\ngo-base58           QmT8rehPR3F6bmwL6zjUN8XpiDBFFpMP2myPdC6ApsWfJf 0.0.0\ngo-crypto           Qme1boxspcQWR8FBzMxeppqug2fYgYc15diNWmqgDVnvn2 0.0.0\ngo-datastore        QmbzuUusHqaLLoNTDEVLcSF6vZDHZDLPC7p4bztRvvkXxU 1.0.0\ngo-ipfs-util        QmZNVWh8LLjAavuQ2JXuFmuYH3C11xo988vSgp7UQrTRj1 1.0.0\ngo-keyspace         QmUusaX99BZoELh7dmPgirqRQ1FAmMnmnBn3oiqDFGBUSc 1.0.0\ngo-libp2p-crypto    QmVoi5es8D5fNHZDqoW6DgDAEPEV5hQp8GBz161vZXiwpQ 1.0.4\ngo-libp2p-peer      QmWXjJo15p4pzT7cayEwZi2sWgJqLnGDof6ZGMh9xBgU1p 2.0.4\ngo-libp2p-peerstore QmYkwVGkwoPbMVQEbf6LonZg4SsCxGP3H7PBEtdNCNRyxD 1.2.5\ngo-log              QmSpJByNKFX1sCsHBEp3R73FL4NF6FnQTEGyNAXHm2GS52 1.2.0\ngo-logging          QmQvJiADDe7JR4m968MwXobTCCzUqQkP87aRHe29MEBGHV 0.0.0\ngo-multiaddr        QmYzDkkgAEmrcNzFCiYo6L1dTX4EAG1gZkbtdbd9trL4vd 0.0.0\ngo-multiaddr-net    QmY83KqqnQ286ZWbV2x7ixpeemH3cBpk8R54egS619WYff 1.3.0\ngo-multihash        QmYf7ng2hG5XBtJA3tN34DQ2GUN5HNksEw1rLDkmr6vGku 0.0.0\ngo-net              QmZy2y8t9zQH2a1b8q2ZSLKp17ATuJoCNxxyMFG5qFExpt 0.0.0\ngo-testutil         QmYpVUnnedgGrp6cX2pBii5HRQgcSr778FiKVe7o7nF5Z3 1.0.2\ngo-text             Qmaau1d1WjnQdTYfRYfFVsCS97cgD8ATyrKuNoEfexL7JZ 0.0.0\ngo.uuid             QmcyaFHbyiZfoX5GTpcqqCPYmbjYNAhRDekXSJPFHdYNSV 1.0.0\ngogo-protobuf       QmZ4Qi3GaRbjcx28Sme5eMH7RQjGkt8wHxt2a65oLaeFEV 0.0.0\ngoprocess           QmSF8fPo3jgVBAy8fpdjjYqgG87dkJgUprRBHRd2tmfgpP 1.0.0\nmafmt               QmeLQ13LftT9XhNn22piZc3GP56fGqhijuL5Y8KdUaRn1g 1.1.1\n```\n\nThat's pretty useful, I now know the full set of packages my package depends on.\nBut what's difficult now is being able to tell what is imported where. To\naddress that, gx has a `--tree` option:\n\n```bash\n$ gx deps --tree\n├─ go-base58          QmT8rehPR3F6bmwL6zjUN8XpiDBFFpMP2myPdC6ApsWfJf 0.0.0\n├─ go-multihash       QmYf7ng2hG5XBtJA3tN34DQ2GUN5HNksEw1rLDkmr6vGku 0.0.0\n│  ├─ go-base58       QmT8rehPR3F6bmwL6zjUN8XpiDBFFpMP2myPdC6ApsWfJf 0.0.0\n│  └─ go-crypto       Qme1boxspcQWR8FBzMxeppqug2fYgYc15diNWmqgDVnvn2 0.0.0\n├─ go-ipfs-util       QmZNVWh8LLjAavuQ2JXuFmuYH3C11xo988vSgp7UQrTRj1 1.0.0\n│  ├─ go-base58       QmT8rehPR3F6bmwL6zjUN8XpiDBFFpMP2myPdC6ApsWfJf 0.0.0\n│  └─ go-multihash    QmYf7ng2hG5XBtJA3tN34DQ2GUN5HNksEw1rLDkmr6vGku 0.0.0\n│     ├─ go-base58    QmT8rehPR3F6bmwL6zjUN8XpiDBFFpMP2myPdC6ApsWfJf 0.0.0\n│     └─ go-crypto    Qme1boxspcQWR8FBzMxeppqug2fYgYc15diNWmqgDVnvn2 0.0.0\n├─ go-log             QmNQynaz7qfriSUJkiEZUrm2Wen1u3Kj9goZzWtrPyu7XR 1.1.2\n│  ├─ randbo          QmYvsG72GsfLgUeSojXArjnU6L4Wmwk7wuAxtNLuyXcc1T 0.0.0\n│  ├─ go-net          QmZy2y8t9zQH2a1b8q2ZSLKp17ATuJoCNxxyMFG5qFExpt 0.0.0\n│  │  ├─ go-text      Qmaau1d1WjnQdTYfRYfFVsCS97cgD8ATyrKuNoEfexL7JZ 0.0.0\n│  │  └─ go-crypto    Qme1boxspcQWR8FBzMxeppqug2fYgYc15diNWmqgDVnvn2 0.0.0\n│  └─ go-logging      QmQvJiADDe7JR4m968MwXobTCCzUqQkP87aRHe29MEBGHV 0.0.0\n└─ go-libp2p-crypto   QmUEUu1CM8bxBJxc3ZLojAi8evhTr4byQogWstABet79oY 1.0.2\n   ├─ gogo-protobuf   QmZ4Qi3GaRbjcx28Sme5eMH7RQjGkt8wHxt2a65oLaeFEV 0.0.0\n   ├─ go-log          Qmazh5oNUVsDZTs2g59rq8aYQqwpss8tcUWQzor5sCCEuH 0.0.0\n   │  ├─ go.uuid      QmPC2dW6jyNzzBKYuHLBhxzfWaUSkyC9qaGMz7ciytRSFM 0.0.0\n   │  ├─ go-logging   QmQvJiADDe7JR4m968MwXobTCCzUqQkP87aRHe29MEBGHV 0.0.0\n   │  ├─ go-net       QmZy2y8t9zQH2a1b8q2ZSLKp17ATuJoCNxxyMFG5qFExpt 0.0.0\n   │  │  ├─ go-text   Qmaau1d1WjnQdTYfRYfFVsCS97cgD8ATyrKuNoEfexL7JZ 0.0.0\n   │  │  └─ go-crypto Qme1boxspcQWR8FBzMxeppqug2fYgYc15diNWmqgDVnvn2 0.0.0\n   │  └─ randbo       QmYvsG72GsfLgUeSojXArjnU6L4Wmwk7wuAxtNLuyXcc1T 0.0.0\n   ├─ go-ipfs-util    QmZNVWh8LLjAavuQ2JXuFmuYH3C11xo988vSgp7UQrTRj1 1.0.0\n   │  ├─ go-base58    QmT8rehPR3F6bmwL6zjUN8XpiDBFFpMP2myPdC6ApsWfJf 0.0.0\n   │  └─ go-multihash QmYf7ng2hG5XBtJA3tN34DQ2GUN5HNksEw1rLDkmr6vGku 0.0.0\n   │     ├─ go-base58 QmT8rehPR3F6bmwL6zjUN8XpiDBFFpMP2myPdC6ApsWfJf 0.0.0\n   │     └─ go-crypto Qme1boxspcQWR8FBzMxeppqug2fYgYc15diNWmqgDVnvn2 0.0.0\n   └─ go-msgio        QmRQhVisS8dmPbjBUthVkenn81pBxrx1GxE281csJhm2vL 0.0.0\n      └─ go-randbuf   QmYNGtJHgaGZkpzq8yG6Wxqm6EQTKqgpBfnyyGBKbZeDUi 0.0.0\n```\n\nNow you can see the *entire* tree of dependencies for this project. Although,\nfor larger projects, this will get messy. If you're just interested in the\ndependency tree of a single package, you can use the `--highlight` option\nto filter the trees printing:\n\n```bash\n$ gx deps --tree --highlight=go-crypto\n├─ go-multihash       QmYf7ng2hG5XBtJA3tN34DQ2GUN5HNksEw1rLDkmr6vGku 0.0.0\n│  └─ go-crypto       Qme1boxspcQWR8FBzMxeppqug2fYgYc15diNWmqgDVnvn2 0.0.0\n├─ go-ipfs-util       QmZNVWh8LLjAavuQ2JXuFmuYH3C11xo988vSgp7UQrTRj1 1.0.0\n│  └─ go-multihash    QmYf7ng2hG5XBtJA3tN34DQ2GUN5HNksEw1rLDkmr6vGku 0.0.0\n│     └─ go-crypto    Qme1boxspcQWR8FBzMxeppqug2fYgYc15diNWmqgDVnvn2 0.0.0\n├─ go-log             QmNQynaz7qfriSUJkiEZUrm2Wen1u3Kj9goZzWtrPyu7XR 1.1.2\n│  └─ go-net          QmZy2y8t9zQH2a1b8q2ZSLKp17ATuJoCNxxyMFG5qFExpt 0.0.0\n│     └─ go-crypto    Qme1boxspcQWR8FBzMxeppqug2fYgYc15diNWmqgDVnvn2 0.0.0\n└─ go-libp2p-crypto   QmUEUu1CM8bxBJxc3ZLojAi8evhTr4byQogWstABet79oY 1.0.2\n   ├─ go-log          Qmazh5oNUVsDZTs2g59rq8aYQqwpss8tcUWQzor5sCCEuH 0.0.0\n   │  └─ go-net       QmZy2y8t9zQH2a1b8q2ZSLKp17ATuJoCNxxyMFG5qFExpt 0.0.0\n   │     └─ go-crypto Qme1boxspcQWR8FBzMxeppqug2fYgYc15diNWmqgDVnvn2 0.0.0\n   └─ go-ipfs-util    QmZNVWh8LLjAavuQ2JXuFmuYH3C11xo988vSgp7UQrTRj1 1.0.0\n      └─ go-multihash QmYf7ng2hG5XBtJA3tN34DQ2GUN5HNksEw1rLDkmr6vGku 0.0.0\n         └─ go-crypto Qme1boxspcQWR8FBzMxeppqug2fYgYc15diNWmqgDVnvn2 0.0.0\n```\n\nThis tree is a subset of the previous one, filtered to only show leaves that\nend in the selected package.\n\nThe gx deps command also has two other smaller subcommands, `dupes` and\n`stats`. `gx deps dupes` will print out packages that are imported multiple\ntimes with the same name, but different hashes. This is useful to see if\ndifferent versions of the same package have been imported in different places\nin the dependency tree. Allowing the user to more easily address the\ndiscrepancy. `gx deps stats` will output the total number of packages imported\n(total and unique) as well as the average depth of imports in the tree. This\ngives you a rough idea of the complexity of your package.\n\n### The gx dependency graph manifesto\nI firmly believe that packages are better when:\n\n#### 1. The depth of the dependency tree is minimized.\nThis means restructuring your code in such a way that flattens (and perhaps\nwidens as a consequence) the tree. For example, in Go, this often times means\nmaking an interface its own package, and implementations into their own\nseparate packages. The benefits here are that flatter trees are far easier to\nupdate. For every package deep a dependency is, you have to update, test,\ncommit, review and merge another package. That's a lot of work, and also a lot\nof extra room for problems to sneak in.\n\n#### 2. The width of the tree is minimized, but not at the cost of increasing depth.\nThis should be fairly common sense, but striving to import packages only where\nthey are actually needed helps to improve code quality. Imagine having a helper\nfunction in one package, simply because it's convenient to have it there, that\ndepends on a bunch of other imports from elsewhere in the tree. Sure it's nice,\nand doesn't actually increase the 'total' number of packages you depend on. But\nnow you've created an extra batch of work for you to do any time any of these\nare updated, and you also now force anyone who wants to import the package with\nyour helper function to also import all those other dependencies.\n\nAdhering to the above two rules should (I'm very open to discussion on this)\nimprove overall code quality, and make your codebase far easier to navigate and\nwork on.\n\n## Updating\nUpdating packages in gx is simple:\n\n```bash\n$ gx update mypkg QmbH7fpAV1FgMp6J7GZXUV6rj6Lck5tDix9JJGBSjFPgUd\n```\n\nThis looks into your `package.json` for a dependency named `mypkg` and replaces\nits hash reference with the one given.\n\nAlternatively, you can just specify the hash you want to update to:\n\n```bash\n$ gx update QmbH7fpAV1FgMp6J7GZXUV6rj6Lck5tDix9JJGBSjFPgUd\n```\n\nDoing it this way will pull down the package, check its name, and then update\nthat dependency.\n\nNote that by default, this will not touch your code at all, so any references\nto that hash you have in your code will need to be updated. If you have a\nlanguage tool (e.g. `gx-go`) installed, and it has a `post-update` hook,\nreferences to the given package should be updated correctly. If not, you may\nhave to run sed over the package to update everything. The bright side of that\nis that you are very unlikely to have those hashes sitting around for any other\nreason so a global find-replace should be just fine.\n\n## Publishing and Releasing\nGx by default will not let you publish a package twice if you haven't updated\nits version. To get around this, you can pass the `-f` flag. Though this is not\nrecommended, it's still perfectly possible to do.\n\nTo update the version easily, use the `gx version` subcommand. You can either set the version manually:\n\n```bash\n$ gx version 5.11.4\n```\n\nOr just do a 'version bump':\n\n```bash\n$ gx version patch\nupdated version to: 5.11.5\n$ gx version minor\nupdated version to: 5.12.0\n$ gx version major\nupdated version to: 6.0.0\n```\n\nMost of the time, your process will look something like:\n\n```bash\n$ gx version minor\nupdated version to: 6.1.0\n$ gx publish\npackage whys-awesome-package published with hash: QmaoaEi6uNMuuXKeYcXM3gGUEQLzbDWGcFUdd3y49crtZK\n$ git commit -a -m \"gx publish 6.1.0\"\n[master 5c4d36c] gx publish 6.1.0\n 2 files changed, 3 insertions(+), 2 deletions(-)\n```\n\nThe `release` subcommand can be used to automate the above process. `gx release <version>`\nwill do a version update (using the same inputs as the normal\n`version` command), run a `gx publish`, and then execute whatever you have set\nin your `package.json` as your `releaseCmd`. To get the above git commit flow,\nyou can set it to: `git commit -a -m \\\"gx publish $VERSION\\\"` and gx will\nreplace `$VERSION` with the newly changed version before executing the git\ncommit.\n\n### Ignoring files from a publish\nYou can use a `.gxignore` file to make gx ignore certain files during a publish.\nThis has the same behaviour as a `.gitignore`.\n\nGx also respects a `.gitignore` file if present, and will not publish any file\nexcluded by it.\n\n\n## Repos\ngx supports named packages via user configured repositories. A repository is\nsimply an ipfs object whose links name package hashes. You can add a repository\nas either an ipns or ipfs path.\n\n### Usage\n\nAdd a new repo\n```bash\n$ gx repo add myrepo /ipns/QmPupmUqXHBxikXxuptYECKaq8tpGNDSetx1Ed44irmew3\n```\n\nList configured repos\n```bash\n$ gx repo list\nmyrepo       /ipns/QmPupmUqXHBxikXxuptYECKaq8tpGNDSetx1Ed44irmew3\n```\n\nList packages in a given repo\n```bash\n$ gx repo list myrepo\nevents      QmeJjwRaGJfx7j6LkPLjyPfzcD2UHHkKehDPkmizqSpcHT\nsmalltree   QmRgTZA6jGi49ipQxorkmC75d3pLe69N6MZBKfQaN6grGY\nstump       QmebiJS1saSNEPAfr9AWoExvpfGoEK4QCtdLKCK4z6Qw7U\n```\n\nImport a package from a repo:\n```bash\n$ gx repo import events\n```\n\n## Hooks\ngx supports a wide array of use cases by having sane defaults that are\nextensible based on the scenario the user is in. To this end, gx has hooks that\nget called during certain operations.\n\nThese hooks are language specific, and gx will attempt to make calls to a\nhelper binary matching your language to execute the hooks. For example, when\nwriting go, gx calls `gx-go hook <hookname> <args>` for any given hook.\n\nCurrently available hooks are:\n\n- `post-import`\n  - called after a new package is imported and its info written to package.json.\n  - takes the hash of the newly imported package as an argument.\n- `post-init`\n  - called after a new package is initialized.\n  - takes an optional argument of the directory of the newly init'ed package.\n- `pre-publish`\n  - called during `gx publish` before the package is bundled up and added to ipfs.\n  - currently takes no arguments.\n- `post-publish`\n  - called during `gx publish` after the package has been added to ipfs.\n  - takes the hash of the newly published package as an argument.\n- `post-update`\n  - called during `gx update` after a dependency has been updated.\n  - takes the old package ref and the new hash as arguments.\n- `post-install`\n  - called after a new package is downloaded, during install and import.\n  - takes the path to the new package as an argument.\n- `install-path`\n  - called during package installs and imports.\n  - sets the location for gx to install packages to.\n\n## Package directories\n\nGx by default will install packages 'globally' in the global install location\nfor your given project type.  Global gx packages are shared across all packages\nthat depend on them.  The location of this directory can be changed if desired. Add a hook\nto your environments extension tool named `install-path` (see above) and gx\nwill use that path instead. If your language does not set a global install\npath, gx will fallback to installing locally as the default.  This means that\nit will create a folder in the current directory named `vendor` and install\nthings to it.\n\nWhen running `gx install` in the directory of your package, gx will recursively\nfetch all of the dependencies specified in the `package.json` and save them to\nthe install path specified.\n\nGx supports both local and global installation paths. Since the default is\nglobal, to install locally, use `--local` or `--global=false`.  The global flag\nis passed to the `install-path` hook for your extension code to use in its\nlogic.\n\n## Using gx as a Go package manager\n\nIf you want (like me) to use gx as a package manager for go, it's pretty easy.\nYou will need the gx go extensions before starting your project:\n```\n$ go get -u github.com/whyrusleeping/gx-go\n```\n\nOnce that's installed, use gx like normal to import dependencies.\nYou can import code from the vendor directory using:\n```go\nimport \"gx/ipfs/<hash>/packagename\"\n```\n\nfor example, if i have a package foobar, you can import with gx it like so:\n```bash\n$ gx import QmR5FHS9TpLbL9oYY8ZDR3A7UWcHTBawU1FJ6pu9SvTcPa\n```\n\nAnd then in your go code, you can use it with:\n```go\nimport \"gx/ipfs/QmR5FHS9TpLbL9oYY8ZDR3A7UWcHTBawU1FJ6pu9SvTcPa/foobar\"\n```\n\nThen simply set the environment variable `GO15VENDOREXPERIMENT` to `1` and run\n`go build` or `go install` like you normally would. Alternatively, install\nyour dependencies globally (`gx install --global`) and you can leave off the\nenvironment variable part.\n\nSee [the gx-go repo](https://github.com/whyrusleeping/gx-go) for more details.\n\n## Using gx as a Javascript package manager\n\nPlease take a look at [gx-js](https://github.com/sterpe/gx-js).\n\n## Using gx as a package manager for language/environment X\n\nIf you want to use gx with a big bunch of repositories/packages please\ntake a look at [gx-workspace](https://github.com/ipfs/gx-workspace).\n\nIf you want to extend gx to work with any other language or environment, you\ncan implement the relevant hooks in a binary named `gx-X` where the 'X' is the\nname of your environment. After that, any package whose language is set to 'X'\nwill call out to that tools hooks during normal `gx` operations. For example, a\n'go' package would call `gx-go hook pre-publish` during a `gx publish`\ninvocation before the package is actually published.  For more information on\nhooks, check out the hooks section above.\n\nSee also the `examples` directory.\n\n## Why is it called gx?\n\nNo reason. \"gx\" stands for nothing.\n\n## Getting Involved\n\nIf you're interested in gx, please stop by #gx and #ipfs on freenode irc!\n\n## License\n\nMIT. Jeromy Johnson."
}
