{
  "name": "cpu_features",
  "full_name": "cpu_features",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Cross platform C99 library to get cpu features at runtime",
  "license": "Apache-2.0",
  "homepage": "https://github.com/google/cpu_features",
  "versions": {
    "stable": "0.8.0",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/google/cpu_features/archive/v0.8.0.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "7021729f2db97aa34f218d12727314f23e8b11eaa2d5a907e8426bcb41d7eaac"
    },
    "head": {
      "url": "https://github.com/google/cpu_features.git",
      "branch": "main"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 1,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/cpu_features/blobs/sha256:b6c3ae68da8ffc33249b6c5631e021be42ca1bc6e947f4093386c0c185528137",
          "sha256": "b6c3ae68da8ffc33249b6c5631e021be42ca1bc6e947f4093386c0c185528137"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/cpu_features/blobs/sha256:140e90dc4c7741d6b33f8bc038bbd68ed545312ee58e07697d8b57584e8762e0",
          "sha256": "140e90dc4c7741d6b33f8bc038bbd68ed545312ee58e07697d8b57584e8762e0"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/cpu_features/blobs/sha256:3a9206c537847ccd89d6569c8db3125ccd345fe4369355c667e87ecb829097e0",
          "sha256": "3a9206c537847ccd89d6569c8db3125ccd345fe4369355c667e87ecb829097e0"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/cpu_features/blobs/sha256:842480ec53a47fc61a3ec7c994315425c2a0539671d757473e0e667982018573",
          "sha256": "842480ec53a47fc61a3ec7c994315425c2a0539671d757473e0e667982018573"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/cpu_features.rb",
  "ruby_source_checksum": {
    "sha256": "e632f63a9856af8d65300ea9b9649b7625d00b8fcc2ff1ce0004b7bc27e26819"
  },
  "date_added": "2019-08-24T17:03:11+08:00",
  "readme": "# cpu_features\n\nA cross-platform C library to retrieve CPU features (such as available\ninstructions) at runtime.\n\n# GitHub-CI Status\n\n[comment]: <> (The following lines are generated by \"scripts/generate_badges.d\" that you can run online https://run.dlang.io/)\n\n| Os | amd64 | AArch64 | ARM | MIPS | POWER | RISCV | s390x |\n| :-- | --: | --: | --: | --: | --: | --: | --: |\n| Linux | [![][i1a0]][l1a0]<br/>[![][i1a1]][l1a1] | [![][i1b0]][l1b0]<br/>![][d1] | [![][i1c0]][l1c0]<br/>![][d1] | [![][i1d0]][l1d0]<br/>![][d1] | [![][i1e0]][l1e0]<br/>![][d1] | [![][i1f0]][l1f0]<br/>![][d1] | [![][i1g0]][l1g0]<br/>![][d1] |\n| FreeBSD | [![][i2a0]][l2a0]<br/>![][d1] | ![][d0]<br/>![][d1] | ![][d0]<br/>![][d1] | ![][d0]<br/>![][d1] | ![][d0]<br/>![][d1] | ![][d0]<br/>![][d1] | ![][d0]<br/>![][d1] |\n| MacOS | [![][i3a0]][l3a0]<br/>![][d1] | ![][d0]<br/>![][d1] | ![][d0]<br/>![][d1] | ![][d0]<br/>![][d1] | ![][d0]<br/>![][d1] | ![][d0]<br/>![][d1] | ![][d0]<br/>![][d1] |\n| Windows | [![][i4a0]][l4a0]<br/>![][d1] | ![][d0]<br/>![][d1] | ![][d0]<br/>![][d1] | ![][d0]<br/>![][d1] | ![][d0]<br/>![][d1] | ![][d0]<br/>![][d1] | ![][d0]<br/>![][d1] |\n\n[d0]: https://img.shields.io/badge/CMake-N%2FA-lightgrey\n[d1]: https://img.shields.io/badge/Bazel-N%2FA-lightgrey\n[i1a0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/amd64_linux_cmake.yml?branch=main&label=CMake\n[i1a1]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/amd64_linux_bazel.yml?branch=main&label=Bazel\n[i1b0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/aarch64_linux_cmake.yml?branch=main&label=CMake\n[i1c0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/arm_linux_cmake.yml?branch=main&label=CMake\n[i1d0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/mips_linux_cmake.yml?branch=main&label=CMake\n[i1e0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/power_linux_cmake.yml?branch=main&label=CMake\n[i1f0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/riscv_linux_cmake.yml?branch=main&label=CMake\n[i1g0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/s390x_linux_cmake.yml?branch=main&label=CMake\n[i2a0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/amd64_freebsd_cmake.yml?branch=main&label=CMake\n[i3a0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/amd64_macos_cmake.yml?branch=main&label=CMake\n[i4a0]: https://img.shields.io/github/actions/workflow/status/google/cpu_features/amd64_windows_cmake.yml?branch=main&label=CMake\n[l1a0]: https://github.com/google/cpu_features/actions/workflows/amd64_linux_cmake.yml\n[l1a1]: https://github.com/google/cpu_features/actions/workflows/amd64_linux_bazel.yml\n[l1b0]: https://github.com/google/cpu_features/actions/workflows/aarch64_linux_cmake.yml\n[l1c0]: https://github.com/google/cpu_features/actions/workflows/arm_linux_cmake.yml\n[l1d0]: https://github.com/google/cpu_features/actions/workflows/mips_linux_cmake.yml\n[l1e0]: https://github.com/google/cpu_features/actions/workflows/power_linux_cmake.yml\n[l1f0]: https://github.com/google/cpu_features/actions/workflows/riscv_linux_cmake.yml\n[l1g0]: https://github.com/google/cpu_features/actions/workflows/s390x_linux_cmake.yml\n[l2a0]: https://github.com/google/cpu_features/actions/workflows/amd64_freebsd_cmake.yml\n[l3a0]: https://github.com/google/cpu_features/actions/workflows/amd64_macos_cmake.yml\n[l4a0]: https://github.com/google/cpu_features/actions/workflows/amd64_windows_cmake.yml\n\n## Table of Contents\n\n- [Design Rationale](#rationale)\n- [Code samples](#codesample)\n- [Running sample code](#usagesample)\n- [What's supported](#support)\n- [Android NDK's drop in replacement](#ndk)\n- [License](#license)\n- [Build with cmake](#cmake)\n- [Community Bindings](#bindings)\n\n<a name=\"rationale\"></a>\n## Design Rationale\n\n-   **Simple to use.** See the snippets below for examples.\n-   **Extensible.** Easy to add missing features or architectures.\n-   **Compatible with old compilers** and available on many architectures so it\n    can be used widely. To ensure that cpu_features works on as many platforms\n    as possible, we implemented it in a highly portable version of C: C99.\n-   **Sandbox-compatible.** The library uses a variety of strategies to cope\n    with sandboxed environments or when `cpuid` is unavailable. This is useful\n    when running integration tests in hermetic environments.\n-   **Thread safe, no memory allocation, and raises no exceptions.**\n    cpu_features is suitable for implementing fundamental libc functions like\n    `malloc`, `memcpy`, and `memcmp`.\n-   **Unit tested.**\n\n<a name=\"codesample\"></a>\n## Code samples\n\n**Note:** For C++ code, the library functions are defined in the `cpu_features` namespace.\n\n### Checking features at runtime\n\nHere's a simple example that executes a codepath if the CPU supports both the\nAES and the SSE4.2 instruction sets:\n\n```c\n#include \"cpuinfo_x86.h\"\n\n// For C++, add `using namespace cpu_features;`\nstatic const X86Features features = GetX86Info().features;\n\nvoid Compute(void) {\n  if (features.aes && features.sse4_2) {\n    // Run optimized code.\n  } else {\n    // Run standard code.\n  }\n}\n```\n\n### Caching for faster evaluation of complex checks\n\nIf you wish, you can read all the features at once into a global variable, and\nthen query for the specific features you care about. Below, we store all the ARM\nfeatures and then check whether AES and NEON are supported.\n\n```c\n#include <stdbool.h>\n#include \"cpuinfo_arm.h\"\n\n// For C++, add `using namespace cpu_features;`\nstatic const ArmFeatures features = GetArmInfo().features;\nstatic const bool has_aes_and_neon = features.aes && features.neon;\n\n// use has_aes_and_neon.\n```\n\nThis is a good approach to take if you're checking for combinations of features\nwhen using a compiler that is slow to extract individual bits from bit-packed\nstructures.\n\n### Checking compile time flags\n\nThe following code determines whether the compiler was told to use the AVX\ninstruction set (e.g., `g++ -mavx`) and sets `has_avx` accordingly.\n\n```c\n#include <stdbool.h>\n#include \"cpuinfo_x86.h\"\n\n// For C++, add `using namespace cpu_features;`\nstatic const X86Features features = GetX86Info().features;\nstatic const bool has_avx = CPU_FEATURES_COMPILED_X86_AVX || features.avx;\n\n// use has_avx.\n```\n\n`CPU_FEATURES_COMPILED_X86_AVX` is set to 1 if the compiler was instructed to\nuse AVX and 0 otherwise, combining compile time and runtime knowledge.\n\n### Rejecting poor hardware implementations based on microarchitecture\n\nOn x86, the first incarnation of a feature in a microarchitecture might not be\nthe most efficient (e.g. AVX on Sandy Bridge). We provide a function to retrieve\nthe underlying microarchitecture so you can decide whether to use it.\n\nBelow, `has_fast_avx` is set to 1 if the CPU supports the AVX instruction\nset&mdash;but only if it's not Sandy Bridge.\n\n```c\n#include <stdbool.h>\n#include \"cpuinfo_x86.h\"\n\n// For C++, add `using namespace cpu_features;`\nstatic const X86Info info = GetX86Info();\nstatic const X86Microarchitecture uarch = GetX86Microarchitecture(&info);\nstatic const bool has_fast_avx = info.features.avx && uarch != INTEL_SNB;\n\n// use has_fast_avx.\n```\n\nThis feature is currently available only for x86 microarchitectures.\n\n<a name=\"usagesample\"></a>\n### Running sample code\n\nBuilding `cpu_features` (check [quickstart](#quickstart) below) brings a small executable to test the library.\n\n```shell\n % ./build/list_cpu_features\narch            : x86\nbrand           :        Intel(R) Xeon(R) CPU E5-1650 0 @ 3.20GHz\nfamily          :   6 (0x06)\nmodel           :  45 (0x2D)\nstepping        :   7 (0x07)\nuarch           : INTEL_SNB\nflags           : aes,avx,cx16,smx,sse4_1,sse4_2,ssse3\n```\n\n```shell\n% ./build/list_cpu_features --json\n{\"arch\":\"x86\",\"brand\":\"       Intel(R) Xeon(R) CPU E5-1650 0 @ 3.20GHz\",\"family\":6,\"model\":45,\"stepping\":7,\"uarch\":\"INTEL_SNB\",\"flags\":[\"aes\",\"avx\",\"cx16\",\"smx\",\"sse4_1\",\"sse4_2\",\"ssse3\"]}\n```\n\n<a name=\"support\"></a>\n## What's supported\n\n|         | x86³ | AArch64 | ARM     | MIPS⁴   | POWER   | RISCV   | s390x   |\n|---------|:----:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| Linux   | yes² | yes¹    | yes¹    | yes¹    | yes¹    | yes¹    | yes¹    |\n| FreeBSD | yes² | not yet | not yet | not yet | not yet | N/A     | not yet |\n| MacOs   | yes² | not yet | N/A     | N/A     | no      | N/A     | no      |\n| Windows | yes² | not yet | not yet | N/A     | N/A     | N/A     | N/A     |\n| Android | yes² | yes¹    | yes¹    | yes¹    | N/A     | N/A     | N/A     |\n| iOS     | N/A  | not yet | not yet | N/A     | N/A     | N/A     | N/A     |\n\n1.  **Features revealed from Linux.** We gather data from several sources\n    depending on availability:\n    +   from glibc's\n        [getauxval](https://www.gnu.org/software/libc/manual/html_node/Auxiliary-Vector.html)\n    +   by parsing `/proc/self/auxv`\n    +   by parsing `/proc/cpuinfo`\n2.  **Features revealed from CPU.** features are retrieved by using the `cpuid`\n    instruction.\n3.  **Microarchitecture detection.** On x86 some features are not always\n    implemented efficiently in hardware (e.g. AVX on Sandybridge). Exposing the\n    microarchitecture allows the client to reject particular microarchitectures.\n4.  All flavors of Mips are supported, little and big endian as well as 32/64\n    bits.\n\n<a name=\"ndk\"></a>\n## Android NDK's drop in replacement\n\n[cpu_features](https://github.com/google/cpu_features) is now officially\nsupporting Android and offers a drop in replacement of for the NDK's [cpu-features.h](https://android.googlesource.com/platform/ndk/+/main/sources/android/cpufeatures/cpu-features.h)\n, see [ndk_compat](ndk_compat) folder for details.\n\n<a name=\"license\"></a>\n## License\n\nThe cpu_features library is licensed under the terms of the Apache license.\nSee [LICENSE](LICENSE) for more information.\n\n<a name=\"cmake\"></a>\n## Build with CMake\n\nPlease check the [CMake build instructions](cmake/README.md).\n\n<a name=\"quickstart\"></a>\n### Quickstart\n\n- Run `list_cpu_features`\n  ```sh\n  cmake -S. -Bbuild -DBUILD_TESTING=OFF -DCMAKE_BUILD_TYPE=Release\n  cmake --build build --config Release -j\n  ./build/list_cpu_features --json\n  ```\n\n  _Note_: Use `--target ALL_BUILD` on the second line for `Visual Studio` and `XCode`.\n\n- run tests\n  ```sh\n  cmake -S. -Bbuild -DBUILD_TESTING=ON -DCMAKE_BUILD_TYPE=Debug\n  cmake --build build --config Debug -j\n  cmake --build build --config Debug --target test\n  ```\n\n  _Note_: Use `--target RUN_TESTS` on the last line for `Visual Studio` and `--target RUN_TEST` for `XCode`.\n\n\n- install `cpu_features`\n  ```sh\n  cmake --build build --config Release --target install -v\n  ```\n\n  _Note_: Use `--target INSTALL` for `Visual Studio`.\n\n  _Note_: When using `Makefile` or `XCode` generator, you can use\n  [`DESTDIR`](https://www.gnu.org/software/make/manual/html_node/DESTDIR.html)\n  to install on a local repository.<br>\n  e.g.\n  ```sh\n  cmake --build build --config Release --target install -v -- DESTDIR=install\n  ```\n\n<a name=\"bindings\"></a>\n## Community bindings\n\nLinks provided here are not affiliated with Google but are kindly provided by the OSS Community.\n\n - .Net\n   - https://github.com/toor1245/cpu_features.NET\n - Python\n   - https://github.com/Narasimha1997/py_cpu\n - Java\n   - https://github.com/aecsocket/cpu-features-java\n\n\n_Send PR to showcase your wrapper here_"
}
