{
  "name": "heatshrink",
  "full_name": "heatshrink",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Data compression library for embedded/real-time systems",
  "license": "ISC",
  "homepage": "https://github.com/atomicobject/heatshrink",
  "versions": {
    "stable": "0.4.1",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/atomicobject/heatshrink/archive/v0.4.1.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "7529a1c8ac501191ad470b166773364e66d9926aad632690c72c63a1dea7e9a6"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/heatshrink/blobs/sha256:f897e27aea76f1c2723f8cca5418f8d1cad173b0457348200b609e452f8584da",
          "sha256": "f897e27aea76f1c2723f8cca5418f8d1cad173b0457348200b609e452f8584da"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/heatshrink/blobs/sha256:1c86c8958da5c539b53eb0a34f12502aea411b86fd0bcece742397fc515178db",
          "sha256": "1c86c8958da5c539b53eb0a34f12502aea411b86fd0bcece742397fc515178db"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/heatshrink/blobs/sha256:a6a1ec3b2cd5dc0ebc16fe7ed2beabdb2aba1c7fd9782d3d7fe5f667f4298b44",
          "sha256": "a6a1ec3b2cd5dc0ebc16fe7ed2beabdb2aba1c7fd9782d3d7fe5f667f4298b44"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/heatshrink/blobs/sha256:0bde7796c0ff7e0b7d9963db722a39a69baa5b9d89b975b8e49bbab5a6b246a7",
          "sha256": "0bde7796c0ff7e0b7d9963db722a39a69baa5b9d89b975b8e49bbab5a6b246a7"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/heatshrink/blobs/sha256:e211c2b12e4cfb4ccc65155ec91a03d4b5eaf04538814a7404787f308463fbcd",
          "sha256": "e211c2b12e4cfb4ccc65155ec91a03d4b5eaf04538814a7404787f308463fbcd"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/heatshrink/blobs/sha256:9131daef95de9b3c7fecb082ade54be4b67f8c4ca3f3bce6d18f19b1492078d9",
          "sha256": "9131daef95de9b3c7fecb082ade54be4b67f8c4ca3f3bce6d18f19b1492078d9"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/heatshrink/blobs/sha256:5956959544286fc9b6474a0f6df508530431c1632527fa4048091f33f319fab2",
          "sha256": "5956959544286fc9b6474a0f6df508530431c1632527fa4048091f33f319fab2"
        },
        "mojave": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/heatshrink/blobs/sha256:504b4b64164343217c6852509b59858494ba38ad9b63e7a9b3bb247290833582",
          "sha256": "504b4b64164343217c6852509b59858494ba38ad9b63e7a9b3bb247290833582"
        },
        "high_sierra": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/heatshrink/blobs/sha256:865d11380a3e586a962a5dec0069def43e777f20626bdc5396735d003d90d20b",
          "sha256": "865d11380a3e586a962a5dec0069def43e777f20626bdc5396735d003d90d20b"
        },
        "sierra": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/heatshrink/blobs/sha256:3965350f672040dfec9d2e07ac5f26aa16b324f59d2a762a4faac0930d2de684",
          "sha256": "3965350f672040dfec9d2e07ac5f26aa16b324f59d2a762a4faac0930d2de684"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/heatshrink/blobs/sha256:ff464d4696b56788cdbde22f9ec08015f65626ee0b8a4707fad973fd0f493495",
          "sha256": "ff464d4696b56788cdbde22f9ec08015f65626ee0b8a4707fad973fd0f493495"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/heatshrink.rb",
  "ruby_source_checksum": {
    "sha256": "95a8e948d099a5bc2cf7dbd5903d04e77aa1c46c3ac4ffa158421d19cb97026c"
  },
  "date_added": "2019-05-31T09:59:35+02:00",
  "readme": "# heatshrink\n\nA data compression/decompression library for embedded/real-time systems.\n\n\n## Key Features:\n\n- **Low memory usage (as low as 50 bytes)**\n    It is useful for some cases with less than 50 bytes, and useful\n    for many general cases with < 300 bytes.\n- **Incremental, bounded CPU use**\n    You can chew on input data in arbitrarily tiny bites.\n    This is a useful property in hard real-time environments.\n- **Can use either static or dynamic memory allocation**\n    The library doesn't impose any constraints on memory management.\n- **ISC license**\n    You can use it freely, even for commercial purposes.\n\n\n## Getting Started:\n\nThere is a standalone command-line program, `heatshrink`, but the\nencoder and decoder can also be used as libraries, independent of each\nother. To do so, copy `heatshrink_common.h`, `heatshrink_config.h`, and\neither `heatshrink_encoder.c` or `heatshrink_decoder.c` (and their\nrespective header) into your project. For projects that use both,\nstatic libraries are built that use static and dynamic allocation.\n\nDynamic allocation is used by default, but in an embedded context, you\nprobably want to statically allocate the encoder/decoder. Set\n`HEATSHRINK_DYNAMIC_ALLOC` to 0 in `heatshrink_config.h`.\n\n\n### Basic Usage\n\n1. Allocate a `heatshrink_encoder` or `heatshrink_decoder` state machine\nusing their `alloc` function, or statically allocate one and call their\n`reset` function to initialize them. (See below for configuration\noptions.)\n\n2. Use `sink` to sink an input buffer into the state machine. The\n`input_size` pointer argument will be set to indicate how many bytes of\nthe input buffer were actually consumed. (If 0 bytes were conusmed, the\nbuffer is full.)\n\n3. Use `poll` to move output from the state machine into an output\nbuffer. The `output_size` pointer argument will be set to indicate how\nmany bytes were output, and the function return value will indicate\nwhether further output is available. (The state machine may not output\nany data until it has received enough input.)\n\nRepeat steps 2 and 3 to stream data through the state machine. Since\nit's doing data compression, the input and output sizes can vary\nsignificantly. Looping will be necessary to buffer the input and output\nas the data is processed.\n\n4. When the end of the input stream is reached, call `finish` to notify\nthe state machine that no more input is available. The return value from\n`finish` will indicate whether any output remains. if so, call `poll` to\nget more.\n\nContinue calling `finish` and `poll`ing to flush remaining output until\n`finish` indicates that the output has been exhausted.\n\nSinking more data after `finish` has been called will not work without\ncalling `reset` on the state machine.\n\n\n## Configuration\n\nheatshrink has a couple configuration options, which impact its resource\nusage and how effectively it can compress data. These are set when\ndynamically allocating an encoder or decoder, or in `heatshrink_config.h`\nif they are statically allocated.\n\n- `window_sz2`, `-w` in the CLI: Set the window size to 2^W bytes.\n\nThe window size determines how far back in the input can be searched for\nrepeated patterns. A `window_sz2` of 8 will only use 256 bytes (2^8),\nwhile a `window_sz2` of 10 will use 1024 bytes (2^10). The latter uses\nmore memory, but may also compress more effectively by detecting more\nrepetition.\n\nThe `window_sz2` setting currently must be between 4 and 15.\n\n- `lookahead_sz2`, `-l` in the CLI: Set the lookahead size to 2^L bytes.\n\nThe lookahead size determines the max length for repeated patterns that\nare found. If the `lookahead_sz2` is 4, a 50-byte run of 'a' characters\nwill be represented as several repeated 16-byte patterns (2^4 is 16),\nwhereas a larger `lookahead_sz2` may be able to represent it all at\nonce. The number of bits used for the lookahead size is fixed, so an\noverly large lookahead size can reduce compression by adding unused\nsize bits to small patterns.\n\nThe `lookahead_sz2` setting currently must be between 3 and the\n`window_sz2` - 1.\n\n- `input_buffer_size` - How large an input buffer to use for the\ndecoder. This impacts how much work the decoder can do in a single\nstep, and a larger buffer will use more memory. An extremely small\nbuffer (say, 1 byte) will add overhead due to lots of suspend/resume\nfunction calls, but should not change how well data compresses.\n\n\n### Recommended Defaults\n\nFor embedded/low memory contexts, a `window_sz2` in the 8 to 10 range is\nprobably a good default, depending on how tight memory is. Smaller or\nlarger window sizes may make better trade-offs in specific\ncircumstances, but should be checked with representative data.\n\nThe `lookahead_sz2` should probably start near the `window_sz2`/2, e.g.\n-w 8 -l 4 or -w 10 -l 5. The command-line program can be used to measure\nhow well test data works with different settings.\n\n\n## More Information and Benchmarks:\n\nheatshrink is based on [LZSS], since it's particularly suitable for\ncompression in small amounts of memory. It can use an optional, small\n[index] to make compression significantly faster, but otherwise can run\nin under 100 bytes of memory. The index currently adds 2^(window size+1)\nbytes to memory usage for compression, and temporarily allocates 512\nbytes on the stack during index construction (if the index is enabled).\n\nFor more information, see the [blog post] for an overview, and the\n`heatshrink_encoder.h` / `heatshrink_decoder.h` header files for API\ndocumentation.\n\n[blog post]: http://spin.atomicobject.com/2013/03/14/heatshrink-embedded-data-compression/\n[index]: http://spin.atomicobject.com/2014/01/13/lightweight-indexing-for-embedded-systems/\n[LZSS]: http://en.wikipedia.org/wiki/Lempel-Ziv-Storer-Szymanski\n\n\n## Build Status\n\n  [![Build Status](https://travis-ci.org/atomicobject/heatshrink.png)](http://travis-ci.org/atomicobject/heatshrink)"
}
