{
  "name": "kubeseal",
  "full_name": "kubeseal",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Kubernetes controller and tool for one-way encrypted Secrets",
  "license": "Apache-2.0",
  "homepage": "https://github.com/bitnami-labs/sealed-secrets",
  "versions": {
    "stable": "0.23.0",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/bitnami-labs/sealed-secrets.git",
      "tag": "v0.23.0",
      "revision": "ad430d5c2bb7cf8ac53024b49930ddd0ef34390f",
      "checksum": null
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/kubeseal/blobs/sha256:5301d35d6c0bdd9c8e03b8a0419e6128f7ce655c11d479863cd60add0ee45e8a",
          "sha256": "5301d35d6c0bdd9c8e03b8a0419e6128f7ce655c11d479863cd60add0ee45e8a"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/kubeseal/blobs/sha256:5f4496845b8efc30c2e2225dbebffa8feaf1ff7fd8381ea78ed8f3c9e1b2d2e1",
          "sha256": "5f4496845b8efc30c2e2225dbebffa8feaf1ff7fd8381ea78ed8f3c9e1b2d2e1"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/kubeseal/blobs/sha256:516ef9e620de75c8f7dcf14d2c1f28d4e4d31e9bff0a126e06144409a35adb03",
          "sha256": "516ef9e620de75c8f7dcf14d2c1f28d4e4d31e9bff0a126e06144409a35adb03"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/kubeseal/blobs/sha256:52376c2000a463eae198d830defa1484fe6739ac5f8b581f312c853e1b5ac2f7",
          "sha256": "52376c2000a463eae198d830defa1484fe6739ac5f8b581f312c853e1b5ac2f7"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/kubeseal/blobs/sha256:5aafb415a2782f7b2a3a93ae6ee2d3c4349ea558843e18e87bf6822288328899",
          "sha256": "5aafb415a2782f7b2a3a93ae6ee2d3c4349ea558843e18e87bf6822288328899"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/kubeseal/blobs/sha256:cc049e782924e2ea118b27b3fa80bd6fb66a9d2fe50476bd0dea91b44837537c",
          "sha256": "cc049e782924e2ea118b27b3fa80bd6fb66a9d2fe50476bd0dea91b44837537c"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/kubeseal/blobs/sha256:eb7727d98bf478b0679cfe1ef8c5221bdbc6aabdb71eedab893c0471021fa024",
          "sha256": "eb7727d98bf478b0679cfe1ef8c5221bdbc6aabdb71eedab893c0471021fa024"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "go"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/kubeseal.rb",
  "ruby_source_checksum": {
    "sha256": "8b325973d06457a2b471a011fc8c2db6a003977843b8485cb6a57518d6b70417"
  },
  "date_added": "2018-12-21T16:25:00+11:00",
  "readme": "# \"Sealed Secrets\" for Kubernetes\n\n[![](https://img.shields.io/badge/install-docs-brightgreen.svg)](#Installation)\n[![](https://img.shields.io/github/release/bitnami-labs/sealed-secrets.svg)](https://github.com/bitnami-labs/sealed-secrets/releases/latest)\n[![](https://img.shields.io/homebrew/v/kubeseal)](https://formulae.brew.sh/formula/kubeseal)\n[![Build Status](https://github.com/bitnami-labs/sealed-secrets/actions/workflows/ci.yml/badge.svg)](https://github.com/bitnami-labs/sealed-secrets/actions/workflows/ci.yml)\n[![](https://img.shields.io/github/v/release/bitnami-labs/sealed-secrets?include_prereleases&label=helm&sort=semver)](https://github.com/bitnami-labs/sealed-secrets/releases)\n[![Download Status](https://img.shields.io/docker/pulls/bitnami/sealed-secrets-controller.svg)](https://hub.docker.com/r/bitnami/sealed-secrets-controller)\n[![Go Report Card](https://goreportcard.com/badge/github.com/bitnami-labs/sealed-secrets)](https://goreportcard.com/report/github.com/bitnami-labs/sealed-secrets)\n![Downloads](https://img.shields.io/github/downloads/bitnami-labs/sealed-secrets/total.svg)\n\n**Problem:** \"I can manage all my K8s config in git, except Secrets.\"\n\n**Solution:** Encrypt your Secret into a SealedSecret, which *is* safe\nto store - even inside a public repository. The SealedSecret can be\ndecrypted only by the controller running in the target cluster and\nnobody else (not even the original author) is able to obtain the\noriginal Secret from the SealedSecret.\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n\n- [Overview](#overview)\n  - [SealedSecrets as templates for secrets](#sealedsecrets-as-templates-for-secrets)\n  - [Public key / Certificate](#public-key--certificate)\n  - [Scopes](#scopes)\n- [Installation](#installation)\n  - [Controller](#controller)\n    - [Kustomize](#kustomize)\n    - [Helm Chart](#helm-chart)\n  - [Kubeseal](#kubeseal)\n    - [Homebrew](#homebrew)\n    - [MacPorts](#macports)\n    - [Linux](#linux)\n    - [Installation from source](#installation-from-source)\n- [Upgrade](#upgrade)\n- [Usage](#usage)\n  - [Managing existing secrets](#managing-existing-secrets)\n  - [Patching existing secrets](#patching-existing-secrets)\n  - [Update existing secrets](#update-existing-secrets)\n  - [Raw mode (experimental)](#raw-mode-experimental)\n  - [Validate a Sealed Secret](#validate-a-sealed-secret)\n- [Secret Rotation](#secret-rotation)\n  - [Sealing key renewal](#sealing-key-renewal)\n  - [User secret rotation](#user-secret-rotation)\n  - [Early key renewal](#early-key-renewal)\n  - [Common misconceptions about key renewal](#common-misconceptions-about-key-renewal)\n  - [Manual key management (advanced)](#manual-key-management-advanced)\n  - [Re-encryption (advanced)](#re-encryption-advanced)\n- [Details (advanced)](#details-advanced)\n  - [Crypto](#crypto)\n- [Developing](#developing)\n- [FAQ](#faq)\n  - [Will you still be able to decrypt if you no longer have access to your cluster?](#will-you-still-be-able-to-decrypt-if-you-no-longer-have-access-to-your-cluster)\n  - [How can I do a backup of my SealedSecrets?](#how-can-i-do-a-backup-of-my-sealedsecrets)\n  - [Can I decrypt my secrets offline with a backup key?](#can-i-decrypt-my-secrets-offline-with-a-backup-key)\n  - [What flags are available for kubeseal?](#what-flags-are-available-for-kubeseal)\n  - [How do I update parts of JSON/YAML/TOML/.. file encrypted with sealed secrets?](#how-do-i-update-parts-of-jsonyamltoml-file-encrypted-with-sealed-secrets)\n  - [Can I bring my own (pre-generated) certificates?](#can-i-bring-my-own-pre-generated-certificates)\n  - [How to use kubeseal if the controller is not running within the `kube-system` namespace?](#how-to-use-kubeseal-if-the-controller-is-not-running-within-the-kube-system-namespace)\n  - [How to verify the images?](#how-to-verify-the-images)\n  - [How to use one controller for a subset of namespaces](#How-to-use-one-controller-for-a-subset-of-namespaces)\n\n- [Community](#community)\n  - [Related projects](#related-projects)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n## Overview\n\nSealed Secrets is composed of two parts:\n\n- A cluster-side controller / operator\n- A client-side utility: `kubeseal`\n\nThe `kubeseal` utility uses asymmetric crypto to encrypt secrets that only the controller can decrypt.\n\nThese encrypted secrets are encoded in a `SealedSecret` resource, which you can see as a recipe for creating\na secret. Here is how it looks:\n\n```yaml\napiVersion: bitnami.com/v1alpha1\nkind: SealedSecret\nmetadata:\n  name: mysecret\n  namespace: mynamespace\nspec:\n  encryptedData:\n    foo: AgBy3i4OJSWK+PiTySYZZA9rO43cGDEq.....\n```\n\nOnce unsealed this will produce a secret equivalent to this:\n\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: mysecret\n  namespace: mynamespace\ndata:\n  foo: YmFy  # <- base64 encoded \"bar\"\n```\n\nThis normal [kubernetes secret](https://kubernetes.io/docs/concepts/configuration/secret/) will appear in the cluster\nafter a few seconds you can use it as you would use any secret that you would have created directly (e.g. reference it from a `Pod`).\n\nJump to the [Installation](#installation) section to get up and running.\n\nThe [Usage](#usage) section explores in more detail how you craft `SealedSecret` resources.\n\n### SealedSecrets as templates for secrets\n\nThe previous example only focused on the encrypted secret items themselves, but the relationship between a `SealedSecret` custom resource and the `Secret` it unseals into is similar in many ways (but not in all of them) to the familiar `Deployment` vs `Pod`.\n\nIn particular, the annotations and labels of a `SealedSecret` resource are not the same as the annotations of the `Secret` that gets generated out of it.\n\nTo capture this distinction, the `SealedSecret` object has a `template` section which encodes all the fields you want the controller to put in the unsealed `Secret`.\n\nThis includes metadata such as labels or annotations, but also things like the `type` of the secret.\n\n```yaml\napiVersion: bitnami.com/v1alpha1\nkind: SealedSecret\nmetadata:\n  name: mysecret\n  namespace: mynamespace\n  annotations:\n    \"kubectl.kubernetes.io/last-applied-configuration\": ....\nspec:\n  encryptedData:\n    .dockerconfigjson: AgBy3i4OJSWK+PiTySYZZA9rO43cGDEq.....\n  template:\n    type: kubernetes.io/dockerconfigjson\n    # this is an example of labels and annotations that will be added to the output secret\n    metadata:\n      labels:\n        \"jenkins.io/credentials-type\": usernamePassword\n      annotations:\n        \"jenkins.io/credentials-description\": credentials from Kubernetes\n```\n\nThe controller would unseal that into something like:\n\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: mysecret\n  namespace: mynamespace\n  labels:\n    \"jenkins.io/credentials-type\": usernamePassword\n  annotations:\n    \"jenkins.io/credentials-description\": credentials from Kubernetes\n  ownerReferences:\n  - apiVersion: bitnami.com/v1alpha1\n    controller: true\n    kind: SealedSecret\n    name: mysecret\n    uid: 5caff6a0-c9ac-11e9-881e-42010aac003e\ntype: kubernetes.io/dockerconfigjson\ndata:\n  .dockerconfigjson: ewogICJjcmVk...\n```\n\nAs you can see, the generated `Secret` resource is a \"dependent object\" of the `SealedSecret` and as such\nit will be updated and deleted whenever the `SealedSecret` object gets updated or deleted.\n\n### Public key / Certificate\n\nThe key certificate (public key portion) is used for sealing secrets,\nand needs to be available wherever `kubeseal` is going to be\nused. The certificate is not secret information, although you need to\nensure you are using the correct one.\n\n`kubeseal` will fetch the certificate from the controller at runtime\n(requires secure access to the Kubernetes API server), which is\nconvenient for interactive use, but it's known to be brittle when users\nhave clusters with special configurations such as [private GKE clusters](docs/GKE.md#private-gke-clusters) that have\nfirewalls between control plane and nodes.\n\nAn alternative workflow\nis to store the certificate somewhere (e.g. local disk) with\n`kubeseal --fetch-cert >mycert.pem`,\nand use it offline with `kubeseal --cert mycert.pem`.\nThe certificate is also printed to the controller log on startup.\n\nSince v0.9.x certificates get automatically renewed every 30 days. It's good practice that you and your team\nupdate your offline certificate periodically. To help you with that, since v0.9.2 `kubeseal` accepts URLs too. You can set up your internal automation to publish certificates somewhere you trust.\n\n```bash\nkubeseal --cert https://your.intranet.company.com/sealed-secrets/your-cluster.cert\n```\n\nIt also recognizes the `SEALED_SECRETS_CERT` env var. (pro-tip: see also [direnv](https://github.com/direnv/direnv)).\n\n> **NOTE**: we are working on providing key management mechanisms that offload the encryption to HSM based modules or managed cloud crypto solutions such as KMS.\n\n### Scopes\n\nSealedSecrets are from the POV of an end user a \"write only\" device.\n\nThe idea is that the SealedSecret can be decrypted only by the controller running in the target cluster and\nnobody else (not even the original author) is able to obtain the original Secret from the SealedSecret.\n\nThe user may or may not have direct access to the target cluster.\nMore specifically, the user might or might not have access to the Secret unsealed by the controller.\n\nThere are many ways to configure RBAC on k8s, but it's quite common to forbid low-privilege users\nfrom reading Secrets. It's also common to give users one or more namespaces where they have higher privileges,\nwhich would allow them to create and read secrets (and/or create deployments that can reference those secrets).\n\nEncrypted `SealedSecret` resources are designed to be safe to be looked at without gaining any knowledge about the secrets it conceals. This implies that we cannot allow users to read a SealedSecret meant for a namespace they wouldn't have access to\nand just push a copy of it in a namespace where they can read secrets from.\n\nSealed-secrets thus behaves *as if* each namespace had its own independent encryption key and thus once you\nseal a secret for a namespace, it cannot be moved in another namespace and decrypted there.\n\nWe don't technically use an independent private key for each namespace, but instead we *include* the namespace name\nduring the encryption process, effectively achieving the same result.\n\nFurthermore, namespaces are not the only level at which RBAC configurations can decide who can see which secret. In fact, it's possible that users can access a secret called `foo` in a given namespace but not any other secret in the same namespace. We cannot thus by default let users freely rename `SealedSecret` resources otherwise a malicious user would be able to decrypt any SealedSecret for that namespace by just renaming it to overwrite the one secret user does have access to. We use the same mechanism used to include the namespace in the encryption key to also include the secret name.\n\nThat said, there are many scenarios where you might not care about this level of protection. For example, the only people who have access to your clusters are either admins or they cannot read any `Secret` resource at all. You might have a use case for moving a sealed secret to other namespaces (e.g. you might not know the namespace name upfront), or you might not know the name of the secret (e.g. it could contain a unique suffix based on the hash of the contents etc).\n\nThese are the possible scopes:\n\n- `strict` (default): the secret must be sealed with exactly the same *name* and *namespace*. These attributes become *part of the encrypted data* and thus changing name and/or namespace would lead to \"decryption error\".\n- `namespace-wide`: you can freely *rename* the sealed secret within a given namespace.\n- `cluster-wide`: the secret can be unsealed in *any* namespace and can be given *any* name.\n\nIn contrast to the restrictions of *name* and *namespace*, secret *items* (i.e. JSON object keys like `spec.encryptedData.my-key`) can be renamed at will without losing the ability to decrypt the sealed secret.\n\nThe scope is selected with the `--scope` flag:\n\n```bash\nkubeseal --scope cluster-wide <secret.yaml >sealed-secret.json\n```\n\nIt's also possible to request a scope via annotations in the input secret you pass to `kubeseal`:\n\n- `sealedsecrets.bitnami.com/namespace-wide: \"true\"` -> for `namespace-wide`\n- `sealedsecrets.bitnami.com/cluster-wide: \"true\"` -> for `cluster-wide`\n\nThe lack of any of such annotations means `strict` mode. If both are set, `cluster-wide` takes precedence.\n\n> NOTE: Next release will consolidate this into a single `sealedsecrets.bitnami.com/scope` annotation.\n\n## Installation\n\nSee https://github.com/bitnami-labs/sealed-secrets/releases for the latest release and detailed installation instructions.\n\nCloud platform specific notes and instructions:\n\n- [GKE](docs/GKE.md)\n\n### Controller\n\nOnce you deploy the manifest it will create the `SealedSecret` resource\nand install the controller into `kube-system` namespace, create a service\naccount and necessary RBAC roles.\n\nAfter a few moments, the controller will start, generate a key pair,\nand be ready for operation. If it does not, check the controller logs.\n\n#### Kustomize\n\nThe official controller manifest installation mechanism is just a YAML file.\n\nIn some cases you might need to apply your own customizations, like set a custom namespace or set some env variables.\n\n`kubectl` has native support for that, see [kustomize](https://kustomize.io/).\n\n#### Helm Chart\n\nThe Sealed Secrets helm chart is now officially supported and hosted in this GitHub repo.\n\n```bash\nhelm repo add sealed-secrets https://bitnami-labs.github.io/sealed-secrets\n```\n\n> NOTE: The versioning scheme of the helm chart differs from the versioning scheme of the sealed secrets project itself.\n\nOriginally the helm chart was maintained by the community and the first version adopted a major version of 1 while the\nsealed secrets project itself is still at major 0.\nThis is ok because the version of the helm chart itself is not meant to be necessarily the version of the app itself.\nHowever this is confusing, so our current versioning rule is:\n\n1. The `SealedSecret` controller version scheme: 0.X.Y\n2. The helm chart version scheme: 1.X.Y-rZ\n\nThere can be thus multiple revisions of the helm chart, with fixes that apply only to the helm chart without\naffecting the static YAML manifests or the controller image itself.\n\n> NOTE: The helm chart readme still contains a deprecation notice, but it no longer reflects reality and will be removed upon the next release.\n\n> NOTE: The helm chart by default installs the controller with the name `sealed-secrets`, while the `kubeseal` command line interface (CLI) tries to access the controller with the name `sealed-secrets-controller`. You can explicitly pass `--controller-name` to the CLI:\n\n```bash\nkubeseal --controller-name sealed-secrets <args>\n```\n\nAlternatively, you can set `fullnameOverride` when installing the chart to override the name. Note also that `kubeseal` assumes that the controller is installed within the `kube-system` namespace by default. So if you want to use the `kubeseal` CLI without having to pass the expected controller name and namespace you should install the Helm Chart like this:\n\n```bash\nhelm install sealed-secrets -n kube-system --set-string fullnameOverride=sealed-secrets-controller sealed-secrets/sealed-secrets\n```\n\n##### Helm Chart on a restricted environment\n\nIn some companies you might be given access only to a single namespace, not a full cluster.\n\nOne of the most restrictive environments you can encounter is:\n- A `namespace` was allocated to you with some `service account`.\n- You do not have access to the rest of the cluster, not even cluster CRDs.\n- You may not even be able to create further service accounts or roles in your namespace.\n- You are required to include resource limits in all your deployments.\n\nEven with these restrictions you can still install the sealed secrets Helm Chart, there is only one pre-requisite:\n- *The cluster must already have the sealed secrets CRDs installed*.\n\nOnce your admins installed the CRDs, if they were not there already, you can install the chart by preparing a YAML config file such as this:\n\n```shell\nserviceAccount:\n  create: false\n  name: {allocated-service-account}\nrbac:\n  create: false\n  clusterRole: false\nresources:\n  limits:\n    cpu: 150m\n    memory: 256Mi\n```\n\nNote that:\n- No service accounts are created, instead the one allocated to you will be used.\n  - `{allocated-service-account}` is the name of the `service account` you were allocated on the cluster.\n- No RBAC roles are created neither in the namespace nor the cluster.\n- Resource limits must be specified.\n  - The limits are samples that should work, but you might want to review them in your particular setup.\n\nOnce that file is ready, if you named it `config.yaml` you now can install the sealed secrets Helm Chart like this:\n\n```shell\nhelm install sealed-secrets -n {allocated-namespace} sealed-secrets/sealed-secrets --skip-crds -f config.yaml\n```\n\nWhere `{allocated-namespace}` is the name of the `namespace` you were allocated in the cluster.\n\n### Kubeseal\n\n#### Homebrew\n\nThe `kubeseal` client is also available on [homebrew](https://formulae.brew.sh/formula/kubeseal):\n\n```bash\nbrew install kubeseal\n```\n\n#### MacPorts\n\nThe `kubeseal` client is also available on [MacPorts](https://ports.macports.org/port/kubeseal/summary):\n\n```bash\nport install kubeseal\n```\n\n#### Nixpkgs\n\nThe `kubeseal` client is also available on [Nixpkgs](https://search.nixos.org/packages?channel=unstable&show=kubeseal&from=0&size=50&sort=relevance&type=packages&query=kubeseal): (**DISCLAIMER**: Not maintained by bitnami-labs)\n\n```bash\nnix-env -iA nixpkgs.kubeseal\n```\n\n#### Linux\n\nThe `kubeseal` client can be installed on Linux, using the below commands:\n\n```bash\nKUBESEAL_VERSION='' # Set this to, for example, KUBESEAL_VERSION='0.23.0'\nwget \"https://github.com/bitnami-labs/sealed-secrets/releases/download/v${KUBESEAL_VERSION:?}/kubeseal-${KUBESEAL_VERSION:?}-linux-amd64.tar.gz\"\ntar -xvzf kubeseal-${KUBESEAL_VERSION:?}-linux-amd64.tar.gz kubeseal\nsudo install -m 755 kubeseal /usr/local/bin/kubeseal\n```\n\nwhere `release-tag` is the [version tag](https://github.com/bitnami-labs/sealed-secrets/tags) of the kubeseal release you want to use. For example: `v0.18.0`.\n\n#### Installation from source\n\nIf you just want the latest client tool, it can be installed into\n`$GOPATH/bin` with:\n\n```bash\ngo install github.com/bitnami-labs/sealed-secrets/cmd/kubeseal@main\n```\n\nYou can specify a release tag or a commit SHA instead of `main`.\n\nThe `go install` command will place the `kubeseal` binary at `$GOPATH/bin`:\n\n```bash\n$(go env GOPATH)/bin/kubeseal\n```\n\n## Upgrade\n\nDon't forget to check the [release notes](RELEASE-NOTES.md) for guidance about\npossible breaking changes when you upgrade the client tool\nand/or the controller.\n\n### Supported Versions\nCurrently, only the latest version of Sealed Secrets is supported for production environments.\n\n### Compatibility with Kubernetes versions\nThe Sealed Secrets controller ensures compatibility with different versions of Kubernetes by relying on a stable Kubernetes API. Typically, Kubernetes versions above 1.16 are considered compatible. However, we officially support the [currently recommended Kubernetes versions](https://kubernetes.io/releases/). Additionally, versions above 1.24 undergo thorough verification through our CI process with every release.\n\n## Usage\n\n```bash\n# Create a json/yaml-encoded Secret somehow:\n# (note use of `--dry-run` - this is just a local file!)\necho -n bar | kubectl create secret generic mysecret --dry-run=client --from-file=foo=/dev/stdin -o json >mysecret.json\n\n# This is the important bit:\n# (note default format is json!)\nkubeseal <mysecret.json >mysealedsecret.json\n\n# At this point mysealedsecret.json is safe to upload to Github,\n# post on Twitter, etc.\n\n# Eventually:\nkubectl create -f mysealedsecret.json\n\n# Profit!\nkubectl get secret mysecret\n```\n\nNote the `SealedSecret` and `Secret` must have **the same namespace and\nname**. This is a feature to prevent other users on the same cluster\nfrom re-using your sealed secrets. See the [Scopes](#scopes) section for more info.\n\n`kubeseal` reads the namespace from the input secret, accepts an explicit `--namespace` argument, and uses\nthe `kubectl` default namespace (in that order). Any labels,\nannotations, etc on the original `Secret` are preserved, but not\nautomatically reflected in the `SealedSecret`.\n\nBy design, this scheme *does not authenticate the user*. In other\nwords, *anyone* can create a `SealedSecret` containing any `Secret`\nthey like (provided the namespace/name matches). It is up to your\nexisting config management workflow, cluster RBAC rules, etc to ensure\nthat only the intended `SealedSecret` is uploaded to the cluster. The\nonly change from existing Kubernetes is that the *contents* of the\n`Secret` are now hidden while outside the cluster.\n\n### Managing existing secrets\n\nIf you want the Sealed Secrets controller to manage an existing `Secret`, you can annotate your `Secret` with the `sealedsecrets.bitnami.com/managed: \"true\"` annotation. The existing `Secret` will be overwritten when unsealing a `SealedSecret` with the same name and namespace, and the `SealedSecret` will take ownership of the `Secret` (so that when the `SealedSecret` is deleted the `Secret` will also be deleted).\n\n### Patching existing secrets\n\n> New in v0.23.0\n\nThere are some use cases in which you don't want to replace the whole `Secret` but just add or modify some keys from the existing `Secret`. For this, you can annotate your `Secret` with `sealedsecrets.bitnami.com/patch: \"true\"`. Using this annotation will make sure that secret keys, labels and annotations in the `Secret` that are not present in the `SealedSecret` won't be deleted, and those present in the `SealedSecret` will be added to the `Secret` (secret keys, labels and annotations that exist both in the `Secret` and the `SealedSecret` will be modified by the `SealedSecret`).\n\nThis annotation does not make the `SealedSecret` take ownership of the `Secret`. You can add both the `patch` and `managed` annotations to obtain the patching behavior while also taking ownership of the `Secret`.\n\n### Seal secret which can skip set owner references\n\nIf you want `SealedSecret` and the `Secret` to be independent, which mean when you delete the `SealedSecret` the `Secret` won't disappear with it, then you have to annotate that Secret with the annotation `sealedsecrets.bitnami.com/skip-set-owner-references: \"true\"` ahead of applying the Usage steps. You still may also add `sealedsecrets.bitnami.com/managed: \"true\"` to your `Secret` so that your secret will be updated when `SealedSecret` is updated.\n\n### Update existing secrets\n\nIf you want to add or update existing sealed secrets without having the cleartext for the other items,\nyou can just copy&paste the new encrypted data items and merge it into an existing sealed secret.\n\nYou must take care of sealing the updated items with a compatible name and namespace (see note about scopes above).\n\nYou can use the `--merge-into` command to update an existing sealed secrets if you don't want to copy&paste:\n\n```bash\necho -n bar | kubectl create secret generic mysecret --dry-run=client --from-file=foo=/dev/stdin -o json \\\n  | kubeseal > mysealedsecret.json\necho -n baz | kubectl create secret generic mysecret --dry-run=client --from-file=bar=/dev/stdin -o json \\\n  | kubeseal --merge-into mysealedsecret.json\n```\n\n### Raw mode (experimental)\n\nCreating temporary Secret with the `kubectl` command, only to throw it away once piped to `kubeseal` can\nbe a quite unfriendly user experience. We're working on an overhaul of the CLI experience. In the meantime,\nwe offer an alternative mode where kubeseal only cares about encrypting a value to stdout, and it's your responsibility to put it inside a `SealedSecret` resource (not unlike any of the other k8s resources).\n\nIt can also be useful as a building block for editor/IDE integrations.\n\nThe downside is that you have to be careful to be consistent with the sealing scope, the namespace and the name.\n\nSee [Scopes](#scopes)\n\n`strict` scope (default):\n\n```console\n$ echo -n foo | kubeseal --raw --namespace bar --name mysecret\nAgBChHUWLMx...\n```\n\n`namespace-wide` scope:\n\n```console\n$ echo -n foo | kubeseal --raw --namespace bar --scope namespace-wide\nAgAbbFNkM54...\n```\nInclude the `sealedsecrets.bitnami.com/namespace-wide` annotation in the `SealedSecret`\n```yaml\nmetadata:\n  annotations:\n    sealedsecrets.bitnami.com/namespace-wide: \"true\"\n```\n\n`cluster-wide` scope:\n\n```console\n$ echo -n foo | kubeseal --raw --scope cluster-wide\nAgAjLKpIYV+...\n```\nInclude the `sealedsecrets.bitnami.com/cluster-wide` annotation in the `SealedSecret`\n```yaml\nmetadata:\n  annotations:\n    sealedsecrets.bitnami.com/cluster-wide: \"true\"\n```\n\n### Validate a Sealed Secret\n\nIf you want to validate an existing sealed secret, `kubeseal` has the flag `--validate` to help you.\n\nGiving a file named `sealed-secrets.yaml` containing the following sealed secret:\n\n```yaml\napiVersion: bitnami.com/v1alpha1\nkind: SealedSecret\nmetadata:\n  name: mysecret\n  namespace: mynamespace\nspec:\n  encryptedData:\n    foo: AgBy3i4OJSWK+PiTySYZZA9rO43cGDEq.....\n```\n\nYou can validate if the sealed secret was properly created or not:\n\n```console\n$ cat sealed-secrets.yaml | kubeseal --validate\n```\n\nIn case of an invalid sealed secret, `kubeseal` will show:\n\n```console\n$ cat sealed-secrets.yaml | kubeseal --validate\nerror: unable to decrypt sealed secret\n```\n\n## Secret Rotation\n\nYou should always rotate your secrets. But since your secrets are encrypted with another secret,\nyou need to understand how these two layers relate to take the right decisions.\n\nTL;DR:\n\n> If a *sealing* private key is compromised, you need to follow the instructions below in \"Early key renewal\"\n> section before rotating any of your actual secret values.\n>\n> SealedSecret key renewal and re-encryption features are **not a substitute** for periodical rotation of your actual secret values.\n\n### Sealing key renewal\n\nSealing keys are automatically renewed every 30 days. Which means a new sealing key is created and appended to the set of active sealing keys the controller can use to unseal `SealedSecret` resources.\n\nThe most recently created sealing key is the one used to seal new secrets when you use `kubeseal` and it's the one whose certificate is downloaded when you use `kubeseal --fetch-cert`.\n\nThe renewal time of 30 days is a reasonable default, but it can be tweaked as needed\nwith the `--key-renew-period=<value>` flag for the command in the pod template of the `SealedSecret` controller. The `value` field can be given as golang\nduration flag (eg: `720h30m`). Assuming that you've installed Sealed Secrets into the `kube-system` namespace, use the following command to edit the Deployment controller, and add the `--key-renew-period` parameter. Once you close your text editor, and the Deployment controller has been modified, a new Pod will be automatically created to replace the old Pod.\n\n```\nkubectl edit deployment/sealed-secrets-controller --namespace=kube-system\n```\n\nA value of `0` will deactivate automatic key renewal. Of course, you may have a valid use case for deactivating automatic sealing key renewal but experience has shown that new users often tend to jump to conclusions that they want control over key renewal, before fully understanding how sealed secrets work. Read more about this in the [common misconceptions](#common-misconceptions-about-key-renewal) section below.\n\n> Unfortunately, you cannot use e.g. \"d\" as a unit for days because that's not supported by the Go stdlib. Instead of hitting your face with a palm, take this as an opportunity to meditate on the [falsehoods programmers believe about time](https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time).\n\nA common misunderstanding is that key renewal is often thought of as a form of key rotation, where the old key is not only obsolete but actually bad and that you thus want to get rid of it.\nIt doesn't help that this feature has been historically called \"key rotation\", which can add to the confusion.\n\nSealed secrets are not automatically rotated and old keys are not deleted\nwhen new keys are generated. Old `SealedSecret` resources can be still decrypted (that's because old sealing keys are not deleted).\n\n### User secret rotation\n\nThe *sealing key* renewal and SealedSecret rotation are **not a substitute** for rotating your actual secrets.\n\nA core value proposition of this tool is:\n\n> Encrypt your Secret into a SealedSecret, which *is* safe to store - even inside a public repository.\n\nIf you store anything in a version control storage, and in a public one in particular, you must assume\nyou cannot ever delete that information.\n\n*If* a sealing key somehow leaks out of the cluster you must consider all your `SealedSecret` resources\nencrypted with that key as compromised. No amount of sealing key rotation in the cluster or even re-encryption of existing SealedSecrets files can change that.\n\nThe best practice is to periodically rotate all your actual secrets (e.g. change the password) **and** craft new\n`SealedSecret` resources with those new secrets.\n\nBut if the `SealedSecret` controller was not renewing the *sealing key* that rotation would be moot,\nsince the attacker could just decrypt the new secrets as well. Thus, you need to do both: periodically renew the sealing key and rotate your actual secrets!\n\n### Early key renewal\n\nIf you know or suspect a *sealing key* has been compromised you should renew the key ASAP before you\nstart sealing your new rotated secrets, otherwise you'll be giving attackers access to your new secrets as well.\n\nA key can be generated early by passing the current timestamp to the controller into a flag called `--key-cutoff-time` or an env var called `SEALED_SECRETS_KEY_CUTOFF_TIME`. The expected format is RFC1123, you can generate it with the `date -R` unix command.\n\n### Common misconceptions about key renewal\n\nSealed secrets sealing keys are not access control keys (e.g. a password). They are more like the GPG key you might use to read encrypted mail sent to you. Let's continue with the email analogy for a bit:\n\nImagine you have reasons to believe your private GPG key might have been compromised. You'd have more to lose than to gain if the first thing you do is just delete your private key. All the previous emails sent with that key are no longer accessible to you (unless you have a decrypted copy of those emails), nor are new emails sent by your friends whom you have not yet managed to tell to use the new key.\n\nSure, the content of those encrypted emails is not secure, as an attacker might now be able to decrypt them, but what's done is done. Your sudden loss of the ability to read those emails surely doesn't undo the damage. If anything, it's worse because you no longer know for sure what secret the attacker got to know. What you really want to do is to make sure that your friend stops using your old key and that from now on all further communication is encrypted with a new key pair (i.e. your friend must know about that new key).\n\nThe same logic applies to SealedSecrets. The ultimate goal is to secure your actual \"user\" secrets. The \"sealing\" secrets are just a mechanism, an \"envelope\". If a secret is leaked there is no going back, what's done is done.\n\nYou first need to ensure that new secrets don't get encrypted with that old compromised key (in the email analogy above that's: create a new key pair and give all your friends your new public key).\n\nThe second logical step is to neutralize the damage, which depends on the nature of the secret. A simple example is a database password: if you accidentally leak your database password, the thing you're supposed to do is simply to change your database password (on the database; and revoke the old one!) *and* update the `SealedSecret` resource with the new password (i.e. running `kubeseal` again).\n\nBoth steps are described in the previous sections, albeit in a less verbose way. There is no shame in reading them again, now that you have a more in-depth grasp of the underlying rationale.\n\n### Manual key management (advanced)\n\nThe `SealedSecret` controller and the associated workflow are designed to keep old sealing keys around and periodically add new ones. You should not delete old keys unless you know what you're doing.\n\nThat said, if you want you can manually manage (create, move, delete) *sealing keys*. They are just normal k8s secrets living in the same namespace where the `SealedSecret` controller lives (usually `kube-system`, but it's configurable).\n\nThere are advanced use cases that you can address by creative management of the sealing keys.\nFor example, you can share the same sealing key among a few clusters so that you can apply exactly the same sealed secret in multiple clusters.\nSince sealing keys are just normal k8s secrets you can even use sealed secrets themselves and use a GitOps workflow to manage your sealing keys (useful when you want to share the same key among different clusters)!\n\nLabeling a *sealing key* secret with anything other than `active` effectively deletes\nthe key from the `SealedSecret` controller, but it is still available in k8s for\nmanual encryption/decryption if need be.\n\n**NOTE** `SealedSecret` controller currently does not automatically pick up manually created, deleted or relabeled sealing keys. An admin must restart the controller before the effect will apply.\n\n### Re-encryption (advanced)\n\nBefore you can get rid of some old sealing keys you need to re-encrypt your SealedSecrets with the latest private key.\n\n```bash\nkubeseal --re-encrypt <my_sealed_secret.json >tmp.json \\\n  && mv tmp.json my_sealed_secret.json\n```\n\nThe invocation above will produce a new sealed secret file freshly encrypted with\nthe latest key, without making the secrets leave the cluster to the client. You can then save that file\nin your version control system (`kubeseal --re-encrypt` doesn't update the in-cluster object).\n\nCurrently, old keys are not garbage collected automatically.\n\nIt's a good idea to periodically re-encrypt your SealedSecrets. But as mentioned above, don't lull yourself in a false sense of security: you must assume the old version of the `SealedSecret` resource (the one encrypted with a key you think of as dead) is still potentially around and accessible to attackers. I.e. re-encryption is not a substitute for periodically rotating your actual secrets.\n\n## Details (advanced)\n\nThis controller adds a new `SealedSecret` custom resource. The\ninteresting part of a `SealedSecret` is a base64-encoded\nasymmetrically encrypted `Secret`.\n\nThe controller maintains a set of private/public key pairs as kubernetes\nsecrets. Keys are labeled with `sealedsecrets.bitnami.com/sealed-secrets-key`\nand identified in the label as either `active` or `compromised`. On startup,\nThe sealed secrets controller will...\n\n1. Search for these keys and add them to its local store if they are\nlabeled as active.\n2. Create a new key\n3. Start the key rotation cycle\n\n### Crypto\n\nMore details about crypto can be found [here](docs/developer/crypto.md).\n\n## Developing\n\nDeveloping guidelines can be found [in the Developer Guide](docs/developer/README.md).\n\n## FAQ\n\n### Will you still be able to decrypt if you no longer have access to your cluster?\n\nNo, the private keys are only stored in the Secret managed by the controller (unless you have some other backup of your k8s objects). There are no backdoors - without that private key used to encrypt a given SealedSecrets, you can't decrypt it. If you can't get to the Secrets with the encryption keys, and you also can't get to the decrypted versions of your Secrets live in the cluster, then you will need to regenerate new passwords for everything, seal them again with a new sealing key, etc.\n\n### How can I do a backup of my SealedSecrets?\n\nIf you do want to make a backup of the encryption private keys, it's easy to do from an account with suitable access:\n\n```bash\nkubectl get secret -n kube-system -l sealedsecrets.bitnami.com/sealed-secrets-key -o yaml >main.key\n\necho \"---\" >> main.key\nkubectl get secret -n kube-system sealed-secrets-key -o yaml >>main.key\n```\n\n> NOTE: You need the second statement only if you ever installed sealed-secrets older than version 0.9.x on your cluster.\n\n> NOTE: This file will contain the controller's public + private keys and should be kept omg-safe!\n\nTo restore from a backup after some disaster, just put that secrets back before starting the controller - or if the controller was already started, replace the newly-created secrets and restart the controller:\n\n```bash\nkubectl apply -f main.key\nkubectl delete pod -n kube-system -l name=sealed-secrets-controller\n```\n\n### Can I decrypt my secrets offline with a backup key?\n\nWhile treating sealed-secrets as long term storage system for secrets is not the recommended use case, some people\ndo have a legitimate requirement for being able to recover secrets when the k8s cluster is down and restoring a backup into a new `SealedSecret` controller deployment is not practical.\n\nIf you have backed up one or more of your private keys (see previous question), you can use the `kubeseal --recovery-unseal --recovery-private-key file1.key,file2.key,...` command to decrypt a sealed secrets file.\n\n### What flags are available for kubeseal?\n\nYou can check the flags available using `kubeseal --help`.\n\n### How do I update parts of JSON/YAML/TOML/.. file encrypted with sealed secrets?\n\nA kubernetes `Secret` resource contains multiple items, basically a flat map of key/value pairs.\nSealedSecrets operate at that level, and does not care what you put in the values. In other words\nit cannot make sense of any structured configuration file you might have put in a secret and thus\ncannot help you update individual fields in it.\n\nSince this is a common problem, especially when dealing with legacy applications, we do offer an [example](docs/examples/config-template) of a possible workaround.\n\n### Can I bring my own (pre-generated) certificates?\n\nYes, you can provide the controller with your own certificates, and it will consume them.\nPlease check [here](docs/bring-your-own-certificates.md) for a workaround.\n\n### How to use kubeseal if the controller is not running within the `kube-system` namespace?\n\nIf you installed the controller in a different namespace than the default `kube-system`, you need to provide this namespace\nto the `kubeseal` commandline tool. There are two options:\n\n1. You can specify the namespace via the command line option `--controller-namespace <namespace>`:\n\n  ```bash\nkubeseal --controller-namespace sealed-secrets <mysecret.json >mysealedsecret.json\n```\n\n2. Via the environment variable `SEALED_SECRETS_CONTROLLER_NAMESPACE`:\n\n  ```bash\nexport SEALED_SECRETS_CONTROLLER_NAMESPACE=sealed-secrets\nkubeseal <mysecret.json >mysealedsecret.json\n```\n\n### How to verify the images?\n\nOur images are being signed using [cosign](https://github.com/sigstore/cosign). The signatures have been saved in our [GitHub Container Registry](https://ghcr.io/bitnami-labs/sealed-secrets-controller/signs).\n\n> Images up to and including v0.20.2 were signed using Cosign v1. Newer images are signed with Cosign v2.\n\nIt is pretty simple to verify the images:\n\n```bash\n# export the COSIGN_VARIABLE setting up the GitHub container registry signs path\nexport COSIGN_REPOSITORY=ghcr.io/bitnami-labs/sealed-secrets-controller/signs\n\n# verify the image uploaded in GHCR\ncosign verify --key .github/workflows/cosign.pub ghcr.io/bitnami-labs/sealed-secrets-controller:latest\n\n# verify the image uploaded in Dockerhub\ncosign verify --key .github/workflows/cosign.pub docker.io/bitnami/sealed-secrets-controller:latest\n```\n\n### How to use one controller for a subset of namespaces\n\nIf you want to use one controller for more than one namespace, but not all namespaces, you can provide additional namespaces using the command line flag `--additional-namespaces=<namespace1>,<namespace2>,<...>`. Make sure you provide appropriate roles and rolebindings in the target namespaces, so the controller can manage the secrets in there.\n\n## Community\n\n- [#sealed-secrets on Kubernetes Slack](https://kubernetes.slack.com/messages/sealed-secrets)\n\nClick [here](http://slack.k8s.io) to sign up to the Kubernetes Slack org.\n\n### Related projects\n\n- `kubeseal-convert`: [https://github.com/EladLeev/kubeseal-convert](https://github.com/EladLeev/kubeseal-convert)\n- Visual Studio Code extension: [https://marketplace.visualstudio.com/items?itemName=codecontemplator.kubeseal](https://marketplace.visualstudio.com/items?itemName=codecontemplator.kubeseal)\n- WebSeal: generates secrets in the browser: [https://socialgouv.github.io/webseal](https://socialgouv.github.io/webseal)\n- HybridEncrypt TypeScript implementation: [https://github.com/SocialGouv/aes-gcm-rsa-oaep](https://github.com/SocialGouv/aes-gcm-rsa-oaep)\n- [DEPRACATED] Sealed Secrets Operator: [https://github.com/disposab1e/sealed-secrets-operator-helm](https://github.com/disposab1e/sealed-secrets-operator-helm)"
}
