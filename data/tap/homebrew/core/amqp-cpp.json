{
  "name": "amqp-cpp",
  "full_name": "amqp-cpp",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "C++ library for communicating with a RabbitMQ message broker",
  "license": "Apache-2.0",
  "homepage": "https://github.com/CopernicaMarketingSoftware/AMQP-CPP",
  "versions": {
    "stable": "4.3.26",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/CopernicaMarketingSoftware/AMQP-CPP/archive/v4.3.26.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "2baaab702f3fd9cce40563dc1e23f433cceee7ec3553bd529a98b1d3d7f7911c"
    },
    "head": {
      "url": "https://github.com/CopernicaMarketingSoftware/AMQP-CPP.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/amqp-cpp/blobs/sha256:f65f76531ab89061aed98f55056ef7a920dd3368d8d738c0615b9d52956745ce",
          "sha256": "f65f76531ab89061aed98f55056ef7a920dd3368d8d738c0615b9d52956745ce"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/amqp-cpp/blobs/sha256:29327632ff96b7dd4cf5721039ad8001ab758f14a528f6b0ca7cb4ee37740ff8",
          "sha256": "29327632ff96b7dd4cf5721039ad8001ab758f14a528f6b0ca7cb4ee37740ff8"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/amqp-cpp/blobs/sha256:065b8751feca819dd49671549d29f038bf41d59076b60ff53aa36da2b974eeae",
          "sha256": "065b8751feca819dd49671549d29f038bf41d59076b60ff53aa36da2b974eeae"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/amqp-cpp/blobs/sha256:7ddb6e8142b7f99ea479a274a21c2e75a0317f1dc48d895744e1b3d396192173",
          "sha256": "7ddb6e8142b7f99ea479a274a21c2e75a0317f1dc48d895744e1b3d396192173"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/amqp-cpp/blobs/sha256:a717607eb6c8014424dad81ecb9e5e55926800a32a2855e6b666bee9f2800dc1",
          "sha256": "a717607eb6c8014424dad81ecb9e5e55926800a32a2855e6b666bee9f2800dc1"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/amqp-cpp/blobs/sha256:1a0b91a113adaaf303a4187051af2f49f52bbedfa84ae5a672be63158f332c85",
          "sha256": "1a0b91a113adaaf303a4187051af2f49f52bbedfa84ae5a672be63158f332c85"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/amqp-cpp/blobs/sha256:08f42f6efd8ed844adc09fa2d7b226c9d955c7e681527fe7d941926dc7c7098b",
          "sha256": "08f42f6efd8ed844adc09fa2d7b226c9d955c7e681527fe7d941926dc7c7098b"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake"
  ],
  "dependencies": [
    "openssl@3"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "2706c66e8def3eeba4d9bf1adf66221c8ad70701",
  "ruby_source_path": "Formula/amqp-cpp.rb",
  "ruby_source_checksum": {
    "sha256": "3f8f8fbeab179ad36c1d70a3158a96aebf56cb0265e09b8ccfda9afed248341b"
  },
  "date_added": "2016-10-03T16:48:10+01:00",
  "readme": "AMQP-CPP\n========\n\n[![Build Status](https://travis-ci.org/CopernicaMarketingSoftware/AMQP-CPP.svg?branch=master)](https://travis-ci.org/CopernicaMarketingSoftware/AMQP-CPP)\n[![Build status](https://ci.appveyor.com/api/projects/status/heh4n7gjwgqcugfn/branch/master?svg=true)](https://ci.appveyor.com/project/copernica/amqp-cpp/branch/master)\n\nAMQP-CPP is a C++ library for communicating with a RabbitMQ message broker. \nThe library can be used to parse incoming data from, and generate frames to, a RabbitMQ server.\n\nOVERVIEW\n========\n\n**Are you upgrading from AMQP-CPP 3 to AMQP-CPP 4?** [Please read the upgrade instructions](#upgrading)\n\n**Note for the reader:** This readme file has a peculiar structure. We start\nexplaining the pure and hard core low level interface in which you have to\ntake care of opening socket connections yourself. In reality, you probably want\nto use the simpler TCP interface that is being described [later on](#tcp-connections).\n\n<br>\n\nThis library has a layered architecture, and allows you - if you like - to\ncompletely take care of the network layer. If you want to set up and manage the\nnetwork connections yourself, the AMQP-CPP library will not make a connection to\nRabbitMQ by itself, nor will it create sockets and/or perform IO operations. As\na user of this library, you create the socket connection and implement an interface \ndefined by AMQP-CPP, passing it to the AMQP-CPP library to use for IO operations.\n\nIntercepting this network layer is optional. The AMQP-CPP library comes with a\npredefined TCP and TLS module that can be used if you trust the AMQP library\nto take care of the network (and optional TLS) handling. In that case, the\nAMQP-CPP library does all the system and library calls to set up network\nconnections, and send/receive the (possibly encrypted) data.\n\nThis layered architecture makes the library flexible and portable: it\ndoes not necessarily rely on operating system specific IO calls, and can be\neasily integrated into any kind of event loop. If you want to implement the AMQP\nprotocol on top of some [other unusual communication layer](https://tools.ietf.org/html/rfc1149),\nthis library can be used for that - but if you want to use it with regular TCP\nconnections, setting it up is just as easy.\n\nAMQP-CPP is fully asynchronous and does not do any blocking (system) calls, so\nit can be used in high performance applications without the need for threads.\n\nThe AMQP-CPP library uses C++17 features, so if you intend to use it, please make\nsure that your compiler is up-to-date and supports C++17.\n\n\nTABLE OF CONTENTS\n=================\n\n* [Overview](#overview)\n* [About](#about)\n* [How to install](#how-to-install)\n* [How to use AMQP-CPP](#how-to-use-amqp-cpp)\n* [Parsing incoming data](#parsing-incoming-data)\n* [TCP connections](#tcp-connections)\n* [Secure connections](#secure-connections)\n* [Existing event loops](#existing-event-loops)\n* [Heartbeats](#heartbeats)\n* [Channels](#channels)\n* [Channel callbacks](#channel-callbacks)\n* [Channel errors](#channel-errors)\n* [Flags and Tables](#flags-and-tables)\n* [Publishing messages](#publishing-messages)\n* [Publisher confirms](#publishing-confirms)\n* [Consuming messages](#consuming-messages)\n* [Upgrading](#upgrading)\n* [Work in progress](#work-in-progress)\n\nABOUT\n=====\n[Back to Table of Contents](#table-of-contents)\n\nThis library is created and maintained by Copernica (www.copernica.com), and is\nused inside the MailerQ (www.mailerq.com) and Yothalot (www.yothalot.com) applications. \nMailerQ is a tool for sending large volumes of email, using AMQP message queues, and Yothalot \nis a big data processing map/reduce framework.\n\nDo you appreciate our work and are you looking for high quality email solutions?\nThen check out our other commercial and open source solutions:\n\n* Copernica Marketing Suite (www.copernica.com)\n* MailerQ on-premise MTA (www.mailerq.com)\n* Responsive Email web service (www.responsiveemail.com)\n* SMTPeter cloud based SMTP server (www.smtpeter.com)\n* PHP-CPP bridge between PHP and C++ (www.php-cpp.com)\n* PHP-JS bridge between PHP and Javascript (www.php-js.com)\n* Yothalot big data processor (www.yothalot.com)\n\n\nHOW TO INSTALL\n==============\n[Back to Table of Contents](#table-of-contents)\n\nStart by cloning the repository and navigating to the `AMQP-CPP` directory.\n\n```bash\ngit clone https://github.com/CopernicaMarketingSoftware/AMQP-CPP.git\ncd AMQP-CPP\n```\n\nThere are two methods to compile AMQP-CPP: CMake and Make. CMake is platform portable \nand works on all systems, while the Makefile only works on Linux. The two methods \ncreate both a shared and a static version of the AMQP-CPP library. Building of a\nshared library is currently not supported on Windows.\n\nAMQP-CPP comes with an optional Linux-only TCP module that takes care of the \nnetwork part required for the AMQP-CPP core library. If you use this module, you \nare required to link with `pthread` and `dl`.\n\nAfter building there are two relevant files to `#include` when you use the library.\n\n File                | Include when?\n---------------------|--------------------------------------------------------\n amqpcpp.h           | Always needed for the core features\n amqpcpp/linux_tcp.h | If using the Linux-only TCP module\n\nOn Windows you are required to define `NOMINMAX` when compiling code that includes public AMQP-CPP header files.\n\n## Using cmake\n\nThe CMake file supports both building and installing. You can choose not to use \nthe install functionality, and instead manually use the build output at `build/bin/`. Keep\nin mind that the TCP module is only supported for Linux. An example install method \nwould be:\n\n```bash\nmkdir build\ncd build\ncmake .. [-DAMQP-CPP_BUILD_SHARED=ON] [-DAMQP-CPP_LINUX_TCP=ON]\ncmake --build . --target install\n```\n\n Option                  | Default | Meaning\n-------------------------|---------|-----------------------------------------------------------------------\n AMQP-CPP_BUILD_SHARED   | OFF     | OFF for static lib, ON for shared lib. Shared is not supported on Windows.\n AMQP-CPP_LINUX_TCP      | OFF     | ON to build TCP module. TCP module is supported for Linux only.\n\n## Using make\n\nCompiling and installing AMQP-CPP with make is as easy as running: \n\n```bash\nmake\nmake install\n```\n\nThis will install the full version of AMQP-CPP, including \nthe system specific TCP module. \n\nTo install without the TCP module (so that you can handle \nnetwork connection yourself), run:\n\n```bash\nmake pure\nmake install\n```\n\n## Compiling a program\n\nWhen you compile an application that uses the AMQP-CPP library, remember to link \nwith the library. For gcc and clang the linker flag is `-lamqpcpp`.\n\nIf you use the TCP module, you also need to pass the `-lpthread` and `-ldl` \nlinker flags. The TCP module uses a thread for running an asynchronous \nand non-blocking DNS hostname lookup, and it must be linked with the `dl` library to \nallow dynamic lookups for functions from the openssl library if a secure connection \nto RabbitMQ has to be set up.\n\nAn example compilation command for an application using the TCP module:\n```bash\ng++ -g -Wall -lamqcpp -lpthread -ldl my-amqp-cpp.c -o my-amqp-cpp\n```\n\nHOW TO USE AMQP-CPP\n===================\n[Back to Table of Contents](#table-of-contents)\n\nAMQP-CPP operates in a network-agnostic fashion. It does not do IO by itself.\nAn object must be provided that defines the IO operations. We have provided the\n`ConnectionHandler` base class for you to extend from and create your own object. \nThis class defines a number of methods called by the library any time it wants \nto send data, or if it wants to notify you an error has occurred.\n\n````c++\n#include <amqpcpp.h>\n\n// You'll need to extend the ConnectionHandler class and make your own, like this\nclass MyConnectionHandler : public AMQP::ConnectionHandler\n{\n    /**\n     *  Method that is called by the AMQP library every time it has data\n     *  available that should be sent to RabbitMQ.\n     *  @param  connection  pointer to the main connection object\n     *  @param  data        memory buffer with the data that should be sent to RabbitMQ\n     *  @param  size        size of the buffer\n     */\n    virtual void onData(AMQP::Connection *connection, const char *data, size_t size)\n    {\n        // @todo\n        //  Add your own implementation, for example by doing a call to the\n        //  send() system call. But be aware that the send() call may not\n        //  send all data at once, so you also need to take care of buffering\n        //  the bytes that could not immediately be sent, and try to send\n        //  them again when the socket becomes writable again\n    }\n\n    /**\n     *  Method that is called by the AMQP library when the login attempt\n     *  succeeded. After this method has been called, the connection is ready\n     *  to use.\n     *  @param  connection      The connection that can now be used\n     */\n    virtual void onReady(AMQP::Connection *connection)\n    {\n        // @todo\n        //  add your own implementation, for example by creating a channel\n        //  instance, and start publishing or consuming\n    }\n\n    /**\n     *  Method that is called by the AMQP library when a fatal error occurs\n     *  on the connection, for example because data received from RabbitMQ\n     *  could not be recognized.\n     *  @param  connection      The connection on which the error occurred\n     *  @param  message         A human readable error message\n     */\n    virtual void onError(AMQP::Connection *connection, const char *message)\n    {\n        // @todo\n        //  add your own implementation, for example by reporting the error\n        //  to the user of your program, log the error, and destruct the\n        //  connection object because it is no longer in a usable state\n    }\n\n    /**\n     *  Method that is called when the connection was closed. This is the\n     *  counter part of a call to Connection::close() and it confirms that the\n     *  AMQP connection was correctly closed.\n     *\n     *  @param  connection      The connection that was closed and that is now unusable\n     */\n    virtual void onClosed(AMQP::Connection *connection) \n    {\n        // @todo\n        //  add your own implementation, for example by closing down the\n        //  underlying TCP connection too\n    }\n\n\n};\n````\n\nEven though `ConnectionHandler` methods are not marked `noexcept` explicitly, \nyou are not expected to throw from them, and the behaviour is undefined if you \ndo so.\n\nAfter you've implemented the `ConnectionHandler` class the way you like, \nyou can start using the library by creating a `Connection` object, and one \nor more `Channel` objects:\n\n````c++\n// create an instance of your own connection handler\nMyConnectionHandler myHandler;\n\n// create a AMQP connection object\nAMQP::Connection connection(&myHandler, AMQP::Login(\"guest\",\"guest\"), \"/\");\n\n// and create a channel\nAMQP::Channel channel(&connection);\n\n// use the channel object to call the AMQP method you like\nchannel.declareExchange(\"my-exchange\", AMQP::fanout);\nchannel.declareQueue(\"my-queue\");\nchannel.bindQueue(\"my-exchange\", \"my-queue\", \"my-routing-key\");\n````\n\nA number of remarks about the example above. You may notice that we've\ncreated all objects on the stack. You are also free to create them\non the heap with the C++ operator `new`. That works just as well, and \nin a real project you will likely want to keep your `Handler`, `Connection`,\nand `Channel` objects around for a longer time.\n\nBut more importantly, you can see in the example above that we instantiated the\n`Channel` object directly after we made the `Connection` object, and we also\nstarted declaring exchanges and queues right away. \n\nHowever, under the hood, a handshake protocol is executed between the \nserver and the client when the `Connection` object is first created.\nDuring this handshake procedure other operations are \nnot permitted (like opening a channel or declaring a queue). \n\nIt would be better practice to wait for the connection to be ready \n(implementing the `MyConnectionHandler::OnReady()` method) and creating the \n`Channel` object only then.\n\nHowever, this is not strictly necessary. Methods called during a handshake \nare cached by the AMQP library, and will be executed the moment the handshake \nis completed and the connection becomes ready for use.\n\n\nPARSING INCOMING DATA\n=====================\n[Back to Table of Contents](#table-of-contents)\n\nThe `ConnectionHandler` class has a method `onData()` that is called by the library\nevery time that it wants to send data. The `onData` method is implemented by you, the user.\nFor example, you might make system calls to `send()` or `write()` to send data to \nthe RabbitMQ server. But what about data in the other direction? How does the\nlibrary receive data from RabbitMQ?\n\nIn this raw setup, the AMQP-CPP library does not do IO by itself, and so does not \nreceive any data from a socket. You will have to create a socket that connects to\nthe RabbitMQ server yourself.\n\nInside your event loop, after checking the socket is readable, \nyou should read out that socket (for example by using the `recv()` system\ncall), and pass the received bytes to the AMQP-CPP library. This is done by\ncalling the `parse()` method in the `Connection` object.\n\nThe `Connection::parse()` method gets two parameters, a pointer to a buffer of\ndata that you just read from the socket, and a parameter that holds the size of\nthis buffer. The code snippet below comes from the Connection.h C++ header file.\n\n````c++\n/**\n *  Parse data that was received from RabbitMQ\n *\n *  Every time that data comes in from RabbitMQ, you should call this method to parse\n *  the incoming data, and let it handle by the AMQP-CPP library. This method returns\n *  the number of bytes that were processed.\n *\n *  If not all bytes could be processed because it only contained a partial frame,\n *  you should call this same method later on when more data is available. The\n *  AMQP-CPP library does not do any buffering, so it is up to the caller to ensure\n *  that the old data is also passed in that later call.\n *\n *  @param  buffer      buffer to decode\n *  @param  size        size of the buffer to decode\n *  @return             number of bytes that were processed\n */\nsize_t parse(char *buffer, size_t size)\n{\n    return _implementation.parse(buffer, size);\n}\n````\n\nYou should do all the book keeping for the buffer yourselves. If you for example\ncall the `Connection::parse()` method with a buffer of 100 bytes, and the method\nreturns that only 60 bytes were processed, you should later call the method again,\nwith a buffer filled with the remaining 40 bytes. If the method returns 0, you should\nmake a new call to `parse()` when more data is available, with a buffer that contains\nboth the old data, and the new data.\n\nTo optimize your calls to the `parse()` method, you _could_ use the `Connection::expected()`\nand `Connection::maxFrame()` methods. The `expected()` method returns the number of bytes\nthat the library prefers to receive next. It is pointless to call the `parse()` method\nwith a smaller buffer, and it is best to call the method with a buffer of exactly this\nsize. The `maxFrame()` returns the max frame size for AMQP messages. If you read your\nmessages into a reusable buffer, you could allocate this buffer up to this size, so that\nyou never will have to reallocate.\n\n\nTCP CONNECTIONS\n===============\n[Back to Table of Contents](#table-of-contents)\n\nAlthough the AMQP-CPP library gives you extreme flexibility by letting you setup\nyour own network connections, the reality is that virtually all AMQP connections\nuse the TCP protocol. To help you out, the library also comes with a\nTCP module that takes care of setting up the network connections, and sending\nand receiving the data.\n\nWith the TCP module, you should not use the `AMQP::Connection`\nand `AMQP::Channel` classes that you saw above, but the alternative `AMQP::TcpConnection`\nand `AMQP::TcpChannel` classes instead. The `AMQP::ConnectionHandler` goes unused here as well; \nIn a TCP connection, you create a class that extends from `AMQP::TcpHandler` instead. \n\nThis `AMQP::TcpHandler` class contains a set of methods that you can override to intercept \nall sort of events that occur during the TCP and AMQP connection lifetime. Overriding these \nmethods is mostly optional, because almost all have a default implementation. \n\nWhat does need to be implemented by the user is the `monitor()` method, \nas that is needed by the AMQP-CPP library to interact with the main event loop.\n\n````c++\n#include <amqpcpp.h>\n#include <amqpcpp/linux_tcp.h>\n\nclass MyTcpHandler : public AMQP::TcpHandler\n{\n    /**\n     *  Method that is called by the AMQP library when a new connection\n     *  is associated with the handler. This is the first call to your handler\n     *  @param  connection      The connection that is attached to the handler\n     */\n    virtual void onAttached(AMQP::TcpConnection *connection) override\n    {\n        // @todo\n        //  add your own implementation, for example initialize things\n        //  to handle the connection.\n    }\n\n    /**\n     *  Method that is called by the AMQP library when the TCP connection \n     *  has been established. After this method has been called, the library\n     *  still has take care of setting up the optional TLS layer and of\n     *  setting up the AMQP connection on top of the TCP layer., This method \n     *  is always paired with a later call to onLost().\n     *  @param  connection      The connection that can now be used\n     */\n    virtual void onConnected(AMQP::TcpConnection *connection) override\n    {\n        // @todo\n        //  add your own implementation (probably not needed)\n    }\n\n    /**\n     *  Method that is called when the secure TLS connection has been established. \n     *  This is only called for amqps:// connections. It allows you to inspect\n     *  whether the connection is secure enough for your liking (you can\n     *  for example check the server certificate). The AMQP protocol still has\n     *  to be started.\n     *  @param  connection      The connection that has been secured\n     *  @param  ssl             SSL structure from openssl library\n     *  @return bool            True if connection can be used\n     */\n    virtual bool onSecured(AMQP::TcpConnection *connection, const SSL *ssl) override\n    {\n        // @todo\n        //  add your own implementation, for example by reading out the\n        //  certificate and check if it is indeed yours\n        return true;\n    }\n\n    /**\n     *  Method that is called by the AMQP library when the login attempt\n     *  succeeded. After this the connection is ready to use.\n     *  @param  connection      The connection that can now be used\n     */\n    virtual void onReady(AMQP::TcpConnection *connection) override\n    {\n        // @todo\n        //  add your own implementation, for example by creating a channel\n        //  instance, and start publishing or consuming\n    }\n\n    /**\n     *  Method that is called by the AMQP library when a fatal error occurs\n     *  on the connection, for example because data received from RabbitMQ\n     *  could not be recognized, or the underlying connection is lost. This\n     *  call is normally followed by a call to onLost() (if the error occurred\n     *  after the TCP connection was established) and onDetached().\n     *  @param  connection      The connection on which the error occurred\n     *  @param  message         A human readable error message\n     */\n    virtual void onError(AMQP::TcpConnection *connection, const char *message) override\n    {\n        // @todo\n        //  add your own implementation, for example by reporting the error\n        //  to the user of your program and logging the error\n    }\n\n    /**\n     *  Method that is called when the AMQP protocol is ended. This is the\n     *  counter-part of a call to connection.close() to graceful shutdown\n     *  the connection. Note that the TCP connection is at this time still \n     *  active, and you will also receive calls to onLost() and onDetached()\n     *  @param  connection      The connection over which the AMQP protocol ended\n     */\n    virtual void onClosed(AMQP::TcpConnection *connection) override \n    {\n        // @todo\n        //  add your own implementation (probably not necessary, but it could\n        //  be useful if you want to do some something immediately after the\n        //  amqp connection is over, but do not want to wait for the tcp \n        //  connection to shut down\n    }\n\n    /**\n     *  Method that is called when the TCP connection was closed or lost.\n     *  This method is always called if there was also a call to onConnected()\n     *  @param  connection      The connection that was closed and that is now unusable\n     */\n    virtual void onLost(AMQP::TcpConnection *connection) override \n    {\n        // @todo\n        //  add your own implementation (probably not necessary)\n    }\n\n    /**\n     *  Final method that is called. This signals that no further calls to your\n     *  handler will be made about the connection.\n     *  @param  connection      The connection that can be destructed\n     */\n    virtual void onDetached(AMQP::TcpConnection *connection) override \n    {\n        // @todo\n        //  add your own implementation, like cleanup resources or exit the application\n    } \n\n    /**\n     *  Method that is called by the AMQP-CPP library when it wants to interact\n     *  with the main event loop. The AMQP-CPP library is completely non-blocking,\n     *  and only make \"write()\" or \"read()\" system calls when it knows in advance\n     *  that these calls will not block. To register a filedescriptor in the\n     *  event loop, it calls this \"monitor()\" method with a filedescriptor and\n     *  flags telling whether the filedescriptor should be checked for readability\n     *  or writability.\n     *\n     *  @param  connection      The connection that wants to interact with the event loop\n     *  @param  fd              The filedescriptor that should be checked\n     *  @param  flags           Bitwise or of AMQP::readable and/or AMQP::writable\n     */\n    virtual void monitor(AMQP::TcpConnection *connection, int fd, int flags) override\n    {\n        // @todo\n        //  add your own implementation, for example by adding the file\n        //  descriptor to the main application event loop (like the select() or\n        //  poll() loop). When the event loop reports that the descriptor becomes\n        //  readable and/or writable, it is up to you to inform the AMQP-CPP\n        //  library that the filedescriptor is active by calling the\n        //  connection->process(fd, flags) method.\n    }\n};\n````\n\nYou see that there are many methods in `TcpHandler` that you can implement. The most important \none is `monitor()`. This method is used to integrate the AMQP filedescriptors in your\napplication's event loop. For some popular event loops (libev, libuv, libevent), we \nhave already added example handler objects (see the next section for that). All the \nother methods are optional to override. It often is a good idea to override the\n`onError()` method to log or report errors and `onDetached()` for cleaning up stuff.\nAMQP-CPP has its own buffers if you send instructions prematurely, but if you\nintend to send a lot of data over the connection, it also is a good idea to \nimplement the `onReady()` method and delay your calls until the AMQP connection \nhas been fully set up.\n\nUsing the TCP module of the AMQP-CPP library is easier than using the\nraw `AMQP::Connection` and `AMQP::Channel` objects. You do not have to\ncreate the sockets and connections yourself, nor do you handle buffering the data. \nThe example that we gave above looks slightly different if you make use of the TCP module:\n\n````c++\n// create an instance of your own tcp handler\nMyTcpHandler myHandler;\n\n// address of the server\nAMQP::Address address(\"amqp://guest:guest@localhost/vhost\");\n\n// create a AMQP connection object\nAMQP::TcpConnection connection(&myHandler, address);\n\n// and create a channel\nAMQP::TcpChannel channel(&connection);\n\n// use the channel object to call the AMQP method you like\nchannel.declareExchange(\"my-exchange\", AMQP::fanout);\nchannel.declareQueue(\"my-queue\");\nchannel.bindQueue(\"my-exchange\", \"my-queue\", \"my-routing-key\");\n````\n\nSECURE CONNECTIONS\n==================\n[Back to Table of Contents](#table-of-contents)\n\nThe TCP module of AMQP-CPP also supports setting up secure connections. If your\nRabbitMQ server accepts SSL connections, you can specify the address to your\nserver using the amqps:// protocol:\n\n````c++\n// init the SSL library (this works for openssl 1.1, for openssl 1.0 use SSL_library_init())\nOPENSSL_init_ssl(0, NULL);\n\n// address of the server (secure!)\nAMQP::Address address(\"amqps://guest:guest@localhost/vhost\");\n\n// create a AMQP connection object\nAMQP::TcpConnection connection(&myHandler, address);\n````\n\nThere are two things to take care of if you want to create a secure connection: \n(1) you must link your application with the `-lssl` flag (or use `dlopen()`), and (2) \nyou must initialize the openssl library by calling `OPENSSL_init_ssl()`. This \ninitialization must take place before you connect to RabbitMQ. \nThis is necessary because AMQP-CPP needs access to the openssl library to set up \nsecure connections. It can only access this library if you have linked it to your \napplication, or if you have loaded this library at runtime using `dlopen()`. \n\nLinking openssl is the normal thing to do. You just have to add the `-lssl` flag\nto your linker. If you however do not want to link your application with openssl, \nyou can also load the openssl library at runtime, and pass in the pointer to the \nhandle to AMQP-CPP:\n\n````c++\n// dynamically open the openssl library\nvoid *handle = dlopen(\"/path/to/openssl.so\", RTLD_LAZY);\n\n// tell AMQP-CPP library where the handle to openssl can be found\nAMQP::openssl(handle);\n\n// @todo call functions to initialize openssl, and create the AMQP connection\n// (see exampe above)\n````\n\nBy itself, AMQP-CPP does not check if the created TLS connection is sufficient\nsecure. Whether the certificate is expired, self-signed, missing, or invalid:\nAMQP-CPP will simply permit the connection. If you want to be more strict (for example: \nif you want to verify the server's certificate), you must do this yourself by implementing \nthe `onSecured()` method in your handler object:\n\n````c++\n#include <amqpcpp.h>\n#include <amqpcpp/linux_tcp.h>\n\nclass MyTcpHandler : public AMQP::TcpHandler\n{\n    /**\n     *  Method that is called right after the TLS connection has been created.\n     *  In this method you can check the connection properties (like the certificate)\n     *  and return false if you find it not secure enough\n     *  @param  connection      the connection that has just completed the tls handshake\n     *  @param  ssl             SSL structure from the openssl library\n     *  @return bool            true if connection is secure enough to start the AMQP protocol\n     */\n    virtual bool onSecured(AMQP::TcpConnection *connection, const SSL *ssl) override\n    {\n        // @todo call functions from the openssl library to check the certificate,\n        // like SSL_get_peer_certificate() or SSL_get_verify_result().\n        // For now we always allow the connection to proceed\n        return true;\n    }\n    \n    /**\n     *  All other methods (like onConnected(), onError(), etc) are left out of this\n     *  example, but would be here if this was an actual user space handler class.\n     */\n};\n````\n\nThe SSL pointer that is passed to the `onSecured()` method refers to the \"SSL\"\nstructure from the openssl library.\n\nEXISTING EVENT LOOPS\n====================\n[Back to Table of Contents](#table-of-contents)\n\nBoth the pure `AMQP::Connection` as well as the easier `AMQP::TcpConnection` class\nallow you to integrate AMQP-CPP in your own event loop. Whether you take care\nof running the event loop yourself (for example by using the `select()` system\ncall), or if you use an existing library for it (like libevent, libev or libuv),\nyou can implement the `monitor()` method to watch the file descriptors and\nhand over control back to AMQP-CPP when one of the sockets become active.\n\nFor libev, libuv and libevent users, we have even implemented an example \nimplementation, so that you do not even have to do this. Instead of implementing \nthe `monitor()` method yourself, you can use the `AMQP::LibEvHandler`, \n`AMQP::LibUvHandler` or `AMQP:LibEventHandler` classes instead:\n\n````c++\n#include <ev.h>\n#include <amqpcpp.h>\n#include <amqpcpp/libev.h>\n\nint main()\n{\n    // access to the event loop\n    auto *loop = EV_DEFAULT;\n\n    // handler for libev (so we don't have to implement AMQP::TcpHandler!)\n    AMQP::LibEvHandler handler(loop);\n\n    // make a connection\n    AMQP::TcpConnection connection(&handler, AMQP::Address(\"amqp://localhost/\"));\n\n    // we need a channel too\n    AMQP::TcpChannel channel(&connection);\n\n    // create a temporary queue\n    channel.declareQueue(AMQP::exclusive).onSuccess([&connection](const std::string &name, uint32_t messagecount, uint32_t consumercount) {\n\n        // report the name of the temporary queue\n        std::cout << \"declared queue \" << name << std::endl;\n\n        // now we can close the connection\n        connection.close();\n    });\n\n    // run the loop\n    ev_run(loop, 0);\n\n    // done\n    return 0;\n}\n````\n\nThe `AMQP::LibEvHandler` and `AMQP::LibEventHandler` classes are extended `AMQP::TcpHandler`\nclasses, with an implementation of the `monitor()` method that simply adds the\nfiledescriptor to the event loop. If you use this class, it is recommended not to\ninstantiate it directly (like we did in the example), but to create your own\n\"MyHandler\" class that extends from it, and in which you also implement the\n`onError()` method to report possible connection errors to your end users.\n\nCurrently, we have example `TcpHandler` implementations for libev, libuv,\nlibevent, and Boost's asio. For other event loops we do not yet have\nsuch examples. The quality of the libboostasio is however debatable: it was\nnot developed and is not maintained by the original AMQP-CPP developers, and \nit has a couple of open issues.\n\n| TCP Handler Impl        | Header File Location   |  Sample File Location     |\n| ----------------------- | ---------------------- | ------------------------- |\n| Boost asio (io_service) | include/libboostasio.h | examples/libboostasio.cpp |  \n| libev                   | include/libev.h        | examples/libev.cpp        |\n| libevent                | include/libevent.h     | examples/libevent.cpp     |\n| libuv                   | include/libuv.h        | examples/libuv.cpp        |\n\nHEARTBEATS\n==========\n[Back to Table of Contents](#table-of-contents)\n\nThe AMQP protocol supports *heartbeats*. If this heartbeat feature is enabled, the\nclient and the server negotiate a heartbeat interval during connection setup, and\nthey agree to send at least *some kind of data* over the connection during every\niteration of that interval. The normal data that is sent over the connection (like\npublishing or consuming messages) is normally sufficient to keep the connection alive,\nbut if the client or server was idle during the negotiated interval time, a dummy\nheartbeat message must be sent instead.\n\nThe default behavior of the AMQP-CPP library is to disable heartbeats. The\nproposed heartbeat interval of the server during connection setup (the server\nnormally suggests an interval of 60 seconds) is vetoed by the AMQP-CPP library so\nno heartbeats are ever needed to be sent over the connection. This means that you\ncan safely keep your AMQP connection idle for as long as you like, and/or run long\nlasting algorithms after you've consumed a message from RabbitMQ, without having\nto worry about the connection being idle for too long.\n\nYou can however choose to enable these heartbeats. If you want to enable heartbeats,\nyou should implement the `onNegotiate()` method inside your `ConnectionHandler` or\n`TcpHandler` class and have it return the interval that you find appropriate.\n\n````c++\n#include <amqpcpp.h>\n\nclass MyTcpHandler : public AMQP::TcpHandler\n{\n    /**\n     *  Method that is called when the server tries to negotiate a heartbeat\n     *  interval, and that is overridden to get rid of the default implementation\n     *  (which vetoes the suggested heartbeat interval), and accept the interval\n     *  instead.\n     *  @param  connection      The connection on which the error occurred\n     *  @param  interval        The suggested interval in seconds\n     */\n    virtual uint16_t onNegotiate(AMQP::TcpConnection *connection, uint16_t interval)\n    {\n        // we accept the suggestion from the server, but if the interval is smaller\n        // that one minute, we will use a one minute interval instead\n        if (interval < 60) interval = 60;\n\n        // @todo\n        //  set a timer in your event loop, and make sure that you call\n        //  connection->heartbeat() every _interval_ seconds if no other\n        //  instruction was sent in that period.\n\n        // return the interval that we want to use\n        return interval;\n    }\n};\n````\n\nIf you enable heartbeats, it is your own responsibility to ensure that the\n```connection->heartbeat()``` method is called at least once during this period,\nor that you call one of the other channel or connection methods to send data\nover the connection. Heartbeats are sent by the server too, RabbitMQ also ensures\nthat _some data_ is sent over the connection from the server to the client \nduring the heartbeat interval. It is also your responnsibility to shutdown \nthe connection if you find out that the server stops sending data during \nthis period.\n\nIf you use the `AMQP::LibEvHandler` event loop implementation, heartbeats are \nenabled by default, and all these checks are automatically performed.\n\n\nCHANNELS\n========\n[Back to Table of Contents](#table-of-contents)\n\nIn the above example we created a channel object. A channel is a sort of virtual\nconnection, and it is possible to create many channels that all use\nthe same connection.\n\nAMQP instructions are always sent over a channel, so before you can send the first\ncommand to the RabbitMQ server, you first need a channel object. The channel\nobject has many methods to send instructions to the RabbitMQ server. It for\nexample has methods to declare queues and exchanges, to bind and unbind them,\nand to publish and consume messages. You can best take a look at the channel.h\nC++ header file for a list of all available methods. Every method in it is well\ndocumented.\n\nAll operations that you can perform on a channel are non-blocking. This means\nthat it is not possible for a method (like `Channel::declareExchange()`) to\nimmediately return `true` or `false`. Instead, almost every method of the `Channel`\nclass returns an instance of the `Deferred` class. This `Deferred` object can be\nused to install handlers that will be called in case of success or failure.\n\nFor example, if you call the `channel.declareExchange()` method, the AMQP-CPP library\nwill send a message to the RabbitMQ message broker to ask it to declare the\nqueue. However, because all operations in the library are asynchronous, the\n`declareExchange()` method can not return `true` or `false` to inform you whether\nthe operation was successful or not. Only after a while, after the instruction\nhas reached the RabbitMQ server, and the confirmation from the server has been\nsent back to the client, the library can report the result of the `declareExchange()`\ncall.\n\nTo prevent any blocking calls, the `channel.declareExchange()` method returns a\n`Deferred` result object, on which you can set callback functions that will be\ncalled when the operation succeeds or fails.\n\n````c++\n// create a channel (or use TcpChannel if you're using the Tcp module)\nChannel myChannel(&connection);\n\n// declare an exchange, and install callbacks for success and failure\nmyChannel.declareExchange(\"my-exchange\")\n\n    .onSuccess([]() {\n        // by now the exchange is created\n    })\n\n    .onError([](const char *message) {\n        // something went wrong creating the exchange\n    });\n````\n\nAs you can see in the above example, we call the `declareExchange()` method, and\ntreat its return value as an object, on which we immediately install a lambda\ncallback function to handle success, and to handle failure.\n\nInstalling the callback methods is optional. If you're not interested in the\nresult of an operation, you do not have to install a callback for it. Next\nto the `onSuccess()` and `onError()` callbacks that can be installed, you can also\ninstall a `onFinalize()` method that gets called directly after the `onSuccess()`\nand `onError()` methods, and that can be used to set a callback that should\nrun in either case: when the operation succeeds or when it fails.\n\nThe signature for the `onError()` method is always the same: it gets one parameter\nwith a human readable error message. The `onSuccess()` function has a different\nsignature depending on the method that you call. Most `onSuccess()` functions\n(like the one we showed for the `declareExchange()` method) do not get any\nparameters at all. Some specific `onSuccess()` callbacks receive extra parameters\nwith additional information.\n\n\nCHANNEL CALLBACKS\n=================\n[Back to Table of Contents](#table-of-contents)\n\nAs explained, most channel methods return a `Deferred` object on which you can\ninstall callbacks using the `Deferred::onError()` and `Deferred::onSuccess()` methods.\n\nThe callbacks that you install on a `Deferred` object, only apply to one specific\noperation. If you want to install a generic error callback for the entire channel,\nyou can do so by using the `Channel::onError()` method. Next to the `Channel::onError()`\nmethod, you can also install a callback to be notified when the channel is ready\nfor sending the first instruction to RabbitMQ.\n\n````c++\n// create a channel (or use TcpChannel if you use the Tcp module)\nChannel myChannel(&connection);\n\n// install a generic channel-error handler that will be called for every\n// error that occurs on the channel\nmyChannel.onError([](const char *message) {\n\n    // report error\n    std::cout << \"channel error: \" << message << std::endl;\n});\n\n// install a generic callback that will be called when the channel is ready\n// for sending the first instruction\nmyChannel.onReady([]() {\n\n    // send the first instructions (like publishing messages)\n});\n````\n\nIn theory, you should wait for the `onReady()` callback to be called before you\nsend any other instructions over the channel. In practice however, the AMQP library\ncaches all instructions that were sent too early, so that you can use the\nchannel object right after it was constructed.\n\n\nCHANNEL ERRORS\n==============\n[Back to Table of Contents](#table-of-contents)\n\nIf a channel ever sees an error, the entire channel is invalidated, including \nsubsequent instructions that were already sent. This means that if you call \nmultiple methods in a row, and the first method fails, all subsequent methods \nwill not be executed:\n\n````c++\nChannel myChannel(&connection);\n\nmyChannel.declareQueue(\"my-queue\");         // If this method fails...\nmyChannel.declareExchange(\"my-exchange\");   // ...this method will not execute.\n````\n\nIf the first `declareQueue()` call fails in the example above, the second\n`myChannel.declareExchange()` method will not be executed, even when this\nsecond instruction was already sent to the server. \n\nThe second instruction will be ignored by the RabbitMQ server \nbecause the channel became invalid at the first instruction.\n\nYou can overcome this by using multiple channels:\n\n````c++\nChannel channel1(&connection);\nChannel channel2(&connection);\nchannel1.declareQueue(\"my-queue\");\nchannel2.declareExchange(\"my-exchange\");\n````\n\nNow, if an error occurs with declaring the queue, it will not have consequences\nfor the other call. But this comes at a small price: setting up the extra channel\nrequires and extra instruction to be sent to the RabbitMQ server, so some extra\nbytes are sent over the network, and some additional resources in both the client\napplication and the RabbitMQ server are used (although this is all very limited).\n\nIf possible, it is best to make use of this feature. For example, if you have an important AMQP\nconnection that you use for consuming messages, and at the same time you want\nto send another instruction to RabbitMQ (like declaring a temporary queue), it is\nbest to set up a new channel for this 'declare' instruction. If the declare fails,\nit will not stop the consumer, because it was sent over a different channel.\n\nThe AMQP-CPP library allows you to create channels on the stack. It is not\na problem if a channel object gets destructed before the instruction was received by\nthe RabbitMQ server:\n\n````c++\nvoid myDeclareMethod(AMQP::Connection *connection)\n{\n    // create temporary channel to declare a queue\n    AMQP::Channel channel(connection);\n\n    // declare the queue (the channel object is destructed before the\n    // instruction reaches the server, but the AMQP-CPP library can deal\n    // with this)\n    channel.declareQueue(\"my-new-queue\");\n}\n````\n\n\nFLAGS AND TABLES\n================\n[Back to Table of Contents](#table-of-contents)\n\nLet's take a closer look at one method in the `Channel` object to explain\ntwo other concepts of this AMQP-CPP library: flags and tables. The method that we\nwill be looking at is the `Channel::declareQueue()` method - but we could've\npicked a different method too because flags and\ntables are used by many methods.\n\n````c++\n/**\n *  Declare a queue\n *\n *  If you do not supply a name, a name will be assigned by the server.\n *\n *  The flags can be a combination of the following values:\n *\n *      -   durable     queue survives a broker restart\n *      -   autodelete  queue is automatically removed when all connected consumers are gone\n *      -   passive     only check if the queue exist\n *      -   exclusive   the queue only exists for this connection, and is automatically removed when connection is gone\n *\n *  @param  name        name of the queue\n *  @param  flags       combination of flags\n *  @param  arguments   optional arguments\n */\nDeferredQueue &declareQueue(const std::string &name, int flags, const Table &arguments);    // This version is the most extensive\nDeferredQueue &declareQueue(const std::string &name, const Table &arguments);\nDeferredQueue &declareQueue(const std::string &name, int flags = 0);\nDeferredQueue &declareQueue(int flags, const Table &arguments);\nDeferredQueue &declareQueue(const Table &arguments);\nDeferredQueue &declareQueue(int flags = 0);\n````\n\nAs you can see, the method comes in many forms, and it is up to you to choose\nthe one that is most appropriate. We now take a look at the most complete\none, the method with three parameters.\n\nAll above methods returns a `DeferredQueue` object. The `DeferredQueue` class\nextends from the `AMQP::Deferred` class and allows you to install a more powerful\n`onSuccess()` callback function. The `onSuccess` method for the `declareQueue()`\nfunction gets three arguments:\n\n````c++\n// create a custom callback\nauto callback = [](const std::string &name, int msgcount, int consumercount) {\n\n    // @todo add your own implementation\n\n};\n\n// declare the queue, and install the callback that is called on success\nchannel.declareQueue(\"myQueue\").onSuccess(std::move(callback));\n````\n\nJust like many others methods in the `Channel` class, the `declareQueue()` method\naccepts an integer parameter named `flags`. This is a variable in which you can\nset method-specific options, by summing up all the options that are described in\nthe documentation above the method. If you for example want to create a durable,\nauto-deleted queue, you can pass in the value `AMQP::durable + AMQP::autodelete`.\n\nThe `declareQueue()` method also accepts a parameter named `arguments`, which is of type\n`Table`. This `Table` object can be used as an associative array to send additional\noptions to RabbitMQ, that are often custom RabbitMQ extensions to the AMQP\nstandard. For a list of all supported arguments, take a look at the documentation\non the RabbitMQ website. With every new RabbitMQ release more features, and\nsupported arguments are added.\n\nThe `Table` class is a very powerful class that enables you to build\ncomplicated, deeply nested structures full of strings, arrays and even other\ntables. In reality, you only need strings and integers.\n\n````c++\n// custom options that are passed to the declareQueue call\nAMQP::Table arguments;\narguments[\"x-dead-letter-exchange\"] = \"some-exchange\";\narguments[\"x-message-ttl\"] = 3600 * 1000;\narguments[\"x-expires\"] = 7200 * 1000;\n\n// declare the queue\nchannel.declareQueue(\"my-queue-name\", AMQP::durable + AMQP::autodelete, arguments);\n````\n\n\nPUBLISHING MESSAGES\n===================\n[Back to Table of Contents](#table-of-contents)\n\nPublishing messages is easy, and the `Channel` class has a list of methods that\ncan all be used for it. The most simple one takes three arguments: the name of the\nexchange to publish to, the routing key to use, and the actual message that\nyou're publishing - all these parameters are standard C++ strings.\n\nMore extended versions of the `publish()` method exist that accept additional\narguments, and that enable you to publish entire `Envelope` objects. An `Envelope`\nis an object that contains the message plus a list of optional meta properties like\nthe content-type, content-encoding, priority, expire time and more. None of these\nmeta fields are interpreted by this library, and RabbitMQ ignores most\nof them, but the AMQP protocol defines them and are free for you to use.\nFor an extensive list of the fields that are supported, take a look at the MetaData.h\nheader file (`MetaData` is the base class for `Envelope`). You should also check the\nRabbitMQ documentation to find out if an envelope header is interpreted by the\nRabbitMQ server (at the time of this writing, only the expire time is being used).\n\nThe following snippet is copied from the Channel.h header file and lists all\navailable `publish()` methods. As you can see, you can call the `publish()` method\nin almost any form:\n\n````c++\n/**\n *  Publish a message to an exchange\n * \n *  You have to supply the name of an exchange and a routing key. RabbitMQ will then try\n *  to send the message to one or more queues. With the optional flags parameter you can\n *  specify what should happen if the message could not be routed to a queue. By default,\n *  unroutable message are silently discarded.\n * \n *  If you set the 'mandatory' and/or 'immediate' flag, messages that could not be handled \n *  are returned to the application. Make sure that you have called the recall()-method and\n *  have set up all appropriate handlers to process these returned messages before you start\n *  publishing.\n * \n *  The following flags can be supplied:\n * \n *      -   mandatory   If set, server returns messages that are not sent to a queue\n *      -   immediate   If set, server returns messages that can not immediately be forwarded to a consumer. \n * \n *  @param  exchange    the exchange to publish to\n *  @param  routingkey  the routing key\n *  @param  envelope    the full envelope to send\n *  @param  message     the message to send\n *  @param  size        size of the message\n *  @param  flags       optional flags\n */\nbool publish(const std::string &exchange, const std::string &routingKey, const Envelope &envelope, int flags = 0) { return _implementation->publish(exchange, routingKey, envelope, flags); }\nbool publish(const std::string &exchange, const std::string &routingKey, const std::string &message, int flags = 0) { return _implementation->publish(exchange, routingKey, Envelope(message.data(), message.size()), flags); }\nbool publish(const std::string &exchange, const std::string &routingKey, const char *message, size_t size, int flags = 0) { return _implementation->publish(exchange, routingKey, Envelope(message, size), flags); }\nbool publish(const std::string &exchange, const std::string &routingKey, const char *message, int flags = 0) { return _implementation->publish(exchange, routingKey, Envelope(message, strlen(message)), flags); }\n````\n\nPublished messages are normally not confirmed by the server, and the RabbitMQ\nwill not send a report back to inform you whether the message was successfully\npublished or not. But with the flags you can instruct RabbitMQ to send back\nthe message if it was undeliverable. In you use these flags you must also install\ncallbacks that will process these bounced messages.\n\nYou can also use transactions to ensure that your messages get delivered.\nLet's say that you are publishing many messages in a row. If you get\nan error halfway through there is no way to know for sure how many messages made\nit to the broker and how many should be republished. If this is important, you can\nwrap the publish commands inside a transaction. In this case, if an error occurs,\nthe transaction is automatically rolled back by RabbitMQ and none of the messages\nare actually published.\n\n````c++\n// start a transaction\nchannel.startTransaction();\n\n// publish a number of messages\nchannel.publish(\"my-exchange\", \"my-key\", \"my first message\");\nchannel.publish(\"my-exchange\", \"my-key\", \"another message\");\n\n// commit the transactions, and set up callbacks that are called when\n// the transaction was successful or not\nchannel.commitTransaction()\n    .onSuccess([]() {\n        // all messages were successfully published\n    })\n    .onError([](const char *message) {\n        // none of the messages were published\n        // now we have to do it all over again\n    });\n````\n\nNote that AMQP transactions are not as powerful as transactions that are\nknows in the database world. It is not possible to wrap all sort of\noperations in a transaction, they are only meaningful for publishing\nand consuming.\n\nPUBLISHER CONFIRMS\n===================\n[Back to Table of Contents](#table-of-contents)\n\nRabbitMQ supports a lightweight method of confirming that broker received \nand  processed a message. When you enable this, RabbitMQ sends back an \n'ack' or 'nack' for each publish-operation. For this to work, the channel \nneeds to be put in _confirm mode_. This is done using the\n`confirmSelect()` method. When the channel is successfully put in confirm mode, \nthe server starts counting the received messages (starting from 1) and sends \nacknowledgments for every message it processed (it can also acknowledge \nmultiple message at once). \n\nIf server is unable to process a message, it will send send negative \nacknowledgments. Both positive and negative acknowledgments handling are \npassed to callbacks that you can install on the object that\nis returned by the `confirmSelect()` method:\n\n````c++\n// setup confirm mode and ack/nack callbacks (from this moment onwards \n// ack/nack confirmations are coming in)\nchannel.confirmSelect().onSuccess([&]() {\n\n    // publish the first message (this will be acked/nacked with deliveryTag=1)\n    channel.publish(\"my-exchange\", \"my-key\", \"my first message\");\n\n    // publish the second message (this will be acked/nacked with deliveryTag=2)\n    channel.publish(\"my-exchange\", \"my-key\", \"my second message\");\n\n}).onAck([&](uint64_t deliveryTag, bool multiple) {\n\n    // deliveryTag is message number\n    // multiple is set to true, if all messages UP TO deliveryTag have been processed\n\n}).onNack([&](uint64_t deliveryTag, bool multiple, bool requeue) {\n\n    // deliveryTag is message number\n    // multiple is set to true, if all messages UP TO deliveryTag have not been processed\n    // requeue is to be ignored\n\n});\n\n````\n\nIf you use this feature, you will have to implement your own bookkeeping to\ntrack which messages have already been acked/nacked, and which messages \nare still being handled. For your convenience, the AMQP-CPP library\ncomes with a number of helper classes that can take over this responsibility.\n\nThe `AMQP::Reliable` class is an optional wrapper around channels. When you use\nit, your underlying channel is automatically put it _confirm method_, and all publish\noperations are individually acknowledged:\n\n````c++\n// create a channel\nAMQP::TcpChannel mychannel(connection);\n\n// wrap the channel into a reliable-object so that publish-opertions are\n// individually confirmed (after wrapping the channel, it is recommended\n// to no longer make direct calls to the channel)\nAMQP::Reliable reliable(mychannel);\n\n// publish a message via the reliable-channel\nreliable.publish(\"my-exchange\", \"my-key\", \"my first message\").onAck([]() {\n\n    // the message has been acknowledged by RabbitMQ (in your application\n    // code you can now safely discard the message as it has been picked up)\n\n}).onNack([]() {\n\n    // the message has _explicitly_ been nack'ed by RabbitMQ (in your application\n    // code you probably want to log or handle this to avoid data-loss)\n\n}).onLost([]() {\n\n    // because the implementation for onNack() and onError() will be the same\n    // in many applications, you can also choose to install a onLost() handler,\n    // which is called when the message has either been nack'ed, or lost.\n\n}).onError([](const char *message) {\n\n    // a channel-error occurred before any ack or nack was received, and the \n    // message is probably lost (which you might want to handle)\n\n});\n\n````\n\nIn the above example we have implemented four callback methods. In a real life\napplication, implementing the `onAck()` and `onLost()` is normally sufficient.\n\nPublisher-confirms are often useful in situations where you need reliability.\nIf you want to have certainty about whether your message was handled by RabbitMQ\nor not, you can enable this feature. Call `channel.confirmSelect()`\nif you want to do your own bookkeeping, or using `AMQP::Reliable` for a simpler\nAPI.\n\nBut it also is useful for flood prevention. RabbitMQ is not great \nat handling big loads of publish-operations. If you publish messages faster \nthan RabbitMQ can handle, a server-side buffer builds up, and RabbitMQ gets slow \n(which causes the buffer to build up even further, etc). With publish-confirms\nyou can keep the messages in your own application, and only proceed with publishing\nthem when your previous messages have been handled. With this approach you\nprevent that RabbitMQ gets overloaded. We call it throttling.\n\nYou can build your own throttling mechanism using the `confirmSelect()` approach\nor the `AMQP::Reliable` class. Or you use `AMQP::Throttle`:\n\n````c++\n// create a channel\nAMQP::TcpChannel mychannel(connection);\n\n// create a throttle (do not publish more than 20 messages at once) (after\n// wrapping the channel in a throttle you should no longer call any of the\n// channel-methods directly)\nAMQP::Throttle throttle(connection, 20);\n\n// publish way more messages than RabbitMQ can handle (the Throttle class\n// will make sure that messages are buffered inside your application if\n// there are more than 20 unacked messages)\nfor (size_t i = 0; i < 100000; ++i)\n{\n    // publish a message\n    throttle.publish(\"my-exchange\", \"my-key\", \"my first message\");\n}\n````\n\nThe `AMQP::Reliable` and `AMQP::Throttle` classes both wrap around a channel.\nBut what if you want to use both? You want to throttle messages, but also like\nto install your own callbacks for `onAck` and `onLost`? This is possible too:\n\n````c++\n// create a channel\nAMQP::TcpChannel mychannel(connection);\n\n// create a throttle that allows reliable-publishing\nAMQP::Throttle<AMQP::Reliable> throttle(connection, 20);\n\n// publish way more messages than RabbitMQ can handle (the Throttle class\n// will make sure that messages are buffered inside your application if\n// there are more than 20 unacked messages)\nfor (size_t i = 0; i < 100000; ++i)\n{\n    // publish a message\n    throttle.publish(\"my-exchange\", \"my-key\", \"my first message\").onAck([]() {\n    \n        // @todo add your own code\n    \n    }).onLost([]() {\n    \n        // @todo add your own code\n    \n    });\n}\n````\n\nFor more information, see http://www.rabbitmq.com/confirms.html.\n\nCONSUMING MESSAGES\n==================\n[Back to Table of Contents](#table-of-contents)\n\nFetching messages from RabbitMQ is called consuming, and can be started by calling\nthe method `Channel::consume()`. After you've called this method, RabbitMQ starts\ndelivering messages to you.\n\nJust like the `publish()` method that we just described, the `consume()` method also\ncomes in many forms. The first parameter is always the name of the queue you like\nto consume from. The subsequent parameters are an optional consumer tag, flags and\na table with custom arguments. The first additional parameter, the consumer tag,\nis nothing more than a string identifier that you can use when you want to stop\nconsuming.\n\nThe full documentation from the C++ Channel.h headerfile looks like this:\n\n````c++\n/**\n *  Tell the RabbitMQ server that we're ready to consume messages\n *\n *  After this method is called, RabbitMQ starts delivering messages to the client\n *  application. The consume tag is a string identifier that will be passed to\n *  each received message, so that you can associate incoming messages with a\n *  consumer. If you do not specify a consumer tag, the server will assign one\n *  for you.\n *\n *  The following flags are supported:\n *\n *      -   nolocal             if set, messages published on this channel are\n *                              not also consumed\n *\n *      -   noack               if set, consumed messages do not have to be acked,\n *                              this happens automatically\n *\n *      -   exclusive           request exclusive access, only this consumer can\n *                              access the queue\n *\n *  The callback registered with DeferredConsumer::onSuccess() will be called when the\n *  consumer has started.\n *\n *  @param  queue               the queue from which you want to consume\n *  @param  tag                 a consumer tag that will be associated with this consume operation\n *  @param  flags               additional flags\n *  @param  arguments           additional arguments\n *  @return bool\n */\nDeferredConsumer &consume(const std::string &queue, const std::string &tag, int flags, const AMQP::Table &arguments);\nDeferredConsumer &consume(const std::string &queue, const std::string &tag, int flags = 0);\nDeferredConsumer &consume(const std::string &queue, const std::string &tag, const AMQP::Table &arguments);\nDeferredConsumer &consume(const std::string &queue, int flags, const AMQP::Table &arguments);\nDeferredConsumer &consume(const std::string &queue, int flags = 0);\nDeferredConsumer &consume(const std::string &queue, const AMQP::Table &arguments);\n````\n\nAs you can see, the consume method returns a `DeferredConsumer`. This object is a\nregular `Deferred`, with additions. The `onSuccess()` method of a\n`DeferredConsumer` is slightly different than the `onSuccess()` method of a regular\n`Deferred` object: one extra parameter will be supplied to your callback function\nwith the consumer tag.\n\nThe `onSuccess()` callback will be called when the consume operation _has started_,\nbut not when messages are actually consumed. For this you will have to install\na different callback, using the `onReceived()` method.\n\n````c++\n// callback function that is called when the consume operation starts\nauto startCb = [](const std::string &consumertag) {\n\n    std::cout << \"consume operation started\" << std::endl;\n};\n\n// callback function that is called when the consume operation failed\nauto errorCb = [](const char *message) {\n\n    std::cout << \"consume operation failed\" << std::endl;\n};\n\n// callback operation when a message was received\nauto messageCb = [&channel](const AMQP::Message &message, uint64_t deliveryTag, bool redelivered) {\n\n    std::cout << \"message received\" << std::endl;\n\n    // acknowledge the message\n    channel.ack(deliveryTag);\n};\n\n// callback that is called when the consumer is cancelled by RabbitMQ (this only happens in\n// rare situations, for example when someone removes the queue that you are consuming from)\nauto cancelledCb = [](const std::string &consumertag) {\n\n    std::cout << \"consume operation cancelled by the RabbitMQ server\" << std::endl;\n};\n\n// start consuming from the queue, and install the callbacks\nchannel.consume(\"my-queue\")\n    .onReceived(messageCb)\n    .onSuccess(startCb)\n    .onCancelled(cancelledCb)\n    .onError(errorCb);\n\n````\n\nThe `Message` object holds all information of the delivered message: the actual\ncontent, all meta information from the envelope (in fact, the `Message` class is\nderived from the `Envelope` class), and even the name of the exchange and the\nrouting key that were used when the message was originally published. For a full\nlist of all information in the `Message` class, you best have a look at the\nmessage.h, envelope.h and metadata.h header files.\n\nAnother important parameter to the `onReceived()` method is the `deliveryTag` parameter.\nThis is a unique identifier that you need to acknowledge an incoming message.\nRabbitMQ only removes the message after it has been acknowledged, so that if your\napplication crashes while it was busy processing the message, the message does\nnot get lost but remains in the queue. But this means that after you've processed\nthe message, you must inform RabbitMQ about it by calling the `Channel:ack()` method.\nThis method is very simple and takes in its simplest form only one parameter: the\n`deliveryTag` of the message.\n\nConsuming messages is a continuous process. RabbitMQ keeps sending messages, until\nyou stop the consumer, which can be done by calling the `Channel::cancel()` method.\nIf you close the channel, or the entire TCP connection, the consumer also stops.\nIn some (rare) situations, the consume operation can also be cancelled by the RabbitMQ\nserver. This for example happens when a queue is removed or becomes unavailable. To\nhandle this scenario you can install a \"onCancelled\" callback.\n\nRabbitMQ throttles the number of messages that are delivered to you, to prevent\nthat your application is flooded with messages from the queue, and to spread out\nthe messages over multiple consumers. This is done with a setting called\nquality-of-service (QOS). The QOS setting is a numeric value which holds the number\nof unacknowledged messages that you are allowed to have. RabbitMQ stops sending\nadditional messages when the number of unacknowledges messages has reached this\nlimit, and only sends additional messages when an earlier message gets acknowledged.\nTo change the QOS, you can simple call `Channel::setQos()`.\n\n\nUPGRADING\n=========\n[Back to Table of Contents](#table-of-contents)\n\nAMQP-CPP 4.* is not always compatible with previous versions. Especially some \nvirtual methods in the `ConnectionHandler` and `TcpHandler` classes have been renamed \nor are called during a different stage in the connection lifetime. Check \nout this README file and the comments inside the connectionhandler.h and \ntcphandler.h files to find out if your application has to be changed. You\nshould especially check the following:\n\n- `ConnectionHandler::onConnected` has been renamed to `ConnectionHandler::onReady`\n- `TcpHandler::onConnected` is now called sooner: when the TCP connection is \n  established, instead of when the AMQP connection is ready for instructions.\n- The new method `TcpHandler::onReady` is called when the AMQP connection is \n  ready to be used (this is the old behavior of `TcpHandler::onConnected`)\n- `TcpHandler::onError` is no longer the last method that is called (`TcpHandler::onLost` \n  could be called and `TcpHandler::onDetached` will be called after the error too)\n- `TcpHandler::onClosed` is now called to indicate the graceful end of the \n  AMQP protocol, and not the end of TCP connection.\n- `TcpHandler::onLost` is called when the TCP connection is lost or closed.\n- The new method `TcpHandler::onDetached` is a better alternative for cleanup \n  code instead of `TcpHandler::onClosed` and/or `TcpHandler::onError`.\n\n\nWORK IN PROGRESS\n================\n[Back to Table of Contents](#table-of-contents)\n\nAlmost all AMQP features have been implemented. But the following things might\nneed additional attention:\n\n    -   ability to set up secure connections (or is this fully done on the IO level)\n    -   login with other protocols than login/password\n\nWe also need to add more safety checks so that strange or invalid data from\nRabbitMQ does not break the library (although in reality RabbitMQ only sends\nvalid data). Also, when we now receive an answer from RabbitMQ that does not\nmatch the request that we sent before, we do not report an error (this is also\nan issue that only occurs in theory).\n\nIt would be nice to have sample implementations for the `ConnectionHandler`\nclass that can be directly plugged into libev, libevent and libuv event loops.\n\nFor performance reasons, we need to investigate if we can limit the number of times\nan incoming or outgoing messages is copied."
}
