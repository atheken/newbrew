{
  "name": "rnr",
  "full_name": "rnr",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Command-line tool to batch rename files and directories",
  "license": "MIT",
  "homepage": "https://github.com/ismaelgv/rnr",
  "versions": {
    "stable": "0.4.2",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/ismaelgv/rnr/archive/refs/tags/v0.4.2.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "cde8e5366552263300e60133b82f6a3868aeced2fe83abc91c2168085dff0998"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/rnr/blobs/sha256:13e613c2d00e9e996d6b0bd2b43e1e23bc60f4a5a6d5f0e1a7c33058be9cd98e",
          "sha256": "13e613c2d00e9e996d6b0bd2b43e1e23bc60f4a5a6d5f0e1a7c33058be9cd98e"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/rnr/blobs/sha256:c47dbe0a3e417a52175e9af2d05752ba236ff850f6278b8829efc1a60bdbcb55",
          "sha256": "c47dbe0a3e417a52175e9af2d05752ba236ff850f6278b8829efc1a60bdbcb55"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/rnr/blobs/sha256:df46ce33f22472a8c3869bd61f8832340953469bc721b9091e04f35fcc4dea7b",
          "sha256": "df46ce33f22472a8c3869bd61f8832340953469bc721b9091e04f35fcc4dea7b"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/rnr/blobs/sha256:e7a1f0fbe20e79691075d96a574c6a55adf50bb2e5339242ca9b2b4ab08c1d1f",
          "sha256": "e7a1f0fbe20e79691075d96a574c6a55adf50bb2e5339242ca9b2b4ab08c1d1f"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/rnr/blobs/sha256:5d77ebcc4d57548d2c95f5c5753e917896627e9ea117f6e4c05861d18b39408b",
          "sha256": "5d77ebcc4d57548d2c95f5c5753e917896627e9ea117f6e4c05861d18b39408b"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/rnr/blobs/sha256:bd2d7d0aafdd9699adc98bfcf5d56c8af2402ed2ae12789734de2fb0471f7380",
          "sha256": "bd2d7d0aafdd9699adc98bfcf5d56c8af2402ed2ae12789734de2fb0471f7380"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/rnr/blobs/sha256:a837c604ac4157d95b648d0b9a4885287868eccf522e44f002d06096dc9145a5",
          "sha256": "a837c604ac4157d95b648d0b9a4885287868eccf522e44f002d06096dc9145a5"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "rust"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/rnr.rb",
  "ruby_source_checksum": {
    "sha256": "e14e10f3d37de8ec1078480e8afcd08812662d73874d1610a63a059e996b5e92"
  },
  "date_added": "2022-11-17T16:06:27+00:00",
  "readme": "<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/8478202/107156909-59030580-6981-11eb-9374-95959b6ec067.png\" width=\"350\" height=\"350\" alt=\"rnr\">\n</p>\n\n<p align=\"center\">\n    <a href=\"https://github.com/ismaelgv/rnr/actions?query=workflow%3ARnR\">\n        <img src=\"https://github.com/ismaelgv/rnr/workflows/RnR/badge.svg\" alt=\"Build Status\"></a>\n    <a href=\"https://crates.io/crates/rnr\">\n        <img src=\"https://img.shields.io/crates/v/rnr.svg\" alt=\"Crates.io\"></a>\n    <a href=\"https://github.com/ismaelgv/rnr/blob/master/LICENSE\">\n        <img src=\"https://img.shields.io/crates/l/rnr.svg\" alt=\"License\"></a>\n</p>\n\n<p align=\"center\">\n    <b>RnR</b> is a command-line tool to <b>securely rename</b> multiple files\n    and directories that supports regular expressions.\n</p>\n\n## Features\n* Batch rename files and directories.\n* Automated checks to avoid unwanted file collisions, removals or overwrites.\n* Use regexp, including capture groups.\n* Include directories recursively.\n* Create backup files.\n* Create and read operations from dump file.\n* Undo operations from dump file.\n* Exclude/include hidden files.\n* Linux, Mac and Windows support, including terminal coloring.\n* Extensive unit testing.\n* Select limit of replacements.\n* Convert UTF-8 file names to ASCII representation.\n\n# Install\n\n## Binaries\n\n### GitHub Releases\nYou can download binaries from [latest release\npage](https://github.com/ismaelgv/rnr/releases), choose the compressed\nfile corresponding to your platform. These compressed files contain the\nexecutable and other additional content such as completion files (*Bash*, *Zsh*,\n*fish* and *PowerShell*).\n\n### Arch Linux\nA package is available in the AUR\n([`rnr`](https://aur.archlinux.org/packages/rnr/)) to install latest version of\n*RnR* on Arch Linux.\n\n### Homebrew\nYou can use [Homebrew package manager](https://brew.sh) to install this tool in macOS or Linux systems.\n```sh\nbrew install rnr\n```\n\n## From Source\n*RnR* is written in Rust. You can build it from source using Cargo.\n\n### From git repository\n```sh\ngit clone https://github.com/ismaelgv/rnr .\ncargo install\n```\n### From Crates.io\n```sh\ncargo install rnr\n```\n# Usage\n## Options\n```\nUSAGE:\n    rnr [FLAGS] [OPTIONS] <EXPRESSION> <REPLACEMENT> <PATH(S)>...\n    rnr [FLAGS] [OPTIONS] <SUBCOMMAND>\n\nFLAGS:\n    -b, --backup          Generate file backups before renaming\n    -n, --dry-run         Only show what would be done (default mode)\n        --dump            Force dumping operations into a file even in dry-run mode\n    -f, --force           Make actual changes to files\n    -h, --help            Prints help information\n    -x, --hidden          Include hidden files and directories\n    -D, --include-dirs    Rename matching directories\n        --no-dump         Do not dump operations into a file\n    -r, --recursive       Recursive mode\n    -s, --silent          Do not print any information\n    -V, --version         Prints version information\n\nOPTIONS:\n        --color <color>            Set color output mode [default: auto]  [possible values: always, auto, never]\n    -d, --max-depth <LEVEL>        Set max depth in recursive mode\n    -l, --replace-limit <LIMIT>    Limit of replacements, all matches if set to 0 [default: 1]\n\nARGS:\n    <EXPRESSION>     Expression to match (can be a regex)\n    <REPLACEMENT>    Expression replacement\n    <PATH(S)>...     Target paths\n\nSUBCOMMANDS:\n    from-file    Read operations from a dump file\n    help         Prints this message or the help of the given subcommand(s)\n    to-ascii     Replace all file name chars with ASCII chars. This operation is extremely lossy.\n```\n\n## Default behavior\n* Checks all operations to avoid overwriting existing files.\n* *Dry-run* by default.\n* Only **UTF-8 valid** input arguments and filenames.\n* Works on files and symlinks (ignores directories).\n* Accepts multiple files as arguments.\n* Accepts a **regex** to generate matches. These expressions have same\n  limitations of `regex` crate. You can check regex syntax\n  [here](https://docs.rs/regex/#syntax). It supports numbered and named *capture\n  groups*.\n* If max depth is not provided to recursive mode, it is assumed *infinite*.\n* Does not generate backups.\n* Output is *colored* (only ANSI terminals).\n* Ignore hidden files and directories.\n* Dump all operations into a file in force mode. This dump file can be used to\n  undo these operations from `from-file` subcommand.\n* Number of replacements set to one.\n\n## Examples\n* [Rename a list of files](#rename-a-list-of-files)\n    * [Include directories](#include-directories)\n    * [Multiple replacements](#multiple-replacements)\n    * [Combination with other UNIX tools](#combination-with-other-unix-tools)\n* [Recursive rename](#recursive-rename)\n    * [Recursive rename with max directory depth](#recursive-rename-with-max-directory-depth)\n    * [Recursive rename including directories and hidden files](#recursive-rename-including-directories-and-hidden-files)\n* [Undo/redo operations using dump file](#undoredo-operations-using-dump-file)\n* [Create backup files before renaming](#create-backup-files-before-renaming)\n* [Convert UTF-8 file names to ASCII](#convert-utf-8-file-names-to-ascii)\n* [Advanced regex examples](#advanced-regex-examples)\n    * [Replace extensions](#replace-extensions)\n    * [Replace numbers](#replace-numbers)\n    * [Capture groups](#capture-groups)\n    * [Capture several named groups and swap them](#capture-several-named-groups-and-swap-them)\n\n__WINDOWS NOTE:__ In the examples that use `*`, you need to expand the wildcard in PowerShell, for example: `rnr a b (Get-Item ./*)`. This is not supported in `cmd.exe`.\n\n### Rename a list of files\nYou can pass a list of files to be renamed as arguments:\n```sh\nrnr -f file renamed ./file-01.txt ./one/file-02.txt ./one/file-03.txt\n```\n*Original tree*\n```\n.\n├── file-01.txt\n├── file-02.txt\n├── file-03.txt\n└── one\n    ├── file-01.txt\n    ├── file-02.txt\n    └── file-03.txt\n```\n*Renamed tree*\n```\n.\n├── renamed-01.txt\n├── file-02.txt\n├── file-03.txt\n└── one\n    ├── file-01.txt\n    ├── renamed-02.txt\n    └── renamed-03.txt\n```\n\n#### Include directories\nDirectories are ignored by default but you can also include them to be renamed using the option `-D`.\n```sh\nrnr -f -D foo bar ./*\n```\n*Original tree*\n```\n.\n├── foo\n│   └── foo.txt\n└── foo.txt\n```\n*Renamed tree*\n```\n.\n├── bar\n│   └── foo.txt\n└── bar.txt\n```\n\n#### Multiple replacements\nThe replacement limit is set to 1 by default, but you can configure this limit\nto replace multiple non-overlapping matches. All matches will be replaced if\nthis option is set to 0.\n\n```sh\nrnr -f -l 0 o u ./*\n```\n*Original tree*\n```\n.\n├── foo.txt\n├── foofoo.txt\n├── foofoofoo.txt\n└── foofoofoofoo.txt\n```\n*Renamed tree*\n```\n.\n├── fuu.txt\n├── fuufuu.txt\n├── fuufuufuu.txt\n└── fuufuufuufuu.txt\n```\n\n#### Combination with other UNIX tools\nYou can combine `rnr` with other UNIX tools using pipes to pass arguments.\n\n##### Find files older than 1 day and rename them\n```sh\nfind . -type f +mtime 1 | xargs rnr -f file renamed\n```\n\n##### Read list of files from a file\n```sh\ncat file_list.txt | xargs rnr -f file rename\n```\n\n`file_list.txt` content:\n```\nfile-01.txt\none/file-02.txt\none/file-03.txt\n```\n\n### Recursive rename\nIf recursive (`-r`) option is passed, `rnr` will look for al files in the path recursively without depth limit.\n```sh\nrnr -f -r file renamed ./\n```\n*Original tree*\n```\n.\n├── file-01.txt\n├── file-02.txt\n├── file-03.txt\n└── one\n    ├── file-01.txt\n    ├── file-02.txt\n    ├── file-03.txt\n    └── two\n        ├── file-01.txt\n        ├── file-02.txt\n        ├── file-03.txt\n        └── three\n            ├── file-01.txt\n            ├── file-02.txt\n            └── file-03.txt\n```\n*Renamed tree*\n```\n.\n├── renamed-01.txt\n├── renamed-02.txt\n├── renamed-03.txt\n└── one\n    ├── renamed-01.txt\n    ├── renamed-02.txt\n    ├── renamed-03.txt\n    └── two\n        ├── renamed-01.txt\n        ├── renamed-02.txt\n        ├── renamed-03.txt\n        └── three\n            ├── renamed-01.txt\n            ├── renamed-02.txt\n            └── renamed-03.txt\n```\n#### Recursive rename with max directory depth\nSimilarly, you can set a maximum directory depth in combination with recursive operations.\n```sh\nrnr -f -r -d 2 file renamed ./\n```\n*Original tree*\n```\n.\n├── file-01.txt\n├── file-02.txt\n├── file-03.txt\n└── one\n    ├── file-01.txt\n    ├── file-02.txt\n    ├── file-03.txt\n    └── two\n        ├── file-01.txt\n        ├── file-02.txt\n        ├── file-03.txt\n        └── three\n            ├── file-01.txt\n            ├── file-02.txt\n            └── file-03.txt\n```\n*Renamed tree*\n```\n.\n├── renamed-01.txt\n├── renamed-02.txt\n├── renamed-03.txt\n└── one\n    ├── renamed-01.txt\n    ├── renamed-02.txt\n    ├── renamed-03.txt\n    └── two\n        ├── file-01.txt\n        ├── file-02.txt\n        ├── file-03.txt\n        └── three\n            ├── file-01.txt\n            ├── file-02.txt\n            └── file-03.txt\n```\n\n#### Recursive rename including directories and hidden files\n`rnr` ignore hidden files by default to speed up the operations and avoid problems with some particular directories like `.git/` or `.local/`. You can include hidden files passing `-x` option. Also, you can use include directories `-D` option with `-r` too.\n```sh\nrnr -f -r -D -x foo bar ./\n```\n*Original tree*\n```\n.\n├── .foo_hidden_file.txt\n├── foo.txt\n├── foo\n│   ├── foo.txt\n│   └── foo\n│       └── foo.txt\n└── .foo_hidden_dir\n    └── foo.txt\n```\n*Renamed tree*\n```\n.\n├── .bar_hidden_file.txt\n├── bar.txt\n├── bar\n│   ├── bar.txt\n│   └── bar\n│       └── bar.txt\n└── .bar_hidden_dir\n    └── bar.txt\n```\n\n### Undo/redo operations using dump file\nWhen you perform a renaming operation, `rnr` will create by default a dump file in the current directory you executed the command. This file can be used to easily revert the operations using `from-file` and `-u` option.\n\n*Rename operation*\n```sh\nrnr -f foo bar ./*\n```\n*Undo previous operation*\n```sh\nrnr from-file -f -u rnr-[timestamp].json\n```\n\nIf you want to redo the operation just pass the dump file without any additional argument:\n```sh\nrnr from-file -f rnr-[timestamp].json\n\n```\n\n### Create backup files before renaming\n`rnr` can create backup files before renaming for any operation passing `-b` option. The backup files names are ensured to be unique and won't be overwritten if another backup is created. If you are working with many large files, take into account that files will be duplicated.\n\n```sh\nrnr -f -b file renamed ./*\n```\n\n*Original tree*\n```\n.\n├── file-01.txt\n├── file-02.txt\n└── file-03.txt\n```\n*Renamed tree*\n```\n.\n├── file-01.txt.bk\n├── file-02.txt.bk\n├── file-03.txt.bk\n├── renamed-01.txt\n├── renamed-02.txt\n└── renamed-03.txt\n```\n\n### Convert UTF-8 file names to ASCII\n`rnr`can convert UTF-8 file names to their ASCII representation. This feature uses\n[AnyAscii library](https://github.com/anyascii/anyascii) to perform the\ntransliteration.\n\nYou can run:\n```sh\nrnr to-ascii ./*\n```\nOr:\n```sh\nrnr to-ascii -r .\n```\n\n*Original tree*\n```\n.\n├── fïlé-01.txt\n├── FïĹÊ-02.txt\n└── file-03.txt\n```\n*Renamed tree*\n```\n.\n├── file-01.txt\n├── FILE-02.txt\n└── file-03.txt\n```\n\n### Advanced regex examples\nMore info about regex used [in the `regex` package](https://docs.rs/regex).\n#### Replace extensions\n```\nrnr -f '\\..*$' '.txt' ./*\n```\n*Original tree*\n```\n.\n├── file-01.ext1\n├── file-02.ext2\n└── file-03.ext3\n```\n*Renamed tree*\n```\n.\n├── file-01.txt\n├── file-02.txt\n└── file-03.txt\n```\n\n#### Replace numbers\n```\nrnr -f '\\d' '1' ./*\n```\n*Original tree*\n```\n.\n├── file-01.txt\n├── file-02.txt\n└── file-03.txt\n```\n*Renamed tree*\n```\n.\n├── file-11.txt\n├── file-12.txt\n└── file-13.txt\n```\n#### Capture groups\n1. Capture three unnamed groups [`name(1)-number(2).extension(3)`].\n2. Swap group 1 (name) and group 2 (number).\n```sh\nrnr -f '(\\w+)-(\\d+).(\\w+)' '${2}-${1}.${3}' ./*\n```\n*Original tree*\n```\n.\n├── file-01.txt\n├── file-02.txt\n└── file-03.txt\n```\n*Renamed tree*\n```\n.\n├── 01-file.txt\n├── 02-file.txt\n└── 03-file.txt\n```\n#### Capture several named groups and swap them\n1. Capture two digits as `number`.\n2. Capture extension as `ext`.\n3. Swap groups.\n```sh\nrnr -f '(?P<number>\\d{2})\\.(?P<ext>\\w{3})' '${ext}.${number}' ./*\n```\n*Original tree*\n```\n.\n├── file-01.txt\n├── file-02.txt\n└── file-03.txt\n```\n*Renamed tree*\n```\n.\n├── file-txt.01\n├── file-txt.02\n└── file-txt.03\n```"
}
