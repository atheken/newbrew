{
  "name": "vc",
  "full_name": "vc",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "SIMD Vector Classes for C++",
  "license": "BSD-3-Clause",
  "homepage": "https://github.com/VcDevel/Vc",
  "versions": {
    "stable": "1.4.2",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/VcDevel/Vc/releases/download/1.4.2/Vc-1.4.2.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "50d3f151e40b0718666935aa71d299d6370fafa67411f0a9e249fbce3e6e3952"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/vc/blobs/sha256:ed67d320940228a21363decdac79a822032888437858a6aaf396f70fa702f1a5",
          "sha256": "ed67d320940228a21363decdac79a822032888437858a6aaf396f70fa702f1a5"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/vc/blobs/sha256:3c8d1af6073bdeb469cc870f57786abd0293cebeb82f32122157428ab7ae7cc9",
          "sha256": "3c8d1af6073bdeb469cc870f57786abd0293cebeb82f32122157428ab7ae7cc9"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/vc/blobs/sha256:67e2a123067f4885b3779f9a8f005988ae16926c34298fc069d5f8c2f53f60e5",
          "sha256": "67e2a123067f4885b3779f9a8f005988ae16926c34298fc069d5f8c2f53f60e5"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/vc/blobs/sha256:216c8242dd65ff90a74b6ae6ab3e6966f20da2d226f0fa0e30df37750eff7773",
          "sha256": "216c8242dd65ff90a74b6ae6ab3e6966f20da2d226f0fa0e30df37750eff7773"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/vc/blobs/sha256:1a4687a8cea3e48b3047a577f07fd6a12742e036ed0d91a5790b4dde878dc9b0",
          "sha256": "1a4687a8cea3e48b3047a577f07fd6a12742e036ed0d91a5790b4dde878dc9b0"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/vc/blobs/sha256:8850a8e86a3ff2810f491ce25af976ec85e49601ba0b094a6543e3c0b665540b",
          "sha256": "8850a8e86a3ff2810f491ce25af976ec85e49601ba0b094a6543e3c0b665540b"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/vc/blobs/sha256:b1f8a4e74cae6267405569a0e4c774c8c68cd258cb61e56e50208f4a32d65d2a",
          "sha256": "b1f8a4e74cae6267405569a0e4c774c8c68cd258cb61e56e50208f4a32d65d2a"
        },
        "mojave": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/vc/blobs/sha256:b2b19a6798b4dd6db4355ab6d069e4b645dec1790c231a18c09e6a2a9ecf0a3f",
          "sha256": "b2b19a6798b4dd6db4355ab6d069e4b645dec1790c231a18c09e6a2a9ecf0a3f"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/vc/blobs/sha256:5076779bd0624e0642a1bdcdd1e85289afd79156716913c7a68c83192438c213",
          "sha256": "5076779bd0624e0642a1bdcdd1e85289afd79156716913c7a68c83192438c213"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "aa66a84309b297ea296f7a4b9c424b5c0ec4875c",
  "ruby_source_path": "Formula/vc.rb",
  "ruby_source_checksum": {
    "sha256": "c67a92b44277ff08f45aa9c427229702dda39d2f64f18138b199351859da5d2b"
  },
  "date_added": "2020-12-10T19:27:53+00:00",
  "readme": "**Vc is now in maintenance mode and no longer actively developed.\nHowever, we continue to review pull requests with bugfixes from the community.**\n\n**You may be interested in switching to [std-simd](https://github.com/VcDevel/std-simd).**\nGCC 11 includes an experimental version of `std::simd` as part of libstdc++, which also works with clang.\nFeatures present in Vc 1.4 and not present in *std-simd* will eventually turn into Vc 2.0,which then depends on *std-simd*.\n\n# Vc: portable, zero-overhead C++ types for explicitly data-parallel programming\n\nRecent generations of CPUs, and GPUs in particular, require data-parallel codes\nfor full efficiency. Data parallelism requires that the same sequence of\noperations is applied to different input data. CPUs and GPUs can thus reduce\nthe necessary hardware for instruction decoding and scheduling in favor of more\narithmetic and logic units, which execute the same instructions synchronously.\nOn CPU architectures this is implemented via SIMD registers and instructions.\nA single SIMD register can store N values and a single SIMD instruction can\nexecute N operations on those values. On GPU architectures N threads run in\nperfect sync, fed by a single instruction decoder/scheduler. Each thread has\nlocal memory and a given index to calculate the offsets in memory for loads and\nstores.\n\nCurrent C++ compilers can do automatic transformation of scalar codes to SIMD\ninstructions (auto-vectorization). However, the compiler must reconstruct an\nintrinsic property of the algorithm that was lost when the developer wrote a\npurely scalar implementation in C++. Consequently, C++ compilers cannot\nvectorize any given code to its most efficient data-parallel variant.\nEspecially larger data-parallel loops, spanning over multiple functions or even\ntranslation units, will often not be transformed into efficient SIMD code.\n\nThe Vc library provides the missing link. Its types enable explicitly stating\ndata-parallel operations on multiple values. The parallelism is therefore added\nvia the type system. Competing approaches state the parallelism via new control\nstructures and consequently new semantics inside the body of these control\nstructures.\n\nVc is a free software library to ease explicit vectorization of C++ code. It\nhas an intuitive API and provides portability between different compilers and\ncompiler versions as well as portability between different vector instruction\nsets. Thus an application written with Vc can be compiled for:\n\n* AVX and AVX2\n* SSE2 up to SSE4.2 or SSE4a\n* Scalar\n* ~~AVX-512 (Vc 2 development)~~\n* ~~NEON (in development)~~\n* ~~NVIDIA GPUs / CUDA (research)~~\n\nAfter Intel dropped MIC support with ICC 18, Vc 1.4 also removed support for it.\n\n## Examples\n\n### Usage on Compiler Explorer\n\n* [Simdize Example](https://godbolt.org/z/JVEM2j)\n* [Total momentum and time stepping of `std::vector<Particle>`](https://godbolt.org/z/JNdkL9)\n* [Matrix Example](https://godbolt.org/z/fFEkuX): This uses vertical\n  vectorization which does not scale to different vector sizes. However, the\n  example is instructive to compare it with similar solutions of other languages\n  or libraries.\n* [N-vortex solver](https://godbolt.org/z/4o1cg_) showing `simdize`d iteration\n  over many `std::vector<float>`. Note how [important the `-march` flag is, compared\n  to plain `-mavx2 -mfma`](https://godbolt.org/z/hKiOjr).\n\n### Scalar Product\n\nLet's start from the code for calculating a 3D scalar product using builtin floats:\n```cpp\nusing Vec3D = std::array<float, 3>;\nfloat scalar_product(Vec3D a, Vec3D b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n```\nUsing Vc, we can easily vectorize the code using the `float_v` type:\n```cpp\nusing Vc::float_v\nusing Vec3D = std::array<float_v, 3>;\nfloat_v scalar_product(Vec3D a, Vec3D b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n```\nThe above will scale to 1, 4, 8, 16, etc. scalar products calculated in parallel, depending\non the target hardware's capabilities.\n\nFor comparison, the same vectorization using Intel SSE intrinsics is more verbose and uses\nprefix notation (i.e. function calls):\n```cpp\nusing Vec3D = std::array<__m128, 3>;\n__m128 scalar_product(Vec3D a, Vec3D b) {\n  return _mm_add_ps(_mm_add_ps(_mm_mul_ps(a[0], b[0]), _mm_mul_ps(a[1], b[1])),\n                    _mm_mul_ps(a[2], b[2]));\n}\n```\nThe above will neither scale to AVX, AVX-512, etc. nor is it portable to other SIMD ISAs.\n\n## Build Requirements\n\ncmake >= 3.0\n\nC++11 Compiler:\n\n* GCC >= 4.8.1\n* clang >= 3.4\n* ICC >= 18.0.5\n* Visual Studio 2019 (64-bit target)\n\n\n## Building and Installing Vc\n\n* Clone Vc and initialize Vc's git submodules:\n\n```sh\ngit clone https://github.com/VcDevel/Vc.git\ncd Vc\ngit submodule update --init\n```\n\n* Create a build directory:\n\n```sh\n$ mkdir build\n$ cd build\n```\n\n* Configure with cmake and add relevant options:\n\n```sh\n$ cmake ..\n```\n\nOptionally, specify an installation directory:\n\n```sh\n$ cmake -DCMAKE_INSTALL_PREFIX=/opt/Vc ..\n```\n\nOptionally, include building the unit tests:\n\n```sh\n$ cmake -DBUILD_TESTING=ON ..\n```\n\nOn Windows, if you have multiple versions of Visual Studio installed, you can select one:\n\n```sh\n$ cmake -G \"Visual Studio 16 2019\" ..\n```\n\nSee `cmake --help` for a list of possible generators.\n\n\n* Build and install:\n\n```sh\n$ cmake --build . -j 16\n$ cmake --install . # may require permissions\n```\n\nOn Windows, you can also open `Vc.sln` in Visual Studio and build/install from the IDE.\n\n## Documentation\n\nThe documentation is generated via [doxygen](http://doxygen.org). You can build\nthe documentation by running `doxygen` in the `doc` subdirectory.\nAlternatively, you can find nightly builds of the documentation at:\n\n* [1.4 branch](https://vcdevel.github.io/Vc-1.4/)\n* [1.4.3 release](https://vcdevel.github.io/Vc-1.4.3/)\n* [1.4.2 release](https://vcdevel.github.io/Vc-1.4.2/)\n* [1.4.1 release](https://vcdevel.github.io/Vc-1.4.1/)\n* [1.4.0 release](https://vcdevel.github.io/Vc-1.4.0/)\n* [1.3 branch](https://vcdevel.github.io/Vc-1.3/)\n* [1.3.0 release](https://vcdevel.github.io/Vc-1.3.0/)\n* [1.2.0 release](https://vcdevel.github.io/Vc-1.2.0/)\n* [1.1.0 release](https://vcdevel.github.io/Vc-1.1.0/)\n* [0.7 branch](https://vcdevel.github.io/Vc-0.7/)\n\n## Publications\n\n* [M. Kretz, \"Extending C++ for Explicit Data-Parallel Programming via SIMD\n  Vector Types\", Goethe University Frankfurt, Dissertation,\n  2015.](http://publikationen.ub.uni-frankfurt.de/frontdoor/index/index/docId/38415)\n* [M. Kretz and V. Lindenstruth, \"Vc: A C++ library for explicit\n  vectorization\", Software: Practice and Experience,\n  2011.](http://dx.doi.org/10.1002/spe.1149)\n* [M. Kretz, \"Efficient Use of Multi- and Many-Core Systems with Vectorization\n  and Multithreading\", University of Heidelberg,\n  2009.](http://code.compeng.uni-frankfurt.de/attachments/13/Diplomarbeit.pdf)\n\n[Work on integrating the functionality of Vc in the C++ standard library.](\nhttps://github.com/VcDevel/Vc/wiki/ISO-Standardization-of-the-Vector-classes)\n\n## License\n\nVc is released under the terms of the [3-clause BSD license](http://opensource.org/licenses/BSD-3-Clause)."
}
