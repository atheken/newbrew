{
  "name": "git-secrets",
  "full_name": "git-secrets",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Prevents you from committing sensitive information to a git repo",
  "license": "Apache-2.0",
  "homepage": "https://github.com/awslabs/git-secrets",
  "versions": {
    "stable": "1.3.0",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/awslabs/git-secrets/archive/1.3.0.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "f1d50c6c5c7564f460ff8d279081879914abe920415c2923934c1f1d1fac3606"
    },
    "head": {
      "url": "https://github.com/awslabs/git-secrets.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/git-secrets/blobs/sha256:3514dfa1af5dfeacdee08546d64f3d60766318d386af8ff7f9a0057314fe7d33",
          "sha256": "3514dfa1af5dfeacdee08546d64f3d60766318d386af8ff7f9a0057314fe7d33"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/git-secrets/blobs/sha256:3514dfa1af5dfeacdee08546d64f3d60766318d386af8ff7f9a0057314fe7d33",
          "sha256": "3514dfa1af5dfeacdee08546d64f3d60766318d386af8ff7f9a0057314fe7d33"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/git-secrets/blobs/sha256:e9de924f892439c26efd7c99bf498edb0425f2ca2ed1b2f6a41894f22a45e362",
          "sha256": "e9de924f892439c26efd7c99bf498edb0425f2ca2ed1b2f6a41894f22a45e362"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/git-secrets/blobs/sha256:3514dfa1af5dfeacdee08546d64f3d60766318d386af8ff7f9a0057314fe7d33",
          "sha256": "3514dfa1af5dfeacdee08546d64f3d60766318d386af8ff7f9a0057314fe7d33"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/git-secrets/blobs/sha256:3514dfa1af5dfeacdee08546d64f3d60766318d386af8ff7f9a0057314fe7d33",
          "sha256": "3514dfa1af5dfeacdee08546d64f3d60766318d386af8ff7f9a0057314fe7d33"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/git-secrets/blobs/sha256:847ce4314909e69c8c5e30d67599c1b7892ceb27016a1b4636a4b92a9996bb97",
          "sha256": "847ce4314909e69c8c5e30d67599c1b7892ceb27016a1b4636a4b92a9996bb97"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/git-secrets/blobs/sha256:92ae3c8447754b1f5d23b5e7e3a601fca133f4b691b51b5004ffe17f4d763622",
          "sha256": "92ae3c8447754b1f5d23b5e7e3a601fca133f4b691b51b5004ffe17f4d763622"
        },
        "mojave": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/git-secrets/blobs/sha256:d77761ee552d2963788f2bcab6c695d1b52f9d0c1d68dad65230901c750e63aa",
          "sha256": "d77761ee552d2963788f2bcab6c695d1b52f9d0c1d68dad65230901c750e63aa"
        },
        "high_sierra": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/git-secrets/blobs/sha256:d77761ee552d2963788f2bcab6c695d1b52f9d0c1d68dad65230901c750e63aa",
          "sha256": "d77761ee552d2963788f2bcab6c695d1b52f9d0c1d68dad65230901c750e63aa"
        },
        "sierra": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/git-secrets/blobs/sha256:fc2745b24be00e6b8e4b82d6768632810823ffff3f80ad99ca9943b31d003003",
          "sha256": "fc2745b24be00e6b8e4b82d6768632810823ffff3f80ad99ca9943b31d003003"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/git-secrets/blobs/sha256:375d6c697493099bc84e7b61eadeadbb75a34c05d724b558a3ff03d7e267d196",
          "sha256": "375d6c697493099bc84e7b61eadeadbb75a34c05d724b558a3ff03d7e267d196"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/git-secrets.rb",
  "ruby_source_checksum": {
    "sha256": "1ff7931406d695de002b4775c92a1a789a3bbfba35c368451acae1589d5e8c33"
  },
  "date_added": "2015-12-25T20:13:40+00:00",
  "readme": "===========\ngit-secrets\n===========\n\n-------------------------------------------------------------------------------------------\nPrevents you from committing passwords and other sensitive information to a git repository.\n-------------------------------------------------------------------------------------------\n\n.. contents:: :depth: 2\n\nSynopsis\n--------\n\n::\n\n    git secrets --scan [-r|--recursive] [--cached] [--no-index] [--untracked] [<files>...]\n    git secrets --scan-history\n    git secrets --install [-f|--force] [<target-directory>]\n    git secrets --list [--global]\n    git secrets --add [-a|--allowed] [-l|--literal] [--global] <pattern>\n    git secrets --add-provider [--global] <command> [arguments...]\n    git secrets --register-aws [--global]\n    git secrets --aws-provider [<credentials-file>]\n\n\nDescription\n-----------\n\n``git-secrets`` scans commits, commit messages, and ``--no-ff`` merges to\nprevent adding secrets into your git repositories. If a commit,\ncommit message, or any commit in a ``--no-ff`` merge history matches one of\nyour configured prohibited regular expression patterns, then the commit is\nrejected.\n\n\nInstalling git-secrets\n----------------------\n\n``git-secrets`` must be placed somewhere in your PATH so that it is picked up\nby ``git`` when running ``git secrets``.\n\n\\*nix (Linux/macOS)\n~~~~~~~~~~~~~~~~~~~\n\nYou can use the ``install`` target of the provided Makefile to install ``git secrets`` and the man page.\nYou can customize the install path using the PREFIX and MANPREFIX variables.\n\n::\n\n    make install\n\nWindows\n~~~~~~~\n\nRun the provided ``install.ps1`` powershell script. This will copy the needed files\nto an installation directory (``%USERPROFILE%/.git-secrets`` by default) and add\nthe directory to the current user ``PATH``.\n\n::\n\n    PS > ./install.ps1\n\nHomebrew (for macOS users)\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    brew install git-secrets\n\n.. warning::\n\n    **You're not done yet! You MUST install the git hooks for every repo that\n    you wish to use with** ``git secrets --install``.\n\nHere's a quick example of how to ensure a git repository is scanned for secrets\non each commit::\n\n    cd /path/to/my/repo\n    git secrets --install\n    git secrets --register-aws\n\n\nAdvanced configuration\n----------------------\n\nAdd a configuration template if you want to add hooks to all repositories you\ninitialize or clone in the future.\n\n::\n\n    git secrets --register-aws --global\n\n\nAdd hooks to all your local repositories.\n\n::\n\n    git secrets --install ~/.git-templates/git-secrets\n    git config --global init.templateDir ~/.git-templates/git-secrets\n\n\nAdd custom providers to scan for security credentials.\n\n::\n\n    git secrets --add-provider -- cat /path/to/secret/file/patterns\n\n\nBefore making public a repository\n---------------------------------\n\nWith git-secrets is also possible to scan a repository including all revisions:\n\n::\n\n    git secrets --scan-history\n\n\nOptions\n-------\n\nOperation Modes\n~~~~~~~~~~~~~~~\n\nEach of these options must appear first on the command line.\n\n``--install``\n    Installs git hooks for a repository. Once the hooks are installed for a git\n    repository, commits and non-fast-forward merges for that repository will be prevented\n    from committing secrets.\n\n``--scan``\n    Scans one or more files for secrets. When a file contains a secret, the\n    matched text from the file being scanned will be written to stdout and the\n    script will exit with a non-zero status. Each matched line will be written with\n    the name of the file that matched, a colon, the line number that matched,\n    a colon, and then the line of text that matched. If no files are provided,\n    all files returned by ``git ls-files`` are scanned.\n\n``--scan-history``\n    Scans repository including all revisions. When a file contains a secret, the\n    matched text from the file being scanned will be written to stdout and the\n    script will exit with a non-zero status. Each matched line will be written with\n    the name of the file that matched, a colon, the line number that matched,\n    a colon, and then the line of text that matched.\n\n``--list``\n    Lists the ``git-secrets`` configuration for the current repo or in the global\n    git config.\n\n``--add``\n    Adds a prohibited or allowed pattern.\n\n``--add-provider``\n    Registers a secret provider. Secret providers are executables that when\n    invoked output prohibited patterns that ``git-secrets`` should treat as\n    prohibited.\n\n``--register-aws``\n    Adds common AWS patterns to the git config and ensures that keys present\n    in ``~/.aws/credentials`` are not found in any commit. The following\n    checks are added:\n\n    - AWS Access Key IDs via ``(A3T[A-Z0-9]|AKIA|AGPA|AIDA|AROA|AIPA|ANPA|ANVA|ASIA)[A-Z0-9]{16}``\n    - AWS Secret Access Key assignments via \":\" or \"=\" surrounded by optional\n      quotes\n    - AWS account ID assignments via \":\" or \"=\" surrounded by optional quotes\n    - Allowed patterns for example AWS keys (``AKIAIOSFODNN7EXAMPLE`` and\n      ``wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY``)\n    - Known credentials from ``~/.aws/credentials``\n\n    .. note::\n\n        While the patterns registered by this command should catch most\n        instances of AWS credentials, these patterns are **not** guaranteed to\n        catch them **all**. ``git-secrets`` should be used as an extra means of\n        insurance -- you still need to do your due diligence to ensure that you\n        do not commit credentials to a repository.\n\n``--aws-provider``\n    Secret provider that outputs credentials found in an INI file. You can\n    optionally provide the path to an INI file.\n\n\nOptions for ``--install``\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\n``-f, --force``\n    Overwrites existing hooks if present.\n\n``<target-directory>``\n    When provided, installs git hooks to the given directory. The current\n    directory is assumed if ``<target-directory>`` is not provided.\n\n    If the provided ``<target-directory>`` is not in a git repository, the\n    directory will be created and hooks will be placed in\n    ``<target-directory>/hooks``. This can be useful for creating git template\n    directories using with ``git init --template <target-directory>``.\n\n    You can run ``git init`` on a repository that has already been initialized.\n    From the `git init documentation <https://git-scm.com/docs/git-init>`_:\n\n        From the git documentation: Running ``git init`` in an existing repository\n        is safe. It will not overwrite things that are already there. The\n        primary reason for rerunning ``git init`` is to pick up newly added\n        templates (or to move the repository to another place if\n        ``--separate-git-dir`` is given).\n\n    The following git hooks are installed:\n\n    1. ``pre-commit``: Used to check if any of the files changed in the commit\n       use prohibited patterns.\n    2. ``commit-msg``: Used to determine if a commit message contains a\n       prohibited patterns.\n    3. ``prepare-commit-msg``: Used to determine if a merge commit will\n       introduce a history that contains a prohibited pattern at any point.\n       Please note that this hook is only invoked for non fast-forward merges.\n\n    .. note::\n\n        Git only allows a single script to be executed per hook. If the\n        repository contains Debian-style subdirectories like ``pre-commit.d``\n        and ``commit-msg.d``, then the git hooks will be installed into these\n        directories, which assumes that you've configured the corresponding\n        hooks to execute all of the scripts found in these directories. If\n        these git subdirectories are not present, then the git hooks will be\n        installed to the git repo's ``.git/hooks`` directory.\n\n\nExamples\n^^^^^^^^\n\nInstall git hooks to the current directory::\n\n    cd /path/to/my/repository\n    git secrets --install\n\nInstall git hooks to a repository other than the current directory::\n\n    git secrets --install /path/to/my/repository\n\nCreate a git template that has ``git-secrets`` installed, and then copy that\ntemplate into a git repository::\n\n    git secrets --install ~/.git-templates/git-secrets\n    git init --template ~/.git-templates/git-secrets\n\nOverwrite existing hooks if present::\n\n    git secrets --install -f\n\n\nOptions for ``--scan``\n~~~~~~~~~~~~~~~~~~~~~~\n\n``-r, --recursive``\n    Scans the given files recursively. If a directory is encountered, the\n    directory will be scanned. If ``-r`` is not provided, directories will be\n    ignored.\n\n    ``-r`` cannot be used alongside ``--cached``, ``--no-index``, or\n    ``--untracked``.\n\n``--cached``\n    Searches blobs registered in the index file.\n\n``--no-index``\n    Searches files in the current directory that is not managed by git.\n\n``--untracked``\n    In addition to searching in the tracked files in the working tree,\n    ``--scan`` also in untracked files.\n\n``<files>...``\n    The path to one or more files on disk to scan for secrets.\n\n    If no files are provided, all files returned by ``git ls-files`` are\n    scanned.\n\n\nExamples\n^^^^^^^^\n\nScan all files in the repo::\n\n    git secrets --scan\n\nScans a single file for secrets::\n\n    git secrets --scan /path/to/file\n\nScans a directory recursively for secrets::\n\n    git secrets --scan -r /path/to/directory\n\nScans multiple files for secrets::\n\n    git secrets --scan /path/to/file /path/to/other/file\n\nYou can scan by globbing::\n\n    git secrets --scan /path/to/directory/*\n\nScan from stdin::\n\n    echo 'hello!' | git secrets --scan -\n\n\nOptions for ``--list``\n~~~~~~~~~~~~~~~~~~~~~~\n\n``--global``\n    Lists only git-secrets configuration in the global git config.\n\n\nOptions for ``--add``\n~~~~~~~~~~~~~~~~~~~~~\n\n``--global``\n    Adds patterns to the global git config\n\n``-l, --literal``\n    Escapes special regular expression characters in the provided pattern so\n    that the pattern is searched for literally.\n\n``-a, --allowed``\n    Mark the pattern as allowed instead of prohibited. Allowed patterns are\n    used to filter out false positives.\n\n``<pattern>``\n    The regex pattern to search.\n\n\nExamples\n^^^^^^^^\n\nAdds a prohibited pattern to the current repo::\n\n    git secrets --add '[A-Z0-9]{20}'\n\nAdds a prohibited pattern to the global git config::\n\n    git secrets --add --global '[A-Z0-9]{20}'\n\nAdds a string that is scanned for literally (``+`` is escaped)::\n\n    git secrets --add --literal 'foo+bar'\n\nAdd an allowed pattern::\n\n    git secrets --add -a 'allowed pattern'\n\n\nOptions for ``--register-aws``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n``--global``\n    Adds AWS specific configuration variables to the global git config.\n\n\nOptions for ``--aws-provider``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n``[<credentials-file>]``\n    If provided, specifies the custom path to an INI file to scan. If not\n    provided, ``~/.aws/credentials`` is assumed.\n\n\nOptions for ``--add-provider``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n``--global``\n    Adds the provider to the global git config.\n\n``<command>``\n    Provider command to invoke. When invoked the command is expected to write\n    prohibited patterns separated by new lines to stdout. Any extra arguments\n    provided are passed on to the command.\n\n\nExamples\n^^^^^^^^\n\nRegisters a secret provider with arguments::\n\n    git secrets --add-provider -- git secrets --aws-provider\n\nCats secrets out of a file::\n\n    git secrets --add-provider -- cat /path/to/secret/file/patterns\n\n\nDefining prohibited patterns\n----------------------------\n\n``egrep``-compatible regular expressions are used to determine if a commit or\ncommit message contains any prohibited patterns. These regular expressions are\ndefined using the ``git config`` command. It is important to note that\ndifferent systems use different versions of egrep. For example, when running on\nmacOS, you will use a different version of ``egrep`` than when running on something\nlike Ubuntu (BSD vs GNU).\n\nYou can add prohibited regular expression patterns to your git config using\n``git secrets --add <pattern>``.\n\n\nIgnoring false positives\n------------------------\n\nSometimes a regular expression might match false positives. For example, git\ncommit SHAs look a lot like AWS access keys. You can specify many different\nregular expression patterns as false positives using the following command:\n\n::\n\n    git secrets --add --allowed 'my regex pattern'\n\nYou can also add regular expressions patterns to filter false positives to a\n``.gitallowed`` file located in the repository's root directory. Lines starting\nwith ``#`` are skipped (comment line) and empty lines are also skipped.\n\nFirst, git-secrets will extract all lines from a file that contain a prohibited\nmatch. Included in the matched results will be the full path to the name of\nthe file that was matched, followed by ':', followed by the line number that was\nmatched, followed by the entire line from the file that was matched by a secret\npattern. Then, if you've defined allowed regular expressions, git-secrets will\ncheck to see if all of the matched lines match at least one of your registered\nallowed regular expressions. If all of the lines that were flagged as secret\nare canceled out by an allowed match, then the subject text does not contain\nany secrets. If any of the matched lines are not matched by an allowed regular\nexpression, then git-secrets will fail the commit/merge/message.\n\n.. important::\n\n    Just as it is a bad practice to add prohibited patterns that are too\n    greedy, it is also a bad practice to add allowed patterns that are too\n    forgiving. Be sure to test out your patterns using ad-hoc calls to\n    ``git secrets --scan $filename`` to ensure they are working as intended.\n\n\nSecret providers\n----------------\n\nSometimes you want to check for an exact pattern match against a set of known\nsecrets. For example, you might want to ensure that no credentials present in\n``~/.aws/credentials`` ever show up in a commit. In these cases, it's better to\nleave these secrets in one location rather than spread them out across git\nrepositories in git configs. You can use \"secret providers\" to fetch these\ntypes of credentials. A secret provider is an executable that when invoked\noutputs prohibited patterns separated by new lines.\n\nYou can add secret providers using the ``--add-provider`` command::\n\n    git secrets --add-provider -- git secrets --aws-provider\n\nNotice the use of ``--``. This ensures that any arguments associated with the\nprovider are passed to the provider each time it is invoked when scanning\nfor secrets.\n\n\nExample walkthrough\n-------------------\n\nLet's take a look at an example. Given the following subject text (stored in\n``/tmp/example``)::\n\n    This is a test!\n    password=ex@mplepassword\n    password=******\n    More test...\n\nAnd the following registered patterns:\n\n::\n\n    git secrets --add 'password\\s*=\\s*.+'\n    git secrets --add --allowed --literal 'ex@mplepassword'\n\nRunning ``git secrets --scan /tmp/example``, the result will\nresult in the following error output::\n\n    /tmp/example:3:password=******\n\n    [ERROR] Matched prohibited pattern\n\n    Possible mitigations:\n    - Mark false positives as allowed using: git config --add secrets.allowed ...\n    - List your configured patterns: git config --get-all secrets.patterns\n    - List your configured allowed patterns: git config --get-all secrets.allowed\n    - Use --no-verify if this is a one-time false positive\n\nBreaking this down, the prohibited pattern value of ``password\\s*=\\s*.+`` will\nmatch the following lines::\n\n    /tmp/example:2:password=ex@mplepassword\n    /tmp/example:3:password=******\n\n...But the first match will be filtered out due to the fact that it matches the\nallowed regular expression of ``ex@mplepassword``. Because there is still a\nremaining line that did not match, it is considered a secret.\n\nBecause that matching lines are placed on lines that start with the filename\nand line number (e.g., ``/tmp/example:3:...``), you can create allowed\npatterns that take filenames and line numbers into account in the regular\nexpression. For example, you could whitelist an entire file using something\nlike::\n\n    git secrets --add --allowed '/tmp/example:.*'\n    git secrets --scan /tmp/example && echo $?\n    # Outputs: 0\n\nAlternatively, you could allow a specific line number of a file if that\nline is unlikely to change using something like the following:\n\n::\n\n    git secrets --add --allowed '/tmp/example:3:.*'\n    git secrets --scan /tmp/example && echo $?\n    # Outputs: 0\n\nKeep this in mind when creating allowed patterns to ensure that your allowed\npatterns are not inadvertently matched due to the fact that the filename is\nincluded in the subject text that allowed patterns are matched against.\n\n\nSkipping validation\n-------------------\n\nUse the ``--no-verify`` option in the event of a false positive match in a\ncommit, merge, or commit message. This will skip the execution of the\ngit hook and allow you to make the commit or merge.\n\n\nAbout\n------\n\n- Author: `Michael Dowling <https://github.com/mtdowling>`_\n- Issue tracker: This project's source code and issue tracker can be found at\n  `https://github.com/awslabs/git-secrets <https://github.com/awslabs/git-secrets>`_\n- Special thanks to Adrian Vatchinsky and Ari Juels of Cornell University for\n  providing suggestions and feedback.\n\nCopyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved."
}
