{
  "name": "fst",
  "full_name": "fst",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Represent large sets and maps compactly with finite state transducers",
  "license": "Unlicense or MIT",
  "homepage": "https://github.com/BurntSushi/fst",
  "versions": {
    "stable": "0.4.3",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/BurntSushi/fst/archive/refs/tags/fst-bin-0.4.3.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "13d1b28a6a6eaf5ce53c1840e7e6c2cb42ff7f846cd57047ddd32601667c8a5f"
    },
    "head": {
      "url": "https://github.com/BurntSushi/fst.git",
      "branch": "master"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/fst/blobs/sha256:5ad7bfd34ae243f510522166d02bd9fc1ad24488cfc16a68d25f96e84ab1ec87",
          "sha256": "5ad7bfd34ae243f510522166d02bd9fc1ad24488cfc16a68d25f96e84ab1ec87"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/fst/blobs/sha256:7e96ce0a1e5e150f27ed111738f01576734e65a4dd1d5799bb3819df0c91d363",
          "sha256": "7e96ce0a1e5e150f27ed111738f01576734e65a4dd1d5799bb3819df0c91d363"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/fst/blobs/sha256:046025781603f0f516c317c8f87a9e2a106eda8d1fc5a2e19303e17d0b4e0b1a",
          "sha256": "046025781603f0f516c317c8f87a9e2a106eda8d1fc5a2e19303e17d0b4e0b1a"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/fst/blobs/sha256:b2674c7f7e94b5381849dd98ed9a17556e5cabd43ff4696d796f2489884bb7d8",
          "sha256": "b2674c7f7e94b5381849dd98ed9a17556e5cabd43ff4696d796f2489884bb7d8"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/fst/blobs/sha256:c947b6915cd67c7c86b1606ab6e9f09ff4aa258ce0282125da3b3072fa06445a",
          "sha256": "c947b6915cd67c7c86b1606ab6e9f09ff4aa258ce0282125da3b3072fa06445a"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/fst/blobs/sha256:daef781d826e2aa4384e136cb9c815b603676b0a7b4376b646619f0a03fe5790",
          "sha256": "daef781d826e2aa4384e136cb9c815b603676b0a7b4376b646619f0a03fe5790"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/fst/blobs/sha256:e05329c5e355ffab20c7a71127133ff6f961b0c36fb5ef2509e5c159cb517e8c",
          "sha256": "e05329c5e355ffab20c7a71127133ff6f961b0c36fb5ef2509e5c159cb517e8c"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "rust"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/fst.rb",
  "ruby_source_checksum": {
    "sha256": "c7379a1baf933832b22e4601fd35264fc3dd96aac23265c343078c3f96cfe90c"
  },
  "date_added": "2021-08-22T17:33:56+00:00",
  "readme": "fst\n===\nThis crate provides a fast implementation of ordered sets and maps using finite\nstate machines. In particular, it makes use of finite state transducers to map\nkeys to values as the machine is executed. Using finite state machines as data\nstructures enables us to store keys in a compact format that is also easily\nsearchable. For example, this crate leverages memory maps to make range queries\nvery fast.\n\nCheck out my blog post\n[Index 1,600,000,000 Keys with Automata and\nRust](https://blog.burntsushi.net/transducers/)\nfor extensive background, examples and experiments.\n\n[![Build status](https://github.com/BurntSushi/fst/workflows/ci/badge.svg)](https://github.com/BurntSushi/fst/actions)\n[![](https://meritbadge.herokuapp.com/fst)](https://crates.io/crates/fst)\n\nDual-licensed under MIT or the [UNLICENSE](https://unlicense.org/).\n\n\n### Documentation\n\nhttps://docs.rs/fst\n\nThe\n[`regex-automata`](https://docs.rs/regex-automata)\ncrate provides implementations of the `fst::Automata` trait when its\n`transducer` feature is enabled. This permits using DFAs compiled by\n`regex-automata` to search finite state transducers produced by this crate.\n\n\n### Installation\n\nSimply add a corresponding entry to your `Cargo.toml` dependency list:\n\n```toml,ignore\n[dependencies]\nfst = \"0.4\"\n```\n\n\n### Example\n\nThis example demonstrates building a set in memory and executing a fuzzy query\nagainst it. You'll need `fst = \"0.4\"` with the `levenshtein` feature enabled in\nyour `Cargo.toml`.\n\n```rust\nuse fst::{IntoStreamer, Set};\nuse fst::automaton::Levenshtein;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n  // A convenient way to create sets in memory.\n  let keys = vec![\"fa\", \"fo\", \"fob\", \"focus\", \"foo\", \"food\", \"foul\"];\n  let set = Set::from_iter(keys)?;\n\n  // Build our fuzzy query.\n  let lev = Levenshtein::new(\"foo\", 1)?;\n\n  // Apply our fuzzy query to the set we built.\n  let stream = set.search(lev).into_stream();\n\n  let keys = stream.into_strs()?;\n  assert_eq!(keys, vec![\"fo\", \"fob\", \"foo\", \"food\"]);\n  Ok(())\n}\n```\n\nCheck out the documentation for a lot more examples!\n\n\n### Cargo features\n\n* `levenshtein` - **Disabled** by default. This adds the `Levenshtein`\n  automaton to the `automaton` sub-module. This includes an additional\n  dependency on `utf8-ranges`."
}
