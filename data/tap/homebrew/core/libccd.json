{
  "name": "libccd",
  "full_name": "libccd",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Collision detection between two convex shapes",
  "license": "BSD-3-Clause",
  "homepage": "https://github.com/danfis/libccd",
  "versions": {
    "stable": "2.1",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/danfis/libccd/archive/v2.1.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "542b6c47f522d581fbf39e51df32c7d1256ac0c626e7c2b41f1040d4b9d50d1e"
    }
  },
  "revision": 1,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libccd/blobs/sha256:9db2e87ee4c5b69faa9269a54f22046b5c4d18a72a65bc0dd4164c35a23edbe1",
          "sha256": "9db2e87ee4c5b69faa9269a54f22046b5c4d18a72a65bc0dd4164c35a23edbe1"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libccd/blobs/sha256:95bbd2e402b8388a6b348fd755b6997ae765568357115013996efe9e596f982f",
          "sha256": "95bbd2e402b8388a6b348fd755b6997ae765568357115013996efe9e596f982f"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libccd/blobs/sha256:69d8c269bc6c5f60d141eaebe6bdff9cf333f789c4d3b72cd69b1e61edff3ea3",
          "sha256": "69d8c269bc6c5f60d141eaebe6bdff9cf333f789c4d3b72cd69b1e61edff3ea3"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libccd/blobs/sha256:6c11cd8ecc1c3434badf237f5b2169731ce62698f07e3dea3fe2420c57186deb",
          "sha256": "6c11cd8ecc1c3434badf237f5b2169731ce62698f07e3dea3fe2420c57186deb"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libccd/blobs/sha256:b07fdb5107c0a1e3b912f441d338729ff2d58a50b65f3d6f5d013e26fa1c9dc2",
          "sha256": "b07fdb5107c0a1e3b912f441d338729ff2d58a50b65f3d6f5d013e26fa1c9dc2"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libccd/blobs/sha256:8257a7f8ab8f5eca8fced2e881b96a68202c08ce94a4aa169d1d80149b61eb0f",
          "sha256": "8257a7f8ab8f5eca8fced2e881b96a68202c08ce94a4aa169d1d80149b61eb0f"
        },
        "catalina": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libccd/blobs/sha256:caa0aba8d2ba740998b54c73d3ab038747ac984e4d27797b9f768195a487dc4e",
          "sha256": "caa0aba8d2ba740998b54c73d3ab038747ac984e4d27797b9f768195a487dc4e"
        },
        "mojave": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/libccd/blobs/sha256:47c19c5f277ecc9016ef1e62a3ce1a0c4aafd1c91e6893fb4f251183ebd505ec",
          "sha256": "47c19c5f277ecc9016ef1e62a3ce1a0c4aafd1c91e6893fb4f251183ebd505ec"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/libccd/blobs/sha256:6bee053612267522f0eb8c55c24a68dddb787126f46771fc8459d4d3460aa077",
          "sha256": "6bee053612267522f0eb8c55c24a68dddb787126f46771fc8459d4d3460aa077"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/libccd.rb",
  "ruby_source_checksum": {
    "sha256": "e1b1831d545cb1415391bb144b3a941c0552db3b7b4fb1e5689e9eb3066e476c"
  },
  "date_added": "2018-01-23T21:27:24+01:00",
  "readme": "# libccd [![Build Status](https://travis-ci.org/danfis/libccd.svg?branch=master)](https://travis-ci.org/danfis/libccd)\n\n***libccd*** is library for a collision detection between two convex shapes.\nlibccd implements variation on Gilbert–Johnson–Keerthi algorithm plus Expand\nPolytope Algorithm (EPA) and also implements algorithm Minkowski Portal\nRefinement (MPR, a.k.a. XenoCollide) as described in Game Programming Gems 7.\n\nlibccd is the only available open source library of my knowledge that include\nMPR algorithm working in 3-D space.  However, there is a library called\n[mpr2d](http://code.google.com/p/mpr2d/), implemented in D programming\nlanguage, that works in 2-D space.\n\nlibccd is currently part of:\n\n1. [ODE](http://www.ode.org/) library (see ODE's *./configure --help* how to enable it),\n2. [FCL](http://www.ros.org/wiki/fcl) library from [Willow Garage](http://www.willowgarage.com/),\n3. [Bullet3](http://bulletphysics.org/) library (https://github.com/bulletphysics/bullet3).\n\nFor implementation details on GJK algorithm, see\nhttp://www.win.tue.nl/~gino/solid/jgt98convex.pdf.\n\n\n## Dependencies\n\nThis library is currently based only on standard libraries.\nThe only exception are testsuites that are built on top of CU\n(https://github.com/danfis/cu) library licensed under LGPL, however only\ntesting depends on it and libccd library itself can be distributed without it.\n\n\n## License\n\nlibccd is licensed under OSI-approved 3-clause BSD License, text of license\nis distributed along with source code in BSD-LICENSE file.\nEach file should include license notice, the rest should be considered as\nlicensed under 3-clause BSD License.\n\n\n## Compile And Install\n\nlibccd contains several mechanisms for compiling and installing. Using a simple Makefile, using autotools, and using CMake.\n\n### 1. Using Makefile\n\nDirectory src/ contains Makefile that should contain everything needed for compilation and installation:\n```sh\n  $ cd src/\n  $ make\n  $ make install\n```\n\nLibrary libccd is by default compiled in double precision of floating point numbers - you can change this by options *USE_SINGLE/USE_DOUBLE*, i.e.:\n```sh\n  $ make USE_SINGLE=yes\n```\nwill compile library in single precision.\n\nInstallation directory can be changed by options PREFIX, INCLUDEDIR and LIBDIR. \nFor more info type 'make help'.\n\n### 2. Using Autotools\n\nlibccd also contains support for autotools:\nGenerate configure script etc.:\n```sh\n  $ ./bootstrap\n```\n\nCreate new build/ directory:\n```sh\n  $ mkdir build && cd build\n```\n\nRun configure script:\n```sh\n  $ ../configure\n```\n\nRun make and make install:\n```sh\n  $ make && make install\n```\n\nconfigure script can change the way libccd is compiled and installed, most significant option is *--enable-double-precision* which enables double precision (single is default in this case).\n\n### 3. Using CMake\n\nTo build using `make`:\n```sh\n  $ mkdir build && cd build\n  $ cmake -G \"Unix Makefiles\" ..\n  $ make && make install\n```\n\nTo build using `ninja`:\n```sh\n  $ mkdir build && cd build\n  $ cmake -G Ninja ..\n  $ ninja && ninja install\n```\n\nOther build tools may be using by specifying a different generator. For example:\n```sh\n  $ cmake -G Xcode ..\n```\n\n```bat\n  > cmake -G \"Visual Studio 14 2015\" ..\n```\n\nTo compile using double precision, set the `ENABLE_DOUBLE_PRECISION` option:\n```sh\n  $ mkdir build && cd build\n  $ cmake -G \"Unix Makefiles\" -DENABLE_DOUBLE_PRECISION=ON ..\n  $ make && make install\n```\n\nTo build libccd as a shared library, set the `BUILD_SHARED_LIBS` option:\n```sh\n  $ mkdir build && cd build\n  $ cmake -G \"Unix Makefiles\" -DBUILD_SHARED_LIBS=ON ..\n  $ make && make install\n```\n\nTo build the test suite, set the `BUILD_TESTING` option:\n```sh\n  $ mkdir build && cd build\n  $ cmake -G \"Unix Makefiles\" -DBUILD_TESTING=ON ..\n  $ make && make test\n```\n\nThe installation directory may be changed using the `CMAKE_INSTALL_PREFIX` variable:\n```sh\n  $ mkdir build && cd build\n  $ cmake -G \"Unix Makefiles\" -DCMAKE_INSTALL_PREFIX=/path/to/install ..\n  $ make && make install\n```\n\n## GJK - Intersection Test\n\nThis section describes how to use libccd for testing if two convex objects intersects (i.e., 'yes/no' test) using Gilbert-Johnson-Keerthi (GJK) algorithm.\n\nProcedure is very simple (and is similar for usages of library):\n\n1. Include *<ccd/ccd.h>* file.\n2. Implement support function for specific shapes. Support function is function that returns furthest point from object (shape) in specified direction.\n3. Set up *ccd_t* structure.\n4. Run ccdGJKIntersect() function on desired objects.\n\nHere is skeleton of simple program:\n```cpp\n  #include <ccd/ccd.h>\n  #include <ccd/quat.h> // for work with quaternions\n\n  /** Support function for box */\n  void support(const void *obj, const ccd_vec3_t *dir, ccd_vec3_t *vec)\n  {\n      // assume that obj_t is user-defined structure that holds info about\n      // object (in this case box: x, y, z, pos, quat - dimensions of box,\n      // position and rotation)\n      obj_t *obj = (obj_t *)_obj;\n      ccd_vec3_t dir;\n      ccd_quat_t qinv;\n\n      // apply rotation on direction vector\n      ccdVec3Copy(&dir, _dir);\n      ccdQuatInvert2(&qinv, &obj->quat);\n      ccdQuatRotVec(&dir, &qinv);\n\n      // compute support point in specified direction\n      ccdVec3Set(v, ccdSign(ccdVec3X(&dir)) * box->x * CCD_REAL(0.5),\n                    ccdSign(ccdVec3Y(&dir)) * box->y * CCD_REAL(0.5),\n                    ccdSign(ccdVec3Z(&dir)) * box->z * CCD_REAL(0.5));\n\n      // transform support point according to position and rotation of object\n      ccdQuatRotVec(v, &obj->quat);\n      ccdVec3Add(v, &obj->pos);\n  }\n\n  int main(int argc, char *argv[])\n  {\n      ...\n\n      ccd_t ccd;\n      CCD_INIT(&ccd); // initialize ccd_t struct\n\n      // set up ccd_t struct\n      ccd.support1       = support; // support function for first object\n      ccd.support2       = support; // support function for second object\n      ccd.max_iterations = 100;     // maximal number of iterations\n\n      int intersect = ccdGJKIntersect(obj1, obj2, &ccd);\n      // now intersect holds true if obj1 and obj2 intersect, false otherwise\n  }\n```\n\n## GJK + EPA - Penetration Of Two Objects\n\nIf you want to obtain also penetration info about two intersection objects ccdGJKPenetration() function can be used.\n\nProcedure is almost same as for previous case:\n```cpp\n  #include <ccd/ccd.h>\n  #include <ccd/quat.h> // for work with quaternions\n\n  /** Support function is same as in previous case */\n\n  int main(int argc, char *argv[])\n  {\n      ...\n      ccd_t ccd;\n      CCD_INIT(&ccd); // initialize ccd_t struct\n\n      // set up ccd_t struct\n      ccd.support1       = support; // support function for first object\n      ccd.support2       = support; // support function for second object\n      ccd.max_iterations = 100;     // maximal number of iterations\n      ccd.epa_tolerance  = 0.0001;  // maximal tolerance fro EPA part\n\n      ccd_real_t depth;\n      ccd_vec3_t dir, pos;\n      int intersect = ccdGJKPenetration(obj1, obj2, &ccd, &depth, &dir, &pos);\n      // now intersect holds 0 if obj1 and obj2 intersect, -1 otherwise\n      // in depth, dir and pos is stored penetration depth, direction of\n      // separation vector and position in global coordinate system\n  }\n```\n\n## MPR - Intersection Test\n\nlibccd also provides MPR - Minkowski Portal Refinement algorithm that can be used for testing if two objects intersects.\n\nProcedure is similar to the one used for GJK algorithm. Support function is same but also function that returns center (or any point near center) of given object must be implemented:\n```cpp\n  #include <ccd/ccd.h>\n  #include <ccd/quat.h> // for work with quaternions\n\n  /** Support function is same as in previous case */\n\n  /** Center function - returns center of object */\n  void center(const void *_obj, ccd_vec3_t *center)\n  {\n      obj_t *obj = (obj_t *)_obj;\n      ccdVec3Copy(center, &obj->pos);\n  }\n\n  int main(int argc, char *argv[])\n  {\n      ...\n      ccd_t ccd;\n      CCD_INIT(&ccd); // initialize ccd_t struct\n\n      // set up ccd_t struct\n      ccd.support1       = support; // support function for first object\n      ccd.support2       = support; // support function for second object\n      ccd.center1        = center;  // center function for first object\n      ccd.center2        = center;  // center function for second object\n      ccd.mpr_tolerance  = 0.0001;  // maximal tolerance\n\n      int intersect = ccdMPRIntersect(obj1, obj2, &ccd);\n      // now intersect holds true if obj1 and obj2 intersect, false otherwise\n  }\n```\n\n\n## MPR - Penetration Of Two Objects\n\nUsing MPR algorithm for obtaining penetration info about two intersection objects is equally easy as in previous case instead ccdMPRPenetration() function is used:\n```cpp\n  #include <ccd/ccd.h>\n  #include <ccd/quat.h> // for work with quaternions\n\n  /** Support function is same as in previous case */\n  /** Center function is same as in prevous case */\n\n  int main(int argc, char *argv[])\n  {\n      ...\n      ccd_t ccd;\n      CCD_INIT(&ccd); // initialize ccd_t struct\n\n      // set up ccd_t struct\n      ccd.support1       = support; // support function for first object\n      ccd.support2       = support; // support function for second object\n      ccd.center1        = center;  // center function for first object\n      ccd.center2        = center;  // center function for second object\n      ccd.mpr_tolerance  = 0.0001;  // maximal tolerance\n\n      ccd_real_t depth;\n      ccd_vec3_t dir, pos;\n      int intersect = ccdMPRPenetration(obj1, obj2, &ccd, &depth, &dir, &pos);\n      // now intersect holds 0 if obj1 and obj2 intersect, -1 otherwise\n      // in depth, dir and pos is stored penetration depth, direction of\n      // separation vector and position in global coordinate system\n  }\n```"
}
