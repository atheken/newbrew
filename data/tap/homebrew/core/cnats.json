{
  "name": "cnats",
  "full_name": "cnats",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "C client for the NATS messaging system",
  "license": "Apache-2.0",
  "homepage": "https://github.com/nats-io/nats.c",
  "versions": {
    "stable": "3.6.1",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/nats-io/nats.c/archive/v3.6.1.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "4b60fd25bbb04dbc82ea09cd9e1df4f975f68e1b2e4293078ae14e01218a22bf"
    }
  },
  "revision": 1,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/cnats/blobs/sha256:223440be48c43cb502eeceb78514c29b0238717cf17de88ab36113762e545c9a",
          "sha256": "223440be48c43cb502eeceb78514c29b0238717cf17de88ab36113762e545c9a"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/cnats/blobs/sha256:862262c067872cac1476ab24f7f55ce0c0dafc5f54725041d0e5a4e4d10eb0e6",
          "sha256": "862262c067872cac1476ab24f7f55ce0c0dafc5f54725041d0e5a4e4d10eb0e6"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/cnats/blobs/sha256:0706ceffcf2d56c553da948c2736b04f0e72e1ff8b510a13c0e189bfee7be8ff",
          "sha256": "0706ceffcf2d56c553da948c2736b04f0e72e1ff8b510a13c0e189bfee7be8ff"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/cnats/blobs/sha256:000d38458fefeb3fa9ed904de8520194edd218f712d1ee270d40c1d01e862d69",
          "sha256": "000d38458fefeb3fa9ed904de8520194edd218f712d1ee270d40c1d01e862d69"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/cnats/blobs/sha256:3eb2b9fd6eafb0da1a4edd95161944335384d9a2239d7932fee0b1837d05cab8",
          "sha256": "3eb2b9fd6eafb0da1a4edd95161944335384d9a2239d7932fee0b1837d05cab8"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/cnats/blobs/sha256:6e2ab1a62323570a24bb87e63de6f94415a032b543603148d6b7821149f9bb6f",
          "sha256": "6e2ab1a62323570a24bb87e63de6f94415a032b543603148d6b7821149f9bb6f"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/cnats/blobs/sha256:f644c78147ae22f040bef2477d148923f0d56af87075b0d407e7ec8087fa86b1",
          "sha256": "f644c78147ae22f040bef2477d148923f0d56af87075b0d407e7ec8087fa86b1"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "cmake"
  ],
  "dependencies": [
    "libevent",
    "libuv",
    "openssl@3",
    "protobuf-c"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/cnats.rb",
  "ruby_source_checksum": {
    "sha256": "1881dc71254a3789bb335734b4a184fe2602217faafd76cb67d56a8319c93fd8"
  },
  "date_added": "2017-01-18T10:14:39+00:00",
  "readme": "# NATS & NATS Streaming - C Client\nA C client for the [NATS messaging system](https://nats.io).\n\nGo [here](http://nats-io.github.io/nats.c) for the online documentation,\nand check the [frequently asked questions](https://github.com/nats-io/nats.c#faq).\n\nThis NATS Client implementation is heavily based on the [NATS GO Client](https://github.com/nats-io/nats.go). There is support for Mac OS/X, Linux and Windows (although we don't have specific platform support matrix).\n\n[![License Apache 2](https://img.shields.io/badge/License-Apache2-blue.svg)](https://www.apache.org/licenses/LICENSE-2.0)\n[![Build Status](https://travis-ci.com/nats-io/nats.c.svg?branch=main)](https://travis-ci.com/github/nats-io/nats.c)\n[![Coverage Status](https://coveralls.io/repos/github/nats-io/nats.c/badge.svg?branch=main)](https://coveralls.io/github/nats-io/nats.c?branch=main)\n[![Release](https://img.shields.io/badge/release-v3.6.1-blue.svg?style=flat)](https://github.com/nats-io/nats.c/releases/tag/v3.6.1)\n[![Documentation](https://img.shields.io/badge/doc-Doxygen-brightgreen.svg?style=flat)](http://nats-io.github.io/nats.c)\n\n# Table of Contents\n\n- [Installing](#installing)\n- [Building](#building)\n\t* [TLS Support](#tls-support)\n        * [Link statically](#link-statically)\n    * [Building with Streaming](#building-with-streaming)\n    * [Building with Libsodium](#building-with-libsodium)\n    * [Testing](#testing)\n- [Documentation](#documentation)\n- [NATS Client](#nats-client)\n    * [Important Changes](#important-changes)\n    * [JetStream](#jetstream)\n        * [JetStream Basic Usage](#jetstream-basic-usage)\n        * [JetStream Basic Management](#jetstream-basic-usage)\n    * [KeyValue](#keyvalue)\n        * [KeyValue Management](#keyvalue-management)\n        * [KeyValue APIs](#keyvalue-apis)\n\t* [Getting Started](#getting-started)\n\t* [Basic Usage](#basic-usage)\n    * [Headers](#headers)\n\t* [Wildcard Subscriptions](#wildcard-subscriptions)\n\t* [Queue Groups](#queue-groups)\n\t* [TLS](#tls)\n\t* [New Authentication (Nkeys and User Credentials)](#new-authentication-nkeys-and-user-credentials)\n\t* [Advanced Usage](#advanced-usage)\n\t* [Clustered Usage](#clustered-usage)\n\t* [Using an Event Loop Library](#using-an-event-loop-library)\n\t* [FAQ](#faq)\n- [NATS Streaming Client](#nats-streaming-client)\n\t* [Streaming Basic Usage](#streaming-basic-usage)\n\t\t* [Streaming Subscriptions](#streaming-subscriptions)\n\t\t* [Streaming Durable Subscriptions](#streaming-durable-subscriptions)\n\t\t* [Streaming Queue Groups](#streaming-queue-groups)\n\t\t\t* [Creating a Queue Group](#creating-a-queue-group)\n\t\t\t* [Start Position](#start-position)\n\t\t\t* [Leaving the Group](#leaving-the-group)\n\t\t\t* [Closing a Queue Group](#closing-a-queue-group)\n\t\t* [Streaming Durable Queue Groups](#streaming-durable-queue-groups)\n\t\t\t* [Creating a Durable Queue Group](#creating-a-durable-queue-group)\n\t\t\t* [Start Position of the Durable Queue Group](#start-position-of-the-durable-queue-group)\n\t\t\t* [Leaving the Durable Queue Group](#leaving-the-durable-queue-group)\n\t\t\t* [Closing the Durable Queue Group](#closing-the-durable-queue-group)\n\t\t* [Streaming Wildcard Subscriptions](#streaming-wildcard-subscriptions)\n\t* [Streaming Advanced Usage](#streaming-advanced-usage)\n\t\t* [Connection Status](#connection-status)\n\t\t* [Asynchronous Publishing](#asynchronous-publishing)\n\t\t* [Message Acknowledgments and Redelivery](#message-acknowledgments-and-redelivery)\n\t\t* [Rate limiting/matching](#rate-limitingmatching)\n\t\t\t* [Publisher Rate Limiting](#publisher-rate-limiting)\n\t\t\t* [Subscriber Rate Limiting](#subscriber-rate-limiting)\n- [License](#license)\n\n## Installing\n\nThere are several package managers with NATS C client library available. If you know one that is not in this list, please submit a PR to add it!\n\n- [Homebrew](https://github.com/Homebrew/homebrew-core) The \"cnats\" formula is [here](https://github.com/Homebrew/homebrew-core/blob/master/Formula/cnats.rb)\n- [vcpkg](https://vcpkg.io) The \"cnats\" port is [here](https://github.com/microsoft/vcpkg/tree/master/ports/cnats)\n\n## Building\n\nFirst, download the source code:\n```\ngit clone git@github.com:nats-io/nats.c.git .\n```\n\nTo build the library, use [CMake](https://cmake.org/download/). Note that by default the NATS Streaming API will be built and included in the NATS library.\nSee below if you do not want to build the Streaming related APIs.\n\nMake sure that CMake is added to your path. If building on Windows, open a command shell from the Visual Studio Tools menu, and select the appropriate command shell (x64 or x86 for 64 or 32 bit builds respectively). You will also probably need to run this with administrator privileges.\n\nCreate a `build` directory (any name would work) from the root source tree, and `cd` into it. Then issue this command for the first time:\n\n```\ncmake ..\n```\n\nIn some architectures, you may experience a compilation error for `mutex.c.o` because there is no support\nfor the assembler instruction that we use to yield when spinning trying to acquire a lock.\n\nYou may get this sort of build error:\n```\n/tmp/cc1Yp7sD.s: Assembler messages:\n/tmp/cc1Yp7sD.s:302: Error: selected processor does not support ARM mode `yield'\nsrc/CMakeFiles/nats_static.dir/build.make:542: recipe for target 'src/CMakeFiles/nats_static.dir/unix/mutex.c.o' failed\n```\nIf that's the case, you can solve this by enabling the `NATS_BUILD_NO_SPIN` flag (or use `-DNATS_NO_SPIN` if you compile without CMake):\n```\ncmake .. -DNATS_BUILD_NO_SPIN=ON\n```\n\nIf you had previously built the library, you may need to do a `make clean`, or simply delete and re-create the build directory before executing the cmake command.\n\nTo build on Windows, you would need to select the build generator. For instance, to select `nmake`, you would run:\n\n```\ncmake .. -G \"NMake Makefiles\"\n```\n\nRunning `cmake -h` would give you the list of possible options and all the generator names.\n\nAlternatively, you can run the GUI version. From that same *build* command shell, start the GUI:\n\n```\nc:\\program files (x86)\\CMake\\bin\\cmake-gui.exe\n```\n\nIf you started with an empty build directory, you would need to select the source and build directory, then click `Configure`. Here, you will be able to select from the drop-down box the name of the build generator. When done, click `Generate`. Then you can go back to your command shell, or Visual Studio and build.\n\nTo modify some of the build options, you need to edit the cache and rebuild.\n\n```\nmake edit_cache\n```\n\nNote that if you build on Windows and have selected \"NMake Makefiles\", replace all following references to `make` with `nmake`.\n\nEditing the cache allows you to select the build type (Debug, Release, etc), the architecture (64 or 32bit), and so on.\n\nThe default target will build everything, that is, the static and shared NATS libraries and also the examples and the test program. Each are located in their respective directories under your build directory: `src`, `examples` and `test`.\n\n```\nmake install\n```\nWill copy both the static and shared libraries in the folder `install/lib` and the public headers in `install/include`.\n\n## TLS Support\n\nBy default, the library is built with TLS support. You can disable this from the cmake gui `make edit_cache` and switch the `NATS_BUILD_WITH_TLS` option to `OFF`, or pass the option directly to the `cmake` command:\n\n```\ncmake .. -DNATS_BUILD_WITH_TLS=OFF\n```\n\nStarting `2.0.0`, when building with TLS/SSL support, the server certificate's expected hostname is always verified. It means that the hostname provided in the URL(s) or through the option `natsOptions_SetExpectedHostname()` will be used to check the hostname present in the certificate. Prior to `2.0.0`, the hostname would be verified *only* if the option `natsOptions_SetExpectedHostname()` was invoked.\n\nAlthough we recommend leaving the new default behavior, you can restore the previous behavior by building the library with this option off:\n\n```\ncmake .. -DNATS_BUILD_TLS_FORCE_HOST_VERIFY=OFF\n```\n\nThe NATS C client is built using APIs from the [OpenSSL](https://github.com/openssl/openssl) library. By default we use `3.0+` APIs. Since OpenSSL `1.0.2` is no longer supported, starting with NATS C Client `v3.6.0` version, the CMake variable `NATS_BUILD_TLS_USE_OPENSSL_1_1_API` is now set to `ON` by default (if you are setting up a new environment) and will use OpenSSL APIs from `1.1+`/`3.0+` APIs. You will still be able to compile with the OpenSSL `1.0.2` library by setting this CMake option to `OFF`:\n\n```\ncmake .. -DNATS_BUILD_TLS_USE_OPENSSL_1_1_API=OFF\n```\n\nThe variable `NATS_BUILD_TLS_USE_OPENSSL_1_1_API` is deprecated, meaning that in the future this option will simply be removed and only OpenSSL `3.0+` APIs will be used. The code in the library using older OpenSSL APIs will be removed too.\n\nNote that the variable `NATS_BUILD_WITH_TLS_CLIENT_METHOD` that was deprecated in `v2.0.0` has now been removed.\n\nSince the NATS C client dynamically links to the OpenSSL library, you need to make sure that you are then running your application against an OpenSSL 1.1+/3.0+ library.\n\n### Link statically\n\nIf you want to link to the static OpenSSL library, you need to delete the `CMakeCache.txt` and regenerate it with the additional option:\n```\nrm CMakeCache.txt\ncmake .. <build options that you may already use> -DNATS_BUILD_OPENSSL_STATIC_LIBS=ON\n```\nThen call `make` (or equivalent depending on your platform) and this should ensure that the library (and examples and/or test suite executable) are linked against the OpenSSL library, if it was found by CMake.\n\n## Building with Streaming\n\nWhen building the library with Streaming support, the NATS library uses the [libprotobuf-c](https://github.com/protobuf-c/protobuf-c) library.\nWhen cmake runs for the first time (or after removing `CMakeCache.txt` and calling `cmake ..` again), it is looking for the libprotobuf-c library. If it does not find it, a message is printed and the build process fails.\nCMake searches for the library in directories where libraries are usually found. However, if you want to specify a specific directory where the library is located, you need to do this:\n```\ncmake .. -DNATS_PROTOBUF_DIR=<my libprotobuf-c directory>\n```\nThe static library will be used by default. If you want to change that, or if the library has not the expected name, you need to do this:\n```\n# Use the library named mylibproto.so located at /my/location\ncmake .. -DNATS_PROTOBUF_LIBRARY=/my/location/mylibproto.so\n```\nThe two could be combined if the include header is located in a different directory\n```\n# Use the library named mylibproto.so located at /my/location and the directory protobuf-c/ containing protobuf-c.h located at /my/other/location\ncmake .. -DNATS_PROTOBUF_LIBRARY=/my/location/mylibproto.so -DNATS_PROTOBUF_DIR=/my/other/location\n```\n\nIf you don't want to build the NATS Streaming APIs to be included in the NATS library:\n```\ncmake .. -DNATS_BUILD_STREAMING=OFF\n```\n\n## Building with Libsodium\n\nWhen using the new NATS 2.0 security features, the library needs to sign some \"nonce\" sent by the server during a connect or reconnect.\nWe use [Ed25519](https://ed25519.cr.yp.to/) public-key signature. The library comes with some code to perform the signature.\nIn most case, it will be fine, but if performance is an issue (especially if you plan to use the `natsConnection_Sign()` function a lot), you will have the option to build with the [Libsodium](https://github.com/jedisct1/libsodium) library.\n\nFollow instructions on how to install the libsodium library [here](https://download.libsodium.org/doc/).\n\nOn macOS, you could use `brew`:\n```\nbrew install libsodium\n```\nOn Linux, you could use `apt-get`\n```\napt-get install libsodium-dev\n```\nOnce installed, you can rebuild the NATS C client by first enabling the use of the libsodium library:\n```\ncmake .. -DNATS_BUILD_USE_SODIUM=ON\n```\nIf you have the libsodium library installed in a non standard location that CMake cannot find, you can specify the location of this directory:\n```\ncmake .. -DNATS_BUILD_USE_SODIUM=ON -DNATS_SODIUM_DIR=/my/path/to/libsodium\n```\n\n## Testing\n\nOn platforms where `valgrind` is available, you can run the tests with memory checks.\nHere is an example:\n\n```\nmake test ARGS=\"-T memcheck\"\n```\n\nOr, you can invoke directly the `ctest` program:\n\n```\nctest -T memcheck -V -I 1,4\n```\nThe above command would run the tests with `valgrind` (`-T memcheck`), with verbose output (`-V`), and run the tests from 1 to 4 (`-I 1,4`).\n\nIf you add a test to `test/test.c`, you need to add it into the `allTests` array. Each entry contains a name, and the test function. You can add it anywhere into this array.\nBuild you changes:\n\n```\nmake\n[ 44%] Built target nats\n[ 88%] Built target nats_static\n[ 90%] Built target nats-publisher\n[ 92%] Built target nats-queuegroup\n[ 94%] Built target nats-replier\n[ 96%] Built target nats-requestor\n[ 98%] Built target nats-subscriber\nScanning dependencies of target testsuite\n[100%] Building C object test/CMakeFiles/testsuite.dir/test.c.o\nLinking C executable testsuite\n[100%] Built target testsuite\n```\n\nNow regenerate the list by invoking the test suite without any argument:\n\n```\n./test/testsuite\nNumber of tests: 77\n```\n\nThis list the number of tests added to the file `list.txt`. Move this file to the source's test directory.\n\n```\nmv list.txt ../test/\n```\n\nThen, refresh the build:\n\n```\ncmake ..\n-- Configuring done\n-- Generating done\n-- Build files have been written to: /home/ivan/nats.c/build\n```\n\nYou can use the following environment variables to influence the testsuite behavior.\n\nWhen running with memory check, timing changes and overall performance is slower. The following variable allows the testsuite to adjust some of values used during the test:\n\n```\nexport NATS_TEST_VALGRIND=yes\n```\n\nOn Windows, it would be `set` instead of `export`.\n\nWhen running the tests in verbose mode, the following environment variable allows you to see the server output from within the test itself. Without this option, the server output is silenced:\n\n```\nexport NATS_TEST_KEEP_SERVER_OUTPUT=yes\n```\n\nIf you want to change the default server executable name (`nats-server.exe`) or specify a specific location, use this environment variable:\n\n```\nset NATS_TEST_SERVER_EXE=c:\\test\\nats-server.exe\n```\n\n\n# Documentation\n\nThe public API has been documented using [Doxygen](http://www.stack.nl/~dimitri/doxygen/).\n\nTo generate the documentation, go to the `doc` directory and type the following command:\n\n```\ndoxygen DoxyFile.NATS.Client\n```\n\nIf you toggle the build of the Streaming APIs, and the documentation is no longer matching\nwhat is being built, you can update the documentation by switching the `NATS_UPDATE_DOC` build flag and rebuild the documentation.\n\nFrom the build directory:\n```\ncmake .. -DNATS_UPDATE_DOC=ON\nmake\ncd <nats.c root dir>/doc\ndoxygen DoxyFile.NATS.Client\n```\n\nThe generated documentation will be located in the `html` directory. To see the documentation, point your browser to the file `index.html` in that directory.\n\nGo [here](http://nats-io.github.io/nats.c) for the online documentation.\n\nThe source code is also quite documented.\n\n# NATS Client\n\n## Important Changes\n\nThis section lists important changes such as deprecation notices, etc...\n\n### Version `2.0.0`\n\nThis version introduces the security concepts used by NATS Server `2.0.0` and therefore aligns with the server version. There have been new APIs introduced, but the most important change is the new default behavior with TLS connections:\n\n* When establishing a secure connection, the server certificate's hostname is now always verified, regardless if the user has invoked `natsOptions_SetExpectedHostname()`. This may break applications that were for instance using an IP to connect to a server that had only the hostname in the certificate. This can be solved by changing your application to use the hostname in the URL or make use of `natsOptions_SetExpectedHostname()`. If this is not possible, you can restore the old behavior by building the library with the new behavior disabled. See #tls-support for more information.\n\n* This repository used to include precompiled libraries of [libprotobuf-c](https://github.com/protobuf-c/protobuf-c) for macOS, Linux and Windows along with the header files (in the `/pbuf` directory).\nWe have now removed this directory and require that the user installs the libprotobuf-c library separately. See the [building instructions](#building) to specify the library location if CMake cannot find it directly.\n\n### Version `1.8.0`\n\n* The `natsConnStatus` enum values have been prefixed with `NATS_CONN_STATUS_`. If your application is\nnot using referencing any original value, such as `CONNECTED` or `CLOSED`, etc.. then there is nothing\nthat you need to do. If you do, you have two options:\n\t* Replace all references from the orignal values to the new value (adding the prefix)\n\t* Compile the library with the option to use the original values (no prefix). Edit the CMake cache\nand turn on the option `NATS_BUILD_NO_PREFIX_CONNSTS`. This can be done this way from the build directory:\n`cmake .. -DNATS_BUILD_NO_PREFIX_CONNSTS=ON`\n\n## Getting Started\n\nThe `examples/getstarted` directory has a set of simple examples that are fully functional, yet very simple.\nThe goal is to demonstrate how easy to use the API is.\n\nA more complex set of examples are in `examples/` directory and can also be used to benchmark the client library.\n\n## Basic Usage\n\nNote that for simplicity, error checking is not performed here.\n```c\nnatsConnection      *nc  = NULL;\nnatsSubscription    *sub = NULL;\nnatsMsg             *msg = NULL;\n\n// Connects to the default NATS Server running locally\nnatsConnection_ConnectTo(&nc, NATS_DEFAULT_URL);\n\n// Connects to a server with username and password\nnatsConnection_ConnectTo(&nc, \"nats://ivan:secret@localhost:4222\");\n\n// Connects to a server with token authentication\nnatsConnection_ConnectTo(&nc, \"nats://myTopSecretAuthenticationToken@localhost:4222\");\n\n// Simple publisher, sending the given string to subject \"foo\"\nnatsConnection_PublishString(nc, \"foo\", \"hello world\");\n\n// Publish binary data. Content is not interpreted as a string.\nchar data[] = {1, 2, 0, 4, 5};\nnatsConnection_Publish(nc, \"foo\", (const void*) data, 5);\n\n// Simple asynchronous subscriber on subject foo, invoking message\n// handler 'onMsg' when messages are received, and not providing a closure.\nnatsConnection_Subscribe(&sub, nc, \"foo\", onMsg, NULL);\n\n// Simple synchronous subscriber\nnatsConnection_SubscribeSync(&sub, nc, \"foo\");\n\n// Using a synchronous subscriber, gets the first message available, waiting\n// up to 1000 milliseconds (1 second)\nnatsSubscription_NextMsg(&msg, sub, 1000);\n\n// Destroy any message received (asynchronously or synchronously) or created\n// by your application. Note that if 'msg' is NULL, the call has no effect.\nnatsMsg_Destroy(msg);\n\n// Unsubscribing\nnatsSubscription_Unsubscribe(sub);\n\n// Destroying the subscription (this will release the object, which may\n// result in freeing the memory). After this call, the object must no\n// longer be used.\nnatsSubscription_Destroy(sub);\n\n// Publish requests to the given reply subject:\nnatsConnection_PublishRequestString(nc, \"foo\", \"bar\", \"help!\");\n\n// Sends a request (internally creates an inbox) and Auto-Unsubscribe the\n// internal subscriber, which means that the subscriber is unsubscribed\n// when receiving the first response from potentially many repliers.\n// This call will wait for the reply for up to 1000 milliseconds (1 second).\nnatsConnection_RequestString(&reply, nc, \"foo\", \"help\", 1000);\n\n// Closing a connection (but not releasing the connection object)\nnatsConnection_Close(nc);\n\n// When done with the object, free the memory. Note that this call\n// closes the connection first, in other words, you could have simply\n// this call instead of natsConnection_Close() followed by the destroy\n// call.\nnatsConnection_Destroy(nc);\n\n// Message handler\nvoid\nonMsg(natsConnection *nc, natsSubscription *sub, natsMsg *msg, void *closure)\n{\n    // Prints the message, using the message getters:\n    printf(\"Received msg: %s - %.*s\\n\",\n        natsMsg_GetSubject(msg),\n        natsMsg_GetDataLength(msg),\n        natsMsg_GetData(msg));\n\n    // Don't forget to destroy the message!\n    natsMsg_Destroy(msg);\n}\n```\n\n## JetStream\n\nSupport for JetStream starts with the version `v3.0.0` of the library and NATS Server `v2.2.0+`, although getting JetStream\nspecific error codes requires the server at version `v2.3.0+`. Some of the configuration options are only available starting `v2.3.3`,\nso we recommend that you use the latest NATS Server release to have a better experience.\n\nLook at examples named `js-xxx.c` in the `examples` directory for examples on how to use the API.\nThe new objects and APIs are full documented in the online [documentation](http://nats-io.github.io/nats.c/group__js_group.html).\n\n### JetStream Basic Usage\n\n```c\n// Connect to NATS\nnatsConnection_Connect(&conn, opts);\n\n// Initialize and set some JetStream options\njsOptions jsOpts;\njsOptions_Init(&jsOpts);\njsOpts.PublishAsync.MaxPending = 256;\n\n// Create JetStream Context\nnatsConnection_JetStream(&js, conn, &jsOpts);\n\n// Simple Stream Publisher\njs_Publish(&pa, js, \"ORDERS.scratch\", (const void*) \"hello\", 5, NULL, &jerr);\n\n// Simple Async Stream Publisher\nfor (i=0; i < 500; i++)\n{\n    js_PublishAsync(js, \"ORDERS.scratch\", (const void*) \"hello\", 5, NULL);\n}\n\n// Wait for up to 5 seconds to receive all publish acknowledgments.\njsPubOptions_Init(&jsPubOpts);\njsPubOpts.MaxWait = 5000;\njs_PublishAsyncComplete(js, &jsPubOpts);\n\n// One can get the list of all pending publish async messages,\n// to either resend them or simply destroy them.\nnatsMsgList pending;\ns = js_PublishAsyncGetPendingList(&pending, js);\nif (s == NATS_OK)\n{\n    int i;\n\n    for (i=0; i<pending.Count; i++)\n    {\n\n        // There could be a decision to resend these messages or not.\n        if (your_decision_to_resend(pending.Msgs[i]))\n        {\n\n            // If the call is successful, pending.Msgs[i] will be set\n            // to NULL so destroying the pending list will not destroy\n            // this message since the library has taken ownership back.\n            js_PublishMsgAsync(js, &(pending.Msgs[i]), NULL);\n        }\n    }\n\n    // Destroy the pending list object and all messages still in that list.\n    natsMsgList_Destroy(&pending);\n}\n\n// To create an asynchronous ephemeral consumer\njs_Subscribe(&sub, js, \"foo\", myMsgHandler, myClosure, &jsOpts, NULL, &jerr);\n\n// Same but use a subscription option to ask the callback to not do auto-ack.\njsSubOptions so;\njsSubOptions_Init(&so);\nso.ManualAck = true;\njs_Subscribe(&sub, js, \"foo\", myMsgHandler, myClosure, &jsOpts, &so, &jerr);\n\n// Or to bind to an existing specific stream/durable:\njsSubOptions_Init(&so);\nso.Stream = \"MY_STREAM\";\nso.Consumer = \"my_durable\";\njs_Subscribe(&sub, js, \"foo\", myMsgHandler, myClosure, &jsOpts, &so, &jerr);\n\n// Synchronous subscription:\njs_SubscribeSync(&sub, js, \"foo\", &jsOpts, &so, &jerr);\n```\n\n### JetStream Basic Management\n\n```c\njsStreamConfig  cfg;\n\n// Connect to NATS\nnatsConnection_Connect(&conn, opts);\n\n// Create JetStream Context\nnatsConnection_JetStream(&js, conn, NULL);\n\n// Initialize the configuration structure.\njsStreamConfig_Init(&cfg);\n// Provide a name\ncfg.Name = \"ORDERS\";\n// Array of subjects and its size\ncfg.Subjects = (const char*[1]){\"ORDERS.*\"};\ncfg.SubjectsLen = 1;\n\n// Create a Stream. If you are not interested in the returned jsStreamInfo object,\n// you can pass NULL.\njs_AddStream(NULL, js, &cfg, NULL, &jerr);\n\n// Update a Stream\ncfg.MaxBytes = 8;\njs_UpdateStream(NULL, js, &cfg, NULL, &jerr);\n\n// Delete a Stream\njs_DeleteStream(js, \"ORDERS\", NULL, &jerr);\n```\n\n## KeyValue\n\n**EXPERIMENTAL FEATURE! We reserve the right to change the API without necessarily bumping the major version of the library.**\n\nA KeyValue store is a materialized view based on JetStream. A bucket is a stream and keys are subjects within that stream.\n\nSome features require NATS Server `v2.6.2`, so we recommend that you use the latest NATS Server release to have a better experience.\n\nThe new objects and APIs are full documented in the online [documentation](http://nats-io.github.io/nats.c/group__kv_group.html).\n\n### KeyValue Management\n\nExample of how to create a KeyValue store:\n```c\njsCtx       *js = NULL;\nkvStore     *kv = NULL;\nkvConfig    kvc;\n\n// Assume we got a JetStream context in `js`...\n\nkvConfig_Init(&kvc);\nkvc.Bucket = \"KVS\";\nkvc.History = 10;\ns = js_CreateKeyValue(&kv, js, &kvc);\n\n// Do some stuff...\n\n// This is to free the memory used by `kv` object,\n// not delete the KeyValue store in the server\nkvStore_Destroy(kv);\n```\n\nThis shows how to \"bind\" to an existing one:\n```c\njsCtx       *js = NULL;\nkvStore     *kv = NULL;\n\n// Assume we got a JetStream context in `js`...\n\ns = js_KeyValue(&kv, ks, \"KVS\");\n\n// Do some stuff...\n\n// This is to free the memory used by `kv` object,\n// not delete the KeyValue store in the server\nkvStore_Destroy(kv);\n```\n\nThis is how to delete a KeyValue store in the server:\n```c\njsCtx       *js = NULL;\n\n// Assume we got a JetStream context in `js`...\n\ns = js_DeleteKeyValue(js, \"KVS\");\n```\n\n### KeyValue APIs\n\nThis is how to put a value for a given key:\n```c\nkvStore     *kv = NULL;\nuint64_t    rev = 0;\n\n// Assume we got a kvStore...\n\ns = kvStore_PutString(&rev, kv, \"MY_KEY\", \"my value\");\n\n// If the one does not care about getting the revision, pass NULL:\ns = kvStore_PutString(NULL, kv, \"MY_KEY\", \"my value\");\n```\n\nThe above places a value for a given key, but if instead one wants to make sure that the value is placed for the key only if it never existed before, one would call:\n```c\n// Same note than before: if \"rev\" is not needed, pass NULL:\ns = kvStore_CreateString(&rev, kv, \"MY_KEY\", \"my value\");\n```\n\nOne can update a key if and only if the last revision in the server matches the one passed to this API:\n```c\n// This would update the key \"MY_KEY\" with the value \"my updated value\" only if the current revision (sequence number) for this key is 10.\ns = kvStore_UpdateString(&rev, kv, \"MY_KEY\", \"my updated value\", 10);\n```\n\nThis is how to get a key:\n```c\nkvStore *kv = NULL;\nkvEntry *e  = NULL;\n\n// Assume we got a kvStore...\n\ns = kvStore_Get(&e, kv, \"MY_KEY\");\n\n// Then we can get some fields from the entry:\nprintf(\"Key value: %s\\n\", kvEntry_ValueString(e));\n\n// Once done with the entry, we need to destroy it to release memory.\n// This is NOT deleting the key from the server.\nkvEntry_Destroy(e);\n```\n\nThis is how to purge a key:\n```c\nkvStore *kv = NULL;\n\n// Assume we got a kvStore...\n\ns = kvStore_Purge(kv, \"MY_KEY\");\n```\n\nThis will delete the key in the server:\n```c\nkvStore *kv = NULL;\n\n// Assume we got a kvStore...\n\ns = kvStore_Delete(kv, \"MY_KEY\");\n```\n\nTo create a \"watcher\" for a given key:\n```c\nkvWatcher       *w = NULL;\nkvWatchOptions  o;\n\n// Assume we got a kvStore...\n\n// Say that we are not interested in getting the\n// delete markers...\n\n// Initialize a kvWatchOptions object:\nkvWatchOptions_Init(&o);\no.IgnoreDeletes = true;\n// Create the watcher\ns = kvStore_Watch(&w, kv, \"foo.*\", &o);\n// Check for error..\n\n// Now get updates:\nwhile (some_condition)\n{\n    kvEntry *e = NULL;\n\n    // Wait for the next update for up to 5 seconds\n    s = kvWatcher_Next(&e, w, 5000);\n\n    // Do something with the entry...\n\n    // Destroy to release memory\n    kvEntry_Destroy(e);\n}\n\n// When done with the watcher, it needs to be destroyed to release memory:\nkvWatcher_Destroy(w);\n```\n\nTo get the history of a key:\n```c\nkvEntryList l;\nint         i;\n\n// The list is defined on the stack and will be initilized/updated by this call:\ns = kvStore_History(&l, kv, \"MY_KEY\", NULL);\n\nfor (i=0; i<l.Count; i++)\n{\n    kvEntry *e = l.Entries[i];\n\n    // Do something with the entry...\n}\n// When done with the list, call this to free entries and the content of the list.\nkvEntryList_Destroy(&l);\n\n// In order to set a timeout to get the history, we need to do so through options:\nkvWatchOptions o;\n\nkvWatchOptions_Init(&o);\no.Timeout = 5000; // 5 seconds.\ns = kvStore_History(&l, kv, \"MY_KEY\", &o);\n```\n\nThis is how you would get the keys of a bucket:\n```c\nkvKeysList  l;\nint         i;\n\n// If no option is required, pass NULL as the last argument.\ns = kvStore_Keys(&l, kv, NULL);\n// Check error..\n\n// Go over all keys:\nfor (i=0; i<l.Count; i++)\n    printf(\"Key: %s\\n\", l.Keys[i]);\n\n// When done, list need to be destroyed.\nkvKeysList_Destroy(&l);\n\n// If option need to be specified:\n\nkvWatchOptions o;\n\nkvWatchOptions_Init(&o);\no.Timeout = 5000; // 5 seconds.\ns = kvStore_Keys(&l, kv, &o);\n```\n\n## Headers\n\nHeaders are available when connecting to servers at version 2.2.0+.\n\nThey closely resemble http headers. They are a map of key/value pairs, the value being an array of strings.\n\nHeaders allow users to add meta information about a message without interfering with the message payload.\n\nNote that if an application attempts to send a message with a header when connected to a server that does not understand them, the publish call will return the error `NATS_NO_SERVER_SUPPORT`.\n\nThere is an API to know if the server currently connected to supports headers:\n```c\nnatsStatus s = natsConnection_HasHeaderSupport(conn);\nif (s == NATS_NO_SERVER_SUPPORT)\n    // deal with server not supporting this feature.\n```\n\nIf the server understands headers but is about to deliver the message to a client that doesn't, the headers are stripped off so that the older clients can still receive the messsage.\nIt is important to have all client and servers to a version that support headers if applications rely on headers.\n\nFor more details on the headers API, please get the example: `examples/getstarted/headers.c`.\n\n## Wildcard Subscriptions\n\nThe `*` wildcard matches any token, at any level of the subject:\n\n```c\nnatsConnection_Subscribe(&sub, nc, \"foo.*.baz\", onMsg, NULL);\n```\nThis subscriber would receive messages sent to:\n\n* foo.bar.baz\n* foo.a.baz\n* etc...\n\nIt would not, however, receive messages on:\n\n* foo.baz\n* foo.baz.bar\n* etc...\n\nThe `>` wildcard matches any length of the fail of a subject, and can only be the last token.\n\n```c\nnatsConnection_Subscribe(&sub, nc, \"foo.>\", onMsg, NULL);\n```\nThis subscriber would receive any message sent to:\n\n* foo.bar\n* foo.bar.baz\n* foo.foo.bar.bax.22\n* etc...\n\nHowever, it would not receive messages sent on:\n\n* foo\n* bar.foo.baz\n* etc...\n\nPublishing on this subject would cause the two above subscriber to receive the message:\n```c\nnatsConnection_PublishString(nc, \"foo.bar.baz\", \"got it?\");\n```\n\n## Queue Groups\n\nAll subscriptions with the same queue name will form a queue group. Each message will be delivered to only one subscriber per queue group, using queue sematics. You can have as many queue groups as you wish. Normal subscribers will continue to work as expected.\n\n```c\nnatsConnection_QueueSubscribe(&sub, nc, \"foo\", \"job_workers\", onMsg, NULL);\n```\n\n## TLS\n\n(Note that the library needs to be built with TLS support - which is by default - for these APIs to work. See the Build chapter on how to build with or without TLS for more details).\n\nAn SSL/TLS connection is configured through the use of `natsOptions`. Depending on the level of security you desire, it can be as simple as setting the secure boolean to true on the `natsOptions_SetSecure()` call.\n\nEven with full security (client verifying server certificate, and server requiring client certificates), the setup involves only a few calls.\n\n```c\n// Here is the minimum to create a TLS/SSL connection:\n\n// Create an options object.\nnatsOptions_Create(&opts);\n\n// Set the secure flag.\nnatsOptions_SetSecure(opts, true);\n\n// You may not need this, but suppose that the server certificate\n// is self-signed and you would normally provide the root CA, but\n// don't want to. You can disable the server certificate verification\n// like this:\nnatsOptions_SkipServerVerification(opts, true);\n\n// Connect now...\nnatsConnection_Connect(&nc, opts);\n\n// That's it! On success you will have a secure connection with the server!\n\n(...)\n\n// This example shows what it takes to have a full SSL configuration,\n// including server expected's hostname, root CA, client certificates\n// and specific ciphers to use.\n\n// Create an options object.\nnatsOptions_Create(&opts);\n\n// Set the secure flag.\nnatsOptions_SetSecure(opts, true);\n\n// For a server with a trusted chain built into the client host,\n// simply designate the server name that is expected. Without this\n// call, the server certificate is still verified, but not the\n// hostname.\nnatsOptions_SetExpectedHostname(opts, \"localhost\");\n\n// Instead, if you are using a self-signed cert and need to load in the CA.\nnatsOptions_LoadCATrustedCertificates(opts, caCertFileName);\n\n// If the server requires client certificates, provide them along with the\n// private key, all in one call.\nnatsOptions_LoadCertificatesChain(opts, certChainFileName, privateKeyFileName);\n\n// You can also specify preferred ciphers if you want.\nnatsOptions_SetCiphers(opts, \"-ALL:HIGH\");\n\n// Then simply pass the options object to the connect call:\nnatsConnection_Connect(&nc, opts);\n\n// That's it! On success you will have a secure connection with the server!\n```\n\n## New Authentication (Nkeys and User Credentials)\n\nThis requires server with version >= 2.0.0\n\nNATS servers have a new security and authentication mechanism to authenticate with user credentials and Nkeys. The simplest form is to use the helper option `natsOptions_SetUserCredentialsFromFiles()`.\n\n```c\n// Retrieve both user JWT and NKey seed from single file `user.creds`.\ns = natsOptions_SetUserCredentialsFromFiles(opts, \"user.creds\", NULL);\nif (s == NATS_OK)\n    s = natsConnection_Connect(&nc, opts);\n```\n\nWith this option, the library will load the user JWT and NKey seed from a single file. Note that the library wipes the buffers used to read the files.\n\nIf you prefer to store the JWT and seed in two distinct files, use this form instead:\n\n```c\n// Retrieve the user JWT from the file `user.jwt` and the seed from the file `user.nk`.\ns = natsOptions_SetUserCredentialsFromFiles(opts, \"user.jwt\", \"user.nk\");\nif (s == NATS_OK)\n    s = natsConnection_Connect(&nc, opts);\n```\n\nYou can also set the callback handlers and manage challenge signing directly.\n\n```c\n/*\n * myUserJWTCb is a callback that is supposed to return the user JWT.\n * An optional closure can be specified.\n * mySignatureCB is a callback that is presented with a nonce and is\n * responsible for returning the signature for this nonce.\n * An optional closure can be specified.\n */\ns = natsOptions_SetUserCredentialsCallbacks(opts, myUserJWTCb, NULL, mySignatureCb, NULL);\nif (s == NATS_OK)\n    s = natsConnection_Connect(&nc, opts);\n```\n\nFor NKey authentication, it is possible to specify the public NKey and the file containing the corresponding NKey seed. On connect, the library will load this file to look for the NKey seed and use it to sign the nonce sent by the server. The library takes care of clearing the memory where the seed is copied as soon\nas the nonce is signed.\n\n```c\ns = natsOptions_SetNKeyFromSeed(opts, \"UDXU4RCSJNZOIQHZNWXHXORDPRTGNJAHAHFRGZNEEJCPQTT2M7NLCNF4\", \"seed.nk\");\nif (s == NATS_OK)\n    s = natsConnection_Connect(&nc, opts);\n```\nThe \"seed.nk\" file contains the NKey seed (private key). Here is an example:\n```\n$ more seed.nk\nSUACSSL3UAHUDXKFSNVUZRF5UHPMWZ6BFDTJ7M6USDXIEDNPPQYYYCU3VY\n```\n\nFinally, it is possible to specify the public NKey and the signature callback. The public key will be sent to the server and the provided callback is responsible for signing the server's nonce. When the server receives the signed nonce, it can check that it was signed poperly using the provided public key.\n\n```c\n/*\n * myPublicKey is the user's public key, which will be sent to the server.\n * mySignatureCB is a callback that is presented with a nonce and is\n * responsible for returning the signature for this nonce.\n * An optional closure can be specified.\n */\ns = natsOptions_SetNKey(opts, myPublicKey, mySignatureCb, NULL);\nif (s == NATS_OK)\n    s = natsConnection_Connect(&nc, opts);\n```\nThe signature callback can use any crypto library to sign the nonce, but also the provided `nats_Sign()` function.\n```c\nnatsStatus\nmySignatureCb(\n    char            **customErrTxt,\n    unsigned char   **signature,\n    int             *signatureLength,\n    const char      *nonce,\n    void            *closure)\n{\n    // This approach requires to provide the seed (private key).\n    // Hardcoding it in the application (like in this example) may not be really safe.\n    return nats_Sign(\n        \"SUACSSL3UAHUDXKFSNVUZRF5UHPMWZ6BFDTJ7M6USDXIEDNPPQYYYCU3VY\",\n        nonce, signature, signatureLength);\n}\n```\n\nYou can sign any content and get the signature in return. The connection must have been created with the `natsOptions_SetUserCredentialsFromFiles()` option for that to work.\n```c\n    s = natsOptions_Create(&opts);\n    if (s == NATS_OK)\n        s = natsOptions_SetUserCredentialsFromFiles(opts, \"user.creds\", NULL);\n    if (s == NATS_OK)\n        s = natsConnection_Connect(&nc, opts);\n\n    // Sign some arbitrary content\n    const unsigned char *content   = (const unsigned char*) \"hello\";\n    int                 contentLen = 5;\n    unsigned char       sig[64];\n\n    s = natsConnection_Sign(nc, content, contentLen, sig);\n    if (s == NATS_OK)\n    {\n        // Do something with signature...\n    }\n```\n\n## Advanced Usage\n\nFlushing a connection ensures that any data buffered is flushed (sent to) the NATS Server.\n\n```c\n// Flush connection to server, returns when all messages have been processed.\nnatsConnection_Flush(nc);\nprintf(\"All clear!\\n\");\n\n// Same as above but with a timeout value, expressed in milliseconds.\ns = natsConnection_FlushTimeout(nc, 1000);\nif (s == NATS_OK)\n    printf(\"All clear!\\n\");\nelse if (s == NATS_TIMEOUT)\n    printf(\"Flushed timed out!\\n\");\nelse\n    printf(\"Error during flush: %d - %s\\n\", s, natsStatus_GetText(s));\n```\n\nAuto-unsubscribe allows a subscription to be automatically removed when the subscriber has received a given number of messages. This is used internally by the `natsConnection_Request()` call.\n\n```c\n// Auto-unsubscribe after 100 messages received\nnatsConnection_Subscribe(&sub, nc, \"foo\", onMsg, NULL);\nnatsSubscription_AutoUnsubscribe(sub, 100);\n```\n\nSubscriptions can be drained. This ensures that the interest is removed from the server but that all messages that were internally queued are processed.\n\n```c\n// This call does not block.\nnatsSubscription_Drain(sub);\n\n// If you want to wait for the drain to complete, call this\n// and specify a timeout. Zero or negative to wait for ever.\nnatsSubscription_WaitForDrainCompletion(sub, 0);\n```\n\nConnections can be drained. This process will first put all registered subscriptions in drain mode and prevent any new subscription from being created. When all subscriptions are drained, the publish calls are drained (by the mean of a connection flush) and new publish calls will fail at this point. Then the connection is closed.\n\n```c\n// Use default timeout of 30 seconds.\n// But this call does not block. Use natsOptions_SetClosedCB() to be notified\n// that the connection is closed.\nnatsConnection_Drain(nc);\n\n// To specify a timeout for the operation to complete, after which the connection\n// is forcefully closed. Here is an exampel of a timeout of 10 seconds (10,000 ms).\nnatsConnection_DrainTimeout(nc, 10000);\n```\n\nYou can have multiple connections in your application, mixing subscribers and publishers.\n```c\n// Create a connection 'nc1' to host1\nnatsConnection_ConnectTo(&nc1, \"nats://host1:4222\");\n\n// Create a connection 'nc2' to host2\nnatsConnection_ConnectTo(&nc2, \"nats://host2:4222\");\n\n// Create a subscription on 'foo' from connection 'nc1'\nnatsConnection_Subscribe(&sub, nc1, \"foo\", onMsg, NULL);\n\n// Uses connection 'nc2' to publish a message on subject 'foo'. The subscriber\n// created previously will receive it through connection 'nc1'.\nnatsConnection_PublishString(nc2, \"foo\", \"hello\");\n```\n\nThe use of `natsOptions` allows you to specify options used by the `natsConnection_Connect()` call. Note that the `natsOptions` object that is  passed to this call is cloned, whhich means that any modification done to the options object will not have any effect on the connected connection.\n\n```c\nnatsOptions *opts = NULL;\n\n// Create an options object\nnatsOptions_Create(&opts);\n\n// Set some properties, starting with the URL to connect to:\nnatsOptions_SetURL(opts, \"nats://host1:4222\");\n\n// Set a callback for asynchronous errors. This is useful when having an asynchronous\n// subscriber, which would otherwise have no other way of reporting an error.\nnatsOptions_SetErrorHandler(opts, asyncCb, NULL);\n\n// Connect using those options:\nnatsConnection_Connect(&nc, opts);\n\n// Destroy the options object to free memory. The object was cloned by the connection,\n// so the options can be safely destroyed.\nnatsOptions_Destroy(opts);\n```\n\nAs we have seen, all callbacks have a `void *closure` parameter. This is useful when the callback needs to perform some work and need a reference to some object. When setting up the callback, you can specify a pointer to that object.\n```c\n// Our object definition\ntypedef struct __Errors\n{\n    int count;\n\n} Errors;\n\n(...)\n\nint\nmain(int argc, char **argv)\n{\n    // Declare an 'Errors' object on the stack.\n    Errors asyncErrors;\n\n    // Initialize this object\n    memset(&asyncErrors, 0, sizeof(asyncErrors);\n\n    // Create a natsOptions object.\n    (...)\n\n    // Set the error callback, and pass the address of our Errors object.\n    natsOptions_SetErrorHandler(opts, asyncCb, (void*) &asyncErrors);\n\n    // Create the connection and subscriber.\n    (...)\n\n    // Say that we are done subscribing, we could check the number of errors:\n    if (asyncErrors.count > 1000)\n    {\n        printf(\"That's a lot of errors!\\n\");\n    }\n\n    (...)\n}\n```\n\nThe callback would use the closure this way:\n```c\nstatic void\nasyncCb(natsConnection *nc, natsSubscription *sub, natsStatus err, void *closure)\n{\n    Errors *errors = (Errors*) closure;\n\n    printf(\"Async error: %d - %s\\n\", err, natsStatus_GetText(err));\n\n    errors->count++;\n}\n```\nThis is the same for all other callbacks used in the C NATS library.\n\nThe library can automaticall reconnect to a NATS Server if the connection breaks.\nHowever, the initial connect itself would fail if no server is available at the\ntime of the connect. An option has been added to make the connect behaves as\nthe reconnect, using the reconnect attempts and wait:\n```c\n    s = natsOptions_SetMaxReconnect(opts, 5);\n    if (s == NATS_OK)\n        s = natsOptions_SetReconnectWait(opts, 1000);\n\n    // Instruct the library to block the connect call for that\n    // long until it can get a connection or fails.\n    if (s == NATS_OK)\n        s = natsOptions_SetRetryOnFailedConnect(opts, true, NULL, NULL);\n\n    // If the server is not running, this will block for about 5 seconds.\n    s = natsConnection_Connect(&conn, opts);\n```\n\nYou can make the connect asynchronous (if it can't connect immediately) by\npassing a connection handler:\n```c\n    s = natsOptions_SetMaxReconnect(opts, 5);\n    if (s == NATS_OK)\n        s = natsOptions_SetReconnectWait(opts, 1000);\n    if (s == NATS_OK)\n        s = natsOptions_SetRetryOnFailedConnect(opts, true, connectedCB, NULL);\n\n    // Start the connect. If no server is running, it should return NATS_NOT_YET_CONNECTED.\n    s = natsConnection_Connect(&conn, opts);\n    printf(\"natsConnection_Connect call returned: %s\\n\", natsStatus_GetText(s));\n\n    // Connection can be used to create subscription and publish messages (as\n    // long as the reconnect buffer is not full).\n```\nCheck the example `examples/connect.c` for more use cases.\n\nYou can also specify a write deadline which means that when the library is trying to\nsend bytes to the NATS Server, if the connection if unhealthy but as not been reported\nas closed, calls will fail with a `NATS_TIMEOUT` error. The socket will be closed and\nthe library will attempt to reconnect (unless disabled). Note that this could also\nhappen in the event the server is not consuming fast enough.\n```c\n    // Sets a write deadline of 2 seconds (value is in milliseconds).\n    s = natsOptions_SetWriteDeadline(opts, 2000);\n```\n\n## Clustered Usage\n\n```c\nstatic char *servers[] = { \"nats://localhost:1222\",\n                           \"nats://localhost:1223\",\n                           \"nats://localhost:1224\"};\n\n// Setup options to include all servers in the cluster.\n// We first created an options object, and pass the list of servers, specifying\n// the number of servers on that list.\nnatsOptions_SetServers(opts, servers, 3);\n\n// We could also set the amount to sleep between each reconnect attempt (expressed in\n// milliseconds), and the number of reconnect attempts.\nnatsOptions_SetMaxReconnect(opts, 5);\nnatsOptions_SetReconnectWait(opts, 2000);\n\n// We could also disable the randomization of the server pool\nnatsOptions_SetNoRandomize(opts, true);\n\n// Setup a callback to be notified on disconnects...\nnatsOptions_SetDisconnectedCB(opts, disconnectedCb, NULL);\n\n// And on reconncet\nnatsOptions_SetReconnectedCB(opts, reconnectedCb, NULL);\n\n// This callback could be used to see who we are connected to on reconnect\nstatic void\nreconnectedCb(natsConnection *nc, void *closure)\n{\n    // Define a buffer to receive the url\n    char buffer[64];\n\n    buffer[0] = '\\0';\n\n    natsConnection_GetConnectedUrl(nc, buffer, sizeof(buffer));\n    printf(\"Got reconnected to: %s\\n\", buffer);\n}\n```\n\n## Using an Event Loop Library\n\nFor each connection, the `NATS` library creates a thread reading data from the socket. Publishing data results in the data being appended to a buffer, which is 'flushed' from a timer callback or in place when the buffer reaches a certain size. Flushing means that we write to the socket (and the socket is in blocking-mode).\n\nIf you have multiple connections running in your process, the number of threads will increase (because each connection uses a thread for receiving data from the socket). If this becomes an issue, or if you are already using an event notification library, you can instruct the `NATS` library to use that event library instead of using a thread to do the reads, and directly writing to the socket when data is published.\n\nThis works by setting the event loop and various callbacks through the `natsOptions_SetEventLoop()` API. Depending of the event loop you are using, you then have extra API calls to make. The API is in the `adapters` directory and is documented.\n\nWe provide adapters for two event notification libraries: [libevent](https://github.com/libevent/libevent), and [libuv](https://github.com/libuv/libuv).\n\n```c\n// Create an event loop object\nuv_loop_t *uvLoop = uv_default_loop();\n\n// Set it into an options object\nnatsOptions_SetEventLoop(opts,\n                         (void*) uvLoop,\n                         natsLibuv_Attach,\n                         natsLibuv_Read,\n                         natsLibuv_Write,\n                         natsLibuv_Detach);\n\n// Connect (as usual)\nnatsConnection_Connect(&conn, opts);\n\n// Subscribe (as usual)\nnatsConnection_Subscribe(&sub, conn, subj, onMsg, NULL);\n\n// Run the event loop\nuv_run(uvLoop, UV_RUN_DEFAULT);\n```\n\nThe callback `onMsg` that you have registered will be triggered as usual when data becomes available.\n\nWhere it becomes tricky is when publishing data. Indeed, publishing is merely putting data in a buffer, and it is the event library that will notify a callback that write to the socket should be performed. For that, the event loop needs to be 'running'.\n\nSo if you publish from the thread where the event loop is running, you need to 'run' the loop after each (or a number) of publish calls in order for data to actually be sent out. Alternatively, you can publish from a different thread than the thread running the event loop.\n\nThe above is important to keep in mind regarding calls that are doing request-reply. They should not be made from the thread running the event loop. Here is an example of such calls:\n\n```\nnatsConnection_Request()\nnatsConnection_Flush()\nnatsConnection_FlushTimeout()\n...\n```\n\nIndeed, since these calls publish data and wait for a 'response', if you execute then in the event loop thread (or while the loop is not 'running'), then data will not be sent out. Calls will fail to get a response and timeout.\n\nFor `natsConnection_Request()`, use the `natsConnection_PublishRequest()` instead, and have a subscriber for the response registered.\n\nFor others, asynchronous version of these calls should be made available.\n\nSee examples in the `examples` directory for complete usage.\n\n## FAQ\n\nHere are some of the frequently asked questions:\n\n<b>Where do I start?</b>\n\nThere are several resources that will help you get started using the NATS C Client library.\n<br>\nThe `examples/getstarted` directory contains very basic programs that use\nthe library for simple functions such as sending a message or setting up a subscription.\n<br>\nThe `examples` directory itself contains more elaborated examples that include error\nhandling and more advanced APIs. You will also find examples to that show the use\nof the NATS C Client library and external event loops.\n\n<b>What about support for platform XYZ?</b>\n\nWe support platforms that are available to us for development and testing. This is currently\nlimited to Linux, macOS and Windows. Even then, there may be OS versions that you may have\nproblem building with and we will gladly accept PRs to fix the build process as long as it\ndoes not break the ones we support!\n\n<b>How do I build?</b>\n\nWe use cmake since it allows cross-platforms builds. This works for us. You are free to\ncreate your own makefile or Windows solution. If you want to use cmake, follow these\n[instructions](https://github.com/nats-io/nats.c#build).\n\n<b>I have found a bug in your library, what do I do?</b>\n\nPlease report an issue [here](https://github.com/nats-io/nats.c/issues/new). Give us as much\nas possible information on how you can reproduce this. If you have a fix for it, you can\nalso open a PR.\n\n<b>Is the library thread-safe?</b>\n\nAll calls use internal locking where needed. As a user, you would need to do your own locking\nif you were to share the same callback with different subscribers (since the callback would\nbe invoked from different threads for each subscriber).<br>\nNote that this is true for any kind of callback that exist in the NATS C library, such as\nconnection or error handlers, etc.. if you specify the same callback you take the risk that\nthe code in that callback may be executed from different internal threads.\n\n<b>What is the threading model of the library?</b>\n\nThe library uses some threads to handle internal timers or dispatch asynchronous errors\nfor instance. Here is a list of threads created as a result of the user creating NATS\nobjects:\n\n- Each connection has a thread to read data from the socket. If you use an external\nevent loop, this thread is not created.\n\n- Each connection has a thread responsible for flushing its outgoing buffer. If you create\nthe connection with the `natsOptions_SetSendAsap()` option, this thread is not created since\nany outgoing data is flushed right away.\n\n- Each asynchronous subscription has a thread used to dispatch messages to the user callback.\nIf you use `nats_SetMessageDeliveryPoolSize()`, a global thread pool (of the\nsize given as a parameter to that function) is used instead of a per-async-subscription thread.\n\n<b>How do I send binary data?</b>\n\nNATS is a text protocol with message payload being a byte array. The server never interprets\nthe content of a message.\n\nThe natsConnection_Publish() API accepts a pointer to memory and the user provides how many\nbytes from that location need to be sent. The natsConnection_PublishString() is added for\nconvenience if you want to send strings, but it is really equivalent to calling natsConnection_Publish()\nwith `strlen` for the number of bytes.\n\n<b>Is the data sent in place or from a different thread?</b>\n\nFor throughput reasons (and to mimic the Go client this library is based on), the client library\nuses a buffer for all socket writes. This buffer is flushed in the thread where the publish occurs\nif the buffer is full. The buffer size can be configured with natsOptions_SetIOBufSize(). You can query how\nmuch data is in that buffer using the natsConnection_Buffered() function.\n\nWhen a publish call does not fill the buffer, the call returns without any data actually sent\nto the server. A dedicated thread (the flusher thread) will flush this buffer automatically. This\nhelps with throughput since the number of system calls are reduced and the number of bytes\nsent at once is higher, however, it can add latency for request/reply situations where one\nwants to send one message at a time. To that effect, natsConnection_Request() call does flush\nthe buffer in place and does not rely on the flusher thread.\n\nThe option natsOptions_SetSendAsap() can be used to force all publish calls from the connection\ncreated with this option to flush the socket buffer at every call and not add delay by relying\non the flusher thread.\n\n<b>The publish call did not return an error, is the message guaranteed to be sent to a subscriber?</b>\n\nNo! It is not even guaranteed that the server got that message. As described above, the message\ncould simply be in connection's buffer, even if each publish call is flushing the socket buffer,\nafter that, the call returns. There is no feedback from the server that it has actually processed\nthat message. The server could have crashed after reading from the socket.\n\nRegardless if the server has gotten the message or not, there is a total decoupling between\npublishing and subscribing. If the publisher needs to know that its message has bee received\nand processed by the subscribing application, request/reply pattern should be used. Check\nnatsConnection_Request() and natsConnection_PublishRequest() for more details.\n\n<b>Do I need to call natsConnection_Flush() everywhere?</b>\n\nThis function is not merely flushing the socket buffer, instead it sends a `PING` protocol\nmessage to the server and gets a `PONG` back in a synchronous way.\n\nAs previously described, if you want to flush the socket buffer to reduce latency in all\npublish calls, you should create the connection with the \"send asap\" option.\n\nThe natsConnection_Flush() API is often used to ensure that the server has processed one of the\nprotocol messages.\n\nFor instance, creating a subscription is asynchronous. When the call returns, you may\nget an error if the connection was previously closed, but you would not get an error if your\nconnection user has no permission to create this subscription for instance.\n\nInstead, the server sends an error message that is asynchronously received by the client library.\nCalling natsConnection_Flush() on the same connection that created the subscription ensures\nthat the server has processed the subscription and if there was an error has sent that error back\nbefore the `PONG`. It is then possible to check the natsConnection_GetLastError()\nto figure out if the subscription was successfully registered or not.\n\n<b>How is data and protocols received from the server?</b>\n\nWhen you create a connection, a library thread is created to read protocols (including messages)\nfrom the socket. You do not have to do anything in that regard. When data is read from the socket\nit will be turned into protocols or messages and distributed to appropriate callbacks.\n\n<b>Lot of things are asynchronous, how do I know if there is an error?</b>\n\nYou should set error callbacks to be notified when asynchronous errors occur. These can be\nset through the use of natsOptions. Check natsOptions_SetErrorHandler() for instance. If you\nregister an error callback for a connection, should an error occurs, your registered error handler\nwill be invoked.\n\n<b>Are messages from an asynchronous subscription dispatched in parallel?</b>\n\nWhen you create an asynchronous subscription, the library will create a thread that is responsible\nto dispatch messages for that subscription. Messages for a given subscription are dispatched\nsequentially. That is, your callback is invoked with one message at a time, and only after the\ncallback returns that the library invokes it again with the next pending message.\n\nSo there is a thread per connection draining data from the socket, and then messages are passed\nto the matching subscription thread that is then responsible to dispatch them.\n\nIf you plan to have many subscriptions and to reduce the number of threads used by the library,\nyou should look at using a library level thread pool that will take care of messages dispatching.\nSee nats_SetMessageDeliveryPoolSize(). A subscription will make use of the library pool if the\nconnection it was created from had the natsOptions_UseGlobalMessageDelivery() option set to true.\n\nEven when using the global pool, messages from a given subscription are always dispatched\nsequentially and from the same thread.\n\n<b>What is the SLOW CONSUMER error that I see in the server?</b>\n\nThe server when sending data to a client (or route) connection sets a write deadline. That is,\nif the socket write blocks for that amount of time, it will simply close the connection.\n\nThis error occurs when the client (or other server) is not reading data fast enough from the\nsocket. As we have seen earlier, a client connection creates a thread whose job is to read\ndata from the socket, parse it and move protocol or messages to appropriate handlers.\n\nSo this is not really symptomatic of a message handler  processing messages too slowly,\ninstead it is probably the result of resources issues (not enough CPU cycles to read from the\nsocket, or not reading fast enough) or internal locking contention that prevents the thread\nreading from the socket to read data fast enough because it is blocked trying to acquire some\nlock.\n\n<b>What is the SLOW CONSUMER error in the client then?</b>\n\nThis error, in contrast with the error reported by the server, has to do with the disptaching\nof messages to the user callback. As explained, messages are moved from the connection's\nthread reading from the socket to the subscription's thread responsible for dispatching.\n\nThe subscription's internal queue as a default limited size. When the connection's thread\ncannot add a message to that queue because it is full, it will drop the message and if\nan error handler has been set, a message will be posted there.\n\nFor instance, having a message handler that takes too much time processing a message is\nlikely to cause a slow consumer client error if the incoming message rate is high and/or\nthe subscription pending limits are not big enough.\n\nThe natsSubscription_SetPendingLimits() API can be used to set the subscription's internal\nqueue limits. Values of `-1` for count and/or size means that the corresponding metric will\nnot be checked. Setting both to `-1` mean that the client library will queued all incoming\nmessages, regardless at which speed they are dispatched, which could cause your application\nto use lots of memory.\n\n<b>What happens if the server is restarted or there is a disconnect?</b>\n\nBy default, the library will try to reconnect. Reconnection options can be set to either\ndisable reconnect logic entirely, or set the number of attempts and delay between attempts.\nSee natsOptions_SetAllowReconnect(), natsOptions_SetMaxReconnect(), etc... for more information.\n\nIf you have not set natsOptions_SetNoRadomize() to true, then the list of given URLs are randomized\nwhen the connection is created. When a disconnect occurs, the next URL is tried. If that fails,\nthe library moves to the next. When all have been tried, the loop restart from the first until\nthey have all been tried the max reconnect attempts defined through options. The library\nwill pause for as long as defined in the options when trying to reconnect to a server it was\npreviously connected to.\n\nIf you connect to a server that has the connect URL advertise enabled (default for servers 0.9.2+),\nwhen servers are added to the cluster of NATS Servers, the server will send URLs of this\nnew server to its clients. This augments the \"pool\" or URLs that the connection may have been\ncreated with and allows the library to reconnect to servers that have been added to the cluster.\n\nWhile the library is disconnected from the server, all publish or new subscription calls are\nbuffered in memory. This buffer as a default size but can be configured. When this buffer is\nfull, further publish or new subscription calls will report failures.<br>\nWhen the client library has reconnected to the server, the pending buffer will\nbe flushed to the server.\n\nIf your application needs to know if a disconnect occurs, or when the library has reconnected,\nyou should again set some callbacks to be notified of such events. Use natsOptions_SetDisconnectedCB(),\nnatsOptions_SetReconnectedCB() and natsOptions_SetClosedCB(). Note that the later is a final\nevent for a connection. When this callback is invoked, the connection is no longer valid, that\nis, you will no longer receive or be able to send data with this connection.\n\n<b>Do I need to free NATS objects?</b>\n\nAll objects that you create and that have a `_Destroy()` API should indeed be destroyed\nif you want to not leak memory.One that is important and often missed is `natsMsg_Destroy()` that\nneeds to be called in the message handler once you are done processing the message. The\nmessage has been created by the library and given to you in the message handler, but you are\nresponsible for calling `natsMsg_Destroy()`.\n\n<b>What is nats_ReleaseThreadMemory() doing?</b>\n\nThe NATS C library may store objects using local thread storage. Threads that are created and\nhandled by the library are automatically cleaned-up, however, if the user creates a thread\nand invokes some NATS APIs, there is a possibility that the library stored something in that\nthread local storage. When the thread exits, the user should call this function so that\nthe library can destroy objects that it may have stored.\n\n# NATS Streaming Client\n\n## Streaming Basic Usage\n\nNote that error checking is being ignored for clarity. Check the `examples/stan` directory\nfor complete usage.\n\n```\n// Connect without options\nstanConnection_Connect(&sc, cluster, clientID, NULL);\n\n// Simple Synchronous Publisher.\n// This does not return until an ack has been received from NATS Streaming\nstanConnection_Publish(sc, \"foo\", (const void*) \"hello\", 5);\n\n// Simple Async Subscriber\nstanConnection_PublishAsync(sc, \"foo\", (const void*) \"hello\", 5, _pubAckHandler, NULL);\n\n// Simple Subscription without options (default to non durable, receive new only)\nstanConnection_Subscribe(&sub, sc, \"foo\", onMsg, NULL, NULL);\n\n// Unsubscribe (note that for non durable subscriptions, Unsubscribe() and Close() are the same\nstanSubscription_Unsubscribe(sub);\n\n// Close connection\nstanConnection_Close(sc);\n```\n\n### Streaming Subscriptions\n\nNATS Streaming subscriptions are similar to NATS subscriptions, but clients may start their subscription at an earlier point in the message stream, allowing them to receive messages that were published before this client registered interest.\n\nThe options are described with examples below:\n\n```\n// Create a Subscription Options:\nstanSubOptions *subOpts = NULL;\n\nstanSubOptions_Create(&subOpts);\n\n// Subscribe starting with most recently published value\nstanSubOptions_StartWithLastReceived(subOpts);\n\n// OR: Receive all stored messages\nstanSubOptions_DeliverAllAvailable(subOpts);\n\n// OR: Receive messages starting at a specific sequence number\nstanSubOptions_StartAtSequence(subOpts, 22);\n\n// OR: Start at messages that were stored 30 seconds ago. Value is expressed in milliseconds.\nstanSubOptions_StartAtTimeDelta(subOpts, 30000);\n\n// Create the subscription with options\nstanConnection_Subscribe(&sub, sc, \"foo\", onMsg, NULL, subOpts);\n```\n\n### Streaming Durable Subscriptions\n\nReplay of messages offers great flexibility for clients wishing to begin processing at some earlier point in the data stream.\nHowever, some clients just need to pick up where they left off from an earlier session, without having to manually track their position in the stream of messages.\nDurable subscriptions allow clients to assign a durable name to a subscription when it is created.\nDoing this causes the NATS Streaming server to track the last acknowledged message for that clientID + durable name, so that only messages since the last acknowledged message will be delivered to the client.\n\n```\nstanConnection_Connect(&sc, \"test-cluster\", \"client-123\", NULL);\n\n// Create subscription options\nstanSubOptions_Create(&subOpts);\n\n// Set a durable name\nstanSubOptions_SetDurableName(subOpts, \"my-durable\");\n\n// Subscribe\nstanConnection_Subscribe(&sub, sc, \"foo\", onMsg, NULL, subOpts);\n...\n// client receives message sequence 1-40\n...\n// client disconnects for an hour\n...\n// client reconnects with same clientID \"client-123\"\nstanConnection_Connect(&sc, \"test-cluster\", \"client-123\", NULL);\n\n// client re-subscribes to \"foo\" with same durable name \"my-durable\"\nstanSubOptions_Create(&subOpts);\nstanSubOptions_SetDurableName(subOpts, \"my-durable\");\nstanConnection_Subscribe(&sub, sc, \"foo\", onMsg, NULL, subOpts);\n...\n// client receives messages 41-current\n```\n\n### Streaming Queue Groups\n\nAll subscriptions with the same queue name (regardless of the connection\nthey originate from) will form a queue group.\nEach message will be delivered to only one subscriber per queue group,\nusing queuing semantics. You can have as many queue groups as you wish.\n\nNormal subscribers will continue to work as expected.\n\n#### Creating a Queue Group\n\nA queue group is automatically created when the first queue subscriber is\ncreated. If the group already exists, the member is added to the group.\n\n```\nstanConnection_Connect(&sc, \"test-cluster\", \"clientid\", NULL);\n\n// Create a queue subscriber on \"foo\" for group \"bar\"\nstanConnection_QueueSubscribe(&qsub1, \"foo\", \"bar\", onMsg, NULL, NULL);\n\n// Add a second member\nstanConnection_QueueSubscribe(&qsub2, \"foo\", \"bar\", onMsg, NULL, NULL);\n\n// Notice that you can have a regular subscriber on that subject\nstanConnection_Subscribe(&sub, sc, \"foo\", onMsg, NULL, NULL);\n\n// A message on \"foo\" will be received by sub and qsub1 or qsub2.\n```\n\n#### Start Position\n\nNote that once a queue group is formed, a member's start position is ignored\nwhen added to the group. It will start receive messages from the last\nposition in the group.\n\nSuppose the channel `foo` exists and there are `500` messages stored, the group\n`bar` is already created, there are two members and the last\nmessage sequence sent is `100`. A new member is added. Note its start position:\n\n```\nstanSubOptions_Create(&subOpts);\nstanSubOptions_StartAtSequence(subOpts, 200);\n\nstanConnection_QueueSubscribe(&qsub, \"foo\", \"bar\", onMsg, NULL, subOpts);\n```\n\nThis will not produce an error, but the start position will be ignored. Assuming\nthis member would be the one receiving the next message, it would receive message\nsequence `101`.\n\n#### Leaving the Group\n\nThere are two ways of leaving the group: closing the subscriber's connection or\ncalling `Unsubscribe`:\n\n```\n// Have qsub leave the queue group\nstanSubscription_Unsubscribe(qsub);\n```\n\nIf the leaving member had un-acknowledged messages, those messages are reassigned\nto the remaining members.\n\n#### Closing a Queue Group\n\nThere is no special API for that. Once all members have left (either calling `Unsubscribe`,\nor their connections are closed), the group is removed from the server.\n\nThe next call to `QueueSubscribe` with the same group name will create a brand new group,\nthat is, the start position will take effect and delivery will start from there.\n\n### Streaming Durable Queue Groups\n\nAs described above, for non durable queue subscribers, when the last member leaves the group,\nthat group is removed. A durable queue group allows you to have all members leave but still\nmaintain state. When a member re-joins, it starts at the last position in that group.\n\n#### Creating a Durable Queue Group\n\nA durable queue group is created in a similar manner as that of a standard queue group,\nexcept the `DurableName` option must be used to specify durability.\n\n```\nstanSubOptions_Create(&subOpts);\nstanSubOptions_SetDurableName(subOpts, \"dur\");\n\nstanConnection_QueueSubscribe(&qsub, \"foo\", \"bar\", onMsg, NULL, subOpts);\n```\nA group called `dur:bar` (the concatenation of durable name and group name) is created in\nthe server. This means two things:\n\n- The character `:` is not allowed for a queue subscriber's durable name.\n- Durable and non-durable queue groups with the same name can coexist.\n\n```\n// Non durable queue subscriber on group \"bar\"\nstanConnection_QueueSubscribe(&qsub, \"foo\", \"bar\", onMsg, NULL, NULL);\n\n// Durable queue subscriber on group \"bar\"\nstanSubOptions_Create(&subOpts);\nstanSubOptions_SetDurableName(subOpts, \"mydurablegroup\");\nstanConnection_QueueSubscribe(&qsub, \"foo\", \"bar\", onMsg, NULL, subOpts);\n\n// The same message produced on \"foo\" would be received by both queue subscribers.\n```\n\n#### Start Position of the Durable Queue Group\n\nThe rules for non-durable queue subscribers apply to durable subscribers.\n\n#### Leaving the Durable Queue Group\n\nAs for non-durable queue subscribers, if a member's connection is closed, or if\n`Unsubscribe` its called, the member leaves the group. Any unacknowledged message\nis transferred to remaining members. See *Closing the Group* for important difference\nwith non-durable queue subscribers.\n\n#### Closing the Durable Queue Group\n\nThe *last* member calling `Unsubscribe` will close (that is destroy) the\ngroup. So if you want to maintain durability of the group, you should not be\ncalling `Unsubscribe`.\n\nSo unlike for non-durable queue subscribers, it is possible to maintain a queue group\nwith no member in the server. When a new member re-joins the durable queue group,\nit will resume from where the group left of, actually first receiving all unacknowledged\nmessages that may have been left when the last member previously left.\n\n\n### Streaming Wildcard Subscriptions\n\nNATS Streaming subscriptions **do not** support wildcards.\n\n\n## Streaming Advanced Usage\n\n### Connection Status\n\nThe fact that the NATS Streaming server and clients are not directly connected poses a challenge when it comes to know if a client is still valid.\nWhen a client disconnects, the streaming server is not notified, hence the importance of calling `stanConnection_Close()`. The server sends heartbeats\nto the client's private inbox and if it misses a certain number of responses, it will consider the client's connection lost and remove it\nfrom its state.\n\nWhy do we need PINGs? Picture the case where a client connects to a NATS Server which has a route to a NATS Streaming server (either connecting\nto a standalone NATS Server or the server it embeds). If the connection between the streaming server and the client's NATS Server is broken,\nthe client's NATS connection would still be ok, yet, no communication with the streaming server is possible.\n\nStarting with NATS Streaming Server `0.10.2`, the client library will send PINGs at regular intervals (default is 5 seconds)\nand will close the streaming connection after a certain number of PINGs have been sent without any response (default is 3). When that\nhappens, a callback - if one is registered - will be invoked to notify the user that the connection is permanently lost, and the reason\nfor the failure.\n\nHere is how you would specify your own PING values and the callback:\n\n```\nstanConnOptions_Create(&connOpts);\n\n// Send PINGs every 10 seconds, and fail after 5 PINGs without any response.\nstanConnOptions_SetPings(connOpts, 10, 5);\n\n// Add a callback to be notified if the STAN connection is lost for good.\nstanConnOptions_SetConnectionLostHandler(connOpts, connectionLostCB, NULL);\n\n// Here is an example of the `connectionLostCB`:\nconnectionLostCB(stanConnection *sc, const char *errTxt, void *closure)\n{\n    printf(\"Connection lost: %s\\n\", errTxt);\n}\n```\n\nNote that the only way to be notified in your application is to set the callback. If the callback is not set, PINGs are still sent and the connection\nwill be closed if needed, but the application won't know if it has only subscriptions. A default callback is used to simply\nprint to standard error the clusterID, the clientID and the error that caused the connection to be lost:\n```\nConnection permanently lost: clusterID=test-cluster clientID=client error=connection lost due to PING failure\n```\n\nWhen the connection is lost, your application would have to re-create it and all subscriptions if any.\n\nThe library creates its own NATS connection and sets set the reconnect attempts to \"infinite\". It should therefore be possible\nfor the library to always reconnect, but this does not mean that the streaming connection will not be closed, even if you set\na very high threshold for the PINGs max out value. Keep in mind that while the client is disconnected, the server is sending\nheartbeats to the clients too, and when not getting any response, it will remove that client from its state. When the\ncommunication is restored, the PINGs sent to the server will allow to detect this condition and report to the client that\nthe connection is now closed.\n\nAlso, while a client is \"disconnected\" from the server, another application with connectivity to the streaming server may\nconnect and uses the same client ID. The server, when detecting the duplicate client ID, will try to contact the first client\nto know if it should reject the connect request of the second client. Since the communication between the server and the\nfirst client is broken, the server will not get a response and therefore will replace the first client with the second one.\n\nPrior to NATS Streaming Server `0.10.2`, if the communication between the first client and server were to be restored,\nand the application would send messages, the server would accept those because the published messages client ID would be\nvalid, although the client is not. With a server `0.10.2+`, additional information is sent with each message to allow\nthe server to reject messages from a client that has been replaced by another client.\n\n### Asynchronous Publishing\n\nThe basic publish API (`stanConnection_Publish()`) is synchronous; it does not return control to the caller until the\nNATS Streaming server has acknowledged receipt of the message. To accomplish this, a unique identifier (GUID) is generated for\nthe message on creation, and the client library waits for a publish acknowledgment from the server with a matching GUID before\nit returns control to the caller, possibly with an error indicating that the operation was not successful due to some server\nproblem or authorization error.\n\nAdvanced users may wish to process these publish acknowledgments manually to achieve higher publish throughput by not\nwaiting on individual acknowledgments during the publish operation. An asynchronous publish API is provided for this purpose:\n\n```\nstatic void\n_pubAckHandler(const char *guid, const char *error, void *closure)\n{\n    // Note: this callback can be invoked by different threads\n    if (error != NULL)\n        printf(\"pub ack for guid:%s error:%s\\n\", guid, error);\n    else\n        printf(\"Received ack for msg id %s\\n\", guid);\n}\n\n(...)\n\ns = stanConnection_PublishAsync(sc, \"foo\", (const void*) \"hello\", 5, _pubAckHandler, NULL);\nif (s != NULL)\n{\n    printf(\"Error on publish: %d - %s\\n\", s, natsStatus_GetText(s));\n    nats_PrintLastErrorStack(stderr);\n}\n```\nIf you want to correlate the published message with the guid in the acknowledgment handler, you should pass\na unique closure as the last argument of the `stanConnection_PublishAsync()` call. Check the `examples/stan/pub-async.c`\nfile for an example on how to do so.\n\n### Message Acknowledgments and Redelivery\n\nNATS Streaming offers At-Least-Once delivery semantics, meaning that once a message has been delivered to an eligible subscriber,\nif an acknowledgment is not received within the configured timeout interval, NATS Streaming will attempt redelivery of the message.\nThis timeout interval is specified by the subscription option `stanSubOptions_SetAckWait()`, which defaults to 30 seconds.\n\nBy default, messages are automatically acknowledged by the NATS Streaming client library after the subscriber's message handler\nis invoked. However, there may be cases in which the subscribing client wishes to accelerate or defer acknowledgment of the message.\nTo do this, the client must set manual acknowledgment mode on the subscription, and invoke `stanSubscription_AckMsg()`. ex:\n\n```\n// Subscribe with manual ack mode, and set AckWait to 60 seconds\nstanSubOptions_Create(&subOpts);\nstanSubOptions_SetManualAckMode(subOpts, true);\nstanSubOptions_SetAckWait(subOpts, 60000);\nstanConnection_Subscribe(&sub, sc, \"foo\", onMsg, NULL, subOpts);\n\n// In the callback\nvoid\nonMsg(stanConnection *sc, stanSubscription *sub, const char *channel, stanMsg *msg, void *closure)\n{\n\t// ack message before performing I/O intensive operation\n    stanSubscription_AckMsg(sub, msg);\n\n\tprintf(\"Received a message on %s: %.*s\\n\",\n        channel,\n        stanMsg_GetDataLength(msg),\n        stanMsg_GetData(msg));\n}\n```\n\n## Rate limiting/matching\n\nA classic problem of publish-subscribe messaging is matching the rate of message producers with the rate of message consumers.\nMessage producers can often outpace the speed of the subscribers that are consuming their messages.\nThis mismatch is commonly called a \"fast producer/slow consumer\" problem, and may result in dramatic resource utilization spikes\nin the underlying messaging system as it tries to buffer messages until the slow consumer(s) can catch up.\n\n### Publisher rate limiting\n\nNATS Streaming provides a connection option called `stanConnOptions_SetMaxPubAcksInflight()` that effectively limits the number\nof unacknowledged messages that a publisher may have in-flight at any given time. When this maximum is reached, further publish\ncalls will block until the number of unacknowledged messages falls below the specified limit. ex:\n\n```\nstanConnOptions_Create(&connOpts);\nstanConnOptions_SetMaxPubAcksInflight(connOpts, 25, 1.0);\nstanConnection_Connect(&sc, cluster, clientID, connOpts);\n\n(...)\nstatic void\n_pubAckHandler(const char *guid, const char *error, void *closure)\n{\n    // process the ack\n    ...\n}\n\n(...)\n\nfor (i = 1; i < 1000; i++)\n{\n    // If the server is unable to keep up with the publisher, the number of outstanding acks will eventually\n    // reach the max and this call will block\n    stanConnection_PublishAsync(sc, \"foo\", (const void*) \"hello\", 5, _pubAckHandler, NULL);\n}\n```\n\nNote the last parameter of `stanConnOptions_SetMaxPubAcksInflight()`. This is a float indicating the percentage\nof outstanding ACKs to fall below before being allowed to send more messages. For instance, if the maximum is\n1000 and percentage is 50% (0.5), the it means that if the publish calls were to be blocked because the\nlibrary has sent 1000 messages and not received an ACK yet from the server, the publish calls would be unblocked\nonly when the library has received 500 ACKs from the server. This prevents the connection from being blocked and\nunblocked for each message when the limit has been reached.\n\n### Subscriber rate limiting\n\nRate limiting may also be accomplished on the subscriber side, on a per-subscription basis, using a subscription\noption called `stanSubOptions_SetMaxInflight()`. This option specifies the maximum number of outstanding acknowledgments\n(messages that have been delivered but not acknowledged) that NATS Streaming will allow for a given subscription.\nWhen this limit is reached, NATS Streaming will suspend delivery of messages to this subscription until the number\nof unacknowledged messages falls below the specified limit. ex:\n\n```\n// Subscribe with manual ack mode and a max in-flight limit of 25\nstanSubOptions_Create(&subOpts);\nstanSubOptions_SetManualAckMode(subOpts, true);\nstanSubOptions_SetMaxInflight(subOpts, 25);\nstanConnection_Subscribe(&sub, \"foo\", onMsg, NULL, subOpts);\n\n// In the callback\nvoid\nonMsg(stanConnection *sc, stanSubscription *sub, const char *channel, stanMsg *msg, void *closure)\n{\n    printf(\"Received a message\\n\");\n    ...\n    // Does not ack, or takes a very long time to ack\n    ...\n    // Message delivery will suspend when the number of unacknowledged messages reaches 25\n}\n```\nHowever, the server will redeliver messages for which it did not receive an acknowledgment for more than the\nvalue passed in `stanSubOptions_SetAckWait()` (or 30 seconds by default).\n\n# License\n\nUnless otherwise noted, the NATS source files are distributed\nunder the Apache Version 2.0 license found in the LICENSE file."
}
