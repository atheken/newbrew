{
  "name": "bash_unit",
  "full_name": "bash_unit",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Bash unit testing enterprise edition framework for professionals",
  "license": "GPL-3.0-only",
  "homepage": "https://github.com/pgrange/bash_unit",
  "versions": {
    "stable": "2.1.0",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/pgrange/bash_unit/archive/refs/tags/v2.1.0.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "51b2c9c906c414efb403b6fbf02cfb77d97b442043b29e39c1d6fddc8806972f"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "all": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/bash_unit/blobs/sha256:7b32bfdb5f5ec420b9186e4780075c2ff6c71122a0615b031c016090da668a0f",
          "sha256": "7b32bfdb5f5ec420b9186e4780075c2ff6c71122a0615b031c016090da668a0f"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [
    {
      "bc": "test"
    }
  ],
  "uses_from_macos_bounds": [
    {}
  ],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "2706c66e8def3eeba4d9bf1adf66221c8ad70701",
  "ruby_source_path": "Formula/bash_unit.rb",
  "ruby_source_checksum": {
    "sha256": "bb44d5fc64300e8ca4dfca7f21d61fb881becac495e45a84112cb30cd59d6840"
  },
  "date_added": "2021-07-27T00:32:01+00:00",
  "readme": "ifdef::backend-manpage[]\n= BASH_UNIT(1)\n\n== NAME\nendif::[]\n\nifndef::backend-manpage[]\nimage::img/bu_50.png[bash_unit]\nendif::[]\n\nbash_unit - bash unit testing enterprise edition framework for professionals!\n\n== Synopsis\n\n*bash_unit* [-f tap] [-p <pattern>] [-r] [test_file]\n\n== Description\n\n*bash_unit* allows you to write unit tests (functions starting with *test*),\nrun them and, in case of failure, displays the stack trace\nwith source file and line number indications to locate the problem.\n\nYou might want to take a look at link:getting_started[how to get started]\nbefore continuing reading this documentation.\n\n_(by the way, the documentation you are reading is itself tested with bash-unit)_\n\n*bash_unit* is free software you may contribute to. See link:CONTRIBUTING.md[CONTRIBUTING.md].\n\n:toc:\n\n== Options\n\n*-p* _pattern_::\n  filters tests to run based on the given pattern.\n  You can specify several patterns by repeating this option\n  for each pattern.\n\n*-r*::\n  executes test cases in random order.\n  Only affects the order within a test file (files are always\n  executed in the order in which they are specified on the\n  command line).\n\n*-f* _output_format_::\n  specify an alternative output format.\n  The only supported value is *tap*.\n\nifndef::backend-manpage[]\n\n== How to install *bash_unit*\n\n=== installing on Archlinux\n\n*bash_unit* package is available on Archlinux through AUR. In order to install, issue the following command :\n\n    yaourt -Sys bash_unit\n\n=== installing via link:https://nixos.org/[Nix/NixOS]\n\n*bash_unit* package has been added to link:https://github.com/nixos/nixpkgs[nixpkgs]. You can use it with the following command:\n\n    nix-shell -p bash_unit\n\n=== installing via link:https://brew.sh[Homebrew]\n\n*bash_unit* is available by invoking brew:\n\n    brew install bash_unit\n\n=== other installation\n\nThis will install *bash_unit* in your current working directory:\n\n    bash <(curl -s https://raw.githubusercontent.com/pgrange/bash_unit/master/install.sh)\n\nYou can also download it from the https://github.com/pgrange/bash_unit/releases[release page].\n\nendif::[]\n\n== How to run tests\n\nTo run tests, simply call *bash_unit* with all your tests files as parameter. For instance to run some *bash_unit* tests, from *bash_unit* directory:\n\n```test\n./bash_unit tests/test_core.sh\n```\n\n```output\nRunning tests in tests/test_core.sh\n\tRunning test_assert_equals_fails_when_not_equal ... SUCCESS\n\tRunning test_assert_equals_succeed_when_equal ... SUCCESS\n\tRunning test_assert_fails ... SUCCESS\n\tRunning test_assert_fails_fails ... SUCCESS\n\tRunning test_assert_fails_succeeds ... SUCCESS\n\tRunning test_assert_matches_fails_when_not_matching ... SUCCESS\n\tRunning test_assert_matches_succeed_when_matching ... SUCCESS\n\tRunning test_assert_no_diff_fails_when_diff ... SUCCESS\n\tRunning test_assert_no_diff_succeeds_when_no_diff ... SUCCESS\n\tRunning test_assert_not_equals_fails_when_equal ... SUCCESS\n\tRunning test_assert_not_equals_succeeds_when_not_equal ... SUCCESS\n\tRunning test_assert_not_matches_fails_when_matching ... SUCCESS\n\tRunning test_assert_not_matches_succeed_when_not_matching ... SUCCESS\n\tRunning test_assert_shows_stderr_on_failure ... SUCCESS\n\tRunning test_assert_shows_stdout_on_failure ... SUCCESS\n\tRunning test_assert_status_code_fails ... SUCCESS\n\tRunning test_assert_status_code_succeeds ... SUCCESS\n\tRunning test_assert_succeeds ... SUCCESS\n\tRunning test_assert_within_delta_fails ... SUCCESS\n\tRunning test_assert_within_delta_succeeds ... SUCCESS\n\tRunning test_fail_fails ... SUCCESS\n\tRunning test_fail_prints_failure_message ... SUCCESS\n\tRunning test_fail_prints_where_is_error ... SUCCESS\n\tRunning test_fake_actually_fakes_the_command ... SUCCESS\n\tRunning test_fake_can_fake_inline ... SUCCESS\n\tRunning test_fake_echo_stdin_when_no_params ... SUCCESS\n\tRunning test_fake_exports_faked_in_subshells ... SUCCESS\n\tRunning test_fake_transmits_params_to_fake_code ... SUCCESS\n\tRunning test_fake_transmits_params_to_fake_code_as_array ... SUCCESS\n\tRunning test_should_pretty_format_even_when_LANG_is_unset ... SUCCESS\nOverall result: SUCCESS\n```\n\nYou might also want to run only specific tests, you may do so with the\n_-p_ option. This option accepts a pattern as parameter and filters test\nfunctions against this pattern.\n\n```test\n./bash_unit -p fail_fails -p assert tests/test_core.sh\n```\n\n```output\nRunning tests in tests/test_core.sh\n\tRunning test_assert_equals_fails_when_not_equal ... SUCCESS\n\tRunning test_assert_equals_succeed_when_equal ... SUCCESS\n\tRunning test_assert_fails ... SUCCESS\n\tRunning test_assert_fails_fails ... SUCCESS\n\tRunning test_assert_fails_succeeds ... SUCCESS\n\tRunning test_assert_matches_fails_when_not_matching ... SUCCESS\n\tRunning test_assert_matches_succeed_when_matching ... SUCCESS\n\tRunning test_assert_no_diff_fails_when_diff ... SUCCESS\n\tRunning test_assert_no_diff_succeeds_when_no_diff ... SUCCESS\n\tRunning test_assert_not_equals_fails_when_equal ... SUCCESS\n\tRunning test_assert_not_equals_succeeds_when_not_equal ... SUCCESS\n\tRunning test_assert_not_matches_fails_when_matching ... SUCCESS\n\tRunning test_assert_not_matches_succeed_when_not_matching ... SUCCESS\n\tRunning test_assert_shows_stderr_on_failure ... SUCCESS\n\tRunning test_assert_shows_stdout_on_failure ... SUCCESS\n\tRunning test_assert_status_code_fails ... SUCCESS\n\tRunning test_assert_status_code_succeeds ... SUCCESS\n\tRunning test_assert_succeeds ... SUCCESS\n\tRunning test_assert_within_delta_fails ... SUCCESS\n\tRunning test_assert_within_delta_succeeds ... SUCCESS\n\tRunning test_fail_fails ... SUCCESS\nOverall result: SUCCESS\n```\n\n*bash_unit* supports the http://testanything.org/[Test Anything Protocol] so you can ask for a tap formatted\noutput with the _-f_ option.\n\n```test\n./bash_unit -f tap tests/test_core.sh\n```\n\n```output\n# Running tests in tests/test_core.sh\nok - test_assert_equals_fails_when_not_equal\nok - test_assert_equals_succeed_when_equal\nok - test_assert_fails\nok - test_assert_fails_fails\nok - test_assert_fails_succeeds\nok - test_assert_matches_fails_when_not_matching\nok - test_assert_matches_succeed_when_matching\nok - test_assert_no_diff_fails_when_diff\nok - test_assert_no_diff_succeeds_when_no_diff\nok - test_assert_not_equals_fails_when_equal\nok - test_assert_not_equals_succeeds_when_not_equal\nok - test_assert_not_matches_fails_when_matching\nok - test_assert_not_matches_succeed_when_not_matching\nok - test_assert_shows_stderr_on_failure\nok - test_assert_shows_stdout_on_failure\nok - test_assert_status_code_fails\nok - test_assert_status_code_succeeds\nok - test_assert_succeeds\nok - test_assert_within_delta_fails\nok - test_assert_within_delta_succeeds\nok - test_fail_fails\nok - test_fail_prints_failure_message\nok - test_fail_prints_where_is_error\nok - test_fake_actually_fakes_the_command\nok - test_fake_can_fake_inline\nok - test_fake_echo_stdin_when_no_params\nok - test_fake_exports_faked_in_subshells\nok - test_fake_transmits_params_to_fake_code\nok - test_fake_transmits_params_to_fake_code_as_array\nok - test_should_pretty_format_even_when_LANG_is_unset\n```\n\n== How to write tests\n\nWrite your test functions in a file. The name of a test function has to start with *test*. Only functions starting with *test* will be tested.\n\nUse the *bash_unit* assertion functions in your test functions, see below.\n\nYou may write a *setup* function that will be executed before each test is run.\n\nYou may write a *teardown* function that will be executed after each test is run.\n\nYou may write a *setup_suite* function that will be executed only once before all the tests of your test file.\n\nYou may write a *teardown_suite* function that will be executed only once after all the tests of your test file.\n\nIf you write code outside of any bash function, this code will be executed once at test file loading time since\nyour file is a bash script and *bash_unit* sources it before running your tests. It is suggested to write a\n*setup_suite* function and avoid any code outside a bash function. you must not use any bash_unit assertion\nin setup_suite or use exit in setup_suite for teardown_suite to be run.\nSee https://github.com/pgrange/bash_unit/issues/43[issue 43] for more details.\n\nIf you want to keep an eye on a test not yet implemented, prefix the name of the function by *todo* instead of test.\nTest to do are not executed and do not impact the global status of your test suite but are displayed in *bash_unit* output.\n\n*bash_unit* changes the current working directory to the one of the running test file. If you need to access files from your test code, for instance the script under test, use path relative to the test file.\n\nYou may need to change the behavior of some commands to create conditions for your code under test to behave as expected. The *fake* function may help you to do that, see bellow.\n\n== Test functions\n\n*bash_unit* supports several shell oriented assertion functions.\n\n=== *fail*\n\n    fail [message]\n\nFails the test and displays an optional message.\n\n```test\ntest_can_fail() {\n  fail \"this test failed on purpose\"\n}\n```\n\n```output\n\tRunning test_can_fail ... FAILURE\nthis test failed on purpose\ndoc:2:test_can_fail()\n```\n\n=== *assert*\n\n    assert <assertion> [message]\n\nEvaluates _assertion_ and fails if _assertion_ fails.\n\n_assertion_ fails if its evaluation returns a status code different from 0.\n\nIn case of failure, the standard output and error of the evaluated _assertion_ is displayed. The optional message is also displayed.\n\n```test\ntest_assert_fails() {\n  assert false \"this test failed, obvioulsy\"\n}\ntest_assert_succeed() {\n  assert true\n}\n```\n\n```output\n\tRunning test_assert_fails ... FAILURE\nthis test failed, obvioulsy\ndoc:2:test_assert_fails()\n\tRunning test_assert_succeed ... SUCCESS\n```\n\nBut you probably want to assert less obvious facts.\n\n```test\ncode() {\n  touch /tmp/the_file\n}\n\ntest_code_creates_the_file() {\n  code\n\n  assert \"test -e /tmp/the_file\"\n}\n\ntest_code_makes_the_file_executable() {\n  code\n\n  assert \"test -x /tmp/the_file\" \"/tmp/the_file should be executable\"\n}\n```\n\n```output\n\tRunning test_code_creates_the_file ... SUCCESS\n\tRunning test_code_makes_the_file_executable ... FAILURE\n/tmp/the_file should be executable\ndoc:14:test_code_makes_the_file_executable()\n```\n\nIt may also be fun to use assert to check for the expected content of a file.\n\n```test\ncode() {\n  echo 'not so cool' > /tmp/the_file\n}\n\ntest_code_write_appropriate_content_in_the_file() {\n  code\n\n  assert \"diff <(echo 'this is cool') /tmp/the_file\"\n}\n```\n\n```output\n\tRunning test_code_write_appropriate_content_in_the_file ... FAILURE\nout> 1c1\nout> < this is cool\nout> ---\nout> > not so cool\ndoc:8:test_code_write_appropriate_content_in_the_file()\n```\n\n=== *assert_fail*\n\n    assert_fail <assertion> [message]\n\nAsserts that _assertion_ fails. This is the opposite of *assert*.\n\n_assertion_ fails if its evaluation returns a status code different from 0.\n\nIf the evaluated expression does not fail, then *assert_fail* will fail and display the standard output and error of the evaluated _assertion_. The optional message is also displayed.\n\n```test\ncode() {\n  echo 'not so cool' > /tmp/the_file\n}\n\ntest_code_does_not_write_cool_in_the_file() {\n  code\n\n  assert_fails \"grep cool /tmp/the_file\" \"should not write 'cool' in /tmp/the_file\"\n}\n\ntest_code_does_not_write_this_in_the_file() {\n  code\n\n  assert_fails \"grep this /tmp/the_file\" \"should not write 'this' in /tmp/the_file\"\n}\n```\n\n```output\n\tRunning test_code_does_not_write_cool_in_the_file ... FAILURE\nshould not write 'cool' in /tmp/the_file\nout> not so cool\ndoc:8:test_code_does_not_write_cool_in_the_file()\n\tRunning test_code_does_not_write_this_in_the_file ... SUCCESS\n```\n\n=== *assert_status_code*\n\n    assert_status_code <expected_status_code> <assertion> [message]\n\nChecks for a precise status code of the evaluation of _assertion_.\n\nIt may be useful if you want to distinguish between several error conditions in your code.\n\nIn case of failure, the standard output and error of the evaluated _assertion_ is displayed. The optional message is also displayed.\n\n```test\ncode() {\n  exit 23\n}\n\ntest_code_should_fail_with_code_25() {\n  assert_status_code 25 code\n}\n```\n\n```output\n\tRunning test_code_should_fail_with_code_25 ... FAILURE\n expected status code 25 but was 23\ndoc:6:test_code_should_fail_with_code_25()\n```\n\n=== *assert_equals*\n\n    assert_equals <expected> <actual> [message]\n\nAsserts for equality of the two strings _expected_ and _actual_.\n\n```test\ntest_obvious_inequality_with_assert_equals(){\n  assert_equals \"a string\" \"another string\" \"a string should be another string\"\n}\ntest_obvious_equality_with_assert_equals(){\n  assert_equals a a\n}\n\n```\n\n```output\n\tRunning test_obvious_equality_with_assert_equals ... SUCCESS\n\tRunning test_obvious_inequality_with_assert_equals ... FAILURE\na string should be another string\n expected [a string] but was [another string]\ndoc:2:test_obvious_inequality_with_assert_equals()\n```\n\n=== *assert_not_equals*\n\n    assert_not_equals <unexpected> <actual> [message]\n\nAsserts for inequality of the two strings _unexpected_ and _actual_.\n\n```test\ntest_obvious_equality_with_assert_not_equals(){\n  assert_not_equals \"a string\" \"a string\" \"a string should be different from another string\"\n}\ntest_obvious_inequality_with_assert_not_equals(){\n  assert_not_equals a b\n}\n\n```\n\n```output\n\tRunning test_obvious_equality_with_assert_not_equals ... FAILURE\na string should be different from another string\n expected different value than [a string] but was the same\ndoc:2:test_obvious_equality_with_assert_not_equals()\n\tRunning test_obvious_inequality_with_assert_not_equals ... SUCCESS\n```\n\n=== *assert_matches*\n\n    assert_matches <expected-regex> <actual> [message]\n\nAsserts that the string _actual_ matches the regex pattern _expected-regex_.\n\n```test\ntest_obvious_notmatching_with_assert_matches(){\n  assert_matches \"a str.*\" \"another string\" \"'another string' should not match 'a str.*'\"\n}\ntest_obvious_matching_with_assert_matches(){\n  assert_matches \"a[nN].t{0,1}.*r str.*\" \"another string\"\n}\n\n```\n\n```output\n\tRunning test_obvious_matching_with_assert_matches ... SUCCESS\n\tRunning test_obvious_notmatching_with_assert_matches ... FAILURE\n'another string' should not match 'a str.*'\n expected regex [a str.*] to match [another string]\ndoc:2:test_obvious_notmatching_with_assert_matches()\n```\n\n=== *assert_not_matches*\n\n    assert_not_matches <unexpected-regex> <actual> [message]\n\nAsserts that the string _actual_ does not match the regex pattern _unexpected-regex_.\n\n```test\ntest_obvious_matching_with_assert_not_matches(){\n  assert_not_matches \"a str.*\" \"a string\" \"'a string' should not match 'a str.*'\"\n}\ntest_obvious_notmatching_with_assert_not_matches(){\n  assert_not_matches \"a str.*\" \"another string\"\n}\n\n```\n\n```output\n\tRunning test_obvious_matching_with_assert_not_matches ... FAILURE\n'a string' should not match 'a str.*'\n expected regex [a str.*] should not match but matched [a string]\ndoc:2:test_obvious_matching_with_assert_not_matches()\n\tRunning test_obvious_notmatching_with_assert_not_matches ... SUCCESS\n```\n\n=== *assert_within_delta*\n\n    assert_within_delta <expected num> <actual num> <max delta> [message]\n\nAsserts that the expected num matches the actual num up to a given max delta.\nThis function only support integers.\nGiven an expectation of 5 and a delta of 2 this would match 3, 4, 5, 6, and 7:\n\n```test\ntest_matches_within_delta(){\n  assert_within_delta 5 3 2\n  assert_within_delta 5 4 2\n  assert_within_delta 5 5 2\n  assert_within_delta 5 6 2\n  assert_within_delta 5 7 2\n}\ntest_does_not_match_within_delta(){\n  assert_within_delta 5 2 2\n}\n\n```\n\n```output\n\tRunning test_does_not_match_within_delta ... FAILURE\n expected value [5] to match [2] with a maximum delta of [2]\ndoc:9:test_does_not_match_within_delta()\n\tRunning test_matches_within_delta ... SUCCESS\n```\n\n=== *assert_no_diff*\n\n    assert_no_diff <expected> <actual> [message]\n\nAsserts that the content of the file _actual_ does not have any differences to the one _expected_.\n\n```test\ntest_obvious_notmatching_with_assert_no_diff(){\n  assert_no_diff <(echo foo) <(echo bar)\n}\ntest_obvious_matching_with_assert_assert_no_diff(){\n  assert_no_diff bash_unit bash_unit\n}\n\n```\n\n```output\n\tRunning test_obvious_matching_with_assert_assert_no_diff ... SUCCESS\n\tRunning test_obvious_notmatching_with_assert_no_diff ... FAILURE\n expected 'doc' to be identical to 'doc' but was different\nout> 1c1\nout> < foo\nout> ---\nout> > bar\ndoc:2:test_obvious_notmatching_with_assert_no_diff()\n```\n\n== *fake* function\n\n    fake <command> [replacement code]\n\nFakes _command_ and replaces it with _replacement code_ (if code is specified) for the rest of the execution of your test. If no replacement code is specified, then it replaces command by one that echoes stdin of fake. This may be useful if you need to simulate an environment for you code under test.\n\nFor instance:\n\n```test\nfake ps echo hello world\nps\n```\n\nwill output:\n\n```output\nhello world\n```\n\nWe can do the same using _stdin_ of fake:\n\n```test\nfake ps << EOF\nhello world\nEOF\nps\n```\n\n```output\nhello world\n```\n\nifndef::backend-manpage[]\nIt has been asked whether using *fake* results in creating actual fakes or stubs or mocks? or may be spies? or may be they are dummies?\nThe first answer to this question is: it depends. The second is: read this\nhttps://www.google.fr/search?tbm=isch&q=fake%20mock%20stub[great and detailed literature] on this subject.\nendif::[]\n\n=== Using stdin\n\nHere is an example, parameterizing fake with its _stdin_ to test that code fails when some process does not run and succeeds otherwise:\n\n```test\ncode() {\n  ps a | grep apache\n}\n\ntest_code_succeeds_if_apache_runs() {\n  fake ps <<EOF\n  PID TTY          TIME CMD\n13525 pts/7    00:00:01 bash\n24162 pts/7    00:00:00 ps\n 8387 ?            0:00 /usr/sbin/apache2 -k start\nEOF\n\n  assert code \"code should succeed when apache is running\"\n}\n\ntest_code_fails_if_apache_does_not_run() {\n  fake ps <<EOF\n  PID TTY          TIME CMD\n13525 pts/7    00:00:01 bash\n24162 pts/7    00:00:00 ps\nEOF\n\n  assert_fails code \"code should fail when apache is not running\"\n}\n\n```\n\n```output\n\tRunning test_code_fails_if_apache_does_not_run ... SUCCESS\n\tRunning test_code_succeeds_if_apache_runs ... SUCCESS\n```\n\n=== Using a function\n\nIn a previous exemple, we faked _ps_ by specifying code inline:\n\n```test\nfake ps echo hello world\nps\n```\n\n```output\nhello world\n```\n\nIf you need to write more complex code to fake your command, you may abstract this code in a function:\n\n```test\n_ps() {\n  echo hello world\n}\nfake ps _ps\nps\n```\n\n```output\nhello world\n```\n\nBe carefull however that your _ps function is not exported to sub-processes. It means that, depending on how your code under test works, _ps may not be defined in the context where ps will be called. For instance:\n\n```test\n_ps() {\n  echo hello world\n}\nfake ps _ps\n\nbash -c ps\n```\n\n```output\nenvironment: line 1: _ps: command not found\n```\n\nIt depends on your code under test but it is safer to just export functions needed by your fake so that they are available in sub-processes:\n\n```test\n_ps() {\n  echo hello world\n}\nexport -f _ps\nfake ps _ps\n\nbash -c ps\n```\n\n```output\nhello world\n```\n\n*fake* is also limited by the fact that it defines a _bash_ function to\noverride the actual command. In some context the command can not be\noverriden by a function. For instance if your code under test relies on _exec_ to launch _ps_, *fake* will have no effect.\n\n*fake* may also imply strange behaviors from bash_unit when you try to\nfake really basic stuff. bash_unit tries to be as much immune to this as\npossible but there are some limits. Especially and as surprising as it\nmight seem, bash allows creating functions named after builtin commands\nand bash_unit won't resist that kind of situation. So, for instance, do\nnot try to fake: `exit`; `local`; `trap`; `eval`; `export`; `if`; `then`; `else`; `fi`; `while`; `do`; `done`; `$`; `echo`; `[` (I know, this is not a builtin but don't).\n\n=== *fake* parameters\n\n*fake* stores parameters given to the fake in the global variable _FAKE_PARAMS_ so that you can use them inside your fake.\n\nIt may be useful if you need to adapt the behavior on the given parameters.\n\nIt can also help in asserting the values of these parameters ... but this may be quite tricky.\n\nFor instance, in our previous code that checks apache is running, we have an issue since our code does not use _ps_ with the appropriate parameters. So we will try to check that parameters given to ps are _ax_.\n\nTo do that, the first naive approach would be:\n\n```test\ncode() {\n  ps a | grep apache\n}\n\ntest_code_gives_ps_appropriate_parameters() {\n  _ps() {\n    cat <<EOF\n  PID TTY          TIME CMD\n13525 pts/7    00:00:01 bash\n24162 pts/7    00:00:00 ps\n 8387 ?            0:00 /usr/sbin/apache2 -k start\nEOF\n    assert_equals ax \"${FAKE_PARAMS[@]}\"\n  }\n  export -f _ps\n  fake ps _ps\n\n  code >/dev/null\n}\n```\n\nThis test calls _code_, which calls _ps_, which is actually implemented by __ps_. Since _code_ does not use _ax_ but only _a_ as parameters, this test should fail. But ...\n\n```output\n\tRunning test_code_gives_ps_appropriate_parameters ... SUCCESS\n```\n\nThe problem here is that _ps_ fail (because of the failed *assert_equals* assertion). But _ps_ is piped with _grep_:\n\n```shell\ncode() {\n  ps a | grep apache\n}\n```\n\nWith bash, the result code of a pipeline equals the result code of the last command of the pipeline. The last command is _grep_ and since grep succeeds, the failure of __ps_ is lost and our test succeeds. We have only succeeded in messing with the test output, nothing more.\n\nAn alternative may be to activate bash _pipefail_ option but this may introduce unwanted side effects. We can also simply not output anything in __ps_ so that _grep_ fails:\n\n```shell\ncode() {\n  ps a | grep apache\n}\n\ntest_code_gives_ps_appropriate_parameters() {\n  _ps() {\n    assert_equals ax \"${FAKE_PARAMS[@]}\"\n  }\n  export -f _ps\n  fake ps _ps\n\n  code >/dev/null\n}\n```\n\nThe problem here is that we use a trick to make the code under test fail but the\nfailure has nothing to do with the actual *assert_equals* failure. This is really\nbad, don't do that.\n\nMoreover, *assert_equals* output is captured by _ps_ and this just messes with the display of our test results:\n\n```shell\n\tRunning test_code_gives_ps_appropriate_parameters ... \n```\n\nThe only correct alternative is for the fake _ps_ to write _FAKE_PARAMS_ in a file descriptor\nso that your test can grab them after code execution and assert their value. For instance\nby writing to a file:\n\n```test\ncode() {\n  ps a | grep apache\n}\n\ntest_code_gives_ps_appropriate_parameters() {\n  _ps() {\n    echo ${FAKE_PARAMS[@]} > /tmp/fake_params\n  }\n  export -f _ps\n  fake ps _ps\n\n  code || true\n\n  assert_equals ax \"$(head -n1 /tmp/fake_params)\"\n}\n\nsetup() {\n  rm -f /tmp/fake_params\n}\n```\n\nHere our fake writes to _/tmp/fake_. We delete this file in *setup* to be\nsure that we do not get inapropriate data from a previous test. We assert\nthat the first line of _/tmp/fake_ equals _ax_. Also, note that we know\nthat _code_ will fail and write this to ignore the error: `code || true`.\n\n\n```output\n\tRunning test_code_gives_ps_appropriate_parameters ... FAILURE\n expected [ax] but was [a]\ndoc:14:test_code_gives_ps_appropriate_parameters()\n```\n\nWe can also compact the fake definition:\n\n```test\ncode() {\n  ps a | grep apache\n}\n\ntest_code_gives_ps_appropriate_parameters() {\n  fake ps 'echo ${FAKE_PARAMS[@]} >/tmp/fake_params'\n\n  code || true\n\n  assert_equals ax \"$(head -n1 /tmp/fake_params)\"\n}\n\nsetup() {\n  rm -f /tmp/fake_params\n}\n```\n\n```output\n\tRunning test_code_gives_ps_appropriate_parameters ... FAILURE\n expected [ax] but was [a]\ndoc:10:test_code_gives_ps_appropriate_parameters()\n```\n\nFinally, we can avoid the _/tmp/fake_params_ temporary file by using _coproc_:\n\n```test\ncode() {\n  ps a | grep apache\n}\n\ntest_get_data_from_fake() {\n  #Fasten you seat belt ...\n  coproc cat\n  exec {test_channel}>&${COPROC[1]}\n  fake ps 'echo ${FAKE_PARAMS[@]} >&$test_channel'\n\n  code || true\n\n  assert_equals ax \"$(head -n1 <&${COPROC[0]})\"\n}\n\n```\n\n```output\n\tRunning test_get_data_from_fake ... FAILURE\n expected [ax] but was [a]\ndoc:13:test_get_data_from_fake()\n```"
}
