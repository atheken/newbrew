{
  "name": "clarinet",
  "full_name": "clarinet",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Command-line tool and runtime for the Clarity smart contract language",
  "license": "GPL-3.0-only",
  "homepage": "https://github.com/hirosystems/clarinet",
  "versions": {
    "stable": "1.7.1",
    "head": "HEAD",
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/hirosystems/clarinet.git",
      "tag": "v1.7.1",
      "revision": "8ca42c032317abb81347449ae1664ba332a641a0",
      "checksum": null
    },
    "head": {
      "url": "https://github.com/hirosystems/clarinet.git",
      "branch": "main"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/clarinet/blobs/sha256:457a409edc57920c345a0550882c19f69669be5ae466dc43467b52e928fe0718",
          "sha256": "457a409edc57920c345a0550882c19f69669be5ae466dc43467b52e928fe0718"
        },
        "ventura": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/clarinet/blobs/sha256:f1bcec8ff1cc9a07f1f0b80a9c7762c3c138df025d022ec169b76515c643ddb2",
          "sha256": "f1bcec8ff1cc9a07f1f0b80a9c7762c3c138df025d022ec169b76515c643ddb2"
        },
        "monterey": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/clarinet/blobs/sha256:1233740e5210db63fd353f26c259f39c36df1b854fd61f4cc6d96c85757f5c98",
          "sha256": "1233740e5210db63fd353f26c259f39c36df1b854fd61f4cc6d96c85757f5c98"
        },
        "big_sur": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/clarinet/blobs/sha256:f7298c110f4b7aef93378fd18cf193ae3b25424598dd2855f0e62139c13af056",
          "sha256": "f7298c110f4b7aef93378fd18cf193ae3b25424598dd2855f0e62139c13af056"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/clarinet/blobs/sha256:397ad409b6f098883082b68eff0b698048b3459baf562acd284e76b0e38374b2",
          "sha256": "397ad409b6f098883082b68eff0b698048b3459baf562acd284e76b0e38374b2"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [
    "rust"
  ],
  "dependencies": [],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/clarinet.rb",
  "ruby_source_checksum": {
    "sha256": "03975ea45bb75eed5613b8278ed52745f23bcdc798ed2c084626effe622dd4b7"
  },
  "date_added": "2021-07-07T20:52:56+00:00",
  "readme": "# Clarinet\n\nClarinet is a Clarity runtime packaged as a command line tool, designed to facilitate smart contract understanding,\ndevelopment, testing and deployment. Clarinet consists of a Clarity Read-Evaluate-Print-Loop (REPL) environment and a testing harness. When used together, Clarity and the REPL environment enable you to rapidly develop and test a Clarity smart contract, allowing you to deploy the contract to a:\n\n- devnet - a local standalone development environment that simulates Bitcoin, Stacks node and other helpful components, similar to a staging environment.\n- [testnet](https://docs.stacks.co/docs/understand-stacks/testnet) - a testing environment not running in production.\n- [mainnet](https://stacks.org/stacks2mainnet) - a production environment where you can deploy smart contracts.\n\nClarity is a **decidable** smart contract language that optimizes for predictability and security, meaning you can know with certainty, from the code itself, what the program will do. Smart contracts allow you to encode essential business logic on a blockchain.\n\n![screenshot](docs/images/demo.gif)\n\n### Clarinet 101\n\nHiro has created an introductory video tutorial series that guides you through some of the fundamentals of Clarinet, and how it can help develop, test, and deploy Clarity smart contracts.\n\nPlease review and watch the YouTube playlist on [Hiro's Youtube](https://www.youtube.com/c/HiroSystems):\n[<img src=\"docs/images/clarinet101.png\">](https://youtube.com/playlist?list=PL5Ujm489LoJaAz9kUJm8lYUWdGJ2AnQTb) channel for information on how to use Clarinet for smart contracts.\n\n## Installation\n\n### Install on macOS (Homebrew)\n\nTo install Clarinet on macOS, run the following command:\n\n```bash\nbrew install clarinet\n```\n\n### Install on Windows\n\nIf you would like to install Clarinet on Windows, the easiest way to install Clarinet on Windows is to use the MSI installer. You can download the executable from the [releases page](https://github.com/hirosystems/clarinet/releases).\n\nClarinet is also available on Winget; the package manager that Microsoft began including in the latest Windows updates:\n\n```powershell\nwinget install clarinet\n```\n\n### Install from a pre-built binary\n\nTo install Clarinet from pre-built binaries, download the latest release from the [releases page](https://github.com/hirosystems/clarinet/releases).\n\nUnzip the binary, then copy it to a location that is already in your path, such as `/usr/local/bin`.\n\n```sh\n# note: you can change the v0.27.0 with version that are available in the releases page.\nwget -nv https://github.com/hirosystems/clarinet/releases/download/v0.27.0/clarinet-linux-x64-glibc.tar.gz -O clarinet-linux-x64.tar.gz\ntar -xf clarinet-linux-x64.tar.gz\nchmod +x ./clarinet\nmv ./clarinet /usr/local/bin\n```\n\nOn MacOS, you may get security errors when trying to run the pre-compiled binary. You can resolve the security warning\nwith command\n\n```sh\nxattr -d com.apple.quarantine /path/to/downloaded/clarinet/binary\n```\n\n### Install from source using Cargo\n\nIf you would like to install Clarinet from source using Cargo, there are some specific steps you will need to follow, which are described below.\n\n#### Prerequisites\n\nYou must first [Install Rust](https://www.rust-lang.org/tools/install) to use the Rust package manager Cargo.\n\nIf you are using Debian and Ubuntu-based distributions, make sure to run the following command to install required packages before building Clarinet.\n\n```bash\nsudo apt install build-essential pkg-config libssl-dev curl\n```\n\n#### Build Clarinet\n\nWhen you are ready to build Clarinet, you can build from source using Cargo with the following commands:\n\n```bash\ngit clone https://github.com/hirosystems/clarinet.git\ncd clarinet\ncargo clarinet-install\n```\n\nBy default, you will be in Hiro's development branch, `develop`, with code that has not been released yet. If you plan on submitting any changes to the code, then this is the right branch for you.\nIf you want the latest stable version, switch to the main branch by entering the following command:\n\n```bash\ngit checkout main\n```\n\n## Getting started with Clarinet\n\nThe following sections describe how to create a new project in Clarinet and populate it with smart contracts. Clarinet\nalso provides tools for interacting with your contracts in a REPL, and performing automated testing of contracts.\n\n### Setup shell completions\n\nClarinet has many different built-in commands, which are useful to enable tab-completion in your shell. You can use `clarinet` to generate the shell completion scripts for many common shells using the command:\n\n```sh\nclarinet completions (bash|elvish|fish|powershell|zsh)\n```\n\nAfter generating the file, please refer to the documentation for your shell to determine where this file should be moved and what other steps may be necessary to enable tab-completion for `clarinet`.\n\n### Create a new project\n\nOnce you have installed Clarinet, you can create a new project by entering the following command:\n\n```bash\nclarinet new my-project && cd my-project\n```\n\nClarinet will create a project directory with the following directory layout:\n\n```bash\n.\n├── Clarinet.toml\n├── contracts\n├── settings\n│   └── Devnet.toml\n│   └── Testnet.toml\n│   └── Mainnet.toml\n└── tests\n```\n\nThe `Clarinet.toml` file contains configuration for the smart contracts in your project. When you create contracts in\nyour project, Clarinet will add them to this file.\n\nThe `settings/Devnet.toml` file contains configuration for accounts in the Clarinet console, including the seed\nphrases and initial balances. Initial balances are in microSTX.\n\nFor a detailed video description on how you can create a new project, please see the [Creating a New Project](https://www.youtube.com/watch?v=F_Sb0sNafEg&list=PL5Ujm489LoJaAz9kUJm8lYUWdGJ2AnQTb&index=4) YouTube video.\n\n### Add a new contract\n\nClarinet can handle adding a new contract and its configuration to your project with the following command:\n\n```bash\nclarinet contract new bbtc\n```\n\nClarinet will add 2 files to your project: the contract file in the `contracts` directory, and the contract test file\nin the `tests` directory.\n\n```bash\n.\n├── Clarinet.toml\n├── contracts\n│   └── bbtc.clar\n├── settings\n│   └── Devnet.toml\n│   └── Mainnet.toml\n│   └── Testnet.toml\n└── tests\n    └── bbtc_test.ts\n```\n\nClarinet will also add configuration to the `Clarinet.toml` file for your contract.\n\n```toml\n[project.cache_location]\npath = \".cache\"\n[contracts.bbtc]\npath = \"contracts/bbtc.clar\"\n```\n\nYou may add contracts to your project by adding the files manually; however, you must add the appropriate configuration\nto `Clarinet.toml` in order for Clarinet to recognize the contracts.\n\n### Check your contracts\n\nClarinet provides syntax and semantics checkers for Clarity, which enable you to check if the Clarity code in your project is valid by using the following command:\n\n```bash\nclarinet check\n```\n\nThis command uses the `Clarinet.toml` file to locate and analyze all of the contracts in the project. If the Clarity code is valid, the command will indicate success with the following message:\n\n```\n✔ 2 contracts checked\n```\n\nThe checker may also report warnings that indicate the code is valid; however, you should be aware of a specific condition that might arise. For example, the check-checker analysis discussed below will generate warnings. If there are errors in the code, the output of the command will indicate the kind and location of the errors.\n\nYou may also perform syntax-check on a single file by using the following command.\n\n```bash\nclarinet check <path/to/file.clar>\n```\n\nIf there are no syntax errors, the output of the command will be a success message similar to the example below.\n\n```\n✔ Syntax of contract successfully checked\n```\n\n**Note** Any syntactical errors in the Clarity code will be reported, but type-checking and other semantic checks will not be performed because Clarinet will only look at this one contract, since it does not have the full context to perform a complete check.\n\n### Static Analysis\n\n#### Check-Checker\n\nThe check-checker is a static analysis pass you can use to help find potential vulnerabilities in your contracts. To enable this pass, add the following lines to your `Clarinet.toml` file:\n\n```toml\n[repl.analysis]\npasses = [\"check_checker\"]\n```\n\nThe check-checker pass analyzes your contract to identify places where untrusted inputs might be used in a potentially dangerous way. Since public functions can be called by anyone, any arguments passed to these public functions should be considered untrusted. This analysis pass takes the opinion that all untrusted data must be checked before being used to modify the state on the blockchain. Modifying the state includes any operations that affect wallet balances, or any data stored in your contracts.\n\n- Actions on Stacks wallets:\n  - stx-burn?\n  - stx-transfer?\n- Actions on fungible tokens:\n  - ft-burn?\n  - ft-mint?\n  - ft-transfer?\n- Actions on non-fungible tokens:\n  - nft-burn?\n  - nft-mint?\n  - nft-transfer?\n- Actions on persisted data:\n  - Maps:\n    - map-delete\n    - map-insert\n    - map-set\n  - Variables:\n    - var-set\n\nIn addition to those operations, the check-checker is also a bit opinionated and prefers that untrusted data be checked near the source, making the code more readable and maintainable. For this reason, the check-checker also requires that arguments passed into private functions and return values must be checked.\n\n- Calls to private functions\n- Return values\n\nFinally, another opportunity for exploits appears when contracts call functions from traits. Those traits are untrusted, just like other parameters to public functions, so they are also required to be checked.\n\n- Dynamic contract calls (through traits)\n\nWhen an untrusted input is used in one of these ways, you will see a warning like this:\n\n```\nbank:27:37: warning: use of potentially unchecked data\n        (as-contract (stx-transfer? (to-uint amount) tx-sender customer))\n                                    ^~~~~~~~~~~~~~~~\nbank:21:36: note: source of untrusted input here\n(define-public (withdrawal-unsafe (amount int))\n```\n\nIn the case where an operation affects only the sender's own wallet (e.g. calling `stx-transfer?` with the sender set to `tx-sender`), then there is no need to generate a warning, because the untrusted input is only affecting the sender, who is the source of that input. To put it another way, the sender should be able to safely specify parameters in an operation that affects only themselves. This sender is also potentially protected by post-conditions.\n\nFor a more detailed description on how to use the Check-Checker, please see the [Catch Smart Contract Vulnerabilities With Clarinet’s Check-Checker Feature](https://www.youtube.com/watch?v=v2qXFL2owC8&list=PL5Ujm489LoJaAz9kUJm8lYUWdGJ2AnQTb&index=14) YouTube video.\n\n##### Options\n\nThe check-checker provides some options that can be specified in `Clarinet.toml` to handle common usage scenarios that may reduce false positives from the analysis:\n\n```toml\n[repl.analysis.check_checker]\nstrict = false\ntrusted_sender = true\ntrusted_caller = true\ncallee_filter = true\n```\n\nIf `strict` is set to true, all other options are ignored and the analysis proceeds with the most strict interpretation of the rules.\n\nThe `trusted_sender` and `trusted_caller` options handle a common practice in smart contracts where there is a concept of a trusted transaction sender (or transaction caller), which is treated like an admin user. Once a check has been performed to validate the sender (or caller), then all inputs should be trusted.\n\nIn the example below, the `asserts!` on line 3 is verifying the `tx-sender`. Because of that check, all inputs are trusted (if the `trusted_sender` option is enabled):\n\n```clarity\n(define-public (take (amount int) (from principal))\n    (let ((balance (- (default-to 0 (get amount (map-get? accounts {holder: from}))) amount)))\n        (asserts! (is-eq tx-sender (var-get bank-owner)) err-unauthorized)\n        (map-set accounts {holder: from} {amount: balance})\n        (stx-transfer? (to-uint amount) (as-contract tx-sender) tx-sender)\n    )\n)\n```\n\nThe `callee_filter` option loosens the restriction on passing untrusted data to private functions, and instead, allows checks in a called function to propagate up to the caller. This is helpful, because it allows you to define input checks in a function that can be reused.\n\nIn the example below, the private function `validate` checks its parameter. The public function `save` calls `validate`, and when the `callee_filter` option is enabled, that call to `validate` will count as a check for the untrusted input, `amount`, resulting in no warnings from the check-checker.\n\n```clarity\n(define-public (save (amount uint))\n    (begin\n        (try! (validate amount))\n        (var-set saved amount)\n        (ok amount)\n    )\n)\n\n(define-private (validate (amount uint))\n    (let ((current (var-get saved)))\n        (asserts! (> amount current) err-too-low)\n        (asserts! (<= amount (* current u2)) err-too-high)\n        (ok amount)\n    )\n)\n```\n\n##### Annotations\n\nSometimes, there is code that the check-checker analysis is unable to determine is safe; however, you know the code is safe. You want to pass this information to the check-checker to disable warnings that you consider to be false positives. To handle these cases, the check-checker supports several annotations, implemented using \"magic comments\" in the contract code.\n\n**`#[allow(unchecked_params)]`**\n\nThis annotation tells the check-checker that the associated private function is allowed to receive unchecked arguments. It will not generate a warning for calls to this function that pass unchecked inputs. Inside the private function, the parameters are considered unchecked and could generate warnings.\n\n```clarity\n;; #[allow(unchecked_params)]\n(define-private (my-func (amount uint))\n    ...\n)\n```\n\n**`#[allow(unchecked_data)]`**\n\nThis annotation tells the check-checker that the following expression is allowed to use unchecked data without warnings. It should be used with care, since this will disable all warnings from the associated expression.\n\n```clarity\n(define-public (dangerous (amount uint))\n    (let ((sender tx-sender))\n        ;; #[allow(unchecked_data)]\n        (as-contract (stx-transfer? amount tx-sender sender))\n    )\n)\n```\n\n**`#[filter(var1, var2)]`**\n\nThis annotation tells the check-checker to consider the specified variables to be checked by the following expression. This is useful for the case where your contract does some indirect check that validates that an input is safe, but there is no way for the analysis to recognize this. In place of the list of variable names in the annotation, an `*` may be used to filter all inputs.\n\n**Note** The command below is the safest and preferred way to silence warnings that you consider false positives.\n\n```clarity\n(define-public (filter_one (amount uint))\n    (let ((sender tx-sender))\n        ;; #[filter(amount)]\n        (asserts! (> block-height u1000) (err u400))\n        (as-contract (stx-transfer? amount tx-sender sender))\n    )\n)\n```\n\n### Execute a test suite\n\nClarinet provides a testing harness based on Deno that can enable you to create automated unit tests or pseudo-integration tests using Typescript.\n\n```bash\nclarinet test\n```\n\nFor more information on how to create unit tests using Typescript, see the [Writing Unit Tests Using Typescript](https://www.youtube.com/watch?v=Z4YEHUxHWuE&list=PL5Ujm489LoJaAz9kUJm8lYUWdGJ2AnQTb&index=7) YouTube video.\n\nWhen you use the `clarinet contract new foo` command to create a new contract, Clarinet will automatically create a unit test file for this new contract, `tests/foo_test.ts`. Other files under the `tests/_ directory` following the Deno test naming convention will also be included:\n\n- named test.{ts, tsx, mts, js, mjs, jsx, cjs, cts},\n- or ending with .test.{ts, tsx, mts, js, mjs, jsx, cjs, cts},\n- or ending with \\_test.{ts, tsx, mts, js, mjs, jsx, cjs, cts}\n\nWithin these tests, you can simulate mining a block containing transactions using your contract, and then examine the results of those transactions as well as the events generated by them.\n\nSee the [billboard example](examples/billboard/tests/billboard_test.ts) for sample unit tests.\n\n**Note:** If you see an error in VS Code on the imports in the generated test file(s), that says, \"An import path cannot end with a '.ts' extension\" (an example is shown below), installing the [Deno extension](https://marketplace.visualstudio.com/items?itemName=denoland.vscode-deno) will resolve this error.\n\n![VS Code deno error](docs/images/deno-error.png)\n\n#### Measure and increase code coverage\n\nTo help maximize a smart contract's test coverage, Clarinet can produce a `lcov` report, using the following option:\n\n```bash\nclarinet test --coverage\n```\n\nFrom there, you can use the `lcov` tooling suite to produce HTML reports:\n\n```bash\nbrew install lcov\ngenhtml --branch-coverage -o coverage coverage.lcov\nopen coverage/index.html\n```\n\n![lcov](docs/images/lcov.png)\n\n### Cost optimizations\n\nClarinet can also be used to optimize costs. When executing a test suite, Clarinet will keep track of all the costs being computed when executing the `contract-call`, and display the most expensive ones in a table:\n\n```bash\nclarinet test --cost\n```\n\nThe `--cost` option can be used in conjunction with `--watch` and filters to maximize productivity, as illustrated here:\n\n![costs](docs/images/costs.gif)\n\n### Load contracts in a console\n\nThe Clarinet console is an interactive Clarity REPL environment that runs in-memory. Any contracts in the current project will be\nautomatically loaded into memory.\n\n```bash\nclarinet console\n```\n\nYou can use the `::help` command in the console for a list of valid commands, which can control the state of the\nREPL chain, and allow you advance the chain tip. Additionally, you can enter Clarity commands into the console and observe\nthe result of the command.\n\nYou can exit the console by pressing `Ctrl + C` twice.\n\nChanges to contracts are not loaded into the console while it is running. If you make any changes to your contracts you\nmust exit the console and run it again.\n\n### Spawn a local Devnet\n\nYou can use Clarinet to deploy your contracts to your own local offline environment for testing and\nevaluation on a blockchain by using the following command:\n\n```bash\nclarinet integrate\n```\n\n**Note** Make sure you have a working installation of Docker running locally.\n\n### Interacting with contracts deployed on Mainnet\n\nComposition and interactions between protocols and contracts are one of the key innovations in blockchains. Clarinet was designed to handle these types of interactions.\n\nBefore referring to contracts deployed on Mainnet, these contracts should be explicitly be listed as a `requirement` in the manifest `Clarinet.toml`, either manually:\n\n```toml\n[project]\nname = \"my-project\"\n[[project.requirements]]\ncontract_id = \"SP2KAF9RF86PVX3NEE27DFV1CQX0T4WGR41X3S45C.bitcoin-whales\"\n\n```\n\nor with the command:\n\n```bash\nclarinet requirements add SP2KAF9RF86PVX3NEE27DFV1CQX0T4WGR41X3S45C.bitcoin-whales\n```\n\nClarinet will be able to resolve the `contract-call?` statements invoking requirements present in your local contracts by downloading and caching a copy of these contracts and using them during the execution of your test suites. All of the different features are available in `clarinet`.\n\nWhen deploying your protocol to Devnet / Testnet, for the contracts involving requirements, the setting `remap_requirements` in your deployment plans must be set.\n\nAs a step-by-step example, we use here the following contract, [**bitcoin-whales**](https://explorer.hiro.so/txid/SP2KAF9RF86PVX3NEE27DFV1CQX0T4WGR41X3S45C.bitcoin-whales?chain=mainnet)\n\nIf you examine this contract, you will see that there are 3 different dependencies: two from the **same**\nproject (included in the same Clarinet.toml file), and one referring to a contract deployed outside of the current project.\n\n### Same Project\n\nIn the contract snippet shown below *(line:260-265)*, there are dependencies on the contracts conversion and conversion-v2 which are included in the same `Clarinet.toml` file.\n\n```clarity\n(define-read-only (get-token-uri (token-id uint))\n  (if (< token-id u5001)\n    (ok (some (concat (concat (var-get ipfs-root) (unwrap-panic (contract-call? .conversion lookup token-id))) \".json\")))\n    (ok (some (concat (concat (var-get ipfs-root) (unwrap-panic (contract-call? .conversion-v2 lookup (- token-id u5001)))) \".json\")))\n    )\n)\n```\n\n### External Deployer \n\nIn this code snippet, there is a dependency on the `nft-trait` *(line:001)* deployed by `'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9`.\n\n```clarity\n(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)\n```\n\n- Dependencies from **external** contracts should be set in `[[project.requirements]]`\n\n```toml\n[project]\nname = \"my-project\"\n\n[[project.requirements]]\ncontract_id = \"SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait\"\n\n[project.cache_location]\npath = \".cache\"\n\n[contracts.bitcoin-whales]\npath = \"contracts/bitcoin-whales.clar\"\n\n[contracts.conversion]\npath = \"contracts/conversion.clar\"\n\n[contracts.conversion-v2]\npath = \"contracts/conversion-v2.clar\"\n\n[repl.analysis]\npasses = [\"check_checker\"]\n\n[repl.analysis.check_checker]\nstrict = false\ntrusted_sender = false\ntrusted_caller = false\ncallee_filter = false\n```\n\nAs a next step we can generate a deployment plan for this project. If you are running `clarinet integrate` for the first time, this file should be created by Clarinet. In addition, you can run `clarinet deployment generate --devnet` to create or overwrite the file.\n\n```yaml\n---\nid: 0\nname: Devnet deployment\nnetwork: devnet\nstacks-node: \"http://localhost:20443\"\nbitcoin-node: \"http://devnet:devnet@localhost:18443\"\nplan:\n  batches:\n    - id: 0\n      transactions:\n        - requirement-publish:\n            contract-id: SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait\n            remap-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n            remap-principals:\n              SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n            cost: 4680\n            path: \".requirements\\\\SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.clar\"\n        - contract-publish:\n            contract-name: conversion\n            expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n            cost: 340250\n            path: \"contracts\\\\conversion.clar\"\n            anchor-block-only: true\n        - contract-publish:\n            contract-name: conversion-v2\n            expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n            cost: 351290\n            path: \"contracts\\\\conversion-v2.clar\"\n            anchor-block-only: true\n        - contract-publish:\n            contract-name: bitcoin-whales\n            expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n            cost: 87210\n            path: \"contracts\\\\bitcoin-whales.clar\"\n            anchor-block-only: true\n```\n\nAs the example above shows, Clarinet will remap the external contract to Hiro's Devnet address. In addition, it will also create a copy of the contract in the folder `requirements`\n\n### Deploy contracts to Devnet / Testnet / Mainnet\n\nYou can use Clarinet to publish your contracts to Devnet / Testnet / Mainnet environment for testing and evaluation on a blockchain.\n\nThe first step to deploy a contract is to generate a deployment plan, with the following command:\n\n```bash\nclarinet deployment generate --mainnet\n```\n\nAfter **cautiously** reviewing (and updating if needed) the generated plan, you can use the command to handle the deployments of your contract, according to your deployment plan:\n\n```bash\nclarinet deployment apply -p <path-to-plan.yaml>\n```\n\n### Use Clarinet in your CI workflow as a GitHub Action\n\nClarinet may also be used in GitHub Actions as a step of your CI workflows.\n\nYou may set-up a simple workflow by adding the following steps in a file `.github/workflows/github-actions-clarinet.yml`:\n\n```yaml\nname: CI\non: [push]\njobs:\n  tests:\n    name: \"Test contracts with Clarinet\"\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: \"Execute unit tests\"\n        uses: docker://hirosystems/clarinet:latest\n        with:\n          args: test --coverage --manifest-path=./Clarinet.toml\n      - name: \"Export code coverage\"\n        uses: codecov/codecov-action@v1\n        with:\n          files: ./coverage.lcov\n          verbose: true\n```\n\nYou may also add the steps above in your existing workflows. The generated code coverage output can then be used as is with GitHub Apps like https://codecov.io.\n\nFor more information on how you can use GitHub Actions with Clarinet, please see the [A Simple CI With Clarinet and GitHub](https://www.youtube.com/watch?v=cEv6Mi4EcKQ&list=PL5Ujm489LoJaAz9kUJm8lYUWdGJ2AnQTb&index=8) YouTube video\n\n### Extensions\n\nClarinet can easily be extended by community members: open source contributions to Clarinet are welcome, but you may also write your own Clarinet extensions if you want to integrate Clarity contracts with your own tooling and workflow.\n\n| Name                      | wallet access | disk write | disk read | Deployment                                                            | Description                                                                                                                                       |\n| ------------------------- | ------------- | ---------- | --------- | --------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |\n| stacksjs-helper-generator | no            | yes        | no        | https://deno.land/x/clarinet@v1.0.2/ext/stacksjs-helper-generator.ts | Facilitates contract integration by generating some typescript constants that can be used with stacks.js. Never hard code a stacks address again! |\n|                           |               |            |           |                                                                       |\n\n#### How to use extensions\n\nExtensions are run with the following syntax:\n\n```\nclarinet run --allow-write https://deno.land/x/clarinet@v0.29.0/ext/stacksjs-helper-generator.ts\n```\n\nAn extension can be deployed as a standalone plugin on Deno, or may also be a local file if it includes sensitive / private setup informations.\n\nAs illustrated in the example above, permissions (wallet / disk read / disk write) are declared using command flags. If at runtime, the Clarinet extension is trying to write to disk, read disk, or access wallets without permission, the script will fail.\n\n### Debug your contracts\n\n#### VS Code Debugger\n\nClarinet supports the [Debug Adapter Protocol](https://microsoft.github.io/debug-adapter-protocol/) (DAP) which enables you to debug your smart contracts inside of VS Code, or any code editor that supports the DAP protocol.\n\nTo setup a debug session, you will first need to create a `launch.json` file to tell VS Code what you want to debug. The easiest way to do this is to let VS Code generate the template for you by opening the \"Run and Debug\" view and clicking \"create a launch.json file\".\n\n![Run and Debug View](docs/images/run-and-debug.png)\n\nThis will create the file `.vscode/launch.json` with the default template:\n\n```json5\n{\n  // Use IntelliSense to learn about possible attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"clarinet\",\n      \"request\": \"launch\",\n      \"name\": \"Call .foo.bar\",\n      \"manifest\": \"${workspaceFolder}/Clarinet.toml\",\n      \"expression\": \"(contract-call? .foo bar 42)\"\n    }\n  ]\n}\n```\n\nDepending on your needs, you will want to set the `name` field to whatever makes sense for your project, then set the `expression` to the Clarity expression that you would like to debug. In the case of the default example shown in the template above, the debugger would start executing the `bar` function of the `foo` contract, passing the argument `42`. Once this file is configured, the debugger works as expected for any [VS Code debugging](https://code.visualstudio.com/docs/editor/debugging).\n\nExecution begins paused at the first expression. The debug toolbar includes buttons to continue, step over, step into, step out, restart, and stop, in that order.\n\n![debug toolbar](docs/images/debug-toolbar.png)\n\nBreakpoints can be set by clicking in the left gutter next to the code or using the right-click menu at a specific code location.\n\n![breakpoint](docs/images/breakpoint.png)\n\nData watchpoints may also be set, by clicking the + in the Watch section of the Debug side bar and typing the contract variable to watch in the format `<principal>.<contract>.<name>` or using the shortcut for a local contract, `.<contract>.<name>`. When a watchpoint is set on a contract variable, execution will pause when its value will change.\n\n![watchpoint](docs/images/watchpoint.png)\n\nDuring execution, the values of the current contract's variables, the current function's arguments, and any local variables (i.e. from a `let` expression) are shown in the side bar. The current watchpoints are also shown with their current values. In both cases, the contents of a map are not shown, but can be queried in the Debug Console. The call stack is also updated to show the call stack of the current execution.\n\n![view of side bar, showing variables, watchpoints, and call stack](docs/images/sidebar.png)\n\nAt any point during execution, an expression can be evaluated in the current context via the Debug Console. Just type any valid Clarity expression and hit enter to evaluate it. Upon completion, the events emitted and the return value are printed to the debug console.\n\n![debug console](docs/images/debug-console.png)\n\nFor more information on how you can use VS Code to debug smart contracts, please see the [How to Debug Smart Contracts in Clarinet’s VS Code Extension](https://www.youtube.com/watch?v=DsLCDQSijwk&list=PL5Ujm489LoJaAz9kUJm8lYUWdGJ2AnQTb&index=15) YouTube video.\n\n#### Command Line Debugger\n\nInside of the console (`clarinet console`), there is a debugger for stepping through your contracts on the command line, including support for:\n\n- Breakpoints\n  - **Source**: Break at a specific line (and optional column) of a contract (`break` or `b` command)\n    ```\n    b SP466FNC0P7JWTNM2R9T199QRZN1MYEDTAR0KP27.miamicoin-token:28:4\n    ```\n  - **Function**: Break at a specific function (`break` or `b` command)\n    ```\n    b .crashpunks-v2.transfer\n    ```\n  - **Data**: Break on read/write to a variable or map (`watch` or `w` to break on write, `rwatch` or `rw` to break on read, and `awatch` or `aw` to break on read or write)\n    ```\n    w contracts/SP2KAF9RF86PVX3NEE27DFV1CQX0T4WGR41X3S45C.bitcoin-whales.payout\n    ```\n- Step execution\n  - **Step-in**: Step into the sub-expressions (`step` or `s` command)\n  - **Step-out**: Complete execution of the current expression and return the result back to the parent (`finish` or `f` command)\n  - **Step-over**: Continue to completion of the current expression, stepping over sub-expressions (`next` or `n` command)\n  - **Continue**: Continue execution until hitting a breakpoint or completing execution (`continue` or `c` command)\n- Evaluate and print the result of any expression (`print` or `p` command)\n\nTo initiate a debug session, first enter the REPL console using the following command:\n\n```\nclarinet console\n```\n\nThen, at the REPL prompt, enter this command to debug any expression:\n\n```\n::debug (contract-call? .foo hello .bar))\n```\n\nAt the debug prompt, use any of the commands described above, or use `help` to get the full help documentation.\n\nFor more information about how to debug a smart contract using the command line, please see the [Debug Your Smart Contracts With Clarinet’s New Inline Debugger](https://www.youtube.com/watch?v=nVDWeuMnkDs&list=PL5Ujm489LoJaAz9kUJm8lYUWdGJ2AnQTb&index=13) YouTube video.\n\n#### Execution Trace\n\nWhen you are in the console (`clarinet console`), the `::trace <expr>` command enables you to execute an expression and print a trace of the execution, which can be very helpful for identifying problems with the contract.\n\nThis trace shows all function calls, both internal calls to private functions, and contract calls to other contracts. For each call, the parameters and return value are shown in the trace. Any events that are emitted are also shown in the trace.\n\n![execution trace](docs/images/trace.png)\n\n### Deploy with Hyperchains on Devnet\n\nClarinet can be used for facilitating experimentations with [Hyperchains](https://www.youtube.com/watch?v=PFPwuVCGGuI).\nTo begin working with subnets, in your `Devnet.toml`, enable the following flag:\n\n```toml\n[devnet]\n# ...\nenable_subnet_node = true\n```\n\nThis same file may also be used for customizing the subnet-node (miner, etc).\n\nWhen running the command:\n\n```bash\nclarinet integrate\n```\n\nClarinet will spin-up a subnet node. More documentation on how to use and interact with this incoming L2 can be found on the [Hyperchain repository](https://github.com/hirosystems/stacks-subnets).\n\n## Bugs and feature requests\n\nIf you encounter a bug or have a feature request, we encourage you to follow the steps below:\n\n 1. **Search for existing issues:** Before submitting a new issue, please search [existing and closed issues](../../issues) to check if a similar problem or feature request has already been reported.\n 1. **Open a new issue:** If it hasn't been addressed, please [open a new issue](../../issues/new/choose). Choose the appropriate issue template and provide as much detail as possible, including steps to reproduce the bug or a clear description of the requested feature.\n 1. **Evaluation SLA:** Our team reads and evaluates all the issues and pull requests. We are avaliable Monday to Friday and we make a best effort to respond within 7 business days.\n\nPlease **do not** use the issue tracker for personal support requests or to ask for the status of a transaction. You'll find help at the [#support Discord channel](https://discord.gg/SK3DxdsP).\n\n## Contributing to Clarinet\n\nContributions are welcome and appreciated. The following sections provide information on how you can contribute to Clarinet.\n\n### Prerequisites\n\nBefore contributing to Clarinet, please ensure you meet the following requirements:\n\n- rust (>=1.52.0)\n- cargo (>=1.52.0)\n- node (>=v14.16.0) - Used for git commit hook\n- npm (>=7.18.0) - Used for git commit hook\n\n### Guide\n\nThis repo follows the [Conventional Commit](https://www.conventionalcommits.org/en/v1.0.0/#summary) specification when writing commit messages.\n\n**Note**It is important that any pull requests you submit have commit messages that follow this standard.\n\nTo start contributing:\n\n1. Fork this repo and clone the fork locally.\n2. Create a new branch\n   ```bash\n   git checkout -b <my-branch>\n   ```\n3. Run `npm i` in the local repo to install and initialize `husky` and `commitlint`.\n\n   ```bash\n   npm i\n   ```\n\n4. These tools will be used in a `git commit` hook to lint and validate your commit message. If the message is invalid, `commitlint` will alert you to try again and fix it.\n\n      Here is an example of a bad message response:\n\n      ```bash\n      git commit -m \"bad message\"\n      ⧗   input: bad message\n      ✖   subject may not be empty [subject-empty]\n      ✖   type may not be empty [type-empty]\n      \n      ✖   found 2 problems, 0 warnings\n      ⓘ   Get help: https://github.com/conventional-changelog/commitlint/#what-is-commitlint\n      \n      husky - commit-msg hook exited with code 1 (error)\n      ```\n\n      Here is an example of a good message response:\n\n      ```bash\n      git commit -m \"fix: added missing dependency\"\n      [my-branch 4c028af] fix: added missing dependency\n      1 file changed, 50 insertions(+)\n      ```\n\n5. After making your changes, ensure the following:\n   -  `cargo build` runs successfully.\n   -  `cargo test` runs successfully.\n   -  You have formatted your code with `cargo fmt --all --`\n   -  All functional tests in the `examples` directory pass.\n      ```bash\n      for testdir in $(ls examples); do\n          pushd examples/${testdir}\n              ../../target/debug/clarinet test .\n          popd\n      done\n      ```\n6. Submit a pull request against the `develop` branch for review.\n\n### Code of Conduct\nPlease read our [Code of conduct](../../../.github/blob/main/CODE_OF_CONDUCT.md) since we expect project participants to adhere to it. \n\n## Community\n\nJoin our community and stay connected with the latest updates and discussions:\n\n- [Join our Discord community chat](https://discord.gg/ZQR6cyZC) to engage with other users, ask questions, and participate in discussions.\n\n- [Visit hiro.so](https://www.hiro.so/) for updates and subcribing to the mailing list.\n\n- Follow [Hiro on Twitter.](https://twitter.com/hirosystems)"
}
