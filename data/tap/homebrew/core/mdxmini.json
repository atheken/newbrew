{
  "name": "mdxmini",
  "full_name": "mdxmini",
  "tap": "homebrew/core",
  "oldname": null,
  "oldnames": [],
  "aliases": [],
  "versioned_formulae": [],
  "desc": "Plays music in X68000 MDX chiptune format",
  "license": "GPL-2.0-or-later",
  "homepage": "https://github.com/mistydemeo/mdxmini/",
  "versions": {
    "stable": "2.0.0",
    "head": null,
    "bottle": true
  },
  "urls": {
    "stable": {
      "url": "https://github.com/mistydemeo/mdxmini/archive/v2.0.0.tar.gz",
      "tag": null,
      "revision": null,
      "checksum": "9b623b365e893a769084f7a2effedc9ece453c6e3861c571ba503f045471a0e0"
    }
  },
  "revision": 0,
  "version_scheme": 0,
  "bottle": {
    "stable": {
      "rebuild": 0,
      "root_url": "https://ghcr.io/v2/homebrew/core",
      "files": {
        "arm64_ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/mdxmini/blobs/sha256:01720e2bc4f1207ec29261562b312955d96ceda87dc354ac708b8ff4f1b95565",
          "sha256": "01720e2bc4f1207ec29261562b312955d96ceda87dc354ac708b8ff4f1b95565"
        },
        "arm64_monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/mdxmini/blobs/sha256:703bdc526a902d8cb2190cbe385078bc5618952697ce3e6554a3473a9f1ec67c",
          "sha256": "703bdc526a902d8cb2190cbe385078bc5618952697ce3e6554a3473a9f1ec67c"
        },
        "arm64_big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/mdxmini/blobs/sha256:0015ac050eb60388f47d9d8ad4dbc839be6c94c53896d472db1f902710d27504",
          "sha256": "0015ac050eb60388f47d9d8ad4dbc839be6c94c53896d472db1f902710d27504"
        },
        "ventura": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/mdxmini/blobs/sha256:bc43ab7d3a985f855e1e2b266956ba2d50d394c73d55f5265fb8e2511b25c83f",
          "sha256": "bc43ab7d3a985f855e1e2b266956ba2d50d394c73d55f5265fb8e2511b25c83f"
        },
        "monterey": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/mdxmini/blobs/sha256:5e384c41501dd14903efefe829b14beb5db30d76bea9f0265aa957ed602fd400",
          "sha256": "5e384c41501dd14903efefe829b14beb5db30d76bea9f0265aa957ed602fd400"
        },
        "big_sur": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/mdxmini/blobs/sha256:4516c7fdc7b008d5d1c1447c8dd18c3562edb70619d40c8798933022da471794",
          "sha256": "4516c7fdc7b008d5d1c1447c8dd18c3562edb70619d40c8798933022da471794"
        },
        "catalina": {
          "cellar": ":any",
          "url": "https://ghcr.io/v2/homebrew/core/mdxmini/blobs/sha256:b3c9c8caa3da6169fedd4893e27d4156b016715fcbf91c47209c34ec4b536a79",
          "sha256": "b3c9c8caa3da6169fedd4893e27d4156b016715fcbf91c47209c34ec4b536a79"
        },
        "x86_64_linux": {
          "cellar": ":any_skip_relocation",
          "url": "https://ghcr.io/v2/homebrew/core/mdxmini/blobs/sha256:152c18564d3252af6530331c08788108b99fbac328066ace0c58f94428fe7b4e",
          "sha256": "152c18564d3252af6530331c08788108b99fbac328066ace0c58f94428fe7b4e"
        }
      }
    }
  },
  "keg_only": false,
  "keg_only_reason": null,
  "options": [],
  "build_dependencies": [],
  "dependencies": [
    "sdl2"
  ],
  "test_dependencies": [],
  "recommended_dependencies": [],
  "optional_dependencies": [],
  "uses_from_macos": [],
  "uses_from_macos_bounds": [],
  "requirements": [],
  "conflicts_with": [],
  "conflicts_with_reasons": [],
  "link_overwrite": [],
  "caveats": null,
  "installed": [],
  "linked_keg": null,
  "pinned": false,
  "outdated": false,
  "deprecated": false,
  "deprecation_date": null,
  "deprecation_reason": null,
  "disabled": false,
  "disable_date": null,
  "disable_reason": null,
  "post_install_defined": false,
  "service": null,
  "tap_git_head": "4eeae4ea50839e967536ba646d5e0ed6fbcbad7f",
  "ruby_source_path": "Formula/mdxmini.rb",
  "ruby_source_checksum": {
    "sha256": "a8a7513247359a25ba5414c0c55441c73fc483911d090f0a01853097c8728247"
  },
  "date_added": "2012-02-04T00:03:57-06:00",
  "readme": "mdxmini\n=======\n\nmdxmini is a C library with a simple API which can play back [MDX](https://en.wikipedia.org/wiki/X68000%27s_MDX) chiptunes from the [X68000 home computer](https://en.wikipedia.org/wiki/X68000). The X68000 was, for its time, an advanced 16-bit computer with excellent multimedia support; its 8-channel [YM2151](https://en.wikipedia.org/wiki/Yamaha_YM2151) sound chip and 1-channel PCM chip gave it excellent music support. A large number of MDX files can be found at the [Fossil of FM-sound era](http://www42.tok2.com/home/mdxoarchive) MDX archive site.\n\nUsage\n=====\n\nDetailed API documentation is available in the mdxmini.h header file, but the following sample program shows how to use mdxmini to open a file, extract some metadata, and play back music:\n\n```c\n// Initializes the t_mdxmini struct and opens the file from disk.\n// The `path_to_samples` argument is the path to the directory containing the song's\n// .pdx files, if any; this can be NULL.\nt_mdxmini data;\nint success = mdx_open(&data, path_to_file, path_to_samples);\n// The return value of mdx_open indicates whether or not the file was opened correctly.\nif (success == -1) {\n    fprintf(stderr, \"Failed to open input file: %s\\n\", path_to_file);\n    return 1;\n}\n\n// Before playback begins, call mdx_set_rate to set the preferred sampling rate\n// for generated audio.\nint playback_rate = 48000;\nmdx_set_rate(playback_rate);\n\n// Get the song duration, in whole seconds.\nint length = mdx_get_length(&data);\nprintf(\"Song length: %i seconds\\n\", length);\n\n// mdx_get_title allows the song's title to be fetched; this is usually\n// encoded in Shift-JIS.\nchar title[MDX_MAX_TITLE_LENGTH];\nmdx_get_title(&data, title);\nprintf(\"Title: %s\\n\", title);\n\n// For playback, define a buffer into which we'll render raw PCM data.\nint buf_len = 8192;\nshort buf[buf_len];\n// Number of channels, which we'll fetch for display later.\n// This is constant for a given song, so just fetch it once.\nint number_of_channels = mdx_get_tracks(&data);\nprintf(\"Number of channels: %i\\n\", number_of_channels);\n// A buffer into which we'll write information about the notes being\n// played in a given frame. 16 is the maximum number of channels supported by MDX\n// (8 FM channels, up to 8 PCM channels).\nint notes[16];\n\nint position;\n\n// mdx_calc_sample will return 0 when the final frame of the song is reached.\nint are_samples_remaining = 1;\n// Track the number of buffers played so far, which is useful to calculate\n// the current position.\nint played_buffers = 0;\n\n// The playback loop!\nwhile (are_samples_remaining == 1)\n{\n    // Calculate the song position based on the buffer size and frequency.\n    position = played_buffers / (((playback_rate * 16 * 2) / 8) / (buf_len * 2));\n    printf(\"Current position: %i / %i\\n\", position, length);\n\n    are_samples_remaining = mdx_calc_sample(&data, buf, buf_len / 2);\n    // Also useful to check the position against the reported duration,\n    // as the song may not terminate itself if it can loop infinitely.\n    if (position >= length) {\n        are_samples_remaining = 0;\n    }\n\n    // Do something with the calculated sample here; this is platform-dependent,\n    // so this intro will omit it.\n    \n    // Fill the note buffer with information about the notes in the current frame\n    mdx_get_current_notes(&data, notes, number_of_channels);\n\n    // Channels 0 through 7 are FM channels; any MDX file will always have these tracks.\n    // The integers for these channels represents a note, divided into standard octaves of 12;\n    // for example, 0 would be C in the lowest octave, and 24 would be C two octaves up.\n    // These values can be useful for visualizations;\n    // for example, the ruby-mdxplay demo program maps these values to piano keys:\n    // https://github.com/mistydemeo/ruby-mdxplay/blob/8f54c28cefcfcbdee70eca35ca9a93187385eb8f/bin/mdxplay#L93-L175\n    for (int i = 0; i <= 7; i++) {\n        printf(\"Note for FM channel %i is %i\\n\", i, notes[i]);\n    }\n    // Channels 8 through 15, if present, are PCM channels.\n    // The original X68000's sound chip has one PCM channel;\n    // through an expansion card, up to 8 PCM channels may be present.\n    // The integers for these channels indicate the index of the PCM sample in use;\n    // this is less informative than the note value, but a visualization might\n    // still be able to use this.\n    for (int i = 8; i < number_of_channels; i++) {\n        printf(\"Sample for PCM channel %i is %i\\n\", i, notes[i]);\n    }\n\n    // Increment the count of played buffers.\n    played_buffers++;\n}\n\n// When playback is over, finalize the t_mdxmini struct.\nmdx_close(&data);\n```\n\nPrograms using mdxmini\n======================\n\n* [MDXPLAYER for Android](https://github.com/mistydemeo/mdxplayer), by BouKiCHi\n* [ruby-mdxplay](https://github.com/mistydemeo/ruby-mdxplay)\n* [Paula](https://github.com/mistydemeo/paula)\n* [Modizer](http://yoyofr.blogspot.ca/p/modizer.html) by [yoyofr](http://yoyofr.blogspot.ca)\n\nCredits\n=======\n\n* milk.K, K.MAEKAWA, Missy.M - authors of the original X68000 MXDRV\n* [Daisuke Nagano](http://web.archive.org/web/20101015100349/http://homepage3.nifty.com/StudioBreeze/) - author of the Unix [mdxplay](http://web.archive.org/web/20130217181839/http://homepage3.nifty.com/StudioBreeze/software/mdxplay-e.html)\n* [BouKiCHi](http://clogging.blog57.fc2.com) - author of the mdxmini library, and of the Android mdxplayer\n* [Misty De Meo](http://www.mistys-internet.website) - bugfixes and improvements to mdxmini, current maintainer"
}
